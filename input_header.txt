/* ===============================================
 * Chunk: GRMT, versions: 7, strucTab: 0x141AE9FB0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructGRMT;

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<6>{
struct AmatGr {
    byte texArrayRange;
    byte texCount;
    byte sortOrder;
    byte sortTri;
    byte procAnim;
    dword debugFlags;
    dword flags;
    helpers::Array<qword> texTokens;

public:
    AmatGr();
    AmatGr(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGr(const AmatGr &p_other);
    AmatGr &operator=(const AmatGr &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGr Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<5>{
struct AmatGr {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    byte sortTri;
    byte procAnim;
    dword debugFlags;
    dword flags;
    dword texType;
    dword textureMasks[4];
    helpers::Array<qword> texTokens;

public:
    AmatGr();
    AmatGr(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGr(const AmatGr &p_other);
    AmatGr &operator=(const AmatGr &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGr Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<4>{
struct AmatGr {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    byte sortTri;
    byte procAnim;
    dword debugFlags;
    dword flags;
    dword texType;
    dword textureMasks[4];

public:
    AmatGr();
    AmatGr(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGr(const AmatGr &p_other);
    AmatGr &operator=(const AmatGr &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGr Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<3>{
struct AmatGrV3 {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    byte sortTri;
    dword debugFlags;
    dword flags;
    dword texType;
    dword textureMasks[4];

public:
    AmatGrV3();
    AmatGrV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGrV3(const AmatGrV3 &p_other);
    AmatGrV3 &operator=(const AmatGrV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGrV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<2>{
struct AmatGrV2 {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    byte sortTri;
    dword flags;
    dword texType;
    dword textureMasks[4];

public:
    AmatGrV2();
    AmatGrV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGrV2(const AmatGrV2 &p_other);
    AmatGrV2 &operator=(const AmatGrV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGrV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<1>{
struct AmatGrV1 {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    dword flags;
    dword texType;
    dword textureMasks[4];

public:
    AmatGrV1();
    AmatGrV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGrV1(const AmatGrV1 &p_other);
    AmatGrV1 &operator=(const AmatGrV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGrV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGRMT<0>{
struct AmatGrV0 {
    byte texArrayRange;
    byte texCount;
    byte texTransformRange;
    byte sortOrder;
    dword flags;
    dword textureMasks[4];

public:
    AmatGrV0();
    AmatGrV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGrV0(const AmatGrV0 &p_other);
    AmatGrV0 &operator=(const AmatGrV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGrV0 Gw2Struct;
};


/* ===============================================
 * Chunk: DX9S, versions: 12, strucTab: 0x141AEA060
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructDX9S;

/* Version: 11, ReferencedFunction: 0x403DDAF000000001 */

template <>
struct Gw2StructDX9S<11>{
struct AmatDx9SamplerV11 {
    dword textureIndex;
    helpers::Array<dword> state;
    dword usesBindTexture;

public:
    AmatDx9SamplerV11();
    AmatDx9SamplerV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV11(const AmatDx9SamplerV11 &p_other);
    AmatDx9SamplerV11 &operator=(const AmatDx9SamplerV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV11 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;
    word instructionCount;

public:
    AmatDx9ShaderV11();
    AmatDx9ShaderV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV11(const AmatDx9ShaderV11 &p_other);
    AmatDx9ShaderV11 &operator=(const AmatDx9ShaderV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV11 {
    qword token;
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV11();
    AmatDx9EffectV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV11(const AmatDx9EffectV11 &p_other);
    AmatDx9EffectV11 &operator=(const AmatDx9EffectV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV11 {
    helpers::Ptr<AmatDx9EffectV11> effects;

public:
    AmatDx9PassV11();
    AmatDx9PassV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV11(const AmatDx9PassV11 &p_other);
    AmatDx9PassV11 &operator=(const AmatDx9PassV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV11 {
    helpers::String name;
    helpers::Array<AmatDx9PassV11> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV11();
    AmatDx9TechniqueV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV11(const AmatDx9TechniqueV11 &p_other);
    AmatDx9TechniqueV11 &operator=(const AmatDx9TechniqueV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV11 {
    helpers::Array<AmatDx9SamplerV11> samplers;
    helpers::Array<AmatDx9ShaderV11> shaders;
    helpers::Array<AmatDx9TechniqueV11> techniques;
    dword useLegacyBindTextures;

public:
    AmatDx9MaterialV11();
    AmatDx9MaterialV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV11(const AmatDx9MaterialV11 &p_other);
    AmatDx9MaterialV11 &operator=(const AmatDx9MaterialV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDX9S<10>{
struct AmatDx9SamplerV10 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV10();
    AmatDx9SamplerV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV10(const AmatDx9SamplerV10 &p_other);
    AmatDx9SamplerV10 &operator=(const AmatDx9SamplerV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV10 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;
    word instructionCount;

public:
    AmatDx9ShaderV10();
    AmatDx9ShaderV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV10(const AmatDx9ShaderV10 &p_other);
    AmatDx9ShaderV10 &operator=(const AmatDx9ShaderV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV10 {
    qword token;
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV10();
    AmatDx9EffectV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV10(const AmatDx9EffectV10 &p_other);
    AmatDx9EffectV10 &operator=(const AmatDx9EffectV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV10 {
    helpers::Ptr<AmatDx9EffectV10> effects;

public:
    AmatDx9PassV10();
    AmatDx9PassV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV10(const AmatDx9PassV10 &p_other);
    AmatDx9PassV10 &operator=(const AmatDx9PassV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV10 {
    helpers::String name;
    helpers::Array<AmatDx9PassV10> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV10();
    AmatDx9TechniqueV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV10(const AmatDx9TechniqueV10 &p_other);
    AmatDx9TechniqueV10 &operator=(const AmatDx9TechniqueV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV10 {
    helpers::Array<AmatDx9SamplerV10> samplers;
    helpers::Array<AmatDx9ShaderV10> shaders;
    helpers::Array<AmatDx9TechniqueV10> techniques;

public:
    AmatDx9MaterialV10();
    AmatDx9MaterialV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV10(const AmatDx9MaterialV10 &p_other);
    AmatDx9MaterialV10 &operator=(const AmatDx9MaterialV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x403DE35000000001 */

template <>
struct Gw2StructDX9S<9>{
struct AmatDx9SamplerV9 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV9();
    AmatDx9SamplerV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV9(const AmatDx9SamplerV9 &p_other);
    AmatDx9SamplerV9 &operator=(const AmatDx9SamplerV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV9 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV9();
    AmatDx9ShaderV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV9(const AmatDx9ShaderV9 &p_other);
    AmatDx9ShaderV9 &operator=(const AmatDx9ShaderV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV9 {
    qword token;
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV9();
    AmatDx9EffectV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV9(const AmatDx9EffectV9 &p_other);
    AmatDx9EffectV9 &operator=(const AmatDx9EffectV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV9 {
    helpers::Ptr<AmatDx9EffectV9> effects;

public:
    AmatDx9PassV9();
    AmatDx9PassV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV9(const AmatDx9PassV9 &p_other);
    AmatDx9PassV9 &operator=(const AmatDx9PassV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV9 {
    helpers::String name;
    helpers::Array<AmatDx9PassV9> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV9();
    AmatDx9TechniqueV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV9(const AmatDx9TechniqueV9 &p_other);
    AmatDx9TechniqueV9 &operator=(const AmatDx9TechniqueV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV9 {
    helpers::Array<AmatDx9SamplerV9> samplers;
    helpers::Array<AmatDx9ShaderV9> shaders;
    helpers::Array<AmatDx9TechniqueV9> techniques;

public:
    AmatDx9MaterialV9();
    AmatDx9MaterialV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV9(const AmatDx9MaterialV9 &p_other);
    AmatDx9MaterialV9 &operator=(const AmatDx9MaterialV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x403DDF9000000001 */

template <>
struct Gw2StructDX9S<8>{
struct AmatDx9SamplerV8 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV8();
    AmatDx9SamplerV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV8(const AmatDx9SamplerV8 &p_other);
    AmatDx9SamplerV8 &operator=(const AmatDx9SamplerV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV8 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV8();
    AmatDx9ShaderV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV8(const AmatDx9ShaderV8 &p_other);
    AmatDx9ShaderV8 &operator=(const AmatDx9ShaderV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV8 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV8();
    AmatDx9EffectV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV8(const AmatDx9EffectV8 &p_other);
    AmatDx9EffectV8 &operator=(const AmatDx9EffectV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV8 {
    helpers::Ptr<AmatDx9EffectV8> effects;

public:
    AmatDx9PassV8();
    AmatDx9PassV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV8(const AmatDx9PassV8 &p_other);
    AmatDx9PassV8 &operator=(const AmatDx9PassV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV8 {
    helpers::String name;
    helpers::Array<AmatDx9PassV8> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV8();
    AmatDx9TechniqueV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV8(const AmatDx9TechniqueV8 &p_other);
    AmatDx9TechniqueV8 &operator=(const AmatDx9TechniqueV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV8 {
    helpers::Array<AmatDx9SamplerV8> samplers;
    helpers::Array<AmatDx9ShaderV8> shaders;
    helpers::Array<AmatDx9TechniqueV8> techniques;

public:
    AmatDx9MaterialV8();
    AmatDx9MaterialV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV8(const AmatDx9MaterialV8 &p_other);
    AmatDx9MaterialV8 &operator=(const AmatDx9MaterialV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x403DDF1000000001 */

template <>
struct Gw2StructDX9S<7>{
struct AmatDx9SamplerV7 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV7();
    AmatDx9SamplerV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV7(const AmatDx9SamplerV7 &p_other);
    AmatDx9SamplerV7 &operator=(const AmatDx9SamplerV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV7 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV7();
    AmatDx9ShaderV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV7(const AmatDx9ShaderV7 &p_other);
    AmatDx9ShaderV7 &operator=(const AmatDx9ShaderV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV7 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV7();
    AmatDx9EffectV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV7(const AmatDx9EffectV7 &p_other);
    AmatDx9EffectV7 &operator=(const AmatDx9EffectV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV7 {
    AmatDx9EffectV7 effects[8];

public:
    AmatDx9PassV7();
    AmatDx9PassV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV7(const AmatDx9PassV7 &p_other);
    AmatDx9PassV7 &operator=(const AmatDx9PassV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV7 {
    helpers::String name;
    helpers::Array<AmatDx9PassV7> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV7();
    AmatDx9TechniqueV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV7(const AmatDx9TechniqueV7 &p_other);
    AmatDx9TechniqueV7 &operator=(const AmatDx9TechniqueV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV7 {
    helpers::Array<AmatDx9SamplerV7> samplers;
    helpers::Array<AmatDx9ShaderV7> shaders;
    helpers::Array<AmatDx9TechniqueV7> techniques;

public:
    AmatDx9MaterialV7();
    AmatDx9MaterialV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV7(const AmatDx9MaterialV7 &p_other);
    AmatDx9MaterialV7 &operator=(const AmatDx9MaterialV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x403DDEB000000001 */

template <>
struct Gw2StructDX9S<6>{
struct AmatDx9SamplerV6 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV6();
    AmatDx9SamplerV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV6(const AmatDx9SamplerV6 &p_other);
    AmatDx9SamplerV6 &operator=(const AmatDx9SamplerV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV6 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV6();
    AmatDx9ShaderV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV6(const AmatDx9ShaderV6 &p_other);
    AmatDx9ShaderV6 &operator=(const AmatDx9ShaderV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV6 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV6();
    AmatDx9EffectV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV6(const AmatDx9EffectV6 &p_other);
    AmatDx9EffectV6 &operator=(const AmatDx9EffectV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV6 {
    AmatDx9EffectV6 effects[8];

public:
    AmatDx9PassV6();
    AmatDx9PassV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV6(const AmatDx9PassV6 &p_other);
    AmatDx9PassV6 &operator=(const AmatDx9PassV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV6 {
    helpers::String name;
    helpers::Array<AmatDx9PassV6> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV6();
    AmatDx9TechniqueV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV6(const AmatDx9TechniqueV6 &p_other);
    AmatDx9TechniqueV6 &operator=(const AmatDx9TechniqueV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV6 {
    helpers::Array<AmatDx9SamplerV6> samplers;
    helpers::Array<AmatDx9ShaderV6> shaders;
    helpers::Array<AmatDx9TechniqueV6> techniques;

public:
    AmatDx9MaterialV6();
    AmatDx9MaterialV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV6(const AmatDx9MaterialV6 &p_other);
    AmatDx9MaterialV6 &operator=(const AmatDx9MaterialV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x403DDDB000000001 */

template <>
struct Gw2StructDX9S<5>{
struct AmatDx9SamplerV5 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV5();
    AmatDx9SamplerV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV5(const AmatDx9SamplerV5 &p_other);
    AmatDx9SamplerV5 &operator=(const AmatDx9SamplerV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV5 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV5();
    AmatDx9ShaderV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV5(const AmatDx9ShaderV5 &p_other);
    AmatDx9ShaderV5 &operator=(const AmatDx9ShaderV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV5 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV5();
    AmatDx9EffectV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV5(const AmatDx9EffectV5 &p_other);
    AmatDx9EffectV5 &operator=(const AmatDx9EffectV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV5 {
    AmatDx9EffectV5 effects[7];

public:
    AmatDx9PassV5();
    AmatDx9PassV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV5(const AmatDx9PassV5 &p_other);
    AmatDx9PassV5 &operator=(const AmatDx9PassV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV5 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV5> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV5();
    AmatDx9TechniqueV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV5(const AmatDx9TechniqueV5 &p_other);
    AmatDx9TechniqueV5 &operator=(const AmatDx9TechniqueV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV5 {
    helpers::Array<AmatDx9SamplerV5> samplers;
    helpers::Array<AmatDx9ShaderV5> shaders;
    helpers::Array<AmatDx9TechniqueV5> techniques;

public:
    AmatDx9MaterialV5();
    AmatDx9MaterialV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV5(const AmatDx9MaterialV5 &p_other);
    AmatDx9MaterialV5 &operator=(const AmatDx9MaterialV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDX9S<4>{
struct AmatDx9SamplerV4 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV4();
    AmatDx9SamplerV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV4(const AmatDx9SamplerV4 &p_other);
    AmatDx9SamplerV4 &operator=(const AmatDx9SamplerV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV4 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV4();
    AmatDx9ShaderV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV4(const AmatDx9ShaderV4 &p_other);
    AmatDx9ShaderV4 &operator=(const AmatDx9ShaderV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV4 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV4();
    AmatDx9EffectV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV4(const AmatDx9EffectV4 &p_other);
    AmatDx9EffectV4 &operator=(const AmatDx9EffectV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV4 {
    AmatDx9EffectV4 effects[7];

public:
    AmatDx9PassV4();
    AmatDx9PassV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV4(const AmatDx9PassV4 &p_other);
    AmatDx9PassV4 &operator=(const AmatDx9PassV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV4 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV4> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV4();
    AmatDx9TechniqueV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV4(const AmatDx9TechniqueV4 &p_other);
    AmatDx9TechniqueV4 &operator=(const AmatDx9TechniqueV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV4 {
    helpers::Array<AmatDx9SamplerV4> samplers;
    helpers::Array<AmatDx9ShaderV4> shaders;
    helpers::Array<AmatDx9TechniqueV4> techniques;

public:
    AmatDx9MaterialV4();
    AmatDx9MaterialV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV4(const AmatDx9MaterialV4 &p_other);
    AmatDx9MaterialV4 &operator=(const AmatDx9MaterialV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDX9S<3>{
struct AmatDx9SamplerV3 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV3();
    AmatDx9SamplerV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV3(const AmatDx9SamplerV3 &p_other);
    AmatDx9SamplerV3 &operator=(const AmatDx9SamplerV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV3 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV3();
    AmatDx9ShaderV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV3(const AmatDx9ShaderV3 &p_other);
    AmatDx9ShaderV3 &operator=(const AmatDx9ShaderV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV3 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV3();
    AmatDx9EffectV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV3(const AmatDx9EffectV3 &p_other);
    AmatDx9EffectV3 &operator=(const AmatDx9EffectV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV3 {
    AmatDx9EffectV3 effects[7];

public:
    AmatDx9PassV3();
    AmatDx9PassV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV3(const AmatDx9PassV3 &p_other);
    AmatDx9PassV3 &operator=(const AmatDx9PassV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV3 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV3> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV3();
    AmatDx9TechniqueV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV3(const AmatDx9TechniqueV3 &p_other);
    AmatDx9TechniqueV3 &operator=(const AmatDx9TechniqueV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV3 {
    helpers::Array<AmatDx9SamplerV3> samplers;
    helpers::Array<AmatDx9ShaderV3> shaders;
    helpers::Array<AmatDx9TechniqueV3> techniques;

public:
    AmatDx9MaterialV3();
    AmatDx9MaterialV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV3(const AmatDx9MaterialV3 &p_other);
    AmatDx9MaterialV3 &operator=(const AmatDx9MaterialV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x403DDB0000000001 */

template <>
struct Gw2StructDX9S<2>{
struct AmatDx9SamplerV2 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV2();
    AmatDx9SamplerV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV2(const AmatDx9SamplerV2 &p_other);
    AmatDx9SamplerV2 &operator=(const AmatDx9SamplerV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV2 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV2();
    AmatDx9ShaderV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV2(const AmatDx9ShaderV2 &p_other);
    AmatDx9ShaderV2 &operator=(const AmatDx9ShaderV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9EffectV2 {
    helpers::Array<dword> renderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9EffectV2();
    AmatDx9EffectV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9EffectV2(const AmatDx9EffectV2 &p_other);
    AmatDx9EffectV2 &operator=(const AmatDx9EffectV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV2 {
    AmatDx9EffectV2 effects[7];

public:
    AmatDx9PassV2();
    AmatDx9PassV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV2(const AmatDx9PassV2 &p_other);
    AmatDx9PassV2 &operator=(const AmatDx9PassV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV2 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV2> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV2();
    AmatDx9TechniqueV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV2(const AmatDx9TechniqueV2 &p_other);
    AmatDx9TechniqueV2 &operator=(const AmatDx9TechniqueV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV2 {
    helpers::Array<AmatDx9SamplerV2> samplers;
    helpers::Array<AmatDx9ShaderV2> shaders;
    helpers::Array<AmatDx9TechniqueV2> techniques;

public:
    AmatDx9MaterialV2();
    AmatDx9MaterialV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV2(const AmatDx9MaterialV2 &p_other);
    AmatDx9MaterialV2 &operator=(const AmatDx9MaterialV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x403DD90000000001 */

template <>
struct Gw2StructDX9S<1>{
struct AmatDx9SamplerV1 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV1();
    AmatDx9SamplerV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV1(const AmatDx9SamplerV1 &p_other);
    AmatDx9SamplerV1 &operator=(const AmatDx9SamplerV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV1 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV1();
    AmatDx9ShaderV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV1(const AmatDx9ShaderV1 &p_other);
    AmatDx9ShaderV1 &operator=(const AmatDx9ShaderV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9RenderStatesV1 {
    helpers::Array<dword> renderStates;

public:
    AmatDx9RenderStatesV1();
    AmatDx9RenderStatesV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9RenderStatesV1(const AmatDx9RenderStatesV1 &p_other);
    AmatDx9RenderStatesV1 &operator=(const AmatDx9RenderStatesV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV1 {
    helpers::Ptr<AmatDx9RenderStatesV1> effectRenderStates;
    helpers::Array<dword> samplerIndex;
    dword pixelShader[5];
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags[5];

public:
    AmatDx9PassV1();
    AmatDx9PassV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV1(const AmatDx9PassV1 &p_other);
    AmatDx9PassV1 &operator=(const AmatDx9PassV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV1 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV1> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV1();
    AmatDx9TechniqueV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV1(const AmatDx9TechniqueV1 &p_other);
    AmatDx9TechniqueV1 &operator=(const AmatDx9TechniqueV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV1 {
    helpers::Array<AmatDx9SamplerV1> samplers;
    helpers::Array<AmatDx9ShaderV1> shaders;
    helpers::Array<AmatDx9TechniqueV1> techniques;

public:
    AmatDx9MaterialV1();
    AmatDx9MaterialV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV1(const AmatDx9MaterialV1 &p_other);
    AmatDx9MaterialV1 &operator=(const AmatDx9MaterialV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDX9S<0>{
struct AmatDx9SamplerV0 {
    dword textureIndex;
    helpers::Array<dword> state;

public:
    AmatDx9SamplerV0();
    AmatDx9SamplerV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9SamplerV0(const AmatDx9SamplerV0 &p_other);
    AmatDx9SamplerV0 &operator=(const AmatDx9SamplerV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9ShaderV0 {
    helpers::Array<dword> shader;
    helpers::Array<dword> constRegisters;
    helpers::Array<dword> constTokens;

public:
    AmatDx9ShaderV0();
    AmatDx9ShaderV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9ShaderV0(const AmatDx9ShaderV0 &p_other);
    AmatDx9ShaderV0 &operator=(const AmatDx9ShaderV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9PassV0 {
    helpers::Array<dword> renderState;
    helpers::Array<dword> samplerIndex;
    dword pixelShader;
    dword vertexShader;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;
    dword vsGenFlags;
    dword passFlags;

public:
    AmatDx9PassV0();
    AmatDx9PassV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9PassV0(const AmatDx9PassV0 &p_other);
    AmatDx9PassV0 &operator=(const AmatDx9PassV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9TechniqueV0 {
    helpers::String name;
    dword sortTri;
    helpers::Array<AmatDx9PassV0> passes;
    word maxPsVersion;
    word maxVsVersion;

public:
    AmatDx9TechniqueV0();
    AmatDx9TechniqueV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9TechniqueV0(const AmatDx9TechniqueV0 &p_other);
    AmatDx9TechniqueV0 &operator=(const AmatDx9TechniqueV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatDx9MaterialV0 {
    helpers::Array<AmatDx9SamplerV0> samplers;
    helpers::Array<AmatDx9ShaderV0> shaders;
    helpers::Array<AmatDx9TechniqueV0> techniques;

public:
    AmatDx9MaterialV0();
    AmatDx9MaterialV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatDx9MaterialV0(const AmatDx9MaterialV0 &p_other);
    AmatDx9MaterialV0 &operator=(const AmatDx9MaterialV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatDx9MaterialV0 Gw2Struct;
};


/* ===============================================
 * Chunk: TOOL, versions: 4, strucTab: 0x141AEA180
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructTOOL;

/* Version: 3, ReferencedFunction: 0x403DE63000000001 */

template <>
struct Gw2StructTOOL<3>{
struct AmatToolConstant {
    dword token;
    helpers::WString displayName;
    float4 defaultValue;
    dword flags;
    float4 minValue;
    float4 maxValue;

public:
    AmatToolConstant();
    AmatToolConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolConstant(const AmatToolConstant &p_other);
    AmatToolConstant &operator=(const AmatToolConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolTexture {
    helpers::WString texName;
    helpers::WString texDefaultFile;
    dword flags;
    helpers::Array<dword> texGen;

public:
    AmatToolTexture();
    AmatToolTexture(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolTexture(const AmatToolTexture &p_other);
    AmatToolTexture &operator=(const AmatToolTexture &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolParams {
    helpers::WString description;
    dword flags;
    byte texCoordCount;
    byte texTransformCount;
    dword decompressedTextCount;
    helpers::Array<byte> compressedText;
    helpers::Array<AmatToolConstant> constants;
    helpers::Array<AmatToolTexture> textures;

public:
    AmatToolParams();
    AmatToolParams(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolParams(const AmatToolParams &p_other);
    AmatToolParams &operator=(const AmatToolParams &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatToolParams Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x403DE5B000000001 */

template <>
struct Gw2StructTOOL<2>{
struct AmatToolConstant {
    dword token;
    helpers::WString displayName;
    float4 defaultValue;
    dword flags;
    float4 minValue;
    float4 maxValue;

public:
    AmatToolConstant();
    AmatToolConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolConstant(const AmatToolConstant &p_other);
    AmatToolConstant &operator=(const AmatToolConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolTexture {
    helpers::WString texName;
    helpers::WString texDefaultFile;
    dword flags;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;

public:
    AmatToolTexture();
    AmatToolTexture(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolTexture(const AmatToolTexture &p_other);
    AmatToolTexture &operator=(const AmatToolTexture &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolParams {
    helpers::WString description;
    dword flags;
    helpers::String text;
    byte texCoordCount;
    byte texTransformCount;
    helpers::Array<AmatToolConstant> constants;
    helpers::Array<AmatToolTexture> textures;

public:
    AmatToolParams();
    AmatToolParams(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolParams(const AmatToolParams &p_other);
    AmatToolParams &operator=(const AmatToolParams &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatToolParams Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x403DE55000000001 */

template <>
struct Gw2StructTOOL<1>{
struct AmatToolConstantV1 {
    dword token;
    helpers::WString displayName;
    float4 defaultValue;
    dword flags;
    float4 minValue;
    float4 maxValue;

public:
    AmatToolConstantV1();
    AmatToolConstantV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolConstantV1(const AmatToolConstantV1 &p_other);
    AmatToolConstantV1 &operator=(const AmatToolConstantV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolTextureV1 {
    helpers::WString texName;
    helpers::WString texDefaultFile;
    dword flags;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;

public:
    AmatToolTextureV1();
    AmatToolTextureV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolTextureV1(const AmatToolTextureV1 &p_other);
    AmatToolTextureV1 &operator=(const AmatToolTextureV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolParamsV1 {
    helpers::WString description;
    dword flags;
    helpers::String text;
    byte texCoordCount;
    byte texTransformCount;
    helpers::Array<AmatToolConstantV1> constants;
    helpers::Array<AmatToolTextureV1> textures;

public:
    AmatToolParamsV1();
    AmatToolParamsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolParamsV1(const AmatToolParamsV1 &p_other);
    AmatToolParamsV1 &operator=(const AmatToolParamsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatToolParamsV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<0>{
struct AmatToolConstantV0 {
    dword token;
    helpers::WString displayName;
    float4 defaultValue;
    dword flags;
    float4 minValue;
    float4 maxValue;

public:
    AmatToolConstantV0();
    AmatToolConstantV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolConstantV0(const AmatToolConstantV0 &p_other);
    AmatToolConstantV0 &operator=(const AmatToolConstantV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolTextureV0 {
    helpers::WString texName;
    helpers::WString texDefaultFile;
    dword flags;
    helpers::Array<dword> texGen;
    helpers::Array<dword> texTransform;

public:
    AmatToolTextureV0();
    AmatToolTextureV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolTextureV0(const AmatToolTextureV0 &p_other);
    AmatToolTextureV0 &operator=(const AmatToolTextureV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatToolParamsV0 {
    helpers::WString description;
    dword flags;
    helpers::String text;
    byte texCoordCount;
    byte texTransformCount;
    helpers::Array<AmatToolConstantV0> constants;
    helpers::Array<AmatToolTextureV0> textures;

public:
    AmatToolParamsV0();
    AmatToolParamsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatToolParamsV0(const AmatToolParamsV0 &p_other);
    AmatToolParamsV0 &operator=(const AmatToolParamsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatToolParamsV0 Gw2Struct;
};


/* ===============================================
 * Chunk: BGFX, versions: 2, strucTab: 0x141AEA1E0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructBGFX;

/* Version: 1, ReferencedFunction: 0x403DD84000000001 */

template <>
struct Gw2StructBGFX<1>{
struct AmatGfxShaderConstant {
    dword token;

public:
    AmatGfxShaderConstant();
    AmatGfxShaderConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShaderConstant(const AmatGfxShaderConstant &p_other);
    AmatGfxShaderConstant &operator=(const AmatGfxShaderConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxSamplerConstant {
    qword token;
    dword stateIndex;
    dword textureIndex;
    dword textureSlot;

public:
    AmatGfxSamplerConstant();
    AmatGfxSamplerConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxSamplerConstant(const AmatGfxSamplerConstant &p_other);
    AmatGfxSamplerConstant &operator=(const AmatGfxSamplerConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxShaderBinary {
    helpers::Array<byte> data;
    helpers::Array<AmatGfxShaderConstant> constants;
    helpers::Array<AmatGfxSamplerConstant> samplers;

public:
    AmatGfxShaderBinary();
    AmatGfxShaderBinary(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShaderBinary(const AmatGfxShaderBinary &p_other);
    AmatGfxShaderBinary &operator=(const AmatGfxShaderBinary &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxShader {
    dword isPixelShader;
    AmatGfxShaderBinary dxShader;
    AmatGfxShaderBinary osxShader;

public:
    AmatGfxShader();
    AmatGfxShader(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShader(const AmatGfxShader &p_other);
    AmatGfxShader &operator=(const AmatGfxShader &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxSamplerState {
    dword state;

public:
    AmatGfxSamplerState();
    AmatGfxSamplerState(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxSamplerState(const AmatGfxSamplerState &p_other);
    AmatGfxSamplerState &operator=(const AmatGfxSamplerState &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxVertexShaderVariant {
    dword variant;
    dword vertexShaderIndex;

public:
    AmatGfxVertexShaderVariant();
    AmatGfxVertexShaderVariant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxVertexShaderVariant(const AmatGfxVertexShaderVariant &p_other);
    AmatGfxVertexShaderVariant &operator=(const AmatGfxVertexShaderVariant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxEffect {
    qword token;
    qword renderState;
    dword shaderPassFlags;
    dword pixelShaderIndex;
    helpers::Array<AmatGfxVertexShaderVariant> vertexShaderVariants;

public:
    AmatGfxEffect();
    AmatGfxEffect(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxEffect(const AmatGfxEffect &p_other);
    AmatGfxEffect &operator=(const AmatGfxEffect &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxPass {
    helpers::Array<AmatGfxEffect> effects;

public:
    AmatGfxPass();
    AmatGfxPass(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxPass(const AmatGfxPass &p_other);
    AmatGfxPass &operator=(const AmatGfxPass &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxTechnique {
    dword quality;
    helpers::Array<AmatGfxPass> passes;

public:
    AmatGfxTechnique();
    AmatGfxTechnique(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxTechnique(const AmatGfxTechnique &p_other);
    AmatGfxTechnique &operator=(const AmatGfxTechnique &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxMaterial {
    helpers::Array<AmatGfxShader> shaders;
    helpers::Array<AmatGfxSamplerState> samplers;
    helpers::Array<AmatGfxTechnique> techniques;

public:
    AmatGfxMaterial();
    AmatGfxMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxMaterial(const AmatGfxMaterial &p_other);
    AmatGfxMaterial &operator=(const AmatGfxMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGfxMaterial Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructBGFX<0>{
struct AmatGfxShaderConstant {
    dword token;

public:
    AmatGfxShaderConstant();
    AmatGfxShaderConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShaderConstant(const AmatGfxShaderConstant &p_other);
    AmatGfxShaderConstant &operator=(const AmatGfxShaderConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxSamplerConstant {
    qword token;
    dword stateIndex;
    dword textureIndex;
    dword textureSlot;

public:
    AmatGfxSamplerConstant();
    AmatGfxSamplerConstant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxSamplerConstant(const AmatGfxSamplerConstant &p_other);
    AmatGfxSamplerConstant &operator=(const AmatGfxSamplerConstant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxShaderBinary {
    helpers::Array<byte> data;
    helpers::Array<AmatGfxShaderConstant> constants;
    helpers::Array<AmatGfxSamplerConstant> samplers;

public:
    AmatGfxShaderBinary();
    AmatGfxShaderBinary(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShaderBinary(const AmatGfxShaderBinary &p_other);
    AmatGfxShaderBinary &operator=(const AmatGfxShaderBinary &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxShader {
    dword isPixelShader;
    AmatGfxShaderBinary dxShader;
    AmatGfxShaderBinary osxShader;

public:
    AmatGfxShader();
    AmatGfxShader(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxShader(const AmatGfxShader &p_other);
    AmatGfxShader &operator=(const AmatGfxShader &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxSamplerState {
    dword state;

public:
    AmatGfxSamplerState();
    AmatGfxSamplerState(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxSamplerState(const AmatGfxSamplerState &p_other);
    AmatGfxSamplerState &operator=(const AmatGfxSamplerState &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxVertexShaderVariant {
    dword variant;
    dword vertexShaderIndex;

public:
    AmatGfxVertexShaderVariant();
    AmatGfxVertexShaderVariant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxVertexShaderVariant(const AmatGfxVertexShaderVariant &p_other);
    AmatGfxVertexShaderVariant &operator=(const AmatGfxVertexShaderVariant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxEffect {
    qword token;
    qword renderState;
    dword shaderPassFlags;
    dword pixelShaderIndex;
    helpers::Array<AmatGfxVertexShaderVariant> vertexShaderVariants;

public:
    AmatGfxEffect();
    AmatGfxEffect(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxEffect(const AmatGfxEffect &p_other);
    AmatGfxEffect &operator=(const AmatGfxEffect &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxPass {
    helpers::Array<AmatGfxEffect> effects;

public:
    AmatGfxPass();
    AmatGfxPass(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxPass(const AmatGfxPass &p_other);
    AmatGfxPass &operator=(const AmatGfxPass &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxTechnique {
    dword quality;
    helpers::Array<AmatGfxPass> passes;

public:
    AmatGfxTechnique();
    AmatGfxTechnique(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxTechnique(const AmatGfxTechnique &p_other);
    AmatGfxTechnique &operator=(const AmatGfxTechnique &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmatGfxMaterial {
    helpers::Array<AmatGfxShader> shaders;
    helpers::Array<AmatGfxSamplerState> samplers;
    helpers::Array<AmatGfxTechnique> techniques;

public:
    AmatGfxMaterial();
    AmatGfxMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmatGfxMaterial(const AmatGfxMaterial &p_other);
    AmatGfxMaterial &operator=(const AmatGfxMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef AmatGfxMaterial Gw2Struct;
};


/* ===============================================
 * Chunk: PGTB, versions: 4, strucTab: 0x141B7B5F0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructPGTB;

/* Version: 3, ReferencedFunction: 0x404470A000000001 */

template <>
struct Gw2StructPGTB<3>{
struct PagedImageLayerDataV3 {
    dword2 rawDims;
    dword2 strippedDims;
    dword rawFormat;
    dword strippedFormat;
    dword diskFormat;

public:
    PagedImageLayerDataV3();
    PagedImageLayerDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV3(const PagedImageLayerDataV3 &p_other);
    PagedImageLayerDataV3 &operator=(const PagedImageLayerDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV3 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV3();
    PagedImagePageDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV3(const PagedImagePageDataV3 &p_other);
    PagedImagePageDataV3 &operator=(const PagedImagePageDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV3 {
    helpers::Array<PagedImageLayerDataV3> layers;
    helpers::Array<PagedImagePageDataV3> rawPages;
    helpers::Array<PagedImagePageDataV3> strippedPages;
    dword flags;

public:
    PagedImageTableDataV3();
    PagedImageTableDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV3(const PagedImageTableDataV3 &p_other);
    PagedImageTableDataV3 &operator=(const PagedImageTableDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPGTB<2>{
struct PagedImageLayerDataV2 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV2();
    PagedImageLayerDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV2(const PagedImageLayerDataV2 &p_other);
    PagedImageLayerDataV2 &operator=(const PagedImageLayerDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV2 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV2();
    PagedImagePageDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV2(const PagedImagePageDataV2 &p_other);
    PagedImagePageDataV2 &operator=(const PagedImagePageDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV2 {
    helpers::Array<PagedImageLayerDataV2> layers;
    helpers::Array<PagedImagePageDataV2> pages;
    dword flags;

public:
    PagedImageTableDataV2();
    PagedImageTableDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV2(const PagedImageTableDataV2 &p_other);
    PagedImageTableDataV2 &operator=(const PagedImageTableDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPGTB<1>{
struct PagedImageLayerDataV1 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV1();
    PagedImageLayerDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV1(const PagedImageLayerDataV1 &p_other);
    PagedImageLayerDataV1 &operator=(const PagedImageLayerDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV1 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV1();
    PagedImagePageDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV1(const PagedImagePageDataV1 &p_other);
    PagedImagePageDataV1 &operator=(const PagedImagePageDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV1 {
    helpers::Array<PagedImageLayerDataV1> layers;
    helpers::Array<PagedImagePageDataV1> pages;

public:
    PagedImageTableDataV1();
    PagedImageTableDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV1(const PagedImageTableDataV1 &p_other);
    PagedImageTableDataV1 &operator=(const PagedImageTableDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPGTB<0>{
struct PagedImageLayerDataV0 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV0();
    PagedImageLayerDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV0(const PagedImageLayerDataV0 &p_other);
    PagedImageLayerDataV0 &operator=(const PagedImageLayerDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV0 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;

public:
    PagedImagePageDataV0();
    PagedImagePageDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV0(const PagedImagePageDataV0 &p_other);
    PagedImagePageDataV0 &operator=(const PagedImagePageDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV0 {
    helpers::Array<PagedImageLayerDataV0> layers;
    helpers::Array<PagedImagePageDataV0> pages;

public:
    PagedImageTableDataV0();
    PagedImageTableDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV0(const PagedImageTableDataV0 &p_other);
    PagedImageTableDataV0 &operator=(const PagedImageTableDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: DATA, versions: 4, strucTab: 0x141B7B650
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructDATA;

/* Version: 3, ReferencedFunction: 0x4044723000000001 */

template <>
struct Gw2StructDATA<3>{
struct PagedImageLayerDataV3 {
    dword2 rawDims;
    dword2 strippedDims;
    dword rawFormat;
    dword strippedFormat;
    dword diskFormat;

public:
    PagedImageLayerDataV3();
    PagedImageLayerDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV3(const PagedImageLayerDataV3 &p_other);
    PagedImageLayerDataV3 &operator=(const PagedImageLayerDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV3 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV3();
    PagedImagePageDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV3(const PagedImagePageDataV3 &p_other);
    PagedImagePageDataV3 &operator=(const PagedImagePageDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV3 {
    helpers::Array<PagedImageLayerDataV3> layers;
    helpers::Array<PagedImagePageDataV3> rawPages;
    helpers::Array<PagedImagePageDataV3> strippedPages;
    dword flags;

public:
    PagedImageTableDataV3();
    PagedImageTableDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV3(const PagedImageTableDataV3 &p_other);
    PagedImageTableDataV3 &operator=(const PagedImageTableDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDATA<2>{
struct PagedImageLayerDataV2 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV2();
    PagedImageLayerDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV2(const PagedImageLayerDataV2 &p_other);
    PagedImageLayerDataV2 &operator=(const PagedImageLayerDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV2 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV2();
    PagedImagePageDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV2(const PagedImagePageDataV2 &p_other);
    PagedImagePageDataV2 &operator=(const PagedImagePageDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV2 {
    helpers::Array<PagedImageLayerDataV2> layers;
    helpers::Array<PagedImagePageDataV2> pages;
    dword flags;

public:
    PagedImageTableDataV2();
    PagedImageTableDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV2(const PagedImageTableDataV2 &p_other);
    PagedImageTableDataV2 &operator=(const PagedImageTableDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDATA<1>{
struct PagedImageLayerDataV1 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV1();
    PagedImageLayerDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV1(const PagedImageLayerDataV1 &p_other);
    PagedImageLayerDataV1 &operator=(const PagedImageLayerDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV1 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV1();
    PagedImagePageDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV1(const PagedImagePageDataV1 &p_other);
    PagedImagePageDataV1 &operator=(const PagedImagePageDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV1 {
    helpers::Array<PagedImageLayerDataV1> layers;
    helpers::Array<PagedImagePageDataV1> pages;

public:
    PagedImageTableDataV1();
    PagedImageTableDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV1(const PagedImageTableDataV1 &p_other);
    PagedImageTableDataV1 &operator=(const PagedImageTableDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageTableDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructDATA<0>{
struct PagedImageEmbeddedPageDataV0 {
    dword layer;
    dword2 coord;
    helpers::Array<byte> rawData;
    helpers::Array<byte> compressedData;

public:
    PagedImageEmbeddedPageDataV0();
    PagedImageEmbeddedPageDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPageDataV0(const PagedImageEmbeddedPageDataV0 &p_other);
    PagedImageEmbeddedPageDataV0 &operator=(const PagedImageEmbeddedPageDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPagesDataV0 {
    helpers::Array<PagedImageEmbeddedPageDataV0> pages;

public:
    PagedImageEmbeddedPagesDataV0();
    PagedImageEmbeddedPagesDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPagesDataV0(const PagedImageEmbeddedPagesDataV0 &p_other);
    PagedImageEmbeddedPagesDataV0 &operator=(const PagedImageEmbeddedPagesDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PagedImageEmbeddedPagesDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: txtm, versions: 1, strucTab: 0x141BB2C00
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtxtm;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtxtm<0>{
struct TextPackLanguage {
    helpers::Array<helpers::FileName> filenames;

public:
    TextPackLanguage();
    TextPackLanguage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackLanguage(const TextPackLanguage &p_other);
    TextPackLanguage &operator=(const TextPackLanguage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextPackManifest {
    dword stringsPerFile;
    helpers::Array<TextPackLanguage> languages;

public:
    TextPackManifest();
    TextPackManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackManifest(const TextPackManifest &p_other);
    TextPackManifest &operator=(const TextPackManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef TextPackManifest Gw2Struct;
};


/* ===============================================
 * Chunk: txtp, versions: 1, strucTab: 0x141BB2C28
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtxtp;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtxtp<0>{
struct TextPackPassword {
    dword textId;
    qword password;

public:
    TextPackPassword();
    TextPackPassword(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackPassword(const TextPackPassword &p_other);
    TextPackPassword &operator=(const TextPackPassword &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextPackPasswords {
    dword stringCount;
    helpers::Array<TextPackPassword> passwords;

public:
    TextPackPasswords();
    TextPackPasswords(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackPasswords(const TextPackPasswords &p_other);
    TextPackPasswords &operator=(const TextPackPasswords &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef TextPackPasswords Gw2Struct;
};


/* ===============================================
 * Chunk: txtv, versions: 1, strucTab: 0x141BB2C50
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtxtv;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtxtv<0>{
struct TextPackVoice {
    dword textId;
    dword voiceId;

public:
    TextPackVoice();
    TextPackVoice(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackVoice(const TextPackVoice &p_other);
    TextPackVoice &operator=(const TextPackVoice &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextPackVoices {
    helpers::Array<TextPackVoice> voices;

public:
    TextPackVoices();
    TextPackVoices(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackVoices(const TextPackVoices &p_other);
    TextPackVoices &operator=(const TextPackVoices &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef TextPackVoices Gw2Struct;
};


/* ===============================================
 * Chunk: vari, versions: 1, strucTab: 0x141BB2C78
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structvari;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structvari<0>{
struct TextPackVariant {
    dword textId;
    helpers::Array<dword> variantTextIds;

public:
    TextPackVariant();
    TextPackVariant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackVariant(const TextPackVariant &p_other);
    TextPackVariant &operator=(const TextPackVariant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextPackVariants {
    helpers::Array<TextPackVariant> variants;

public:
    TextPackVariants();
    TextPackVariants(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextPackVariants(const TextPackVariants &p_other);
    TextPackVariants &operator=(const TextPackVariants &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef TextPackVariants Gw2Struct;
};


/* ===============================================
 * Chunk: AMSP, versions: 33, strucTab: 0x141FD5660
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructAMSP;

/* Version: 32, ReferencedFunction: 0x40F84B1000000001 */

template <>
struct Gw2StructAMSP<32>{
struct DspDataV31 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV31();
    DspDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV31(const DspDataV31 &p_other);
    DspDataV31 &operator=(const DspDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV31 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV31> dsp;

public:
    BussDynamicDataV31();
    BussDynamicDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV31(const BussDynamicDataV31 &p_other);
    BussDynamicDataV31 &operator=(const BussDynamicDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV31 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV31> dynamicData;

public:
    BussDataV31();
    BussDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV31(const BussDataV31 &p_other);
    BussDataV31 &operator=(const BussDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV31 {
    float offset;
    float value;

public:
    EnvelopePointDataV31();
    EnvelopePointDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV31(const EnvelopePointDataV31 &p_other);
    EnvelopePointDataV31 &operator=(const EnvelopePointDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV31 {
    float inputOffset;
    qword inputOffsetProperty;
    qword inputParameter;
    float inputScale;
    qword inputScaleProperty;
    byte inputType;
    float outputOffset;
    qword outputOffsetProperty;
    float outputScale;
    qword outputScaleProperty;
    helpers::Array<EnvelopePointDataV31> envelopePoint;

public:
    EnvelopeDataV31();
    EnvelopeDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV31(const EnvelopeDataV31 &p_other);
    EnvelopeDataV31 &operator=(const EnvelopeDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV31 {
    float max;
    float min;
    byte min;

public:
    RangeDataV31();
    RangeDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV31(const RangeDataV31 &p_other);
    RangeDataV31 &operator=(const RangeDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV31 {
    RangeDataV31 time;
    RangeDataV31 value;

public:
    RandomParamDataV31();
    RandomParamDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV31(const RandomParamDataV31 &p_other);
    RandomParamDataV31 &operator=(const RandomParamDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV31 {
    helpers::Ptr<EnvelopeDataV31> envelopeData;
    helpers::Ptr<RandomParamDataV31> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV31();
    DynamicParamDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV31(const DynamicParamDataV31 &p_other);
    DynamicParamDataV31 &operator=(const DynamicParamDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV31 {
    float doppler;
    DynamicParamDataV31 lowPass;
    DynamicParamDataV31 highPass;
    DynamicParamDataV31 pan3D;
    DynamicParamDataV31 reverb;
    DynamicParamDataV31 spread3D;
    DynamicParamDataV31 volumeA;
    DynamicParamDataV31 volumeB;
    DynamicParamDataV31 lfe;

public:
    AttenuationDataV31();
    AttenuationDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV31(const AttenuationDataV31 &p_other);
    AttenuationDataV31 &operator=(const AttenuationDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV31 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV31();
    CategoryDynamicDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV31(const CategoryDynamicDataV31 &p_other);
    CategoryDynamicDataV31 &operator=(const CategoryDynamicDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV31 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV31> attenuation;
    helpers::Ptr<CategoryDynamicDataV31> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV31();
    CategoryDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV31(const CategoryDataV31 &p_other);
    CategoryDataV31 &operator=(const CategoryDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV31 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV31();
    MaterialDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV31(const MaterialDataV31 &p_other);
    MaterialDataV31 &operator=(const MaterialDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV31 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV31();
    MusicConditionDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV31(const MusicConditionDataV31 &p_other);
    MusicConditionDataV31 &operator=(const MusicConditionDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV31 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV31();
    FileNameDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV31(const FileNameDataV31 &p_other);
    FileNameDataV31 &operator=(const FileNameDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV31 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV31> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV31 initialSilence;
    RangeDataV31 intervalSilence;
    RangeDataV31 maxPlayLength;
    DynamicParamDataV31 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV31();
    MusicPlaylistDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV31(const MusicPlaylistDataV31 &p_other);
    MusicPlaylistDataV31 &operator=(const MusicPlaylistDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV31 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV31();
    PropertyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV31(const PropertyDataV31 &p_other);
    PropertyDataV31 &operator=(const PropertyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV31 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV31();
    ReverbDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV31(const ReverbDataV31 &p_other);
    ReverbDataV31 &operator=(const ReverbDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV31 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV31();
    ScriptRefDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV31(const ScriptRefDataV31 &p_other);
    ScriptRefDataV31 &operator=(const ScriptRefDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV31 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV31> buss;
    helpers::Array<CategoryDynamicDataV31> category;
    byte priority;

public:
    SnapshotDataV31();
    SnapshotDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV31(const SnapshotDataV31 &p_other);
    SnapshotDataV31 &operator=(const SnapshotDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicExternalDataV31 {
    qword name;
    helpers::WString externalPlaylist;

public:
    MusicExternalDataV31();
    MusicExternalDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicExternalDataV31(const MusicExternalDataV31 &p_other);
    MusicExternalDataV31 &operator=(const MusicExternalDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV31 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV31> buss;
    helpers::Array<CategoryDataV31> category;
    helpers::Array<MaterialDataV31> material;
    helpers::Array<MusicConditionDataV31> musicCondition;
    helpers::Array<MusicPlaylistDataV31> musicPlaylist;
    helpers::Array<PropertyDataV31> property;
    helpers::Array<ReverbDataV31> reverb;
    helpers::Array<ScriptRefDataV31> scriptRef;
    helpers::Array<SnapshotDataV31> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;
    helpers::Array<MusicExternalDataV31> musicExternal;

public:
    AudioSettingsDataV31();
    AudioSettingsDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV31(const AudioSettingsDataV31 &p_other);
    AudioSettingsDataV31 &operator=(const AudioSettingsDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV31 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV31();
    HandlerDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV31(const HandlerDataV31 &p_other);
    HandlerDataV31 &operator=(const HandlerDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV31 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV31> dsp;
    helpers::Ptr<AttenuationDataV31> attenuation;
    helpers::Array<FileNameDataV31> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float modelScaleSizeFactor;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV31 depth;
    DynamicParamDataV31 pan;
    DynamicParamDataV31 pitch;
    DynamicParamDataV31 pitchMS;
    DynamicParamDataV31 volume;
    DynamicParamDataV31 volumeMS;
    RangeDataV31 initialDelay;
    RangeDataV31 playLength;
    RangeDataV31 positionOffsetAngle;
    RangeDataV31 positionRange;
    RangeDataV31 repeatCount;
    RangeDataV31 repeatTime;
    RangeDataV31 replayDelay;
    RangeDataV31 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV31();
    MetaSoundDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV31(const MetaSoundDataV31 &p_other);
    MetaSoundDataV31 &operator=(const MetaSoundDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV31 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV31();
    TriggerMarkerDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV31(const TriggerMarkerDataV31 &p_other);
    TriggerMarkerDataV31 &operator=(const TriggerMarkerDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV31 {
    qword name;
    helpers::Array<TriggerMarkerDataV31> triggerMarker;

public:
    TriggerKeyDataV31();
    TriggerKeyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV31(const TriggerKeyDataV31 &p_other);
    TriggerKeyDataV31 &operator=(const TriggerKeyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV32 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV31> audioSettings;
    helpers::Array<HandlerDataV31> handler;
    helpers::Array<MetaSoundDataV31> metaSound;
    helpers::Array<ScriptRefDataV31> scriptRef;
    helpers::Array<TriggerKeyDataV31> triggerKey;
    helpers::Array<PropertyDataV31> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;
    byte soundPoolMode;
    byte interpolation;
    float radialLimit;
    RangeDataV31 scaleBucketRange;

public:
    ScriptFileDataV32();
    ScriptFileDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV32(const ScriptFileDataV32 &p_other);
    ScriptFileDataV32 &operator=(const ScriptFileDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV32 Gw2Struct;
};

/* Version: 31, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<31>{
struct DspDataV31 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV31();
    DspDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV31(const DspDataV31 &p_other);
    DspDataV31 &operator=(const DspDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV31 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV31> dsp;

public:
    BussDynamicDataV31();
    BussDynamicDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV31(const BussDynamicDataV31 &p_other);
    BussDynamicDataV31 &operator=(const BussDynamicDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV31 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV31> dynamicData;

public:
    BussDataV31();
    BussDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV31(const BussDataV31 &p_other);
    BussDataV31 &operator=(const BussDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV31 {
    float offset;
    float value;

public:
    EnvelopePointDataV31();
    EnvelopePointDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV31(const EnvelopePointDataV31 &p_other);
    EnvelopePointDataV31 &operator=(const EnvelopePointDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV31 {
    float inputOffset;
    qword inputOffsetProperty;
    qword inputParameter;
    float inputScale;
    qword inputScaleProperty;
    byte inputType;
    float outputOffset;
    qword outputOffsetProperty;
    float outputScale;
    qword outputScaleProperty;
    helpers::Array<EnvelopePointDataV31> envelopePoint;

public:
    EnvelopeDataV31();
    EnvelopeDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV31(const EnvelopeDataV31 &p_other);
    EnvelopeDataV31 &operator=(const EnvelopeDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV31 {
    float max;
    float min;
    byte min;

public:
    RangeDataV31();
    RangeDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV31(const RangeDataV31 &p_other);
    RangeDataV31 &operator=(const RangeDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV31 {
    RangeDataV31 time;
    RangeDataV31 value;

public:
    RandomParamDataV31();
    RandomParamDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV31(const RandomParamDataV31 &p_other);
    RandomParamDataV31 &operator=(const RandomParamDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV31 {
    helpers::Ptr<EnvelopeDataV31> envelopeData;
    helpers::Ptr<RandomParamDataV31> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV31();
    DynamicParamDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV31(const DynamicParamDataV31 &p_other);
    DynamicParamDataV31 &operator=(const DynamicParamDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV31 {
    float doppler;
    DynamicParamDataV31 lowPass;
    DynamicParamDataV31 highPass;
    DynamicParamDataV31 pan3D;
    DynamicParamDataV31 reverb;
    DynamicParamDataV31 spread3D;
    DynamicParamDataV31 volumeA;
    DynamicParamDataV31 volumeB;
    DynamicParamDataV31 lfe;

public:
    AttenuationDataV31();
    AttenuationDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV31(const AttenuationDataV31 &p_other);
    AttenuationDataV31 &operator=(const AttenuationDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV31 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV31();
    CategoryDynamicDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV31(const CategoryDynamicDataV31 &p_other);
    CategoryDynamicDataV31 &operator=(const CategoryDynamicDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV31 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV31> attenuation;
    helpers::Ptr<CategoryDynamicDataV31> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV31();
    CategoryDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV31(const CategoryDataV31 &p_other);
    CategoryDataV31 &operator=(const CategoryDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV31 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV31();
    MaterialDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV31(const MaterialDataV31 &p_other);
    MaterialDataV31 &operator=(const MaterialDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV31 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV31();
    MusicConditionDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV31(const MusicConditionDataV31 &p_other);
    MusicConditionDataV31 &operator=(const MusicConditionDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV31 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV31();
    FileNameDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV31(const FileNameDataV31 &p_other);
    FileNameDataV31 &operator=(const FileNameDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV31 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV31> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV31 initialSilence;
    RangeDataV31 intervalSilence;
    RangeDataV31 maxPlayLength;
    DynamicParamDataV31 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV31();
    MusicPlaylistDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV31(const MusicPlaylistDataV31 &p_other);
    MusicPlaylistDataV31 &operator=(const MusicPlaylistDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV31 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV31();
    PropertyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV31(const PropertyDataV31 &p_other);
    PropertyDataV31 &operator=(const PropertyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV31 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV31();
    ReverbDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV31(const ReverbDataV31 &p_other);
    ReverbDataV31 &operator=(const ReverbDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV31 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV31();
    ScriptRefDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV31(const ScriptRefDataV31 &p_other);
    ScriptRefDataV31 &operator=(const ScriptRefDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV31 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV31> buss;
    helpers::Array<CategoryDynamicDataV31> category;
    byte priority;

public:
    SnapshotDataV31();
    SnapshotDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV31(const SnapshotDataV31 &p_other);
    SnapshotDataV31 &operator=(const SnapshotDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicExternalDataV31 {
    qword name;
    helpers::WString externalPlaylist;

public:
    MusicExternalDataV31();
    MusicExternalDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicExternalDataV31(const MusicExternalDataV31 &p_other);
    MusicExternalDataV31 &operator=(const MusicExternalDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV31 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV31> buss;
    helpers::Array<CategoryDataV31> category;
    helpers::Array<MaterialDataV31> material;
    helpers::Array<MusicConditionDataV31> musicCondition;
    helpers::Array<MusicPlaylistDataV31> musicPlaylist;
    helpers::Array<PropertyDataV31> property;
    helpers::Array<ReverbDataV31> reverb;
    helpers::Array<ScriptRefDataV31> scriptRef;
    helpers::Array<SnapshotDataV31> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;
    helpers::Array<MusicExternalDataV31> musicExternal;

public:
    AudioSettingsDataV31();
    AudioSettingsDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV31(const AudioSettingsDataV31 &p_other);
    AudioSettingsDataV31 &operator=(const AudioSettingsDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV31 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV31();
    HandlerDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV31(const HandlerDataV31 &p_other);
    HandlerDataV31 &operator=(const HandlerDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV31 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV31> dsp;
    helpers::Ptr<AttenuationDataV31> attenuation;
    helpers::Array<FileNameDataV31> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float modelScaleSizeFactor;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV31 depth;
    DynamicParamDataV31 pan;
    DynamicParamDataV31 pitch;
    DynamicParamDataV31 pitchMS;
    DynamicParamDataV31 volume;
    DynamicParamDataV31 volumeMS;
    RangeDataV31 initialDelay;
    RangeDataV31 playLength;
    RangeDataV31 positionOffsetAngle;
    RangeDataV31 positionRange;
    RangeDataV31 repeatCount;
    RangeDataV31 repeatTime;
    RangeDataV31 replayDelay;
    RangeDataV31 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV31();
    MetaSoundDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV31(const MetaSoundDataV31 &p_other);
    MetaSoundDataV31 &operator=(const MetaSoundDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV31 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV31();
    TriggerMarkerDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV31(const TriggerMarkerDataV31 &p_other);
    TriggerMarkerDataV31 &operator=(const TriggerMarkerDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV31 {
    qword name;
    helpers::Array<TriggerMarkerDataV31> triggerMarker;

public:
    TriggerKeyDataV31();
    TriggerKeyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV31(const TriggerKeyDataV31 &p_other);
    TriggerKeyDataV31 &operator=(const TriggerKeyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV31 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV31> audioSettings;
    helpers::Array<HandlerDataV31> handler;
    helpers::Array<MetaSoundDataV31> metaSound;
    helpers::Array<ScriptRefDataV31> scriptRef;
    helpers::Array<TriggerKeyDataV31> triggerKey;
    helpers::Array<PropertyDataV31> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;
    byte soundPoolMode;

public:
    ScriptFileDataV31();
    ScriptFileDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV31(const ScriptFileDataV31 &p_other);
    ScriptFileDataV31 &operator=(const ScriptFileDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV31 Gw2Struct;
};

/* Version: 30, ReferencedFunction: 0x40F8497000000001 */

template <>
struct Gw2StructAMSP<30>{
struct DspDataV30 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV30();
    DspDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV30(const DspDataV30 &p_other);
    DspDataV30 &operator=(const DspDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV30 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV30> dsp;

public:
    BussDynamicDataV30();
    BussDynamicDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV30(const BussDynamicDataV30 &p_other);
    BussDynamicDataV30 &operator=(const BussDynamicDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV30 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV30> dynamicData;

public:
    BussDataV30();
    BussDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV30(const BussDataV30 &p_other);
    BussDataV30 &operator=(const BussDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV30 {
    float offset;
    float value;

public:
    EnvelopePointDataV30();
    EnvelopePointDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV30(const EnvelopePointDataV30 &p_other);
    EnvelopePointDataV30 &operator=(const EnvelopePointDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV30 {
    float inputOffset;
    qword inputOffsetProperty;
    qword inputParameter;
    float inputScale;
    qword inputScaleProperty;
    byte inputType;
    float outputOffset;
    qword outputOffsetProperty;
    float outputScale;
    qword outputScaleProperty;
    helpers::Array<EnvelopePointDataV30> envelopePoint;

public:
    EnvelopeDataV30();
    EnvelopeDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV30(const EnvelopeDataV30 &p_other);
    EnvelopeDataV30 &operator=(const EnvelopeDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV30 {
    float max;
    float min;
    byte min;

public:
    RangeDataV30();
    RangeDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV30(const RangeDataV30 &p_other);
    RangeDataV30 &operator=(const RangeDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV30 {
    RangeDataV30 time;
    RangeDataV30 value;

public:
    RandomParamDataV30();
    RandomParamDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV30(const RandomParamDataV30 &p_other);
    RandomParamDataV30 &operator=(const RandomParamDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV30 {
    helpers::Ptr<EnvelopeDataV30> envelopeData;
    helpers::Ptr<RandomParamDataV30> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV30();
    DynamicParamDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV30(const DynamicParamDataV30 &p_other);
    DynamicParamDataV30 &operator=(const DynamicParamDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV30 {
    float doppler;
    DynamicParamDataV30 lowPass;
    DynamicParamDataV30 highPass;
    DynamicParamDataV30 pan3D;
    DynamicParamDataV30 reverb;
    DynamicParamDataV30 spread3D;
    DynamicParamDataV30 volumeA;
    DynamicParamDataV30 volumeB;
    DynamicParamDataV30 lfe;

public:
    AttenuationDataV30();
    AttenuationDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV30(const AttenuationDataV30 &p_other);
    AttenuationDataV30 &operator=(const AttenuationDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV30 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV30();
    CategoryDynamicDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV30(const CategoryDynamicDataV30 &p_other);
    CategoryDynamicDataV30 &operator=(const CategoryDynamicDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV30 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV30> attenuation;
    helpers::Ptr<CategoryDynamicDataV30> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV30();
    CategoryDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV30(const CategoryDataV30 &p_other);
    CategoryDataV30 &operator=(const CategoryDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV30 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV30();
    MaterialDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV30(const MaterialDataV30 &p_other);
    MaterialDataV30 &operator=(const MaterialDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV30 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV30();
    MusicConditionDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV30(const MusicConditionDataV30 &p_other);
    MusicConditionDataV30 &operator=(const MusicConditionDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV30 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV30();
    FileNameDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV30(const FileNameDataV30 &p_other);
    FileNameDataV30 &operator=(const FileNameDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV30 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV30> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV30 initialSilence;
    RangeDataV30 intervalSilence;
    RangeDataV30 maxPlayLength;
    DynamicParamDataV30 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV30();
    MusicPlaylistDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV30(const MusicPlaylistDataV30 &p_other);
    MusicPlaylistDataV30 &operator=(const MusicPlaylistDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV30 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV30();
    PropertyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV30(const PropertyDataV30 &p_other);
    PropertyDataV30 &operator=(const PropertyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV30 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV30();
    ReverbDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV30(const ReverbDataV30 &p_other);
    ReverbDataV30 &operator=(const ReverbDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV30 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV30();
    ScriptRefDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV30(const ScriptRefDataV30 &p_other);
    ScriptRefDataV30 &operator=(const ScriptRefDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV30 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV30> buss;
    helpers::Array<CategoryDynamicDataV30> category;
    byte priority;

public:
    SnapshotDataV30();
    SnapshotDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV30(const SnapshotDataV30 &p_other);
    SnapshotDataV30 &operator=(const SnapshotDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicExternalDataV30 {
    qword name;
    helpers::WString externalPlaylist;

public:
    MusicExternalDataV30();
    MusicExternalDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicExternalDataV30(const MusicExternalDataV30 &p_other);
    MusicExternalDataV30 &operator=(const MusicExternalDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV30 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV30> buss;
    helpers::Array<CategoryDataV30> category;
    helpers::Array<MaterialDataV30> material;
    helpers::Array<MusicConditionDataV30> musicCondition;
    helpers::Array<MusicPlaylistDataV30> musicPlaylist;
    helpers::Array<PropertyDataV30> property;
    helpers::Array<ReverbDataV30> reverb;
    helpers::Array<ScriptRefDataV30> scriptRef;
    helpers::Array<SnapshotDataV30> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;
    helpers::Array<MusicExternalDataV30> musicExternal;

public:
    AudioSettingsDataV30();
    AudioSettingsDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV30(const AudioSettingsDataV30 &p_other);
    AudioSettingsDataV30 &operator=(const AudioSettingsDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV30 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV30();
    HandlerDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV30(const HandlerDataV30 &p_other);
    HandlerDataV30 &operator=(const HandlerDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV30 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV30> dsp;
    helpers::Ptr<AttenuationDataV30> attenuation;
    helpers::Array<FileNameDataV30> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV30 depth;
    DynamicParamDataV30 pan;
    DynamicParamDataV30 pitch;
    DynamicParamDataV30 pitchMS;
    DynamicParamDataV30 volume;
    DynamicParamDataV30 volumeMS;
    RangeDataV30 initialDelay;
    RangeDataV30 playLength;
    RangeDataV30 positionOffsetAngle;
    RangeDataV30 positionRange;
    RangeDataV30 repeatCount;
    RangeDataV30 repeatTime;
    RangeDataV30 replayDelay;
    RangeDataV30 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV30();
    MetaSoundDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV30(const MetaSoundDataV30 &p_other);
    MetaSoundDataV30 &operator=(const MetaSoundDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV30 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV30();
    TriggerMarkerDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV30(const TriggerMarkerDataV30 &p_other);
    TriggerMarkerDataV30 &operator=(const TriggerMarkerDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV30 {
    qword name;
    helpers::Array<TriggerMarkerDataV30> triggerMarker;

public:
    TriggerKeyDataV30();
    TriggerKeyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV30(const TriggerKeyDataV30 &p_other);
    TriggerKeyDataV30 &operator=(const TriggerKeyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV30 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV30> audioSettings;
    helpers::Array<HandlerDataV30> handler;
    helpers::Array<MetaSoundDataV30> metaSound;
    helpers::Array<ScriptRefDataV30> scriptRef;
    helpers::Array<TriggerKeyDataV30> triggerKey;
    helpers::Array<PropertyDataV30> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;
    byte soundPoolMode;

public:
    ScriptFileDataV30();
    ScriptFileDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV30(const ScriptFileDataV30 &p_other);
    ScriptFileDataV30 &operator=(const ScriptFileDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV30 Gw2Struct;
};

/* Version: 29, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<29>{
struct DspDataV29 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV29();
    DspDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV29(const DspDataV29 &p_other);
    DspDataV29 &operator=(const DspDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV29 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV29> dsp;

public:
    BussDynamicDataV29();
    BussDynamicDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV29(const BussDynamicDataV29 &p_other);
    BussDynamicDataV29 &operator=(const BussDynamicDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV29 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV29> dynamicData;

public:
    BussDataV29();
    BussDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV29(const BussDataV29 &p_other);
    BussDataV29 &operator=(const BussDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV29 {
    float offset;
    float value;

public:
    EnvelopePointDataV29();
    EnvelopePointDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV29(const EnvelopePointDataV29 &p_other);
    EnvelopePointDataV29 &operator=(const EnvelopePointDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV29 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV29> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV29();
    EnvelopeDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV29(const EnvelopeDataV29 &p_other);
    EnvelopeDataV29 &operator=(const EnvelopeDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV29 {
    float max;
    float min;
    byte min;

public:
    RangeDataV29();
    RangeDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV29(const RangeDataV29 &p_other);
    RangeDataV29 &operator=(const RangeDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV29 {
    RangeDataV29 time;
    RangeDataV29 value;

public:
    RandomParamDataV29();
    RandomParamDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV29(const RandomParamDataV29 &p_other);
    RandomParamDataV29 &operator=(const RandomParamDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV29 {
    helpers::Ptr<EnvelopeDataV29> envelopeData;
    helpers::Ptr<RandomParamDataV29> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV29();
    DynamicParamDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV29(const DynamicParamDataV29 &p_other);
    DynamicParamDataV29 &operator=(const DynamicParamDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV29 {
    float doppler;
    DynamicParamDataV29 lowPass;
    DynamicParamDataV29 highPass;
    DynamicParamDataV29 pan3D;
    DynamicParamDataV29 reverb;
    DynamicParamDataV29 spread3D;
    DynamicParamDataV29 volumeA;
    DynamicParamDataV29 volumeB;
    DynamicParamDataV29 lfe;

public:
    AttenuationDataV29();
    AttenuationDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV29(const AttenuationDataV29 &p_other);
    AttenuationDataV29 &operator=(const AttenuationDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV29 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV29();
    CategoryDynamicDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV29(const CategoryDynamicDataV29 &p_other);
    CategoryDynamicDataV29 &operator=(const CategoryDynamicDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV29 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV29> attenuation;
    helpers::Ptr<CategoryDynamicDataV29> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV29();
    CategoryDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV29(const CategoryDataV29 &p_other);
    CategoryDataV29 &operator=(const CategoryDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV29 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV29();
    MaterialDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV29(const MaterialDataV29 &p_other);
    MaterialDataV29 &operator=(const MaterialDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV29 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV29();
    MusicConditionDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV29(const MusicConditionDataV29 &p_other);
    MusicConditionDataV29 &operator=(const MusicConditionDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV29 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV29();
    FileNameDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV29(const FileNameDataV29 &p_other);
    FileNameDataV29 &operator=(const FileNameDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV29 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV29> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV29 initialSilence;
    RangeDataV29 intervalSilence;
    RangeDataV29 maxPlayLength;
    DynamicParamDataV29 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV29();
    MusicPlaylistDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV29(const MusicPlaylistDataV29 &p_other);
    MusicPlaylistDataV29 &operator=(const MusicPlaylistDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV29 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV29();
    PropertyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV29(const PropertyDataV29 &p_other);
    PropertyDataV29 &operator=(const PropertyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV29 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV29();
    ReverbDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV29(const ReverbDataV29 &p_other);
    ReverbDataV29 &operator=(const ReverbDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV29 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV29();
    ScriptRefDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV29(const ScriptRefDataV29 &p_other);
    ScriptRefDataV29 &operator=(const ScriptRefDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV29 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV29> buss;
    helpers::Array<CategoryDynamicDataV29> category;
    byte priority;

public:
    SnapshotDataV29();
    SnapshotDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV29(const SnapshotDataV29 &p_other);
    SnapshotDataV29 &operator=(const SnapshotDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicExternalDataV29 {
    qword name;
    helpers::WString externalPlaylist;

public:
    MusicExternalDataV29();
    MusicExternalDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicExternalDataV29(const MusicExternalDataV29 &p_other);
    MusicExternalDataV29 &operator=(const MusicExternalDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV29 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV29> buss;
    helpers::Array<CategoryDataV29> category;
    helpers::Array<MaterialDataV29> material;
    helpers::Array<MusicConditionDataV29> musicCondition;
    helpers::Array<MusicPlaylistDataV29> musicPlaylist;
    helpers::Array<PropertyDataV29> property;
    helpers::Array<ReverbDataV29> reverb;
    helpers::Array<ScriptRefDataV29> scriptRef;
    helpers::Array<SnapshotDataV29> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;
    helpers::Array<MusicExternalDataV29> musicExternal;

public:
    AudioSettingsDataV29();
    AudioSettingsDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV29(const AudioSettingsDataV29 &p_other);
    AudioSettingsDataV29 &operator=(const AudioSettingsDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV29 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV29();
    HandlerDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV29(const HandlerDataV29 &p_other);
    HandlerDataV29 &operator=(const HandlerDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV29 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV29> dsp;
    helpers::Ptr<AttenuationDataV29> attenuation;
    helpers::Array<FileNameDataV29> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV29 depth;
    DynamicParamDataV29 pan;
    DynamicParamDataV29 pitch;
    DynamicParamDataV29 pitchMS;
    DynamicParamDataV29 volume;
    DynamicParamDataV29 volumeMS;
    RangeDataV29 initialDelay;
    RangeDataV29 playLength;
    RangeDataV29 positionOffsetAngle;
    RangeDataV29 positionRange;
    RangeDataV29 repeatCount;
    RangeDataV29 repeatTime;
    RangeDataV29 replayDelay;
    RangeDataV29 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV29();
    MetaSoundDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV29(const MetaSoundDataV29 &p_other);
    MetaSoundDataV29 &operator=(const MetaSoundDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV29 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV29();
    TriggerMarkerDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV29(const TriggerMarkerDataV29 &p_other);
    TriggerMarkerDataV29 &operator=(const TriggerMarkerDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV29 {
    qword name;
    helpers::Array<TriggerMarkerDataV29> triggerMarker;

public:
    TriggerKeyDataV29();
    TriggerKeyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV29(const TriggerKeyDataV29 &p_other);
    TriggerKeyDataV29 &operator=(const TriggerKeyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV29 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV29> audioSettings;
    helpers::Array<HandlerDataV29> handler;
    helpers::Array<MetaSoundDataV29> metaSound;
    helpers::Array<ScriptRefDataV29> scriptRef;
    helpers::Array<TriggerKeyDataV29> triggerKey;
    helpers::Array<PropertyDataV29> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;
    byte soundPoolMode;

public:
    ScriptFileDataV29();
    ScriptFileDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV29(const ScriptFileDataV29 &p_other);
    ScriptFileDataV29 &operator=(const ScriptFileDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV29 Gw2Struct;
};

/* Version: 28, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<28>{
struct DspDataV28 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV28();
    DspDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV28(const DspDataV28 &p_other);
    DspDataV28 &operator=(const DspDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV28 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV28> dsp;

public:
    BussDynamicDataV28();
    BussDynamicDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV28(const BussDynamicDataV28 &p_other);
    BussDynamicDataV28 &operator=(const BussDynamicDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV28 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV28> dynamicData;

public:
    BussDataV28();
    BussDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV28(const BussDataV28 &p_other);
    BussDataV28 &operator=(const BussDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV28 {
    float offset;
    float value;

public:
    EnvelopePointDataV28();
    EnvelopePointDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV28(const EnvelopePointDataV28 &p_other);
    EnvelopePointDataV28 &operator=(const EnvelopePointDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV28 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV28> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV28();
    EnvelopeDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV28(const EnvelopeDataV28 &p_other);
    EnvelopeDataV28 &operator=(const EnvelopeDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV28 {
    float max;
    float min;
    byte min;

public:
    RangeDataV28();
    RangeDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV28(const RangeDataV28 &p_other);
    RangeDataV28 &operator=(const RangeDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV28 {
    RangeDataV28 time;
    RangeDataV28 value;

public:
    RandomParamDataV28();
    RandomParamDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV28(const RandomParamDataV28 &p_other);
    RandomParamDataV28 &operator=(const RandomParamDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV28 {
    helpers::Ptr<EnvelopeDataV28> envelopeData;
    helpers::Ptr<RandomParamDataV28> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV28();
    DynamicParamDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV28(const DynamicParamDataV28 &p_other);
    DynamicParamDataV28 &operator=(const DynamicParamDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV28 {
    float doppler;
    DynamicParamDataV28 lowPass;
    DynamicParamDataV28 highPass;
    DynamicParamDataV28 pan3D;
    DynamicParamDataV28 reverb;
    DynamicParamDataV28 spread3D;
    DynamicParamDataV28 volumeA;
    DynamicParamDataV28 volumeB;
    DynamicParamDataV28 lfe;

public:
    AttenuationDataV28();
    AttenuationDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV28(const AttenuationDataV28 &p_other);
    AttenuationDataV28 &operator=(const AttenuationDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV28 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV28();
    CategoryDynamicDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV28(const CategoryDynamicDataV28 &p_other);
    CategoryDynamicDataV28 &operator=(const CategoryDynamicDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV28 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV28> attenuation;
    helpers::Ptr<CategoryDynamicDataV28> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV28();
    CategoryDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV28(const CategoryDataV28 &p_other);
    CategoryDataV28 &operator=(const CategoryDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV28 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV28();
    MaterialDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV28(const MaterialDataV28 &p_other);
    MaterialDataV28 &operator=(const MaterialDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV28 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV28();
    MusicConditionDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV28(const MusicConditionDataV28 &p_other);
    MusicConditionDataV28 &operator=(const MusicConditionDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV28 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV28();
    FileNameDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV28(const FileNameDataV28 &p_other);
    FileNameDataV28 &operator=(const FileNameDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV28 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV28> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV28 initialSilence;
    RangeDataV28 intervalSilence;
    RangeDataV28 maxPlayLength;
    DynamicParamDataV28 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV28();
    MusicPlaylistDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV28(const MusicPlaylistDataV28 &p_other);
    MusicPlaylistDataV28 &operator=(const MusicPlaylistDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV28 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV28();
    PropertyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV28(const PropertyDataV28 &p_other);
    PropertyDataV28 &operator=(const PropertyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV28 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV28();
    ReverbDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV28(const ReverbDataV28 &p_other);
    ReverbDataV28 &operator=(const ReverbDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV28 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV28();
    ScriptRefDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV28(const ScriptRefDataV28 &p_other);
    ScriptRefDataV28 &operator=(const ScriptRefDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV28 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV28> buss;
    helpers::Array<CategoryDynamicDataV28> category;
    byte priority;

public:
    SnapshotDataV28();
    SnapshotDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV28(const SnapshotDataV28 &p_other);
    SnapshotDataV28 &operator=(const SnapshotDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV28 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV28> buss;
    helpers::Array<CategoryDataV28> category;
    helpers::Array<MaterialDataV28> material;
    helpers::Array<MusicConditionDataV28> musicCondition;
    helpers::Array<MusicPlaylistDataV28> musicPlaylist;
    helpers::Array<PropertyDataV28> property;
    helpers::Array<ReverbDataV28> reverb;
    helpers::Array<ScriptRefDataV28> scriptRef;
    helpers::Array<SnapshotDataV28> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV28();
    AudioSettingsDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV28(const AudioSettingsDataV28 &p_other);
    AudioSettingsDataV28 &operator=(const AudioSettingsDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV28 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV28();
    HandlerDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV28(const HandlerDataV28 &p_other);
    HandlerDataV28 &operator=(const HandlerDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV28 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV28> dsp;
    helpers::Ptr<AttenuationDataV28> attenuation;
    helpers::Array<FileNameDataV28> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV28 depth;
    DynamicParamDataV28 pan;
    DynamicParamDataV28 pitch;
    DynamicParamDataV28 pitchMS;
    DynamicParamDataV28 volume;
    DynamicParamDataV28 volumeMS;
    RangeDataV28 initialDelay;
    RangeDataV28 playLength;
    RangeDataV28 positionOffsetAngle;
    RangeDataV28 positionRange;
    RangeDataV28 repeatCount;
    RangeDataV28 repeatTime;
    RangeDataV28 replayDelay;
    RangeDataV28 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV28();
    MetaSoundDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV28(const MetaSoundDataV28 &p_other);
    MetaSoundDataV28 &operator=(const MetaSoundDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV28 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV28();
    TriggerMarkerDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV28(const TriggerMarkerDataV28 &p_other);
    TriggerMarkerDataV28 &operator=(const TriggerMarkerDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV28 {
    qword name;
    helpers::Array<TriggerMarkerDataV28> triggerMarker;

public:
    TriggerKeyDataV28();
    TriggerKeyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV28(const TriggerKeyDataV28 &p_other);
    TriggerKeyDataV28 &operator=(const TriggerKeyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV28 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV28> audioSettings;
    helpers::Array<HandlerDataV28> handler;
    helpers::Array<MetaSoundDataV28> metaSound;
    helpers::Array<ScriptRefDataV28> scriptRef;
    helpers::Array<TriggerKeyDataV28> triggerKey;
    helpers::Array<PropertyDataV28> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;
    byte soundPoolMode;

public:
    ScriptFileDataV28();
    ScriptFileDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV28(const ScriptFileDataV28 &p_other);
    ScriptFileDataV28 &operator=(const ScriptFileDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV28 Gw2Struct;
};

/* Version: 27, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<27>{
struct DspDataV27 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV27();
    DspDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV27(const DspDataV27 &p_other);
    DspDataV27 &operator=(const DspDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV27 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV27> dsp;

public:
    BussDynamicDataV27();
    BussDynamicDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV27(const BussDynamicDataV27 &p_other);
    BussDynamicDataV27 &operator=(const BussDynamicDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV27 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV27> dynamicData;

public:
    BussDataV27();
    BussDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV27(const BussDataV27 &p_other);
    BussDataV27 &operator=(const BussDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV27 {
    float offset;
    float value;

public:
    EnvelopePointDataV27();
    EnvelopePointDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV27(const EnvelopePointDataV27 &p_other);
    EnvelopePointDataV27 &operator=(const EnvelopePointDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV27 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV27> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV27();
    EnvelopeDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV27(const EnvelopeDataV27 &p_other);
    EnvelopeDataV27 &operator=(const EnvelopeDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV27 {
    float max;
    float min;
    byte min;

public:
    RangeDataV27();
    RangeDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV27(const RangeDataV27 &p_other);
    RangeDataV27 &operator=(const RangeDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV27 {
    RangeDataV27 time;
    RangeDataV27 value;

public:
    RandomParamDataV27();
    RandomParamDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV27(const RandomParamDataV27 &p_other);
    RandomParamDataV27 &operator=(const RandomParamDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV27 {
    helpers::Ptr<EnvelopeDataV27> envelopeData;
    helpers::Ptr<RandomParamDataV27> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV27();
    DynamicParamDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV27(const DynamicParamDataV27 &p_other);
    DynamicParamDataV27 &operator=(const DynamicParamDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV27 {
    float doppler;
    DynamicParamDataV27 lowPass;
    DynamicParamDataV27 highPass;
    DynamicParamDataV27 pan3D;
    DynamicParamDataV27 reverb;
    DynamicParamDataV27 spread3D;
    DynamicParamDataV27 volumeA;
    DynamicParamDataV27 volumeB;
    DynamicParamDataV27 lfe;

public:
    AttenuationDataV27();
    AttenuationDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV27(const AttenuationDataV27 &p_other);
    AttenuationDataV27 &operator=(const AttenuationDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV27 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV27();
    CategoryDynamicDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV27(const CategoryDynamicDataV27 &p_other);
    CategoryDynamicDataV27 &operator=(const CategoryDynamicDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV27 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV27> attenuation;
    helpers::Ptr<CategoryDynamicDataV27> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV27();
    CategoryDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV27(const CategoryDataV27 &p_other);
    CategoryDataV27 &operator=(const CategoryDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV27 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV27();
    MaterialDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV27(const MaterialDataV27 &p_other);
    MaterialDataV27 &operator=(const MaterialDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV27 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV27();
    MusicConditionDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV27(const MusicConditionDataV27 &p_other);
    MusicConditionDataV27 &operator=(const MusicConditionDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV27 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV27();
    FileNameDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV27(const FileNameDataV27 &p_other);
    FileNameDataV27 &operator=(const FileNameDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV27 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV27> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV27 initialSilence;
    RangeDataV27 intervalSilence;
    RangeDataV27 maxPlayLength;
    DynamicParamDataV27 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV27();
    MusicPlaylistDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV27(const MusicPlaylistDataV27 &p_other);
    MusicPlaylistDataV27 &operator=(const MusicPlaylistDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PropertyDataV27 {
    qword name;
    qword tokenValue;
    float floatValue;

public:
    PropertyDataV27();
    PropertyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV27(const PropertyDataV27 &p_other);
    PropertyDataV27 &operator=(const PropertyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV27 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV27();
    ReverbDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV27(const ReverbDataV27 &p_other);
    ReverbDataV27 &operator=(const ReverbDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV27 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV27();
    ScriptRefDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV27(const ScriptRefDataV27 &p_other);
    ScriptRefDataV27 &operator=(const ScriptRefDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV27 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV27> buss;
    helpers::Array<CategoryDynamicDataV27> category;
    byte priority;

public:
    SnapshotDataV27();
    SnapshotDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV27(const SnapshotDataV27 &p_other);
    SnapshotDataV27 &operator=(const SnapshotDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV27 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float echoLevel;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV27> buss;
    helpers::Array<CategoryDataV27> category;
    helpers::Array<MaterialDataV27> material;
    helpers::Array<MusicConditionDataV27> musicCondition;
    helpers::Array<MusicPlaylistDataV27> musicPlaylist;
    helpers::Array<PropertyDataV27> property;
    helpers::Array<ReverbDataV27> reverb;
    helpers::Array<ScriptRefDataV27> scriptRef;
    helpers::Array<SnapshotDataV27> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV27();
    AudioSettingsDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV27(const AudioSettingsDataV27 &p_other);
    AudioSettingsDataV27 &operator=(const AudioSettingsDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV27 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV27();
    HandlerDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV27(const HandlerDataV27 &p_other);
    HandlerDataV27 &operator=(const HandlerDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV27 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV27> dsp;
    helpers::Ptr<AttenuationDataV27> attenuation;
    helpers::Array<FileNameDataV27> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV27 depth;
    DynamicParamDataV27 pan;
    DynamicParamDataV27 pitch;
    DynamicParamDataV27 pitchMS;
    DynamicParamDataV27 volume;
    DynamicParamDataV27 volumeMS;
    RangeDataV27 initialDelay;
    RangeDataV27 playLength;
    RangeDataV27 positionOffsetAngle;
    RangeDataV27 positionRange;
    RangeDataV27 repeatCount;
    RangeDataV27 repeatTime;
    RangeDataV27 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV27();
    MetaSoundDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV27(const MetaSoundDataV27 &p_other);
    MetaSoundDataV27 &operator=(const MetaSoundDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV27 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV27();
    TriggerMarkerDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV27(const TriggerMarkerDataV27 &p_other);
    TriggerMarkerDataV27 &operator=(const TriggerMarkerDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV27 {
    qword name;
    helpers::Array<TriggerMarkerDataV27> triggerMarker;

public:
    TriggerKeyDataV27();
    TriggerKeyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV27(const TriggerKeyDataV27 &p_other);
    TriggerKeyDataV27 &operator=(const TriggerKeyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV27 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV27> audioSettings;
    helpers::Array<HandlerDataV27> handler;
    helpers::Array<MetaSoundDataV27> metaSound;
    helpers::Array<ScriptRefDataV27> scriptRef;
    helpers::Array<TriggerKeyDataV27> triggerKey;
    helpers::Array<PropertyDataV27> property;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;

public:
    ScriptFileDataV27();
    ScriptFileDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV27(const ScriptFileDataV27 &p_other);
    ScriptFileDataV27 &operator=(const ScriptFileDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV27 Gw2Struct;
};

/* Version: 26, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<26>{
struct DspDataV26 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV26();
    DspDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV26(const DspDataV26 &p_other);
    DspDataV26 &operator=(const DspDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV26 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV26> dsp;

public:
    BussDynamicDataV26();
    BussDynamicDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV26(const BussDynamicDataV26 &p_other);
    BussDynamicDataV26 &operator=(const BussDynamicDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV26 {
    qword name;
    qword output;
    dword flags;
    float normalizeFadeTime;
    float normalizeThreshold;
    float normalizeMaxAmp;
    float compressorThreshold;
    float compressorAttack;
    float compressorRelease;
    float compressorGainMakeup;
    helpers::Ptr<BussDynamicDataV26> dynamicData;

public:
    BussDataV26();
    BussDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV26(const BussDataV26 &p_other);
    BussDataV26 &operator=(const BussDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV26 {
    float offset;
    float value;

public:
    EnvelopePointDataV26();
    EnvelopePointDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV26(const EnvelopePointDataV26 &p_other);
    EnvelopePointDataV26 &operator=(const EnvelopePointDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV26 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV26> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV26();
    EnvelopeDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV26(const EnvelopeDataV26 &p_other);
    EnvelopeDataV26 &operator=(const EnvelopeDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV26 {
    float max;
    float min;
    byte min;

public:
    RangeDataV26();
    RangeDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV26(const RangeDataV26 &p_other);
    RangeDataV26 &operator=(const RangeDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV26 {
    RangeDataV26 time;
    RangeDataV26 value;

public:
    RandomParamDataV26();
    RandomParamDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV26(const RandomParamDataV26 &p_other);
    RandomParamDataV26 &operator=(const RandomParamDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV26 {
    helpers::Ptr<EnvelopeDataV26> envelopeData;
    helpers::Ptr<RandomParamDataV26> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV26();
    DynamicParamDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV26(const DynamicParamDataV26 &p_other);
    DynamicParamDataV26 &operator=(const DynamicParamDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV26 {
    float doppler;
    DynamicParamDataV26 lowPass;
    DynamicParamDataV26 highPass;
    DynamicParamDataV26 pan3D;
    DynamicParamDataV26 reverb;
    DynamicParamDataV26 spread3D;
    DynamicParamDataV26 volumeA;
    DynamicParamDataV26 volumeB;
    DynamicParamDataV26 lfe;

public:
    AttenuationDataV26();
    AttenuationDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV26(const AttenuationDataV26 &p_other);
    AttenuationDataV26 &operator=(const AttenuationDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV26 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;
    dword minAudible;
    dword maxAudibleLQ;
    dword maxAudibleHG;

public:
    CategoryDynamicDataV26();
    CategoryDynamicDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV26(const CategoryDynamicDataV26 &p_other);
    CategoryDynamicDataV26 &operator=(const CategoryDynamicDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV26 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV26> attenuation;
    helpers::Ptr<CategoryDynamicDataV26> dynamicData;
    float focusReserve;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    byte priority;

public:
    CategoryDataV26();
    CategoryDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV26(const CategoryDataV26 &p_other);
    CategoryDataV26 &operator=(const CategoryDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV26 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV26();
    MaterialDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV26(const MaterialDataV26 &p_other);
    MaterialDataV26 &operator=(const MaterialDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV26 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV26();
    MusicConditionDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV26(const MusicConditionDataV26 &p_other);
    MusicConditionDataV26 &operator=(const MusicConditionDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV26 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV26();
    FileNameDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV26(const FileNameDataV26 &p_other);
    FileNameDataV26 &operator=(const FileNameDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV26 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV26> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV26 initialSilence;
    RangeDataV26 intervalSilence;
    RangeDataV26 maxPlayLength;
    DynamicParamDataV26 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV26();
    MusicPlaylistDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV26(const MusicPlaylistDataV26 &p_other);
    MusicPlaylistDataV26 &operator=(const MusicPlaylistDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV26 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV26();
    ReverbDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV26(const ReverbDataV26 &p_other);
    ReverbDataV26 &operator=(const ReverbDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV26 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV26> buss;
    helpers::Array<CategoryDynamicDataV26> category;
    byte priority;

public:
    SnapshotDataV26();
    SnapshotDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV26(const SnapshotDataV26 &p_other);
    SnapshotDataV26 &operator=(const SnapshotDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV26 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    float memoryPool;
    float reverbLevel;
    dword minChannelsLQ;
    dword maxChannelsLQ;
    helpers::Array<BussDataV26> buss;
    helpers::Array<CategoryDataV26> category;
    helpers::Array<MaterialDataV26> material;
    helpers::Array<MusicConditionDataV26> musicCondition;
    helpers::Array<MusicPlaylistDataV26> musicPlaylist;
    helpers::Array<ReverbDataV26> reverb;
    helpers::Array<SnapshotDataV26> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV26();
    AudioSettingsDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV26(const AudioSettingsDataV26 &p_other);
    AudioSettingsDataV26 &operator=(const AudioSettingsDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV26 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV26();
    HandlerDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV26(const HandlerDataV26 &p_other);
    HandlerDataV26 &operator=(const HandlerDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV26 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV26> dsp;
    helpers::Ptr<AttenuationDataV26> attenuation;
    helpers::Array<FileNameDataV26> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV26 depth;
    DynamicParamDataV26 pan;
    DynamicParamDataV26 pitch;
    DynamicParamDataV26 pitchMS;
    DynamicParamDataV26 volume;
    DynamicParamDataV26 volumeMS;
    RangeDataV26 initialDelay;
    RangeDataV26 playLength;
    RangeDataV26 positionOffsetAngle;
    RangeDataV26 positionRange;
    RangeDataV26 repeatCount;
    RangeDataV26 repeatTime;
    RangeDataV26 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV26();
    MetaSoundDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV26(const MetaSoundDataV26 &p_other);
    MetaSoundDataV26 &operator=(const MetaSoundDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV26 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV26();
    ScriptRefDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV26(const ScriptRefDataV26 &p_other);
    ScriptRefDataV26 &operator=(const ScriptRefDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV26 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV26();
    TriggerMarkerDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV26(const TriggerMarkerDataV26 &p_other);
    TriggerMarkerDataV26 &operator=(const TriggerMarkerDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV26 {
    qword name;
    helpers::Array<TriggerMarkerDataV26> triggerMarker;

public:
    TriggerKeyDataV26();
    TriggerKeyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV26(const TriggerKeyDataV26 &p_other);
    TriggerKeyDataV26 &operator=(const TriggerKeyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV26 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV26> audioSettings;
    helpers::Array<HandlerDataV26> handler;
    helpers::Array<MetaSoundDataV26> metaSound;
    helpers::Array<ScriptRefDataV26> scriptRef;
    helpers::Array<TriggerKeyDataV26> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;

public:
    ScriptFileDataV26();
    ScriptFileDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV26(const ScriptFileDataV26 &p_other);
    ScriptFileDataV26 &operator=(const ScriptFileDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV26 Gw2Struct;
};

/* Version: 25, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<25>{
struct DspDataV25 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV25();
    DspDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV25(const DspDataV25 &p_other);
    DspDataV25 &operator=(const DspDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV25 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV25> dsp;

public:
    BussDynamicDataV25();
    BussDynamicDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV25(const BussDynamicDataV25 &p_other);
    BussDynamicDataV25 &operator=(const BussDynamicDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV25 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV25> dynamicData;

public:
    BussDataV25();
    BussDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV25(const BussDataV25 &p_other);
    BussDataV25 &operator=(const BussDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV25 {
    float offset;
    float value;

public:
    EnvelopePointDataV25();
    EnvelopePointDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV25(const EnvelopePointDataV25 &p_other);
    EnvelopePointDataV25 &operator=(const EnvelopePointDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV25 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV25> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV25();
    EnvelopeDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV25(const EnvelopeDataV25 &p_other);
    EnvelopeDataV25 &operator=(const EnvelopeDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV25 {
    float max;
    float min;
    byte min;

public:
    RangeDataV25();
    RangeDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV25(const RangeDataV25 &p_other);
    RangeDataV25 &operator=(const RangeDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV25 {
    RangeDataV25 time;
    RangeDataV25 value;

public:
    RandomParamDataV25();
    RandomParamDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV25(const RandomParamDataV25 &p_other);
    RandomParamDataV25 &operator=(const RandomParamDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV25 {
    helpers::Ptr<EnvelopeDataV25> envelopeData;
    helpers::Ptr<RandomParamDataV25> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV25();
    DynamicParamDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV25(const DynamicParamDataV25 &p_other);
    DynamicParamDataV25 &operator=(const DynamicParamDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV25 {
    float doppler;
    DynamicParamDataV25 lowPass;
    DynamicParamDataV25 highPass;
    DynamicParamDataV25 pan3D;
    DynamicParamDataV25 reverb;
    DynamicParamDataV25 spread3D;
    DynamicParamDataV25 volumeA;
    DynamicParamDataV25 volumeB;

public:
    AttenuationDataV25();
    AttenuationDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV25(const AttenuationDataV25 &p_other);
    AttenuationDataV25 &operator=(const AttenuationDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV25 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV25();
    CategoryDynamicDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV25(const CategoryDynamicDataV25 &p_other);
    CategoryDynamicDataV25 &operator=(const CategoryDynamicDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV25 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV25> attenuation;
    helpers::Ptr<CategoryDynamicDataV25> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV25();
    CategoryDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV25(const CategoryDataV25 &p_other);
    CategoryDataV25 &operator=(const CategoryDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MaterialDataV25 {
    qword name;
    dword flags;
    float absorptionLF;
    float absorptionMF;
    float absorptionHF;
    float occlusion;

public:
    MaterialDataV25();
    MaterialDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MaterialDataV25(const MaterialDataV25 &p_other);
    MaterialDataV25 &operator=(const MaterialDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV25 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV25();
    MusicConditionDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV25(const MusicConditionDataV25 &p_other);
    MusicConditionDataV25 &operator=(const MusicConditionDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV25 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV25();
    FileNameDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV25(const FileNameDataV25 &p_other);
    FileNameDataV25 &operator=(const FileNameDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV25 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV25> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV25 initialSilence;
    RangeDataV25 intervalSilence;
    RangeDataV25 maxPlayLength;
    DynamicParamDataV25 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV25();
    MusicPlaylistDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV25(const MusicPlaylistDataV25 &p_other);
    MusicPlaylistDataV25 &operator=(const MusicPlaylistDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV25 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV25();
    ReverbDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV25(const ReverbDataV25 &p_other);
    ReverbDataV25 &operator=(const ReverbDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV25 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV25> buss;
    helpers::Array<CategoryDynamicDataV25> category;
    byte priority;

public:
    SnapshotDataV25();
    SnapshotDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV25(const SnapshotDataV25 &p_other);
    SnapshotDataV25 &operator=(const SnapshotDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV25 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV25> buss;
    helpers::Array<CategoryDataV25> category;
    helpers::Array<MaterialDataV25> material;
    helpers::Array<MusicConditionDataV25> musicCondition;
    helpers::Array<MusicPlaylistDataV25> musicPlaylist;
    helpers::Array<ReverbDataV25> reverb;
    helpers::Array<SnapshotDataV25> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV25();
    AudioSettingsDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV25(const AudioSettingsDataV25 &p_other);
    AudioSettingsDataV25 &operator=(const AudioSettingsDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV25 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV25();
    HandlerDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV25(const HandlerDataV25 &p_other);
    HandlerDataV25 &operator=(const HandlerDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV25 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV25> dsp;
    helpers::Ptr<AttenuationDataV25> attenuation;
    helpers::Array<FileNameDataV25> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV25 depth;
    DynamicParamDataV25 pan;
    DynamicParamDataV25 pitch;
    DynamicParamDataV25 pitchMS;
    DynamicParamDataV25 volume;
    DynamicParamDataV25 volumeMS;
    RangeDataV25 initialDelay;
    RangeDataV25 playLength;
    RangeDataV25 positionOffsetAngle;
    RangeDataV25 positionRange;
    RangeDataV25 repeatCount;
    RangeDataV25 repeatTime;
    RangeDataV25 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV25();
    MetaSoundDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV25(const MetaSoundDataV25 &p_other);
    MetaSoundDataV25 &operator=(const MetaSoundDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV25 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV25();
    ScriptRefDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV25(const ScriptRefDataV25 &p_other);
    ScriptRefDataV25 &operator=(const ScriptRefDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV25 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV25();
    TriggerMarkerDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV25(const TriggerMarkerDataV25 &p_other);
    TriggerMarkerDataV25 &operator=(const TriggerMarkerDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV25 {
    qword name;
    helpers::Array<TriggerMarkerDataV25> triggerMarker;

public:
    TriggerKeyDataV25();
    TriggerKeyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV25(const TriggerKeyDataV25 &p_other);
    TriggerKeyDataV25 &operator=(const TriggerKeyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV25 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV25> audioSettings;
    helpers::Array<HandlerDataV25> handler;
    helpers::Array<MetaSoundDataV25> metaSound;
    helpers::Array<ScriptRefDataV25> scriptRef;
    helpers::Array<TriggerKeyDataV25> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;

public:
    ScriptFileDataV25();
    ScriptFileDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV25(const ScriptFileDataV25 &p_other);
    ScriptFileDataV25 &operator=(const ScriptFileDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV25 Gw2Struct;
};

/* Version: 24, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<24>{
struct DspDataV24 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV24();
    DspDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV24(const DspDataV24 &p_other);
    DspDataV24 &operator=(const DspDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV24 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV24> dsp;

public:
    BussDynamicDataV24();
    BussDynamicDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV24(const BussDynamicDataV24 &p_other);
    BussDynamicDataV24 &operator=(const BussDynamicDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV24 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV24> dynamicData;

public:
    BussDataV24();
    BussDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV24(const BussDataV24 &p_other);
    BussDataV24 &operator=(const BussDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV24 {
    float offset;
    float value;

public:
    EnvelopePointDataV24();
    EnvelopePointDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV24(const EnvelopePointDataV24 &p_other);
    EnvelopePointDataV24 &operator=(const EnvelopePointDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV24 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV24> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV24();
    EnvelopeDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV24(const EnvelopeDataV24 &p_other);
    EnvelopeDataV24 &operator=(const EnvelopeDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV24 {
    float max;
    float min;
    byte min;

public:
    RangeDataV24();
    RangeDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV24(const RangeDataV24 &p_other);
    RangeDataV24 &operator=(const RangeDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV24 {
    RangeDataV24 time;
    RangeDataV24 value;

public:
    RandomParamDataV24();
    RandomParamDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV24(const RandomParamDataV24 &p_other);
    RandomParamDataV24 &operator=(const RandomParamDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV24 {
    helpers::Ptr<EnvelopeDataV24> envelopeData;
    helpers::Ptr<RandomParamDataV24> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV24();
    DynamicParamDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV24(const DynamicParamDataV24 &p_other);
    DynamicParamDataV24 &operator=(const DynamicParamDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV24 {
    float doppler;
    DynamicParamDataV24 lowPass;
    DynamicParamDataV24 highPass;
    DynamicParamDataV24 pan3D;
    DynamicParamDataV24 reverb;
    DynamicParamDataV24 spread3D;
    DynamicParamDataV24 volumeA;
    DynamicParamDataV24 volumeB;

public:
    AttenuationDataV24();
    AttenuationDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV24(const AttenuationDataV24 &p_other);
    AttenuationDataV24 &operator=(const AttenuationDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV24 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV24();
    CategoryDynamicDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV24(const CategoryDynamicDataV24 &p_other);
    CategoryDynamicDataV24 &operator=(const CategoryDynamicDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV24 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV24> attenuation;
    helpers::Ptr<CategoryDynamicDataV24> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV24();
    CategoryDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV24(const CategoryDataV24 &p_other);
    CategoryDataV24 &operator=(const CategoryDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV24 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV24();
    MusicConditionDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV24(const MusicConditionDataV24 &p_other);
    MusicConditionDataV24 &operator=(const MusicConditionDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV24 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;
    byte noteBase;
    byte noteMin;
    byte noteMax;

public:
    FileNameDataV24();
    FileNameDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV24(const FileNameDataV24 &p_other);
    FileNameDataV24 &operator=(const FileNameDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV24 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV24> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV24 initialSilence;
    RangeDataV24 intervalSilence;
    RangeDataV24 maxPlayLength;
    DynamicParamDataV24 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV24();
    MusicPlaylistDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV24(const MusicPlaylistDataV24 &p_other);
    MusicPlaylistDataV24 &operator=(const MusicPlaylistDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV24 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV24();
    ReverbDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV24(const ReverbDataV24 &p_other);
    ReverbDataV24 &operator=(const ReverbDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV24 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV24> buss;
    helpers::Array<CategoryDynamicDataV24> category;
    byte priority;

public:
    SnapshotDataV24();
    SnapshotDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV24(const SnapshotDataV24 &p_other);
    SnapshotDataV24 &operator=(const SnapshotDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV24 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV24> buss;
    helpers::Array<CategoryDataV24> category;
    helpers::Array<MusicConditionDataV24> musicCondition;
    helpers::Array<MusicPlaylistDataV24> musicPlaylist;
    helpers::Array<ReverbDataV24> reverb;
    helpers::Array<SnapshotDataV24> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV24();
    AudioSettingsDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV24(const AudioSettingsDataV24 &p_other);
    AudioSettingsDataV24 &operator=(const AudioSettingsDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV24 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV24();
    HandlerDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV24(const HandlerDataV24 &p_other);
    HandlerDataV24 &operator=(const HandlerDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV24 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV24> dsp;
    helpers::Ptr<AttenuationDataV24> attenuation;
    helpers::Array<FileNameDataV24> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV24 depth;
    DynamicParamDataV24 pan;
    DynamicParamDataV24 pitch;
    DynamicParamDataV24 pitchMS;
    DynamicParamDataV24 volume;
    DynamicParamDataV24 volumeMS;
    RangeDataV24 initialDelay;
    RangeDataV24 playLength;
    RangeDataV24 positionOffsetAngle;
    RangeDataV24 positionRange;
    RangeDataV24 repeatCount;
    RangeDataV24 repeatTime;
    RangeDataV24 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV24();
    MetaSoundDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV24(const MetaSoundDataV24 &p_other);
    MetaSoundDataV24 &operator=(const MetaSoundDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV24 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV24();
    ScriptRefDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV24(const ScriptRefDataV24 &p_other);
    ScriptRefDataV24 &operator=(const ScriptRefDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV24 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV24();
    TriggerMarkerDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV24(const TriggerMarkerDataV24 &p_other);
    TriggerMarkerDataV24 &operator=(const TriggerMarkerDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV24 {
    qword name;
    helpers::Array<TriggerMarkerDataV24> triggerMarker;

public:
    TriggerKeyDataV24();
    TriggerKeyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV24(const TriggerKeyDataV24 &p_other);
    TriggerKeyDataV24 &operator=(const TriggerKeyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV24 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV24> audioSettings;
    helpers::Array<HandlerDataV24> handler;
    helpers::Array<MetaSoundDataV24> metaSound;
    helpers::Array<ScriptRefDataV24> scriptRef;
    helpers::Array<TriggerKeyDataV24> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;

public:
    ScriptFileDataV24();
    ScriptFileDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV24(const ScriptFileDataV24 &p_other);
    ScriptFileDataV24 &operator=(const ScriptFileDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV24 Gw2Struct;
};

/* Version: 23, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<23>{
struct DspDataV23 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV23();
    DspDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV23(const DspDataV23 &p_other);
    DspDataV23 &operator=(const DspDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV23 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV23> dsp;

public:
    BussDynamicDataV23();
    BussDynamicDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV23(const BussDynamicDataV23 &p_other);
    BussDynamicDataV23 &operator=(const BussDynamicDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV23 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV23> dynamicData;

public:
    BussDataV23();
    BussDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV23(const BussDataV23 &p_other);
    BussDataV23 &operator=(const BussDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV23 {
    float offset;
    float value;

public:
    EnvelopePointDataV23();
    EnvelopePointDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV23(const EnvelopePointDataV23 &p_other);
    EnvelopePointDataV23 &operator=(const EnvelopePointDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV23 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV23> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV23();
    EnvelopeDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV23(const EnvelopeDataV23 &p_other);
    EnvelopeDataV23 &operator=(const EnvelopeDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV23 {
    float max;
    float min;
    byte min;

public:
    RangeDataV23();
    RangeDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV23(const RangeDataV23 &p_other);
    RangeDataV23 &operator=(const RangeDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV23 {
    RangeDataV23 time;
    RangeDataV23 value;

public:
    RandomParamDataV23();
    RandomParamDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV23(const RandomParamDataV23 &p_other);
    RandomParamDataV23 &operator=(const RandomParamDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV23 {
    helpers::Ptr<EnvelopeDataV23> envelopeData;
    helpers::Ptr<RandomParamDataV23> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV23();
    DynamicParamDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV23(const DynamicParamDataV23 &p_other);
    DynamicParamDataV23 &operator=(const DynamicParamDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV23 {
    float doppler;
    DynamicParamDataV23 lowPass;
    DynamicParamDataV23 highPass;
    DynamicParamDataV23 pan3D;
    DynamicParamDataV23 reverb;
    DynamicParamDataV23 spread3D;
    DynamicParamDataV23 volumeA;
    DynamicParamDataV23 volumeB;

public:
    AttenuationDataV23();
    AttenuationDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV23(const AttenuationDataV23 &p_other);
    AttenuationDataV23 &operator=(const AttenuationDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV23 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV23();
    CategoryDynamicDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV23(const CategoryDynamicDataV23 &p_other);
    CategoryDynamicDataV23 &operator=(const CategoryDynamicDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV23 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV23> attenuation;
    helpers::Ptr<CategoryDynamicDataV23> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV23();
    CategoryDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV23(const CategoryDataV23 &p_other);
    CategoryDataV23 &operator=(const CategoryDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV23 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV23();
    MusicConditionDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV23(const MusicConditionDataV23 &p_other);
    MusicConditionDataV23 &operator=(const MusicConditionDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV23 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV23();
    FileNameDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV23(const FileNameDataV23 &p_other);
    FileNameDataV23 &operator=(const FileNameDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV23 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV23> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV23 initialSilence;
    RangeDataV23 intervalSilence;
    RangeDataV23 maxPlayLength;
    DynamicParamDataV23 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV23();
    MusicPlaylistDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV23(const MusicPlaylistDataV23 &p_other);
    MusicPlaylistDataV23 &operator=(const MusicPlaylistDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV23 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV23();
    ReverbDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV23(const ReverbDataV23 &p_other);
    ReverbDataV23 &operator=(const ReverbDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV23 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV23> buss;
    helpers::Array<CategoryDynamicDataV23> category;
    byte priority;

public:
    SnapshotDataV23();
    SnapshotDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV23(const SnapshotDataV23 &p_other);
    SnapshotDataV23 &operator=(const SnapshotDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV23 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV23> buss;
    helpers::Array<CategoryDataV23> category;
    helpers::Array<MusicConditionDataV23> musicCondition;
    helpers::Array<MusicPlaylistDataV23> musicPlaylist;
    helpers::Array<ReverbDataV23> reverb;
    helpers::Array<SnapshotDataV23> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV23();
    AudioSettingsDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV23(const AudioSettingsDataV23 &p_other);
    AudioSettingsDataV23 &operator=(const AudioSettingsDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV23 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV23();
    HandlerDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV23(const HandlerDataV23 &p_other);
    HandlerDataV23 &operator=(const HandlerDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV23 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV23> dsp;
    helpers::Ptr<AttenuationDataV23> attenuation;
    helpers::Array<FileNameDataV23> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV23 depth;
    DynamicParamDataV23 pan;
    DynamicParamDataV23 pitch;
    DynamicParamDataV23 pitchMS;
    DynamicParamDataV23 volume;
    DynamicParamDataV23 volumeMS;
    RangeDataV23 initialDelay;
    RangeDataV23 playLength;
    RangeDataV23 positionOffsetAngle;
    RangeDataV23 positionRange;
    RangeDataV23 repeatCount;
    RangeDataV23 repeatTime;
    RangeDataV23 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV23();
    MetaSoundDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV23(const MetaSoundDataV23 &p_other);
    MetaSoundDataV23 &operator=(const MetaSoundDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV23 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV23();
    ScriptRefDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV23(const ScriptRefDataV23 &p_other);
    ScriptRefDataV23 &operator=(const ScriptRefDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV23 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV23();
    TriggerMarkerDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV23(const TriggerMarkerDataV23 &p_other);
    TriggerMarkerDataV23 &operator=(const TriggerMarkerDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV23 {
    qword name;
    helpers::Array<TriggerMarkerDataV23> triggerMarker;

public:
    TriggerKeyDataV23();
    TriggerKeyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV23(const TriggerKeyDataV23 &p_other);
    TriggerKeyDataV23 &operator=(const TriggerKeyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV23 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV23> audioSettings;
    helpers::Array<HandlerDataV23> handler;
    helpers::Array<MetaSoundDataV23> metaSound;
    helpers::Array<ScriptRefDataV23> scriptRef;
    helpers::Array<TriggerKeyDataV23> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;
    byte musicMutePriority;

public:
    ScriptFileDataV23();
    ScriptFileDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV23(const ScriptFileDataV23 &p_other);
    ScriptFileDataV23 &operator=(const ScriptFileDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV23 Gw2Struct;
};

/* Version: 22, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<22>{
struct DspDataV22 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV22();
    DspDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV22(const DspDataV22 &p_other);
    DspDataV22 &operator=(const DspDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV22 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV22> dsp;

public:
    BussDynamicDataV22();
    BussDynamicDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV22(const BussDynamicDataV22 &p_other);
    BussDynamicDataV22 &operator=(const BussDynamicDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV22 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV22> dynamicData;

public:
    BussDataV22();
    BussDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV22(const BussDataV22 &p_other);
    BussDataV22 &operator=(const BussDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV22 {
    float offset;
    float value;

public:
    EnvelopePointDataV22();
    EnvelopePointDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV22(const EnvelopePointDataV22 &p_other);
    EnvelopePointDataV22 &operator=(const EnvelopePointDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV22 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV22> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV22();
    EnvelopeDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV22(const EnvelopeDataV22 &p_other);
    EnvelopeDataV22 &operator=(const EnvelopeDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV22 {
    float max;
    float min;
    byte min;

public:
    RangeDataV22();
    RangeDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV22(const RangeDataV22 &p_other);
    RangeDataV22 &operator=(const RangeDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV22 {
    RangeDataV22 time;
    RangeDataV22 value;

public:
    RandomParamDataV22();
    RandomParamDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV22(const RandomParamDataV22 &p_other);
    RandomParamDataV22 &operator=(const RandomParamDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV22 {
    helpers::Ptr<EnvelopeDataV22> envelopeData;
    helpers::Ptr<RandomParamDataV22> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV22();
    DynamicParamDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV22(const DynamicParamDataV22 &p_other);
    DynamicParamDataV22 &operator=(const DynamicParamDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV22 {
    float doppler;
    DynamicParamDataV22 lowPass;
    DynamicParamDataV22 highPass;
    DynamicParamDataV22 pan3D;
    DynamicParamDataV22 reverb;
    DynamicParamDataV22 spread3D;
    DynamicParamDataV22 volumeA;
    DynamicParamDataV22 volumeB;

public:
    AttenuationDataV22();
    AttenuationDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV22(const AttenuationDataV22 &p_other);
    AttenuationDataV22 &operator=(const AttenuationDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV22 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float highPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV22();
    CategoryDynamicDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV22(const CategoryDynamicDataV22 &p_other);
    CategoryDynamicDataV22 &operator=(const CategoryDynamicDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV22 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV22> attenuation;
    helpers::Ptr<CategoryDynamicDataV22> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV22();
    CategoryDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV22(const CategoryDataV22 &p_other);
    CategoryDataV22 &operator=(const CategoryDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV22 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV22();
    MusicConditionDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV22(const MusicConditionDataV22 &p_other);
    MusicConditionDataV22 &operator=(const MusicConditionDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV22 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV22();
    FileNameDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV22(const FileNameDataV22 &p_other);
    FileNameDataV22 &operator=(const FileNameDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV22 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV22> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV22 initialSilence;
    RangeDataV22 intervalSilence;
    RangeDataV22 maxPlayLength;
    DynamicParamDataV22 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV22();
    MusicPlaylistDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV22(const MusicPlaylistDataV22 &p_other);
    MusicPlaylistDataV22 &operator=(const MusicPlaylistDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV22 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV22();
    ReverbDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV22(const ReverbDataV22 &p_other);
    ReverbDataV22 &operator=(const ReverbDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV22 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV22> buss;
    helpers::Array<CategoryDynamicDataV22> category;
    byte priority;

public:
    SnapshotDataV22();
    SnapshotDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV22(const SnapshotDataV22 &p_other);
    SnapshotDataV22 &operator=(const SnapshotDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV22 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV22> buss;
    helpers::Array<CategoryDataV22> category;
    helpers::Array<MusicConditionDataV22> musicCondition;
    helpers::Array<MusicPlaylistDataV22> musicPlaylist;
    helpers::Array<ReverbDataV22> reverb;
    helpers::Array<SnapshotDataV22> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV22();
    AudioSettingsDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV22(const AudioSettingsDataV22 &p_other);
    AudioSettingsDataV22 &operator=(const AudioSettingsDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV22 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV22();
    HandlerDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV22(const HandlerDataV22 &p_other);
    HandlerDataV22 &operator=(const HandlerDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV22 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV22> dsp;
    helpers::Ptr<AttenuationDataV22> attenuation;
    helpers::Array<FileNameDataV22> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV22 depth;
    DynamicParamDataV22 pan;
    DynamicParamDataV22 pitch;
    DynamicParamDataV22 pitchMS;
    DynamicParamDataV22 volume;
    DynamicParamDataV22 volumeMS;
    RangeDataV22 initialDelay;
    RangeDataV22 playLength;
    RangeDataV22 positionOffsetAngle;
    RangeDataV22 positionRange;
    RangeDataV22 repeatCount;
    RangeDataV22 repeatTime;
    RangeDataV22 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV22();
    MetaSoundDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV22(const MetaSoundDataV22 &p_other);
    MetaSoundDataV22 &operator=(const MetaSoundDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV22 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV22();
    ScriptRefDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV22(const ScriptRefDataV22 &p_other);
    ScriptRefDataV22 &operator=(const ScriptRefDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV22 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV22();
    TriggerMarkerDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV22(const TriggerMarkerDataV22 &p_other);
    TriggerMarkerDataV22 &operator=(const TriggerMarkerDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV22 {
    qword name;
    helpers::Array<TriggerMarkerDataV22> triggerMarker;

public:
    TriggerKeyDataV22();
    TriggerKeyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV22(const TriggerKeyDataV22 &p_other);
    TriggerKeyDataV22 &operator=(const TriggerKeyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV22 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV22> audioSettings;
    helpers::Array<HandlerDataV22> handler;
    helpers::Array<MetaSoundDataV22> metaSound;
    helpers::Array<ScriptRefDataV22> scriptRef;
    helpers::Array<TriggerKeyDataV22> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV22();
    ScriptFileDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV22(const ScriptFileDataV22 &p_other);
    ScriptFileDataV22 &operator=(const ScriptFileDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV22 Gw2Struct;
};

/* Version: 21, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<21>{
struct DspDataV21 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV21();
    DspDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV21(const DspDataV21 &p_other);
    DspDataV21 &operator=(const DspDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV21 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV21> dsp;

public:
    BussDynamicDataV21();
    BussDynamicDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV21(const BussDynamicDataV21 &p_other);
    BussDynamicDataV21 &operator=(const BussDynamicDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV21 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV21> dynamicData;

public:
    BussDataV21();
    BussDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV21(const BussDataV21 &p_other);
    BussDataV21 &operator=(const BussDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV21 {
    float offset;
    float value;

public:
    EnvelopePointDataV21();
    EnvelopePointDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV21(const EnvelopePointDataV21 &p_other);
    EnvelopePointDataV21 &operator=(const EnvelopePointDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV21 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV21> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV21();
    EnvelopeDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV21(const EnvelopeDataV21 &p_other);
    EnvelopeDataV21 &operator=(const EnvelopeDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV21 {
    float max;
    float min;
    byte min;

public:
    RangeDataV21();
    RangeDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV21(const RangeDataV21 &p_other);
    RangeDataV21 &operator=(const RangeDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV21 {
    RangeDataV21 time;
    RangeDataV21 value;

public:
    RandomParamDataV21();
    RandomParamDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV21(const RandomParamDataV21 &p_other);
    RandomParamDataV21 &operator=(const RandomParamDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV21 {
    helpers::Ptr<EnvelopeDataV21> envelopeData;
    helpers::Ptr<RandomParamDataV21> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV21();
    DynamicParamDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV21(const DynamicParamDataV21 &p_other);
    DynamicParamDataV21 &operator=(const DynamicParamDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV21 {
    float doppler;
    DynamicParamDataV21 lowPass;
    DynamicParamDataV21 pan3D;
    DynamicParamDataV21 reverb;
    DynamicParamDataV21 spread3D;
    DynamicParamDataV21 volumeA;
    DynamicParamDataV21 volumeB;

public:
    AttenuationDataV21();
    AttenuationDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV21(const AttenuationDataV21 &p_other);
    AttenuationDataV21 &operator=(const AttenuationDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV21 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV21();
    CategoryDynamicDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV21(const CategoryDynamicDataV21 &p_other);
    CategoryDynamicDataV21 &operator=(const CategoryDynamicDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV21 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV21> attenuation;
    helpers::Ptr<CategoryDynamicDataV21> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV21();
    CategoryDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV21(const CategoryDataV21 &p_other);
    CategoryDataV21 &operator=(const CategoryDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicConditionDataV21 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    MusicConditionDataV21();
    MusicConditionDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicConditionDataV21(const MusicConditionDataV21 &p_other);
    MusicConditionDataV21 &operator=(const MusicConditionDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV21 {
    qword condition;
    qword language;
    float volume;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV21();
    FileNameDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV21(const FileNameDataV21 &p_other);
    FileNameDataV21 &operator=(const FileNameDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MusicPlaylistDataV21 {
    qword category;
    qword name;
    qword primaryPlaylistId;
    qword secondaryPlaylistId;
    helpers::Array<FileNameDataV21> fileName;
    float fadeInTime;
    float fadeOutTime;
    dword flags;
    RangeDataV21 initialSilence;
    RangeDataV21 intervalSilence;
    RangeDataV21 maxPlayLength;
    DynamicParamDataV21 volume;
    byte fileIterateMode;

public:
    MusicPlaylistDataV21();
    MusicPlaylistDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MusicPlaylistDataV21(const MusicPlaylistDataV21 &p_other);
    MusicPlaylistDataV21 &operator=(const MusicPlaylistDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV21 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV21();
    ReverbDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV21(const ReverbDataV21 &p_other);
    ReverbDataV21 &operator=(const ReverbDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV21 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV21> buss;
    helpers::Array<CategoryDynamicDataV21> category;
    byte priority;

public:
    SnapshotDataV21();
    SnapshotDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV21(const SnapshotDataV21 &p_other);
    SnapshotDataV21 &operator=(const SnapshotDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV21 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV21> buss;
    helpers::Array<CategoryDataV21> category;
    helpers::Array<MusicConditionDataV21> musicCondition;
    helpers::Array<MusicPlaylistDataV21> musicPlaylist;
    helpers::Array<ReverbDataV21> reverb;
    helpers::Array<SnapshotDataV21> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV21();
    AudioSettingsDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV21(const AudioSettingsDataV21 &p_other);
    AudioSettingsDataV21 &operator=(const AudioSettingsDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV21 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV21();
    HandlerDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV21(const HandlerDataV21 &p_other);
    HandlerDataV21 &operator=(const HandlerDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV21 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV21> dsp;
    helpers::Ptr<AttenuationDataV21> attenuation;
    helpers::Array<FileNameDataV21> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV21 depth;
    DynamicParamDataV21 pan;
    DynamicParamDataV21 pitch;
    DynamicParamDataV21 pitchMS;
    DynamicParamDataV21 volume;
    DynamicParamDataV21 volumeMS;
    RangeDataV21 initialDelay;
    RangeDataV21 playLength;
    RangeDataV21 positionOffsetAngle;
    RangeDataV21 positionRange;
    RangeDataV21 repeatCount;
    RangeDataV21 repeatTime;
    RangeDataV21 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV21();
    MetaSoundDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV21(const MetaSoundDataV21 &p_other);
    MetaSoundDataV21 &operator=(const MetaSoundDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV21 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV21();
    ScriptRefDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV21(const ScriptRefDataV21 &p_other);
    ScriptRefDataV21 &operator=(const ScriptRefDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV21 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV21();
    TriggerMarkerDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV21(const TriggerMarkerDataV21 &p_other);
    TriggerMarkerDataV21 &operator=(const TriggerMarkerDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV21 {
    qword name;
    helpers::Array<TriggerMarkerDataV21> triggerMarker;

public:
    TriggerKeyDataV21();
    TriggerKeyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV21(const TriggerKeyDataV21 &p_other);
    TriggerKeyDataV21 &operator=(const TriggerKeyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV21 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV21> audioSettings;
    helpers::Array<HandlerDataV21> handler;
    helpers::Array<MetaSoundDataV21> metaSound;
    helpers::Array<ScriptRefDataV21> scriptRef;
    helpers::Array<TriggerKeyDataV21> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV21();
    ScriptFileDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV21(const ScriptFileDataV21 &p_other);
    ScriptFileDataV21 &operator=(const ScriptFileDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV21 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<20>{
struct DspDataV20 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV20();
    DspDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV20(const DspDataV20 &p_other);
    DspDataV20 &operator=(const DspDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV20 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV20> dsp;

public:
    BussDynamicDataV20();
    BussDynamicDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV20(const BussDynamicDataV20 &p_other);
    BussDynamicDataV20 &operator=(const BussDynamicDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV20 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV20> dynamicData;

public:
    BussDataV20();
    BussDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV20(const BussDataV20 &p_other);
    BussDataV20 &operator=(const BussDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV20 {
    float offset;
    float value;

public:
    EnvelopePointDataV20();
    EnvelopePointDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV20(const EnvelopePointDataV20 &p_other);
    EnvelopePointDataV20 &operator=(const EnvelopePointDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV20 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV20> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV20();
    EnvelopeDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV20(const EnvelopeDataV20 &p_other);
    EnvelopeDataV20 &operator=(const EnvelopeDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV20 {
    float max;
    float min;
    byte min;

public:
    RangeDataV20();
    RangeDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV20(const RangeDataV20 &p_other);
    RangeDataV20 &operator=(const RangeDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV20 {
    RangeDataV20 time;
    RangeDataV20 value;

public:
    RandomParamDataV20();
    RandomParamDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV20(const RandomParamDataV20 &p_other);
    RandomParamDataV20 &operator=(const RandomParamDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV20 {
    helpers::Ptr<EnvelopeDataV20> envelopeData;
    helpers::Ptr<RandomParamDataV20> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV20();
    DynamicParamDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV20(const DynamicParamDataV20 &p_other);
    DynamicParamDataV20 &operator=(const DynamicParamDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV20 {
    float doppler;
    DynamicParamDataV20 lowPass;
    DynamicParamDataV20 pan3D;
    DynamicParamDataV20 reverb;
    DynamicParamDataV20 spread3D;
    DynamicParamDataV20 volumeA;
    DynamicParamDataV20 volumeB;

public:
    AttenuationDataV20();
    AttenuationDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV20(const AttenuationDataV20 &p_other);
    AttenuationDataV20 &operator=(const AttenuationDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV20 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV20();
    CategoryDynamicDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV20(const CategoryDynamicDataV20 &p_other);
    CategoryDynamicDataV20 &operator=(const CategoryDynamicDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV20 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV20> attenuation;
    helpers::Ptr<CategoryDynamicDataV20> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV20();
    CategoryDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV20(const CategoryDataV20 &p_other);
    CategoryDataV20 &operator=(const CategoryDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV20 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV20();
    ReverbDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV20(const ReverbDataV20 &p_other);
    ReverbDataV20 &operator=(const ReverbDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV20 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV20> buss;
    helpers::Array<CategoryDynamicDataV20> category;
    byte priority;

public:
    SnapshotDataV20();
    SnapshotDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV20(const SnapshotDataV20 &p_other);
    SnapshotDataV20 &operator=(const SnapshotDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV20 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV20> buss;
    helpers::Array<CategoryDataV20> category;
    helpers::Array<ReverbDataV20> reverb;
    helpers::Array<SnapshotDataV20> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV20();
    AudioSettingsDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV20(const AudioSettingsDataV20 &p_other);
    AudioSettingsDataV20 &operator=(const AudioSettingsDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV20 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV20();
    HandlerDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV20(const HandlerDataV20 &p_other);
    HandlerDataV20 &operator=(const HandlerDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV20 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV20();
    FileNameDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV20(const FileNameDataV20 &p_other);
    FileNameDataV20 &operator=(const FileNameDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV20 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV20> dsp;
    helpers::Ptr<AttenuationDataV20> attenuation;
    helpers::Array<FileNameDataV20> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV20 depth;
    DynamicParamDataV20 pan;
    DynamicParamDataV20 pitch;
    DynamicParamDataV20 pitchMS;
    DynamicParamDataV20 volume;
    DynamicParamDataV20 volumeMS;
    RangeDataV20 initialDelay;
    RangeDataV20 playLength;
    RangeDataV20 positionOffsetAngle;
    RangeDataV20 positionRange;
    RangeDataV20 repeatCount;
    RangeDataV20 repeatTime;
    RangeDataV20 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV20();
    MetaSoundDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV20(const MetaSoundDataV20 &p_other);
    MetaSoundDataV20 &operator=(const MetaSoundDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV20 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV20();
    ScriptRefDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV20(const ScriptRefDataV20 &p_other);
    ScriptRefDataV20 &operator=(const ScriptRefDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV20 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV20();
    TriggerMarkerDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV20(const TriggerMarkerDataV20 &p_other);
    TriggerMarkerDataV20 &operator=(const TriggerMarkerDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV20 {
    qword name;
    helpers::Array<TriggerMarkerDataV20> triggerMarker;

public:
    TriggerKeyDataV20();
    TriggerKeyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV20(const TriggerKeyDataV20 &p_other);
    TriggerKeyDataV20 &operator=(const TriggerKeyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV20 {
    qword musicCue;
    qword reverbOverride;
    qword snapshot;
    helpers::Ptr<AudioSettingsDataV20> audioSettings;
    helpers::Array<HandlerDataV20> handler;
    helpers::Array<MetaSoundDataV20> metaSound;
    helpers::Array<ScriptRefDataV20> scriptRef;
    helpers::Array<TriggerKeyDataV20> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV20();
    ScriptFileDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV20(const ScriptFileDataV20 &p_other);
    ScriptFileDataV20 &operator=(const ScriptFileDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV20 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x40F848A000000001 */

template <>
struct Gw2StructAMSP<19>{
struct DspDataV19 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV19();
    DspDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV19(const DspDataV19 &p_other);
    DspDataV19 &operator=(const DspDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV19 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV19> dsp;

public:
    BussDynamicDataV19();
    BussDynamicDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV19(const BussDynamicDataV19 &p_other);
    BussDynamicDataV19 &operator=(const BussDynamicDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV19 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV19> dynamicData;

public:
    BussDataV19();
    BussDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV19(const BussDataV19 &p_other);
    BussDataV19 &operator=(const BussDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV19 {
    float offset;
    float value;

public:
    EnvelopePointDataV19();
    EnvelopePointDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV19(const EnvelopePointDataV19 &p_other);
    EnvelopePointDataV19 &operator=(const EnvelopePointDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV19 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV19> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV19();
    EnvelopeDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV19(const EnvelopeDataV19 &p_other);
    EnvelopeDataV19 &operator=(const EnvelopeDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV19 {
    float max;
    float min;
    byte min;

public:
    RangeDataV19();
    RangeDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV19(const RangeDataV19 &p_other);
    RangeDataV19 &operator=(const RangeDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV19 {
    RangeDataV19 time;
    RangeDataV19 value;

public:
    RandomParamDataV19();
    RandomParamDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV19(const RandomParamDataV19 &p_other);
    RandomParamDataV19 &operator=(const RandomParamDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV19 {
    helpers::Ptr<EnvelopeDataV19> envelopeData;
    helpers::Ptr<RandomParamDataV19> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV19();
    DynamicParamDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV19(const DynamicParamDataV19 &p_other);
    DynamicParamDataV19 &operator=(const DynamicParamDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV19 {
    float doppler;
    DynamicParamDataV19 lowPass;
    DynamicParamDataV19 pan3D;
    DynamicParamDataV19 reverb;
    DynamicParamDataV19 spread3D;
    DynamicParamDataV19 volumeA;
    DynamicParamDataV19 volumeB;

public:
    AttenuationDataV19();
    AttenuationDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV19(const AttenuationDataV19 &p_other);
    AttenuationDataV19 &operator=(const AttenuationDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV19 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV19();
    CategoryDynamicDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV19(const CategoryDynamicDataV19 &p_other);
    CategoryDynamicDataV19 &operator=(const CategoryDynamicDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV19 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV19> attenuation;
    helpers::Ptr<CategoryDynamicDataV19> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV19();
    CategoryDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV19(const CategoryDataV19 &p_other);
    CategoryDataV19 &operator=(const CategoryDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV19 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV19();
    ReverbDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV19(const ReverbDataV19 &p_other);
    ReverbDataV19 &operator=(const ReverbDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV19 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV19> buss;
    helpers::Array<CategoryDynamicDataV19> category;
    byte priority;

public:
    SnapshotDataV19();
    SnapshotDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV19(const SnapshotDataV19 &p_other);
    SnapshotDataV19 &operator=(const SnapshotDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV19 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV19> buss;
    helpers::Array<CategoryDataV19> category;
    helpers::Array<ReverbDataV19> reverb;
    helpers::Array<SnapshotDataV19> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV19();
    AudioSettingsDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV19(const AudioSettingsDataV19 &p_other);
    AudioSettingsDataV19 &operator=(const AudioSettingsDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV19 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV19();
    HandlerDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV19(const HandlerDataV19 &p_other);
    HandlerDataV19 &operator=(const HandlerDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV19 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV19();
    FileNameDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV19(const FileNameDataV19 &p_other);
    FileNameDataV19 &operator=(const FileNameDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV19 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV19> dsp;
    helpers::Ptr<AttenuationDataV19> attenuation;
    helpers::Array<FileNameDataV19> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV19 depth;
    DynamicParamDataV19 pan;
    DynamicParamDataV19 pitch;
    DynamicParamDataV19 pitchMS;
    DynamicParamDataV19 volume;
    DynamicParamDataV19 volumeMS;
    RangeDataV19 initialDelay;
    RangeDataV19 playLength;
    RangeDataV19 positionOffsetAngle;
    RangeDataV19 positionRange;
    RangeDataV19 repeatCount;
    RangeDataV19 repeatTime;
    RangeDataV19 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV19();
    MetaSoundDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV19(const MetaSoundDataV19 &p_other);
    MetaSoundDataV19 &operator=(const MetaSoundDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV19 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV19();
    ScriptRefDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV19(const ScriptRefDataV19 &p_other);
    ScriptRefDataV19 &operator=(const ScriptRefDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV19 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV19();
    TriggerMarkerDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV19(const TriggerMarkerDataV19 &p_other);
    TriggerMarkerDataV19 &operator=(const TriggerMarkerDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV19 {
    qword name;
    helpers::Array<TriggerMarkerDataV19> triggerMarker;

public:
    TriggerKeyDataV19();
    TriggerKeyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV19(const TriggerKeyDataV19 &p_other);
    TriggerKeyDataV19 &operator=(const TriggerKeyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV19 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV19> audioSettings;
    helpers::Array<HandlerDataV19> handler;
    helpers::Array<MetaSoundDataV19> metaSound;
    helpers::Array<ScriptRefDataV19> scriptRef;
    helpers::Array<TriggerKeyDataV19> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV19();
    ScriptFileDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV19(const ScriptFileDataV19 &p_other);
    ScriptFileDataV19 &operator=(const ScriptFileDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV19 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x40F8463000000001 */

template <>
struct Gw2StructAMSP<18>{
struct DspDataV18 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV18();
    DspDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV18(const DspDataV18 &p_other);
    DspDataV18 &operator=(const DspDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV18 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV18> dsp;

public:
    BussDynamicDataV18();
    BussDynamicDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV18(const BussDynamicDataV18 &p_other);
    BussDynamicDataV18 &operator=(const BussDynamicDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV18 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV18> dynamicData;

public:
    BussDataV18();
    BussDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV18(const BussDataV18 &p_other);
    BussDataV18 &operator=(const BussDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV18 {
    float offset;
    float value;

public:
    EnvelopePointDataV18();
    EnvelopePointDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV18(const EnvelopePointDataV18 &p_other);
    EnvelopePointDataV18 &operator=(const EnvelopePointDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV18 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV18> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV18();
    EnvelopeDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV18(const EnvelopeDataV18 &p_other);
    EnvelopeDataV18 &operator=(const EnvelopeDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV18 {
    float max;
    float min;
    byte min;

public:
    RangeDataV18();
    RangeDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV18(const RangeDataV18 &p_other);
    RangeDataV18 &operator=(const RangeDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV18 {
    RangeDataV18 time;
    RangeDataV18 value;

public:
    RandomParamDataV18();
    RandomParamDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV18(const RandomParamDataV18 &p_other);
    RandomParamDataV18 &operator=(const RandomParamDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV18 {
    helpers::Ptr<EnvelopeDataV18> envelopeData;
    helpers::Ptr<RandomParamDataV18> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV18();
    DynamicParamDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV18(const DynamicParamDataV18 &p_other);
    DynamicParamDataV18 &operator=(const DynamicParamDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV18 {
    float doppler;
    DynamicParamDataV18 lowPass;
    DynamicParamDataV18 pan3D;
    DynamicParamDataV18 reverb;
    DynamicParamDataV18 spread3D;
    DynamicParamDataV18 volumeA;
    DynamicParamDataV18 volumeB;

public:
    AttenuationDataV18();
    AttenuationDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV18(const AttenuationDataV18 &p_other);
    AttenuationDataV18 &operator=(const AttenuationDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV18 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV18();
    CategoryDynamicDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV18(const CategoryDynamicDataV18 &p_other);
    CategoryDynamicDataV18 &operator=(const CategoryDynamicDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV18 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV18> attenuation;
    helpers::Ptr<CategoryDynamicDataV18> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV18();
    CategoryDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV18(const CategoryDataV18 &p_other);
    CategoryDataV18 &operator=(const CategoryDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV18 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV18();
    ReverbDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV18(const ReverbDataV18 &p_other);
    ReverbDataV18 &operator=(const ReverbDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV18 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV18> buss;
    helpers::Array<CategoryDynamicDataV18> category;

public:
    SnapshotDataV18();
    SnapshotDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV18(const SnapshotDataV18 &p_other);
    SnapshotDataV18 &operator=(const SnapshotDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV18 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV18> buss;
    helpers::Array<CategoryDataV18> category;
    helpers::Array<ReverbDataV18> reverb;
    helpers::Array<SnapshotDataV18> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV18();
    AudioSettingsDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV18(const AudioSettingsDataV18 &p_other);
    AudioSettingsDataV18 &operator=(const AudioSettingsDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV18 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV18();
    HandlerDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV18(const HandlerDataV18 &p_other);
    HandlerDataV18 &operator=(const HandlerDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV18 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV18();
    FileNameDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV18(const FileNameDataV18 &p_other);
    FileNameDataV18 &operator=(const FileNameDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV18 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV18> dsp;
    helpers::Ptr<AttenuationDataV18> attenuation;
    helpers::Array<FileNameDataV18> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV18 depth;
    DynamicParamDataV18 pan;
    DynamicParamDataV18 pitch;
    DynamicParamDataV18 pitchMS;
    DynamicParamDataV18 volume;
    DynamicParamDataV18 volumeMS;
    RangeDataV18 initialDelay;
    RangeDataV18 playLength;
    RangeDataV18 positionOffsetAngle;
    RangeDataV18 positionRange;
    RangeDataV18 repeatCount;
    RangeDataV18 repeatTime;
    RangeDataV18 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV18();
    MetaSoundDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV18(const MetaSoundDataV18 &p_other);
    MetaSoundDataV18 &operator=(const MetaSoundDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV18 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV18();
    ScriptRefDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV18(const ScriptRefDataV18 &p_other);
    ScriptRefDataV18 &operator=(const ScriptRefDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV18 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV18();
    TriggerMarkerDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV18(const TriggerMarkerDataV18 &p_other);
    TriggerMarkerDataV18 &operator=(const TriggerMarkerDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV18 {
    qword name;
    helpers::Array<TriggerMarkerDataV18> triggerMarker;

public:
    TriggerKeyDataV18();
    TriggerKeyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV18(const TriggerKeyDataV18 &p_other);
    TriggerKeyDataV18 &operator=(const TriggerKeyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV18 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV18> audioSettings;
    helpers::Array<HandlerDataV18> handler;
    helpers::Array<MetaSoundDataV18> metaSound;
    helpers::Array<ScriptRefDataV18> scriptRef;
    helpers::Array<TriggerKeyDataV18> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV18();
    ScriptFileDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV18(const ScriptFileDataV18 &p_other);
    ScriptFileDataV18 &operator=(const ScriptFileDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<17>{
struct DspDataV17 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV17();
    DspDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV17(const DspDataV17 &p_other);
    DspDataV17 &operator=(const DspDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV17 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV17> dsp;

public:
    BussDynamicDataV17();
    BussDynamicDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV17(const BussDynamicDataV17 &p_other);
    BussDynamicDataV17 &operator=(const BussDynamicDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV17 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV17> dynamicData;

public:
    BussDataV17();
    BussDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV17(const BussDataV17 &p_other);
    BussDataV17 &operator=(const BussDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV17 {
    float offset;
    float value;

public:
    EnvelopePointDataV17();
    EnvelopePointDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV17(const EnvelopePointDataV17 &p_other);
    EnvelopePointDataV17 &operator=(const EnvelopePointDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV17 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV17> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV17();
    EnvelopeDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV17(const EnvelopeDataV17 &p_other);
    EnvelopeDataV17 &operator=(const EnvelopeDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV17 {
    float max;
    float min;
    byte min;

public:
    RangeDataV17();
    RangeDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV17(const RangeDataV17 &p_other);
    RangeDataV17 &operator=(const RangeDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV17 {
    RangeDataV17 time;
    RangeDataV17 value;

public:
    RandomParamDataV17();
    RandomParamDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV17(const RandomParamDataV17 &p_other);
    RandomParamDataV17 &operator=(const RandomParamDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV17 {
    helpers::Ptr<EnvelopeDataV17> envelopeData;
    helpers::Ptr<RandomParamDataV17> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV17();
    DynamicParamDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV17(const DynamicParamDataV17 &p_other);
    DynamicParamDataV17 &operator=(const DynamicParamDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV17 {
    float doppler;
    DynamicParamDataV17 lowPass;
    DynamicParamDataV17 pan3D;
    DynamicParamDataV17 reverb;
    DynamicParamDataV17 spread3D;
    DynamicParamDataV17 volumeA;
    DynamicParamDataV17 volumeB;

public:
    AttenuationDataV17();
    AttenuationDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV17(const AttenuationDataV17 &p_other);
    AttenuationDataV17 &operator=(const AttenuationDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV17 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV17();
    CategoryDynamicDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV17(const CategoryDynamicDataV17 &p_other);
    CategoryDynamicDataV17 &operator=(const CategoryDynamicDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV17 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV17> attenuation;
    helpers::Ptr<CategoryDynamicDataV17> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV17();
    CategoryDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV17(const CategoryDataV17 &p_other);
    CategoryDataV17 &operator=(const CategoryDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV17 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV17();
    ReverbDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV17(const ReverbDataV17 &p_other);
    ReverbDataV17 &operator=(const ReverbDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV17 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV17> buss;
    helpers::Array<CategoryDynamicDataV17> category;

public:
    SnapshotDataV17();
    SnapshotDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV17(const SnapshotDataV17 &p_other);
    SnapshotDataV17 &operator=(const SnapshotDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV17 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV17> buss;
    helpers::Array<CategoryDataV17> category;
    helpers::Array<ReverbDataV17> reverb;
    helpers::Array<SnapshotDataV17> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV17();
    AudioSettingsDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV17(const AudioSettingsDataV17 &p_other);
    AudioSettingsDataV17 &operator=(const AudioSettingsDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV17 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV17();
    HandlerDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV17(const HandlerDataV17 &p_other);
    HandlerDataV17 &operator=(const HandlerDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV17 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV17();
    FileNameDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV17(const FileNameDataV17 &p_other);
    FileNameDataV17 &operator=(const FileNameDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV17 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV17> dsp;
    helpers::Ptr<AttenuationDataV17> attenuation;
    helpers::Array<FileNameDataV17> fileName;
    float channelFadeIn;
    float channelFadeOut;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword channelMax;
    dword flags;
    dword loopCount;
    DynamicParamDataV17 depth;
    DynamicParamDataV17 pan;
    DynamicParamDataV17 pitch;
    DynamicParamDataV17 pitchMS;
    DynamicParamDataV17 volume;
    DynamicParamDataV17 volumeMS;
    RangeDataV17 initialDelay;
    RangeDataV17 playLength;
    RangeDataV17 positionOffsetAngle;
    RangeDataV17 positionRange;
    RangeDataV17 repeatCount;
    RangeDataV17 repeatTime;
    RangeDataV17 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV17();
    MetaSoundDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV17(const MetaSoundDataV17 &p_other);
    MetaSoundDataV17 &operator=(const MetaSoundDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV17 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV17();
    ScriptRefDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV17(const ScriptRefDataV17 &p_other);
    ScriptRefDataV17 &operator=(const ScriptRefDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV17 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV17();
    TriggerMarkerDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV17(const TriggerMarkerDataV17 &p_other);
    TriggerMarkerDataV17 &operator=(const TriggerMarkerDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV17 {
    qword name;
    helpers::Array<TriggerMarkerDataV17> triggerMarker;

public:
    TriggerKeyDataV17();
    TriggerKeyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV17(const TriggerKeyDataV17 &p_other);
    TriggerKeyDataV17 &operator=(const TriggerKeyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV17 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV17> audioSettings;
    helpers::Array<HandlerDataV17> handler;
    helpers::Array<MetaSoundDataV17> metaSound;
    helpers::Array<ScriptRefDataV17> scriptRef;
    helpers::Array<TriggerKeyDataV17> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV17();
    ScriptFileDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV17(const ScriptFileDataV17 &p_other);
    ScriptFileDataV17 &operator=(const ScriptFileDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<16>{
struct DspDataV16 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV16();
    DspDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV16(const DspDataV16 &p_other);
    DspDataV16 &operator=(const DspDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV16 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV16> dsp;

public:
    BussDynamicDataV16();
    BussDynamicDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV16(const BussDynamicDataV16 &p_other);
    BussDynamicDataV16 &operator=(const BussDynamicDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV16 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV16> dynamicData;

public:
    BussDataV16();
    BussDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV16(const BussDataV16 &p_other);
    BussDataV16 &operator=(const BussDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV16 {
    float offset;
    float value;

public:
    EnvelopePointDataV16();
    EnvelopePointDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV16(const EnvelopePointDataV16 &p_other);
    EnvelopePointDataV16 &operator=(const EnvelopePointDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV16 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV16> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV16();
    EnvelopeDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV16(const EnvelopeDataV16 &p_other);
    EnvelopeDataV16 &operator=(const EnvelopeDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV16 {
    float max;
    float min;
    byte min;

public:
    RangeDataV16();
    RangeDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV16(const RangeDataV16 &p_other);
    RangeDataV16 &operator=(const RangeDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV16 {
    RangeDataV16 time;
    RangeDataV16 value;

public:
    RandomParamDataV16();
    RandomParamDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV16(const RandomParamDataV16 &p_other);
    RandomParamDataV16 &operator=(const RandomParamDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV16 {
    helpers::Ptr<EnvelopeDataV16> envelopeData;
    helpers::Ptr<RandomParamDataV16> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV16();
    DynamicParamDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV16(const DynamicParamDataV16 &p_other);
    DynamicParamDataV16 &operator=(const DynamicParamDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV16 {
    float doppler;
    DynamicParamDataV16 lowPass;
    DynamicParamDataV16 pan3D;
    DynamicParamDataV16 reverb;
    DynamicParamDataV16 spread3D;
    DynamicParamDataV16 volumeA;
    DynamicParamDataV16 volumeB;

public:
    AttenuationDataV16();
    AttenuationDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV16(const AttenuationDataV16 &p_other);
    AttenuationDataV16 &operator=(const AttenuationDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV16 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV16();
    CategoryDynamicDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV16(const CategoryDynamicDataV16 &p_other);
    CategoryDynamicDataV16 &operator=(const CategoryDynamicDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV16 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV16> attenuation;
    helpers::Ptr<CategoryDynamicDataV16> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV16();
    CategoryDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV16(const CategoryDataV16 &p_other);
    CategoryDataV16 &operator=(const CategoryDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV16 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;
    float echoDelay;
    float echoDecayRatio;
    float echoWetMix;
    float echoDryMix;

public:
    ReverbDataV16();
    ReverbDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV16(const ReverbDataV16 &p_other);
    ReverbDataV16 &operator=(const ReverbDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV16 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV16> buss;
    helpers::Array<CategoryDynamicDataV16> category;

public:
    SnapshotDataV16();
    SnapshotDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV16(const SnapshotDataV16 &p_other);
    SnapshotDataV16 &operator=(const SnapshotDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV16 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV16> buss;
    helpers::Array<CategoryDataV16> category;
    helpers::Array<ReverbDataV16> reverb;
    helpers::Array<SnapshotDataV16> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV16();
    AudioSettingsDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV16(const AudioSettingsDataV16 &p_other);
    AudioSettingsDataV16 &operator=(const AudioSettingsDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV16 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV16();
    HandlerDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV16(const HandlerDataV16 &p_other);
    HandlerDataV16 &operator=(const HandlerDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV16 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV16();
    FileNameDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV16(const FileNameDataV16 &p_other);
    FileNameDataV16 &operator=(const FileNameDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV16 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV16> dsp;
    helpers::Ptr<AttenuationDataV16> attenuation;
    helpers::Array<FileNameDataV16> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV16 depth;
    DynamicParamDataV16 pan;
    DynamicParamDataV16 pitch;
    DynamicParamDataV16 pitchMS;
    DynamicParamDataV16 volume;
    DynamicParamDataV16 volumeMS;
    RangeDataV16 initialDelay;
    RangeDataV16 playLength;
    RangeDataV16 positionOffsetAngle;
    RangeDataV16 positionRange;
    RangeDataV16 repeatCount;
    RangeDataV16 repeatTime;
    RangeDataV16 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV16();
    MetaSoundDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV16(const MetaSoundDataV16 &p_other);
    MetaSoundDataV16 &operator=(const MetaSoundDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV16 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV16();
    ScriptRefDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV16(const ScriptRefDataV16 &p_other);
    ScriptRefDataV16 &operator=(const ScriptRefDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV16 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV16();
    TriggerMarkerDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV16(const TriggerMarkerDataV16 &p_other);
    TriggerMarkerDataV16 &operator=(const TriggerMarkerDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV16 {
    qword name;
    helpers::Array<TriggerMarkerDataV16> triggerMarker;

public:
    TriggerKeyDataV16();
    TriggerKeyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV16(const TriggerKeyDataV16 &p_other);
    TriggerKeyDataV16 &operator=(const TriggerKeyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV16 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV16> audioSettings;
    helpers::Array<HandlerDataV16> handler;
    helpers::Array<MetaSoundDataV16> metaSound;
    helpers::Array<ScriptRefDataV16> scriptRef;
    helpers::Array<TriggerKeyDataV16> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV16();
    ScriptFileDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV16(const ScriptFileDataV16 &p_other);
    ScriptFileDataV16 &operator=(const ScriptFileDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<15>{
struct DspDataV15 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV15();
    DspDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV15(const DspDataV15 &p_other);
    DspDataV15 &operator=(const DspDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV15 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV15> dsp;

public:
    BussDynamicDataV15();
    BussDynamicDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV15(const BussDynamicDataV15 &p_other);
    BussDynamicDataV15 &operator=(const BussDynamicDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV15 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV15> dynamicData;

public:
    BussDataV15();
    BussDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV15(const BussDataV15 &p_other);
    BussDataV15 &operator=(const BussDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV15 {
    float offset;
    float value;

public:
    EnvelopePointDataV15();
    EnvelopePointDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV15(const EnvelopePointDataV15 &p_other);
    EnvelopePointDataV15 &operator=(const EnvelopePointDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV15 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV15> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV15();
    EnvelopeDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV15(const EnvelopeDataV15 &p_other);
    EnvelopeDataV15 &operator=(const EnvelopeDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV15 {
    float max;
    float min;
    byte min;

public:
    RangeDataV15();
    RangeDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV15(const RangeDataV15 &p_other);
    RangeDataV15 &operator=(const RangeDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV15 {
    RangeDataV15 time;
    RangeDataV15 value;

public:
    RandomParamDataV15();
    RandomParamDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV15(const RandomParamDataV15 &p_other);
    RandomParamDataV15 &operator=(const RandomParamDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV15 {
    helpers::Ptr<EnvelopeDataV15> envelopeData;
    helpers::Ptr<RandomParamDataV15> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV15();
    DynamicParamDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV15(const DynamicParamDataV15 &p_other);
    DynamicParamDataV15 &operator=(const DynamicParamDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV15 {
    float doppler;
    DynamicParamDataV15 lowPass;
    DynamicParamDataV15 pan3D;
    DynamicParamDataV15 reverb;
    DynamicParamDataV15 spread3D;
    DynamicParamDataV15 volumeA;
    DynamicParamDataV15 volumeB;

public:
    AttenuationDataV15();
    AttenuationDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV15(const AttenuationDataV15 &p_other);
    AttenuationDataV15 &operator=(const AttenuationDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV15 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV15();
    CategoryDynamicDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV15(const CategoryDynamicDataV15 &p_other);
    CategoryDynamicDataV15 &operator=(const CategoryDynamicDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV15 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV15> attenuation;
    helpers::Ptr<CategoryDynamicDataV15> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV15();
    CategoryDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV15(const CategoryDataV15 &p_other);
    CategoryDataV15 &operator=(const CategoryDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV15 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV15();
    ReverbDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV15(const ReverbDataV15 &p_other);
    ReverbDataV15 &operator=(const ReverbDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV15 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV15> buss;
    helpers::Array<CategoryDynamicDataV15> category;

public:
    SnapshotDataV15();
    SnapshotDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV15(const SnapshotDataV15 &p_other);
    SnapshotDataV15 &operator=(const SnapshotDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV15 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV15> buss;
    helpers::Array<CategoryDataV15> category;
    helpers::Array<ReverbDataV15> reverb;
    helpers::Array<SnapshotDataV15> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV15();
    AudioSettingsDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV15(const AudioSettingsDataV15 &p_other);
    AudioSettingsDataV15 &operator=(const AudioSettingsDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV15 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV15();
    HandlerDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV15(const HandlerDataV15 &p_other);
    HandlerDataV15 &operator=(const HandlerDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV15 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV15();
    FileNameDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV15(const FileNameDataV15 &p_other);
    FileNameDataV15 &operator=(const FileNameDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV15 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV15> dsp;
    helpers::Ptr<AttenuationDataV15> attenuation;
    helpers::Array<FileNameDataV15> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV15 depth;
    DynamicParamDataV15 pan;
    DynamicParamDataV15 pitch;
    DynamicParamDataV15 pitchMS;
    DynamicParamDataV15 volume;
    DynamicParamDataV15 volumeMS;
    RangeDataV15 initialDelay;
    RangeDataV15 playLength;
    RangeDataV15 positionOffsetAngle;
    RangeDataV15 positionRange;
    RangeDataV15 repeatCount;
    RangeDataV15 repeatTime;
    RangeDataV15 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV15();
    MetaSoundDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV15(const MetaSoundDataV15 &p_other);
    MetaSoundDataV15 &operator=(const MetaSoundDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV15 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV15();
    ScriptRefDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV15(const ScriptRefDataV15 &p_other);
    ScriptRefDataV15 &operator=(const ScriptRefDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV15 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV15();
    TriggerMarkerDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV15(const TriggerMarkerDataV15 &p_other);
    TriggerMarkerDataV15 &operator=(const TriggerMarkerDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV15 {
    qword name;
    helpers::Array<TriggerMarkerDataV15> triggerMarker;

public:
    TriggerKeyDataV15();
    TriggerKeyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV15(const TriggerKeyDataV15 &p_other);
    TriggerKeyDataV15 &operator=(const TriggerKeyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV15 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV15> audioSettings;
    helpers::Array<HandlerDataV15> handler;
    helpers::Array<MetaSoundDataV15> metaSound;
    helpers::Array<ScriptRefDataV15> scriptRef;
    helpers::Array<TriggerKeyDataV15> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV15();
    ScriptFileDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV15(const ScriptFileDataV15 &p_other);
    ScriptFileDataV15 &operator=(const ScriptFileDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<14>{
struct DspDataV14 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV14();
    DspDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV14(const DspDataV14 &p_other);
    DspDataV14 &operator=(const DspDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV14 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV14> dsp;

public:
    BussDynamicDataV14();
    BussDynamicDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV14(const BussDynamicDataV14 &p_other);
    BussDynamicDataV14 &operator=(const BussDynamicDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV14 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV14> dynamicData;

public:
    BussDataV14();
    BussDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV14(const BussDataV14 &p_other);
    BussDataV14 &operator=(const BussDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV14 {
    float offset;
    float value;

public:
    EnvelopePointDataV14();
    EnvelopePointDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV14(const EnvelopePointDataV14 &p_other);
    EnvelopePointDataV14 &operator=(const EnvelopePointDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV14 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV14> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV14();
    EnvelopeDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV14(const EnvelopeDataV14 &p_other);
    EnvelopeDataV14 &operator=(const EnvelopeDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV14 {
    float max;
    float min;
    byte min;

public:
    RangeDataV14();
    RangeDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV14(const RangeDataV14 &p_other);
    RangeDataV14 &operator=(const RangeDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV14 {
    RangeDataV14 time;
    RangeDataV14 value;

public:
    RandomParamDataV14();
    RandomParamDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV14(const RandomParamDataV14 &p_other);
    RandomParamDataV14 &operator=(const RandomParamDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV14 {
    helpers::Ptr<EnvelopeDataV14> envelopeData;
    helpers::Ptr<RandomParamDataV14> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV14();
    DynamicParamDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV14(const DynamicParamDataV14 &p_other);
    DynamicParamDataV14 &operator=(const DynamicParamDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV14 {
    float doppler;
    DynamicParamDataV14 lowPass;
    DynamicParamDataV14 pan3D;
    DynamicParamDataV14 spread3D;
    DynamicParamDataV14 volumeA;
    DynamicParamDataV14 volumeB;

public:
    AttenuationDataV14();
    AttenuationDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV14(const AttenuationDataV14 &p_other);
    AttenuationDataV14 &operator=(const AttenuationDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV14 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV14();
    CategoryDynamicDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV14(const CategoryDynamicDataV14 &p_other);
    CategoryDynamicDataV14 &operator=(const CategoryDynamicDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV14 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV14> attenuation;
    helpers::Ptr<CategoryDynamicDataV14> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV14();
    CategoryDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV14(const CategoryDataV14 &p_other);
    CategoryDataV14 &operator=(const CategoryDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV14 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV14();
    ReverbDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV14(const ReverbDataV14 &p_other);
    ReverbDataV14 &operator=(const ReverbDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV14 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV14> buss;
    helpers::Array<CategoryDynamicDataV14> category;

public:
    SnapshotDataV14();
    SnapshotDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV14(const SnapshotDataV14 &p_other);
    SnapshotDataV14 &operator=(const SnapshotDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV14 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float dopplerScale;
    float focusTransition;
    helpers::Array<BussDataV14> buss;
    helpers::Array<CategoryDataV14> category;
    helpers::Array<ReverbDataV14> reverb;
    helpers::Array<SnapshotDataV14> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV14();
    AudioSettingsDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV14(const AudioSettingsDataV14 &p_other);
    AudioSettingsDataV14 &operator=(const AudioSettingsDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV14 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV14();
    HandlerDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV14(const HandlerDataV14 &p_other);
    HandlerDataV14 &operator=(const HandlerDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV14 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV14();
    FileNameDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV14(const FileNameDataV14 &p_other);
    FileNameDataV14 &operator=(const FileNameDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV14 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV14> dsp;
    helpers::Ptr<AttenuationDataV14> attenuation;
    helpers::Array<FileNameDataV14> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV14 depth;
    DynamicParamDataV14 pan;
    DynamicParamDataV14 pitch;
    DynamicParamDataV14 pitchMS;
    DynamicParamDataV14 volume;
    DynamicParamDataV14 volumeMS;
    RangeDataV14 initialDelay;
    RangeDataV14 playLength;
    RangeDataV14 positionOffsetAngle;
    RangeDataV14 positionRange;
    RangeDataV14 repeatCount;
    RangeDataV14 repeatTime;
    RangeDataV14 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV14();
    MetaSoundDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV14(const MetaSoundDataV14 &p_other);
    MetaSoundDataV14 &operator=(const MetaSoundDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV14 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV14();
    ScriptRefDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV14(const ScriptRefDataV14 &p_other);
    ScriptRefDataV14 &operator=(const ScriptRefDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV14 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV14();
    TriggerMarkerDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV14(const TriggerMarkerDataV14 &p_other);
    TriggerMarkerDataV14 &operator=(const TriggerMarkerDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV14 {
    qword name;
    helpers::Array<TriggerMarkerDataV14> triggerMarker;

public:
    TriggerKeyDataV14();
    TriggerKeyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV14(const TriggerKeyDataV14 &p_other);
    TriggerKeyDataV14 &operator=(const TriggerKeyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV14 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV14> audioSettings;
    helpers::Array<HandlerDataV14> handler;
    helpers::Array<MetaSoundDataV14> metaSound;
    helpers::Array<ScriptRefDataV14> scriptRef;
    helpers::Array<TriggerKeyDataV14> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV14();
    ScriptFileDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV14(const ScriptFileDataV14 &p_other);
    ScriptFileDataV14 &operator=(const ScriptFileDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<13>{
struct DspDataV13 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV13();
    DspDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV13(const DspDataV13 &p_other);
    DspDataV13 &operator=(const DspDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV13 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV13> dsp;

public:
    BussDynamicDataV13();
    BussDynamicDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV13(const BussDynamicDataV13 &p_other);
    BussDynamicDataV13 &operator=(const BussDynamicDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV13 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV13> dynamicData;

public:
    BussDataV13();
    BussDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV13(const BussDataV13 &p_other);
    BussDataV13 &operator=(const BussDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV13 {
    float offset;
    float value;

public:
    EnvelopePointDataV13();
    EnvelopePointDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV13(const EnvelopePointDataV13 &p_other);
    EnvelopePointDataV13 &operator=(const EnvelopePointDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV13 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV13> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV13();
    EnvelopeDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV13(const EnvelopeDataV13 &p_other);
    EnvelopeDataV13 &operator=(const EnvelopeDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV13 {
    float max;
    float min;
    byte min;

public:
    RangeDataV13();
    RangeDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV13(const RangeDataV13 &p_other);
    RangeDataV13 &operator=(const RangeDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV13 {
    RangeDataV13 time;
    RangeDataV13 value;

public:
    RandomParamDataV13();
    RandomParamDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV13(const RandomParamDataV13 &p_other);
    RandomParamDataV13 &operator=(const RandomParamDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV13 {
    helpers::Ptr<EnvelopeDataV13> envelopeData;
    helpers::Ptr<RandomParamDataV13> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV13();
    DynamicParamDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV13(const DynamicParamDataV13 &p_other);
    DynamicParamDataV13 &operator=(const DynamicParamDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV13 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV13 lowPass;
    DynamicParamDataV13 pan3D;
    DynamicParamDataV13 spread3D;
    DynamicParamDataV13 volumeA;
    DynamicParamDataV13 volumeB;

public:
    AttenuationDataV13();
    AttenuationDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV13(const AttenuationDataV13 &p_other);
    AttenuationDataV13 &operator=(const AttenuationDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV13 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV13();
    CategoryDynamicDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV13(const CategoryDynamicDataV13 &p_other);
    CategoryDynamicDataV13 &operator=(const CategoryDynamicDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV13 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV13> attenuation;
    helpers::Ptr<CategoryDynamicDataV13> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV13();
    CategoryDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV13(const CategoryDataV13 &p_other);
    CategoryDataV13 &operator=(const CategoryDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV13 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV13();
    ReverbDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV13(const ReverbDataV13 &p_other);
    ReverbDataV13 &operator=(const ReverbDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV13 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV13> buss;
    helpers::Array<CategoryDynamicDataV13> category;

public:
    SnapshotDataV13();
    SnapshotDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV13(const SnapshotDataV13 &p_other);
    SnapshotDataV13 &operator=(const SnapshotDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV13 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV13> buss;
    helpers::Array<CategoryDataV13> category;
    helpers::Array<ReverbDataV13> reverb;
    helpers::Array<SnapshotDataV13> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV13();
    AudioSettingsDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV13(const AudioSettingsDataV13 &p_other);
    AudioSettingsDataV13 &operator=(const AudioSettingsDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV13 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV13();
    HandlerDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV13(const HandlerDataV13 &p_other);
    HandlerDataV13 &operator=(const HandlerDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV13 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV13();
    FileNameDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV13(const FileNameDataV13 &p_other);
    FileNameDataV13 &operator=(const FileNameDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV13 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV13> dsp;
    helpers::Ptr<AttenuationDataV13> attenuation;
    helpers::Array<FileNameDataV13> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV13 depth;
    DynamicParamDataV13 pan;
    DynamicParamDataV13 pitch;
    DynamicParamDataV13 pitchMS;
    DynamicParamDataV13 volume;
    DynamicParamDataV13 volumeMS;
    RangeDataV13 initialDelay;
    RangeDataV13 playLength;
    RangeDataV13 positionOffsetAngle;
    RangeDataV13 positionRange;
    RangeDataV13 repeatCount;
    RangeDataV13 repeatTime;
    RangeDataV13 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV13();
    MetaSoundDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV13(const MetaSoundDataV13 &p_other);
    MetaSoundDataV13 &operator=(const MetaSoundDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV13 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV13();
    ScriptRefDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV13(const ScriptRefDataV13 &p_other);
    ScriptRefDataV13 &operator=(const ScriptRefDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV13 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV13();
    TriggerMarkerDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV13(const TriggerMarkerDataV13 &p_other);
    TriggerMarkerDataV13 &operator=(const TriggerMarkerDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV13 {
    qword name;
    helpers::Array<TriggerMarkerDataV13> triggerMarker;

public:
    TriggerKeyDataV13();
    TriggerKeyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV13(const TriggerKeyDataV13 &p_other);
    TriggerKeyDataV13 &operator=(const TriggerKeyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV13 {
    qword musicCue;
    qword reverbOverride;
    helpers::Ptr<AudioSettingsDataV13> audioSettings;
    helpers::Array<HandlerDataV13> handler;
    helpers::Array<MetaSoundDataV13> metaSound;
    helpers::Array<ScriptRefDataV13> scriptRef;
    helpers::Array<TriggerKeyDataV13> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV13();
    ScriptFileDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV13(const ScriptFileDataV13 &p_other);
    ScriptFileDataV13 &operator=(const ScriptFileDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x40F8462000000001 */

template <>
struct Gw2StructAMSP<12>{
struct DspDataV12 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV12();
    DspDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV12(const DspDataV12 &p_other);
    DspDataV12 &operator=(const DspDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV12 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV12> dsp;

public:
    BussDynamicDataV12();
    BussDynamicDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV12(const BussDynamicDataV12 &p_other);
    BussDynamicDataV12 &operator=(const BussDynamicDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV12 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV12> dynamicData;

public:
    BussDataV12();
    BussDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV12(const BussDataV12 &p_other);
    BussDataV12 &operator=(const BussDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV12 {
    float offset;
    float value;

public:
    EnvelopePointDataV12();
    EnvelopePointDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV12(const EnvelopePointDataV12 &p_other);
    EnvelopePointDataV12 &operator=(const EnvelopePointDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV12 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV12> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV12();
    EnvelopeDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV12(const EnvelopeDataV12 &p_other);
    EnvelopeDataV12 &operator=(const EnvelopeDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV12 {
    float max;
    float min;
    byte min;

public:
    RangeDataV12();
    RangeDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV12(const RangeDataV12 &p_other);
    RangeDataV12 &operator=(const RangeDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV12 {
    RangeDataV12 time;
    RangeDataV12 value;

public:
    RandomParamDataV12();
    RandomParamDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV12(const RandomParamDataV12 &p_other);
    RandomParamDataV12 &operator=(const RandomParamDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV12 {
    helpers::Ptr<EnvelopeDataV12> envelopeData;
    helpers::Ptr<RandomParamDataV12> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV12();
    DynamicParamDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV12(const DynamicParamDataV12 &p_other);
    DynamicParamDataV12 &operator=(const DynamicParamDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV12 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV12 lowPass;
    DynamicParamDataV12 pan3D;
    DynamicParamDataV12 spread3D;
    DynamicParamDataV12 volumeA;
    DynamicParamDataV12 volumeB;

public:
    AttenuationDataV12();
    AttenuationDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV12(const AttenuationDataV12 &p_other);
    AttenuationDataV12 &operator=(const AttenuationDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV12 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV12();
    CategoryDynamicDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV12(const CategoryDynamicDataV12 &p_other);
    CategoryDynamicDataV12 &operator=(const CategoryDynamicDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV12 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV12> attenuation;
    helpers::Ptr<CategoryDynamicDataV12> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV12();
    CategoryDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV12(const CategoryDataV12 &p_other);
    CategoryDataV12 &operator=(const CategoryDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV12 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV12();
    ReverbDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV12(const ReverbDataV12 &p_other);
    ReverbDataV12 &operator=(const ReverbDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV12 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV12> buss;
    helpers::Array<CategoryDynamicDataV12> category;

public:
    SnapshotDataV12();
    SnapshotDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV12(const SnapshotDataV12 &p_other);
    SnapshotDataV12 &operator=(const SnapshotDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV12 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV12> buss;
    helpers::Array<CategoryDataV12> category;
    helpers::Array<ReverbDataV12> reverb;
    helpers::Array<SnapshotDataV12> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV12();
    AudioSettingsDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV12(const AudioSettingsDataV12 &p_other);
    AudioSettingsDataV12 &operator=(const AudioSettingsDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV12 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV12();
    HandlerDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV12(const HandlerDataV12 &p_other);
    HandlerDataV12 &operator=(const HandlerDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV12 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV12();
    FileNameDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV12(const FileNameDataV12 &p_other);
    FileNameDataV12 &operator=(const FileNameDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV12 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV12> dsp;
    helpers::Ptr<AttenuationDataV12> attenuation;
    helpers::Array<FileNameDataV12> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV12 depth;
    DynamicParamDataV12 pan;
    DynamicParamDataV12 pitch;
    DynamicParamDataV12 pitchMS;
    DynamicParamDataV12 volume;
    DynamicParamDataV12 volumeMS;
    RangeDataV12 initialDelay;
    RangeDataV12 playLength;
    RangeDataV12 positionOffsetAngle;
    RangeDataV12 positionRange;
    RangeDataV12 repeatCount;
    RangeDataV12 repeatTime;
    RangeDataV12 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV12();
    MetaSoundDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV12(const MetaSoundDataV12 &p_other);
    MetaSoundDataV12 &operator=(const MetaSoundDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV12 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV12();
    ScriptRefDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV12(const ScriptRefDataV12 &p_other);
    ScriptRefDataV12 &operator=(const ScriptRefDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV12 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV12();
    TriggerMarkerDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV12(const TriggerMarkerDataV12 &p_other);
    TriggerMarkerDataV12 &operator=(const TriggerMarkerDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV12 {
    qword name;
    helpers::Array<TriggerMarkerDataV12> triggerMarker;

public:
    TriggerKeyDataV12();
    TriggerKeyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV12(const TriggerKeyDataV12 &p_other);
    TriggerKeyDataV12 &operator=(const TriggerKeyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV12 {
    qword musicCue;
    helpers::Ptr<AudioSettingsDataV12> audioSettings;
    helpers::Array<HandlerDataV12> handler;
    helpers::Array<MetaSoundDataV12> metaSound;
    helpers::Array<ScriptRefDataV12> scriptRef;
    helpers::Array<TriggerKeyDataV12> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;
    byte musicCuePriority;

public:
    ScriptFileDataV12();
    ScriptFileDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV12(const ScriptFileDataV12 &p_other);
    ScriptFileDataV12 &operator=(const ScriptFileDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<11>{
struct DspDataV11 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV11();
    DspDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV11(const DspDataV11 &p_other);
    DspDataV11 &operator=(const DspDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV11 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV11> dsp;

public:
    BussDynamicDataV11();
    BussDynamicDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV11(const BussDynamicDataV11 &p_other);
    BussDynamicDataV11 &operator=(const BussDynamicDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV11 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV11> dynamicData;

public:
    BussDataV11();
    BussDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV11(const BussDataV11 &p_other);
    BussDataV11 &operator=(const BussDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV11 {
    float offset;
    float value;

public:
    EnvelopePointDataV11();
    EnvelopePointDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV11(const EnvelopePointDataV11 &p_other);
    EnvelopePointDataV11 &operator=(const EnvelopePointDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV11 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV11> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV11();
    EnvelopeDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV11(const EnvelopeDataV11 &p_other);
    EnvelopeDataV11 &operator=(const EnvelopeDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV11 {
    float max;
    float min;
    byte min;

public:
    RangeDataV11();
    RangeDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV11(const RangeDataV11 &p_other);
    RangeDataV11 &operator=(const RangeDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV11 {
    RangeDataV11 time;
    RangeDataV11 value;

public:
    RandomParamDataV11();
    RandomParamDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV11(const RandomParamDataV11 &p_other);
    RandomParamDataV11 &operator=(const RandomParamDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV11 {
    helpers::Ptr<EnvelopeDataV11> envelopeData;
    helpers::Ptr<RandomParamDataV11> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV11();
    DynamicParamDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV11(const DynamicParamDataV11 &p_other);
    DynamicParamDataV11 &operator=(const DynamicParamDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV11 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV11 lowPass;
    DynamicParamDataV11 pan3D;
    DynamicParamDataV11 spread3D;
    DynamicParamDataV11 volumeA;
    DynamicParamDataV11 volumeB;

public:
    AttenuationDataV11();
    AttenuationDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV11(const AttenuationDataV11 &p_other);
    AttenuationDataV11 &operator=(const AttenuationDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV11 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV11();
    CategoryDynamicDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV11(const CategoryDynamicDataV11 &p_other);
    CategoryDynamicDataV11 &operator=(const CategoryDynamicDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV11 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV11> attenuation;
    helpers::Ptr<CategoryDynamicDataV11> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV11();
    CategoryDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV11(const CategoryDataV11 &p_other);
    CategoryDataV11 &operator=(const CategoryDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV11 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV11();
    ReverbDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV11(const ReverbDataV11 &p_other);
    ReverbDataV11 &operator=(const ReverbDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV11 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV11> buss;
    helpers::Array<CategoryDynamicDataV11> category;

public:
    SnapshotDataV11();
    SnapshotDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV11(const SnapshotDataV11 &p_other);
    SnapshotDataV11 &operator=(const SnapshotDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV11 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV11> buss;
    helpers::Array<CategoryDataV11> category;
    helpers::Array<ReverbDataV11> reverb;
    helpers::Array<SnapshotDataV11> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;
    helpers::FileName musicScriptFileName;

public:
    AudioSettingsDataV11();
    AudioSettingsDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV11(const AudioSettingsDataV11 &p_other);
    AudioSettingsDataV11 &operator=(const AudioSettingsDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV11 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV11();
    HandlerDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV11(const HandlerDataV11 &p_other);
    HandlerDataV11 &operator=(const HandlerDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV11 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV11();
    FileNameDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV11(const FileNameDataV11 &p_other);
    FileNameDataV11 &operator=(const FileNameDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV11 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV11> dsp;
    helpers::Ptr<AttenuationDataV11> attenuation;
    helpers::Array<FileNameDataV11> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV11 depth;
    DynamicParamDataV11 pan;
    DynamicParamDataV11 pitch;
    DynamicParamDataV11 pitchMS;
    DynamicParamDataV11 volume;
    DynamicParamDataV11 volumeMS;
    RangeDataV11 initialDelay;
    RangeDataV11 playLength;
    RangeDataV11 positionOffsetAngle;
    RangeDataV11 positionRange;
    RangeDataV11 repeatCount;
    RangeDataV11 repeatTime;
    RangeDataV11 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV11();
    MetaSoundDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV11(const MetaSoundDataV11 &p_other);
    MetaSoundDataV11 &operator=(const MetaSoundDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV11 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV11();
    ScriptRefDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV11(const ScriptRefDataV11 &p_other);
    ScriptRefDataV11 &operator=(const ScriptRefDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV11 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV11();
    TriggerMarkerDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV11(const TriggerMarkerDataV11 &p_other);
    TriggerMarkerDataV11 &operator=(const TriggerMarkerDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV11 {
    qword name;
    helpers::Array<TriggerMarkerDataV11> triggerMarker;

public:
    TriggerKeyDataV11();
    TriggerKeyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV11(const TriggerKeyDataV11 &p_other);
    TriggerKeyDataV11 &operator=(const TriggerKeyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV11 {
    qword musicCue;
    helpers::Ptr<AudioSettingsDataV11> audioSettings;
    helpers::Array<HandlerDataV11> handler;
    helpers::Array<MetaSoundDataV11> metaSound;
    helpers::Array<ScriptRefDataV11> scriptRef;
    helpers::Array<TriggerKeyDataV11> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;

public:
    ScriptFileDataV11();
    ScriptFileDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV11(const ScriptFileDataV11 &p_other);
    ScriptFileDataV11 &operator=(const ScriptFileDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<10>{
struct DspDataV10 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV10();
    DspDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV10(const DspDataV10 &p_other);
    DspDataV10 &operator=(const DspDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV10 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV10> dsp;

public:
    BussDynamicDataV10();
    BussDynamicDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV10(const BussDynamicDataV10 &p_other);
    BussDynamicDataV10 &operator=(const BussDynamicDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV10 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV10> dynamicData;

public:
    BussDataV10();
    BussDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV10(const BussDataV10 &p_other);
    BussDataV10 &operator=(const BussDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV10 {
    float offset;
    float value;

public:
    EnvelopePointDataV10();
    EnvelopePointDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV10(const EnvelopePointDataV10 &p_other);
    EnvelopePointDataV10 &operator=(const EnvelopePointDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV10 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV10> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV10();
    EnvelopeDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV10(const EnvelopeDataV10 &p_other);
    EnvelopeDataV10 &operator=(const EnvelopeDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV10 {
    float max;
    float min;
    byte min;

public:
    RangeDataV10();
    RangeDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV10(const RangeDataV10 &p_other);
    RangeDataV10 &operator=(const RangeDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV10 {
    RangeDataV10 time;
    RangeDataV10 value;

public:
    RandomParamDataV10();
    RandomParamDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV10(const RandomParamDataV10 &p_other);
    RandomParamDataV10 &operator=(const RandomParamDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV10 {
    helpers::Ptr<EnvelopeDataV10> envelopeData;
    helpers::Ptr<RandomParamDataV10> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV10();
    DynamicParamDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV10(const DynamicParamDataV10 &p_other);
    DynamicParamDataV10 &operator=(const DynamicParamDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV10 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV10 lowPass;
    DynamicParamDataV10 pan3D;
    DynamicParamDataV10 spread3D;
    DynamicParamDataV10 volumeA;
    DynamicParamDataV10 volumeB;

public:
    AttenuationDataV10();
    AttenuationDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV10(const AttenuationDataV10 &p_other);
    AttenuationDataV10 &operator=(const AttenuationDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV10 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV10();
    CategoryDynamicDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV10(const CategoryDynamicDataV10 &p_other);
    CategoryDynamicDataV10 &operator=(const CategoryDynamicDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV10 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV10> attenuation;
    helpers::Ptr<CategoryDynamicDataV10> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV10();
    CategoryDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV10(const CategoryDataV10 &p_other);
    CategoryDataV10 &operator=(const CategoryDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV10 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV10();
    ReverbDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV10(const ReverbDataV10 &p_other);
    ReverbDataV10 &operator=(const ReverbDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV10 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV10> buss;
    helpers::Array<CategoryDynamicDataV10> category;

public:
    SnapshotDataV10();
    SnapshotDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV10(const SnapshotDataV10 &p_other);
    SnapshotDataV10 &operator=(const SnapshotDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV10 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV10> buss;
    helpers::Array<CategoryDataV10> category;
    helpers::Array<ReverbDataV10> reverb;
    helpers::Array<SnapshotDataV10> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV10();
    AudioSettingsDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV10(const AudioSettingsDataV10 &p_other);
    AudioSettingsDataV10 &operator=(const AudioSettingsDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV10 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV10();
    HandlerDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV10(const HandlerDataV10 &p_other);
    HandlerDataV10 &operator=(const HandlerDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV10 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV10();
    FileNameDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV10(const FileNameDataV10 &p_other);
    FileNameDataV10 &operator=(const FileNameDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV10 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV10> dsp;
    helpers::Ptr<AttenuationDataV10> attenuation;
    helpers::Array<FileNameDataV10> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV10 depth;
    DynamicParamDataV10 pan;
    DynamicParamDataV10 pitch;
    DynamicParamDataV10 pitchMS;
    DynamicParamDataV10 volume;
    DynamicParamDataV10 volumeMS;
    RangeDataV10 initialDelay;
    RangeDataV10 playLength;
    RangeDataV10 positionOffsetAngle;
    RangeDataV10 positionRange;
    RangeDataV10 repeatCount;
    RangeDataV10 repeatTime;
    RangeDataV10 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV10();
    MetaSoundDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV10(const MetaSoundDataV10 &p_other);
    MetaSoundDataV10 &operator=(const MetaSoundDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV10 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV10();
    ScriptRefDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV10(const ScriptRefDataV10 &p_other);
    ScriptRefDataV10 &operator=(const ScriptRefDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV10 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV10();
    TriggerMarkerDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV10(const TriggerMarkerDataV10 &p_other);
    TriggerMarkerDataV10 &operator=(const TriggerMarkerDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV10 {
    qword name;
    helpers::Array<TriggerMarkerDataV10> triggerMarker;

public:
    TriggerKeyDataV10();
    TriggerKeyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV10(const TriggerKeyDataV10 &p_other);
    TriggerKeyDataV10 &operator=(const TriggerKeyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV10 {
    qword musicCue;
    helpers::Ptr<AudioSettingsDataV10> audioSettings;
    helpers::Array<HandlerDataV10> handler;
    helpers::Array<MetaSoundDataV10> metaSound;
    helpers::Array<ScriptRefDataV10> scriptRef;
    helpers::Array<TriggerKeyDataV10> triggerKey;
    dword flags;
    dword soundPoolCount;
    float fadeInTime;
    float soundPoolDelay;
    float volume;

public:
    ScriptFileDataV10();
    ScriptFileDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV10(const ScriptFileDataV10 &p_other);
    ScriptFileDataV10 &operator=(const ScriptFileDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<9>{
struct DspDataV9 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV9();
    DspDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV9(const DspDataV9 &p_other);
    DspDataV9 &operator=(const DspDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV9 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV9> dsp;

public:
    BussDynamicDataV9();
    BussDynamicDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV9(const BussDynamicDataV9 &p_other);
    BussDynamicDataV9 &operator=(const BussDynamicDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV9 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV9> dynamicData;

public:
    BussDataV9();
    BussDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV9(const BussDataV9 &p_other);
    BussDataV9 &operator=(const BussDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV9 {
    float offset;
    float value;

public:
    EnvelopePointDataV9();
    EnvelopePointDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV9(const EnvelopePointDataV9 &p_other);
    EnvelopePointDataV9 &operator=(const EnvelopePointDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV9 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV9> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV9();
    EnvelopeDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV9(const EnvelopeDataV9 &p_other);
    EnvelopeDataV9 &operator=(const EnvelopeDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV9 {
    float max;
    float min;
    byte min;

public:
    RangeDataV9();
    RangeDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV9(const RangeDataV9 &p_other);
    RangeDataV9 &operator=(const RangeDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV9 {
    RangeDataV9 time;
    RangeDataV9 value;

public:
    RandomParamDataV9();
    RandomParamDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV9(const RandomParamDataV9 &p_other);
    RandomParamDataV9 &operator=(const RandomParamDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV9 {
    helpers::Ptr<EnvelopeDataV9> envelopeData;
    helpers::Ptr<RandomParamDataV9> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV9();
    DynamicParamDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV9(const DynamicParamDataV9 &p_other);
    DynamicParamDataV9 &operator=(const DynamicParamDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV9 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV9 lowPass;
    DynamicParamDataV9 pan3D;
    DynamicParamDataV9 spread3D;
    DynamicParamDataV9 volumeA;
    DynamicParamDataV9 volumeB;

public:
    AttenuationDataV9();
    AttenuationDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV9(const AttenuationDataV9 &p_other);
    AttenuationDataV9 &operator=(const AttenuationDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV9 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV9();
    CategoryDynamicDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV9(const CategoryDynamicDataV9 &p_other);
    CategoryDynamicDataV9 &operator=(const CategoryDynamicDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV9 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    qword soundPoolCategory;
    helpers::Ptr<AttenuationDataV9> attenuation;
    helpers::Ptr<CategoryDynamicDataV9> dynamicData;
    float muteFadeTime;
    float soundPoolDelay;
    dword flags;
    dword maxAudible;
    dword soundPoolCount;
    byte maxAudibleBehavior;
    byte soundPoolCountBehavior;
    byte soundPoolMode;

public:
    CategoryDataV9();
    CategoryDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV9(const CategoryDataV9 &p_other);
    CategoryDataV9 &operator=(const CategoryDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV9 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV9();
    ReverbDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV9(const ReverbDataV9 &p_other);
    ReverbDataV9 &operator=(const ReverbDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV9 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV9> buss;
    helpers::Array<CategoryDynamicDataV9> category;

public:
    SnapshotDataV9();
    SnapshotDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV9(const SnapshotDataV9 &p_other);
    SnapshotDataV9 &operator=(const SnapshotDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV9 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV9> buss;
    helpers::Array<CategoryDataV9> category;
    helpers::Array<ReverbDataV9> reverb;
    helpers::Array<SnapshotDataV9> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV9();
    AudioSettingsDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV9(const AudioSettingsDataV9 &p_other);
    AudioSettingsDataV9 &operator=(const AudioSettingsDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV9 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV9();
    HandlerDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV9(const HandlerDataV9 &p_other);
    HandlerDataV9 &operator=(const HandlerDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV9 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV9();
    FileNameDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV9(const FileNameDataV9 &p_other);
    FileNameDataV9 &operator=(const FileNameDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV9 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV9> dsp;
    helpers::Ptr<AttenuationDataV9> attenuation;
    helpers::Array<FileNameDataV9> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV9 depth;
    DynamicParamDataV9 pan;
    DynamicParamDataV9 pitch;
    DynamicParamDataV9 pitchMS;
    DynamicParamDataV9 volume;
    DynamicParamDataV9 volumeMS;
    RangeDataV9 initialDelay;
    RangeDataV9 playLength;
    RangeDataV9 positionOffsetAngle;
    RangeDataV9 positionRange;
    RangeDataV9 repeatCount;
    RangeDataV9 repeatTime;
    RangeDataV9 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV9();
    MetaSoundDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV9(const MetaSoundDataV9 &p_other);
    MetaSoundDataV9 &operator=(const MetaSoundDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV9 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV9();
    ScriptRefDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV9(const ScriptRefDataV9 &p_other);
    ScriptRefDataV9 &operator=(const ScriptRefDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV9 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV9();
    TriggerMarkerDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV9(const TriggerMarkerDataV9 &p_other);
    TriggerMarkerDataV9 &operator=(const TriggerMarkerDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV9 {
    qword name;
    helpers::Array<TriggerMarkerDataV9> triggerMarker;

public:
    TriggerKeyDataV9();
    TriggerKeyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV9(const TriggerKeyDataV9 &p_other);
    TriggerKeyDataV9 &operator=(const TriggerKeyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV9 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV9> audioSettings;
    helpers::Array<HandlerDataV9> handler;
    helpers::Array<MetaSoundDataV9> metaSound;
    helpers::Array<ScriptRefDataV9> scriptRef;
    helpers::Array<TriggerKeyDataV9> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV9();
    ScriptFileDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV9(const ScriptFileDataV9 &p_other);
    ScriptFileDataV9 &operator=(const ScriptFileDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<8>{
struct DspDataV8 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV8();
    DspDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV8(const DspDataV8 &p_other);
    DspDataV8 &operator=(const DspDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV8 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV8> dsp;

public:
    BussDynamicDataV8();
    BussDynamicDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV8(const BussDynamicDataV8 &p_other);
    BussDynamicDataV8 &operator=(const BussDynamicDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV8 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV8> dynamicData;

public:
    BussDataV8();
    BussDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV8(const BussDataV8 &p_other);
    BussDataV8 &operator=(const BussDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV8 {
    float offset;
    float value;

public:
    EnvelopePointDataV8();
    EnvelopePointDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV8(const EnvelopePointDataV8 &p_other);
    EnvelopePointDataV8 &operator=(const EnvelopePointDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV8 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV8> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV8();
    EnvelopeDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV8(const EnvelopeDataV8 &p_other);
    EnvelopeDataV8 &operator=(const EnvelopeDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV8 {
    float max;
    float min;
    byte min;

public:
    RangeDataV8();
    RangeDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV8(const RangeDataV8 &p_other);
    RangeDataV8 &operator=(const RangeDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV8 {
    RangeDataV8 time;
    RangeDataV8 value;

public:
    RandomParamDataV8();
    RandomParamDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV8(const RandomParamDataV8 &p_other);
    RandomParamDataV8 &operator=(const RandomParamDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV8 {
    helpers::Ptr<EnvelopeDataV8> envelopeData;
    helpers::Ptr<RandomParamDataV8> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV8();
    DynamicParamDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV8(const DynamicParamDataV8 &p_other);
    DynamicParamDataV8 &operator=(const DynamicParamDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV8 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV8 lowPass;
    DynamicParamDataV8 pan3D;
    DynamicParamDataV8 spread3D;
    DynamicParamDataV8 volumeA;
    DynamicParamDataV8 volumeB;

public:
    AttenuationDataV8();
    AttenuationDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV8(const AttenuationDataV8 &p_other);
    AttenuationDataV8 &operator=(const AttenuationDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV8 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    float reverbDirect;
    float reverbRoom;
    dword flags;

public:
    CategoryDynamicDataV8();
    CategoryDynamicDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV8(const CategoryDynamicDataV8 &p_other);
    CategoryDynamicDataV8 &operator=(const CategoryDynamicDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV8 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV8> attenuation;
    helpers::Ptr<CategoryDynamicDataV8> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV8();
    CategoryDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV8(const CategoryDataV8 &p_other);
    CategoryDataV8 &operator=(const CategoryDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReverbDataV8 {
    qword name;
    dword flags;
    float room;
    float roomHF;
    float roomLF;
    float decayTime;
    float decayHFRatio;
    float reflections;
    float reflectionsDelay;
    float reverb;
    float reverbDelay;
    float referenceHF;
    float referenceLF;
    float diffusion;
    float density;

public:
    ReverbDataV8();
    ReverbDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReverbDataV8(const ReverbDataV8 &p_other);
    ReverbDataV8 &operator=(const ReverbDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV8 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV8> buss;
    helpers::Array<CategoryDynamicDataV8> category;

public:
    SnapshotDataV8();
    SnapshotDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV8(const SnapshotDataV8 &p_other);
    SnapshotDataV8 &operator=(const SnapshotDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV8 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV8> buss;
    helpers::Array<CategoryDataV8> category;
    helpers::Array<ReverbDataV8> reverb;
    helpers::Array<SnapshotDataV8> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV8();
    AudioSettingsDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV8(const AudioSettingsDataV8 &p_other);
    AudioSettingsDataV8 &operator=(const AudioSettingsDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV8 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV8();
    HandlerDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV8(const HandlerDataV8 &p_other);
    HandlerDataV8 &operator=(const HandlerDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV8 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV8();
    FileNameDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV8(const FileNameDataV8 &p_other);
    FileNameDataV8 &operator=(const FileNameDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV8 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV8> dsp;
    helpers::Ptr<AttenuationDataV8> attenuation;
    helpers::Array<FileNameDataV8> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV8 depth;
    DynamicParamDataV8 pan;
    DynamicParamDataV8 pitch;
    DynamicParamDataV8 pitchMS;
    DynamicParamDataV8 volume;
    DynamicParamDataV8 volumeMS;
    RangeDataV8 initialDelay;
    RangeDataV8 playLength;
    RangeDataV8 positionOffsetAngle;
    RangeDataV8 positionRange;
    RangeDataV8 repeatCount;
    RangeDataV8 repeatTime;
    RangeDataV8 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte musicPriority;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV8();
    MetaSoundDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV8(const MetaSoundDataV8 &p_other);
    MetaSoundDataV8 &operator=(const MetaSoundDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV8 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV8();
    ScriptRefDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV8(const ScriptRefDataV8 &p_other);
    ScriptRefDataV8 &operator=(const ScriptRefDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV8 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV8();
    TriggerMarkerDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV8(const TriggerMarkerDataV8 &p_other);
    TriggerMarkerDataV8 &operator=(const TriggerMarkerDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV8 {
    qword name;
    helpers::Array<TriggerMarkerDataV8> triggerMarker;

public:
    TriggerKeyDataV8();
    TriggerKeyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV8(const TriggerKeyDataV8 &p_other);
    TriggerKeyDataV8 &operator=(const TriggerKeyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV8 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV8> audioSettings;
    helpers::Array<HandlerDataV8> handler;
    helpers::Array<MetaSoundDataV8> metaSound;
    helpers::Array<ScriptRefDataV8> scriptRef;
    helpers::Array<TriggerKeyDataV8> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV8();
    ScriptFileDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV8(const ScriptFileDataV8 &p_other);
    ScriptFileDataV8 &operator=(const ScriptFileDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x40F845A000000001 */

template <>
struct Gw2StructAMSP<7>{
struct DspDataV7 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV7();
    DspDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV7(const DspDataV7 &p_other);
    DspDataV7 &operator=(const DspDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV7 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV7> dsp;

public:
    BussDynamicDataV7();
    BussDynamicDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV7(const BussDynamicDataV7 &p_other);
    BussDynamicDataV7 &operator=(const BussDynamicDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV7 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV7> dynamicData;

public:
    BussDataV7();
    BussDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV7(const BussDataV7 &p_other);
    BussDataV7 &operator=(const BussDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV7 {
    float offset;
    float value;

public:
    EnvelopePointDataV7();
    EnvelopePointDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV7(const EnvelopePointDataV7 &p_other);
    EnvelopePointDataV7 &operator=(const EnvelopePointDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV7 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV7> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV7();
    EnvelopeDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV7(const EnvelopeDataV7 &p_other);
    EnvelopeDataV7 &operator=(const EnvelopeDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV7 {
    float max;
    float min;
    byte min;

public:
    RangeDataV7();
    RangeDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV7(const RangeDataV7 &p_other);
    RangeDataV7 &operator=(const RangeDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV7 {
    RangeDataV7 time;
    RangeDataV7 value;

public:
    RandomParamDataV7();
    RandomParamDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV7(const RandomParamDataV7 &p_other);
    RandomParamDataV7 &operator=(const RandomParamDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV7 {
    helpers::Ptr<EnvelopeDataV7> envelopeData;
    helpers::Ptr<RandomParamDataV7> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV7();
    DynamicParamDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV7(const DynamicParamDataV7 &p_other);
    DynamicParamDataV7 &operator=(const DynamicParamDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV7 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV7 lowPass;
    DynamicParamDataV7 pan3D;
    DynamicParamDataV7 spread3D;
    DynamicParamDataV7 volumeA;
    DynamicParamDataV7 volumeB;

public:
    AttenuationDataV7();
    AttenuationDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV7(const AttenuationDataV7 &p_other);
    AttenuationDataV7 &operator=(const AttenuationDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDynamicDataV7 {
    qword name;
    float volume;
    float nonFocusGain;
    float lowPass;
    dword flags;

public:
    CategoryDynamicDataV7();
    CategoryDynamicDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDynamicDataV7(const CategoryDynamicDataV7 &p_other);
    CategoryDynamicDataV7 &operator=(const CategoryDynamicDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV7 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV7> attenuation;
    helpers::Ptr<CategoryDynamicDataV7> dynamicData;
    float muteFadeTime;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV7();
    CategoryDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV7(const CategoryDataV7 &p_other);
    CategoryDataV7 &operator=(const CategoryDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV7 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV7> buss;
    helpers::Array<CategoryDynamicDataV7> category;

public:
    SnapshotDataV7();
    SnapshotDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV7(const SnapshotDataV7 &p_other);
    SnapshotDataV7 &operator=(const SnapshotDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV7 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    float focusTransition;
    helpers::Array<BussDataV7> buss;
    helpers::Array<CategoryDataV7> category;
    helpers::Array<SnapshotDataV7> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV7();
    AudioSettingsDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV7(const AudioSettingsDataV7 &p_other);
    AudioSettingsDataV7 &operator=(const AudioSettingsDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV7 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV7();
    HandlerDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV7(const HandlerDataV7 &p_other);
    HandlerDataV7 &operator=(const HandlerDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV7 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV7();
    FileNameDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV7(const FileNameDataV7 &p_other);
    FileNameDataV7 &operator=(const FileNameDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV7 {
    qword category;
    qword endCue;
    qword name;
    qword offsetBone;
    qword playlistId;
    helpers::Array<DspDataV7> dsp;
    helpers::Ptr<AttenuationDataV7> attenuation;
    helpers::Array<FileNameDataV7> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV7 depth;
    DynamicParamDataV7 pan;
    DynamicParamDataV7 pitch;
    DynamicParamDataV7 pitchMS;
    DynamicParamDataV7 volume;
    DynamicParamDataV7 volumeMS;
    RangeDataV7 initialDelay;
    RangeDataV7 playLength;
    RangeDataV7 positionOffsetAngle;
    RangeDataV7 positionRange;
    RangeDataV7 repeatCount;
    RangeDataV7 repeatTime;
    RangeDataV7 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV7();
    MetaSoundDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV7(const MetaSoundDataV7 &p_other);
    MetaSoundDataV7 &operator=(const MetaSoundDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV7 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV7();
    ScriptRefDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV7(const ScriptRefDataV7 &p_other);
    ScriptRefDataV7 &operator=(const ScriptRefDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV7 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV7();
    TriggerMarkerDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV7(const TriggerMarkerDataV7 &p_other);
    TriggerMarkerDataV7 &operator=(const TriggerMarkerDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV7 {
    qword name;
    helpers::Array<TriggerMarkerDataV7> triggerMarker;

public:
    TriggerKeyDataV7();
    TriggerKeyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV7(const TriggerKeyDataV7 &p_other);
    TriggerKeyDataV7 &operator=(const TriggerKeyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV7 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV7> audioSettings;
    helpers::Array<HandlerDataV7> handler;
    helpers::Array<MetaSoundDataV7> metaSound;
    helpers::Array<ScriptRefDataV7> scriptRef;
    helpers::Array<TriggerKeyDataV7> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV7();
    ScriptFileDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV7(const ScriptFileDataV7 &p_other);
    ScriptFileDataV7 &operator=(const ScriptFileDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<6>{
struct DspDataV6 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV6();
    DspDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV6(const DspDataV6 &p_other);
    DspDataV6 &operator=(const DspDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDynamicDataV6 {
    qword name;
    dword flags;
    float volume;
    helpers::Array<DspDataV6> dsp;

public:
    BussDynamicDataV6();
    BussDynamicDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDynamicDataV6(const BussDynamicDataV6 &p_other);
    BussDynamicDataV6 &operator=(const BussDynamicDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV6 {
    qword name;
    dword flags;
    qword output;
    helpers::Ptr<BussDynamicDataV6> dynamicData;

public:
    BussDataV6();
    BussDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV6(const BussDataV6 &p_other);
    BussDataV6 &operator=(const BussDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV6 {
    float offset;
    float value;

public:
    EnvelopePointDataV6();
    EnvelopePointDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV6(const EnvelopePointDataV6 &p_other);
    EnvelopePointDataV6 &operator=(const EnvelopePointDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV6 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV6> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV6();
    EnvelopeDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV6(const EnvelopeDataV6 &p_other);
    EnvelopeDataV6 &operator=(const EnvelopeDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV6 {
    float max;
    float min;
    byte min;

public:
    RangeDataV6();
    RangeDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV6(const RangeDataV6 &p_other);
    RangeDataV6 &operator=(const RangeDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV6 {
    RangeDataV6 time;
    RangeDataV6 value;

public:
    RandomParamDataV6();
    RandomParamDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV6(const RandomParamDataV6 &p_other);
    RandomParamDataV6 &operator=(const RandomParamDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV6 {
    helpers::Ptr<EnvelopeDataV6> envelopeData;
    helpers::Ptr<RandomParamDataV6> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV6();
    DynamicParamDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV6(const DynamicParamDataV6 &p_other);
    DynamicParamDataV6 &operator=(const DynamicParamDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV6 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV6 lowPass;
    DynamicParamDataV6 pan3D;
    DynamicParamDataV6 spread3D;
    DynamicParamDataV6 volumeA;

public:
    AttenuationDataV6();
    AttenuationDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV6(const AttenuationDataV6 &p_other);
    AttenuationDataV6 &operator=(const AttenuationDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV6 {
    qword name;
    qword volumeGroupName;
    qword outputBussName;
    helpers::Ptr<AttenuationDataV6> attenuation;
    float muteFadeTime;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV6();
    CategoryDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV6(const CategoryDataV6 &p_other);
    CategoryDataV6 &operator=(const CategoryDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV6 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDynamicDataV6> buss;

public:
    SnapshotDataV6();
    SnapshotDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV6(const SnapshotDataV6 &p_other);
    SnapshotDataV6 &operator=(const SnapshotDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV6 {
    qword defaultSnapshot;
    qword effectsBuss;
    float distanceScale;
    helpers::Array<BussDataV6> buss;
    helpers::Array<CategoryDataV6> category;
    helpers::Array<SnapshotDataV6> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV6();
    AudioSettingsDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV6(const AudioSettingsDataV6 &p_other);
    AudioSettingsDataV6 &operator=(const AudioSettingsDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV6 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV6();
    HandlerDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV6(const HandlerDataV6 &p_other);
    HandlerDataV6 &operator=(const HandlerDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV6 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV6();
    FileNameDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV6(const FileNameDataV6 &p_other);
    FileNameDataV6 &operator=(const FileNameDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV6 {
    qword category;
    qword endCue;
    qword name;
    qword playlistId;
    helpers::Array<DspDataV6> dsp;
    helpers::Ptr<AttenuationDataV6> attenuation;
    helpers::Array<FileNameDataV6> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV6 depth;
    DynamicParamDataV6 pan;
    DynamicParamDataV6 pitch;
    DynamicParamDataV6 pitchMS;
    DynamicParamDataV6 volume;
    DynamicParamDataV6 volumeMS;
    RangeDataV6 initialDelay;
    RangeDataV6 playLength;
    RangeDataV6 positionOffsetAngle;
    RangeDataV6 positionRange;
    RangeDataV6 repeatCount;
    RangeDataV6 repeatTime;
    RangeDataV6 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV6();
    MetaSoundDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV6(const MetaSoundDataV6 &p_other);
    MetaSoundDataV6 &operator=(const MetaSoundDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV6 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV6();
    ScriptRefDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV6(const ScriptRefDataV6 &p_other);
    ScriptRefDataV6 &operator=(const ScriptRefDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV6 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV6();
    TriggerMarkerDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV6(const TriggerMarkerDataV6 &p_other);
    TriggerMarkerDataV6 &operator=(const TriggerMarkerDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV6 {
    qword name;
    helpers::Array<TriggerMarkerDataV6> triggerMarker;

public:
    TriggerKeyDataV6();
    TriggerKeyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV6(const TriggerKeyDataV6 &p_other);
    TriggerKeyDataV6 &operator=(const TriggerKeyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV6 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV6> audioSettings;
    helpers::Array<HandlerDataV6> handler;
    helpers::Array<MetaSoundDataV6> metaSound;
    helpers::Array<ScriptRefDataV6> scriptRef;
    helpers::Array<TriggerKeyDataV6> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV6();
    ScriptFileDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV6(const ScriptFileDataV6 &p_other);
    ScriptFileDataV6 &operator=(const ScriptFileDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<5>{
struct EnvelopePointDataV5 {
    float offset;
    float value;

public:
    EnvelopePointDataV5();
    EnvelopePointDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV5(const EnvelopePointDataV5 &p_other);
    EnvelopePointDataV5 &operator=(const EnvelopePointDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV5 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV5> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV5();
    EnvelopeDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV5(const EnvelopeDataV5 &p_other);
    EnvelopeDataV5 &operator=(const EnvelopeDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV5 {
    float max;
    float min;
    byte min;

public:
    RangeDataV5();
    RangeDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV5(const RangeDataV5 &p_other);
    RangeDataV5 &operator=(const RangeDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV5 {
    RangeDataV5 time;
    RangeDataV5 value;

public:
    RandomParamDataV5();
    RandomParamDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV5(const RandomParamDataV5 &p_other);
    RandomParamDataV5 &operator=(const RandomParamDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV5 {
    helpers::Ptr<EnvelopeDataV5> envelopeData;
    helpers::Ptr<RandomParamDataV5> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV5();
    DynamicParamDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV5(const DynamicParamDataV5 &p_other);
    DynamicParamDataV5 &operator=(const DynamicParamDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV5 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV5 lowPass;
    DynamicParamDataV5 pan3D;
    DynamicParamDataV5 spread3D;
    DynamicParamDataV5 volumeA;

public:
    AttenuationDataV5();
    AttenuationDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV5(const AttenuationDataV5 &p_other);
    AttenuationDataV5 &operator=(const AttenuationDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV5 {
    qword name;
    qword volumeGroupName;
    helpers::Ptr<AttenuationDataV5> attenuation;
    float muteFadeTime;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV5();
    CategoryDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV5(const CategoryDataV5 &p_other);
    CategoryDataV5 &operator=(const CategoryDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV5 {
    dword type;
    dword flags;
    helpers::Array<float> property;

public:
    DspDataV5();
    DspDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV5(const DspDataV5 &p_other);
    DspDataV5 &operator=(const DspDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BussDataV5 {
    qword name;
    qword output;
    dword flags;
    helpers::Array<DspDataV5> dsp;
    float volume;

public:
    BussDataV5();
    BussDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BussDataV5(const BussDataV5 &p_other);
    BussDataV5 &operator=(const BussDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SnapshotDataV5 {
    qword name;
    float blendInTime;
    float blendOutTime;
    dword flags;
    helpers::Array<BussDataV5> buss;

public:
    SnapshotDataV5();
    SnapshotDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SnapshotDataV5(const SnapshotDataV5 &p_other);
    SnapshotDataV5 &operator=(const SnapshotDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV5 {
    qword defaultBuss;
    qword effectsBuss;
    float distanceScale;
    helpers::Array<CategoryDataV5> category;
    helpers::Array<SnapshotDataV5> snapshot;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV5();
    AudioSettingsDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV5(const AudioSettingsDataV5 &p_other);
    AudioSettingsDataV5 &operator=(const AudioSettingsDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV5 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV5();
    HandlerDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV5(const HandlerDataV5 &p_other);
    HandlerDataV5 &operator=(const HandlerDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV5 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV5();
    FileNameDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV5(const FileNameDataV5 &p_other);
    FileNameDataV5 &operator=(const FileNameDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV5 {
    qword category;
    qword endCue;
    qword name;
    qword playlistId;
    helpers::Array<DspDataV5> dsp;
    helpers::Ptr<AttenuationDataV5> attenuation;
    helpers::Array<FileNameDataV5> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV5 depth;
    DynamicParamDataV5 pan;
    DynamicParamDataV5 pitch;
    DynamicParamDataV5 pitchMS;
    DynamicParamDataV5 volume;
    DynamicParamDataV5 volumeMS;
    RangeDataV5 initialDelay;
    RangeDataV5 playLength;
    RangeDataV5 positionOffsetAngle;
    RangeDataV5 positionRange;
    RangeDataV5 repeatCount;
    RangeDataV5 repeatTime;
    RangeDataV5 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV5();
    MetaSoundDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV5(const MetaSoundDataV5 &p_other);
    MetaSoundDataV5 &operator=(const MetaSoundDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV5 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV5();
    ScriptRefDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV5(const ScriptRefDataV5 &p_other);
    ScriptRefDataV5 &operator=(const ScriptRefDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV5 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV5();
    TriggerMarkerDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV5(const TriggerMarkerDataV5 &p_other);
    TriggerMarkerDataV5 &operator=(const TriggerMarkerDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV5 {
    qword name;
    helpers::Array<TriggerMarkerDataV5> triggerMarker;

public:
    TriggerKeyDataV5();
    TriggerKeyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV5(const TriggerKeyDataV5 &p_other);
    TriggerKeyDataV5 &operator=(const TriggerKeyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV5 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV5> audioSettings;
    helpers::Array<HandlerDataV5> handler;
    helpers::Array<MetaSoundDataV5> metaSound;
    helpers::Array<ScriptRefDataV5> scriptRef;
    helpers::Array<TriggerKeyDataV5> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV5();
    ScriptFileDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV5(const ScriptFileDataV5 &p_other);
    ScriptFileDataV5 &operator=(const ScriptFileDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<4>{
struct VolumeGroupDataV4 {
    qword name;
    qword parentName;
    dword flags;
    float volume;

public:
    VolumeGroupDataV4();
    VolumeGroupDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    VolumeGroupDataV4(const VolumeGroupDataV4 &p_other);
    VolumeGroupDataV4 &operator=(const VolumeGroupDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV4 {
    float offset;
    float value;

public:
    EnvelopePointDataV4();
    EnvelopePointDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV4(const EnvelopePointDataV4 &p_other);
    EnvelopePointDataV4 &operator=(const EnvelopePointDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV4 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV4> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV4();
    EnvelopeDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV4(const EnvelopeDataV4 &p_other);
    EnvelopeDataV4 &operator=(const EnvelopeDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV4 {
    float max;
    float min;
    byte min;

public:
    RangeDataV4();
    RangeDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV4(const RangeDataV4 &p_other);
    RangeDataV4 &operator=(const RangeDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV4 {
    RangeDataV4 time;
    RangeDataV4 value;

public:
    RandomParamDataV4();
    RandomParamDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV4(const RandomParamDataV4 &p_other);
    RandomParamDataV4 &operator=(const RandomParamDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV4 {
    helpers::Ptr<EnvelopeDataV4> envelopeData;
    helpers::Ptr<RandomParamDataV4> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV4();
    DynamicParamDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV4(const DynamicParamDataV4 &p_other);
    DynamicParamDataV4 &operator=(const DynamicParamDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV4 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV4 lowPass;
    DynamicParamDataV4 pan3D;
    DynamicParamDataV4 spread3D;
    DynamicParamDataV4 volumeA;

public:
    AttenuationDataV4();
    AttenuationDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV4(const AttenuationDataV4 &p_other);
    AttenuationDataV4 &operator=(const AttenuationDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV4 {
    qword name;
    qword volumeGroupName;
    helpers::Ptr<AttenuationDataV4> attenuation;
    float muteFadeTime;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV4();
    CategoryDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV4(const CategoryDataV4 &p_other);
    CategoryDataV4 &operator=(const CategoryDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV4 {
    helpers::Array<VolumeGroupDataV4> volumeGroup;
    helpers::Array<CategoryDataV4> category;
    float distanceScale;
    helpers::FileName bankIndexFileName;
    helpers::FileName bankScriptFileName;

public:
    AudioSettingsDataV4();
    AudioSettingsDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV4(const AudioSettingsDataV4 &p_other);
    AudioSettingsDataV4 &operator=(const AudioSettingsDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV4 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV4();
    HandlerDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV4(const HandlerDataV4 &p_other);
    HandlerDataV4 &operator=(const HandlerDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV4 {
    helpers::Array<DynamicParamDataV4> param;
    byte type;

public:
    DspDataV4();
    DspDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV4(const DspDataV4 &p_other);
    DspDataV4 &operator=(const DspDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV4 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV4();
    FileNameDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV4(const FileNameDataV4 &p_other);
    FileNameDataV4 &operator=(const FileNameDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV4 {
    qword category;
    qword endCue;
    qword name;
    qword playlistId;
    helpers::Array<DspDataV4> dsp;
    helpers::Ptr<AttenuationDataV4> attenuation;
    helpers::Array<FileNameDataV4> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV4 depth;
    DynamicParamDataV4 pan;
    DynamicParamDataV4 pitch;
    DynamicParamDataV4 pitchMS;
    DynamicParamDataV4 volume;
    DynamicParamDataV4 volumeMS;
    RangeDataV4 initialDelay;
    RangeDataV4 playLength;
    RangeDataV4 positionOffsetAngle;
    RangeDataV4 positionRange;
    RangeDataV4 repeatCount;
    RangeDataV4 repeatTime;
    RangeDataV4 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV4();
    MetaSoundDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV4(const MetaSoundDataV4 &p_other);
    MetaSoundDataV4 &operator=(const MetaSoundDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV4 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV4();
    ScriptRefDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV4(const ScriptRefDataV4 &p_other);
    ScriptRefDataV4 &operator=(const ScriptRefDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV4 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV4();
    TriggerMarkerDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV4(const TriggerMarkerDataV4 &p_other);
    TriggerMarkerDataV4 &operator=(const TriggerMarkerDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV4 {
    qword name;
    helpers::Array<TriggerMarkerDataV4> triggerMarker;

public:
    TriggerKeyDataV4();
    TriggerKeyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV4(const TriggerKeyDataV4 &p_other);
    TriggerKeyDataV4 &operator=(const TriggerKeyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV4 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV4> audioSettings;
    helpers::Array<HandlerDataV4> handler;
    helpers::Array<MetaSoundDataV4> metaSound;
    helpers::Array<ScriptRefDataV4> scriptRef;
    helpers::Array<TriggerKeyDataV4> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV4();
    ScriptFileDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV4(const ScriptFileDataV4 &p_other);
    ScriptFileDataV4 &operator=(const ScriptFileDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<3>{
struct VolumeGroupDataV3 {
    qword name;
    qword parentName;
    dword flags;
    float volume;

public:
    VolumeGroupDataV3();
    VolumeGroupDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    VolumeGroupDataV3(const VolumeGroupDataV3 &p_other);
    VolumeGroupDataV3 &operator=(const VolumeGroupDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV3 {
    float offset;
    float value;

public:
    EnvelopePointDataV3();
    EnvelopePointDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV3(const EnvelopePointDataV3 &p_other);
    EnvelopePointDataV3 &operator=(const EnvelopePointDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV3 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV3> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV3();
    EnvelopeDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV3(const EnvelopeDataV3 &p_other);
    EnvelopeDataV3 &operator=(const EnvelopeDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV3 {
    float max;
    float min;
    byte min;

public:
    RangeDataV3();
    RangeDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV3(const RangeDataV3 &p_other);
    RangeDataV3 &operator=(const RangeDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV3 {
    RangeDataV3 time;
    RangeDataV3 value;

public:
    RandomParamDataV3();
    RandomParamDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV3(const RandomParamDataV3 &p_other);
    RandomParamDataV3 &operator=(const RandomParamDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV3 {
    helpers::Ptr<EnvelopeDataV3> envelopeData;
    helpers::Ptr<RandomParamDataV3> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV3();
    DynamicParamDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV3(const DynamicParamDataV3 &p_other);
    DynamicParamDataV3 &operator=(const DynamicParamDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV3 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV3 lowPass;
    DynamicParamDataV3 pan3D;
    DynamicParamDataV3 spread3D;
    DynamicParamDataV3 volumeA;

public:
    AttenuationDataV3();
    AttenuationDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV3(const AttenuationDataV3 &p_other);
    AttenuationDataV3 &operator=(const AttenuationDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV3 {
    qword name;
    qword volumeGroupName;
    helpers::Ptr<AttenuationDataV3> attenuation;
    float muteFadeTime;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV3();
    CategoryDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV3(const CategoryDataV3 &p_other);
    CategoryDataV3 &operator=(const CategoryDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV3 {
    helpers::Array<VolumeGroupDataV3> volumeGroup;
    helpers::Array<CategoryDataV3> category;
    float distanceScale;
    helpers::FileName voiceBankFileName;

public:
    AudioSettingsDataV3();
    AudioSettingsDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV3(const AudioSettingsDataV3 &p_other);
    AudioSettingsDataV3 &operator=(const AudioSettingsDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV3 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV3();
    HandlerDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV3(const HandlerDataV3 &p_other);
    HandlerDataV3 &operator=(const HandlerDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV3 {
    helpers::Array<DynamicParamDataV3> param;
    byte type;

public:
    DspDataV3();
    DspDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV3(const DspDataV3 &p_other);
    DspDataV3 &operator=(const DspDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV3 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV3();
    FileNameDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV3(const FileNameDataV3 &p_other);
    FileNameDataV3 &operator=(const FileNameDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV3 {
    qword category;
    qword endCue;
    qword name;
    qword playlistId;
    helpers::Array<DspDataV3> dsp;
    helpers::Ptr<AttenuationDataV3> attenuation;
    helpers::Array<FileNameDataV3> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV3 depth;
    DynamicParamDataV3 pan;
    DynamicParamDataV3 pitch;
    DynamicParamDataV3 pitchMS;
    DynamicParamDataV3 volume;
    DynamicParamDataV3 volumeMS;
    RangeDataV3 initialDelay;
    RangeDataV3 playLength;
    RangeDataV3 positionOffsetAngle;
    RangeDataV3 positionRange;
    RangeDataV3 repeatCount;
    RangeDataV3 repeatTime;
    RangeDataV3 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV3();
    MetaSoundDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV3(const MetaSoundDataV3 &p_other);
    MetaSoundDataV3 &operator=(const MetaSoundDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV3 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV3();
    ScriptRefDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV3(const ScriptRefDataV3 &p_other);
    ScriptRefDataV3 &operator=(const ScriptRefDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV3 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV3();
    TriggerMarkerDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV3(const TriggerMarkerDataV3 &p_other);
    TriggerMarkerDataV3 &operator=(const TriggerMarkerDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV3 {
    qword name;
    helpers::Array<TriggerMarkerDataV3> triggerMarker;

public:
    TriggerKeyDataV3();
    TriggerKeyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV3(const TriggerKeyDataV3 &p_other);
    TriggerKeyDataV3 &operator=(const TriggerKeyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV3 {
    qword musicCue;
    qword endCue;
    helpers::Ptr<AudioSettingsDataV3> audioSettings;
    helpers::Array<HandlerDataV3> handler;
    helpers::Array<MetaSoundDataV3> metaSound;
    helpers::Array<ScriptRefDataV3> scriptRef;
    helpers::Array<TriggerKeyDataV3> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV3();
    ScriptFileDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV3(const ScriptFileDataV3 &p_other);
    ScriptFileDataV3 &operator=(const ScriptFileDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<2>{
struct VolumeGroupDataV2 {
    qword name;
    qword parentName;
    dword flags;
    float volume;

public:
    VolumeGroupDataV2();
    VolumeGroupDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    VolumeGroupDataV2(const VolumeGroupDataV2 &p_other);
    VolumeGroupDataV2 &operator=(const VolumeGroupDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV2 {
    float offset;
    float value;

public:
    EnvelopePointDataV2();
    EnvelopePointDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV2(const EnvelopePointDataV2 &p_other);
    EnvelopePointDataV2 &operator=(const EnvelopePointDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV2 {
    qword offsetParameter;
    helpers::Array<EnvelopePointDataV2> envelopePoint;
    byte offsetType;

public:
    EnvelopeDataV2();
    EnvelopeDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV2(const EnvelopeDataV2 &p_other);
    EnvelopeDataV2 &operator=(const EnvelopeDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV2 {
    float max;
    float min;
    byte min;

public:
    RangeDataV2();
    RangeDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV2(const RangeDataV2 &p_other);
    RangeDataV2 &operator=(const RangeDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV2 {
    RangeDataV2 time;
    RangeDataV2 value;

public:
    RandomParamDataV2();
    RandomParamDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV2(const RandomParamDataV2 &p_other);
    RandomParamDataV2 &operator=(const RandomParamDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV2 {
    helpers::Ptr<EnvelopeDataV2> envelopeData;
    helpers::Ptr<RandomParamDataV2> randomParamData;
    float value;
    byte type;

public:
    DynamicParamDataV2();
    DynamicParamDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV2(const DynamicParamDataV2 &p_other);
    DynamicParamDataV2 &operator=(const DynamicParamDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV2 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV2 lowPass;
    DynamicParamDataV2 pan3D;
    DynamicParamDataV2 spread3D;
    DynamicParamDataV2 volumeA;

public:
    AttenuationDataV2();
    AttenuationDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV2(const AttenuationDataV2 &p_other);
    AttenuationDataV2 &operator=(const AttenuationDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV2 {
    qword name;
    qword volumeGroupName;
    helpers::Ptr<AttenuationDataV2> attenuation;
    float muteFadeTime;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;

public:
    CategoryDataV2();
    CategoryDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV2(const CategoryDataV2 &p_other);
    CategoryDataV2 &operator=(const CategoryDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV2 {
    helpers::Array<VolumeGroupDataV2> volumeGroup;
    helpers::Array<CategoryDataV2> category;
    float distanceScale;
    helpers::FileName voiceBankFileName;

public:
    AudioSettingsDataV2();
    AudioSettingsDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV2(const AudioSettingsDataV2 &p_other);
    AudioSettingsDataV2 &operator=(const AudioSettingsDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV2 {
    qword name;
    dword flags;
    helpers::Array<byte> byteCode;

public:
    HandlerDataV2();
    HandlerDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV2(const HandlerDataV2 &p_other);
    HandlerDataV2 &operator=(const HandlerDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV2 {
    helpers::Array<DynamicParamDataV2> param;
    byte type;

public:
    DspDataV2();
    DspDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV2(const DspDataV2 &p_other);
    DspDataV2 &operator=(const DspDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV2 {
    qword language;
    float weight;
    helpers::FileName fileName;
    byte audioType;

public:
    FileNameDataV2();
    FileNameDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV2(const FileNameDataV2 &p_other);
    FileNameDataV2 &operator=(const FileNameDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV2 {
    qword category;
    qword endCue;
    qword name;
    qword playlistId;
    helpers::Array<DspDataV2> dsp;
    helpers::Ptr<AttenuationDataV2> attenuation;
    helpers::Array<FileNameDataV2> fileName;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    float3 positionOffset;
    dword flags;
    dword loopCount;
    DynamicParamDataV2 depth;
    DynamicParamDataV2 pan;
    DynamicParamDataV2 pitch;
    DynamicParamDataV2 pitchMS;
    DynamicParamDataV2 volume;
    DynamicParamDataV2 volumeMS;
    RangeDataV2 initialDelay;
    RangeDataV2 playLength;
    RangeDataV2 positionOffsetAngle;
    RangeDataV2 positionRange;
    RangeDataV2 repeatCount;
    RangeDataV2 repeatTime;
    RangeDataV2 startTimeOffset;
    byte channelMode;
    byte channelPriority;
    byte fileIterateMode;
    byte loopMode;
    byte playbackMode;
    byte positionMode;
    byte repeatTimeFrom;

public:
    MetaSoundDataV2();
    MetaSoundDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV2(const MetaSoundDataV2 &p_other);
    MetaSoundDataV2 &operator=(const MetaSoundDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV2 {
    qword name;
    helpers::FileName fileName;

public:
    ScriptRefDataV2();
    ScriptRefDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV2(const ScriptRefDataV2 &p_other);
    ScriptRefDataV2 &operator=(const ScriptRefDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV2 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV2();
    TriggerMarkerDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV2(const TriggerMarkerDataV2 &p_other);
    TriggerMarkerDataV2 &operator=(const TriggerMarkerDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV2 {
    qword name;
    helpers::Array<TriggerMarkerDataV2> triggerMarker;

public:
    TriggerKeyDataV2();
    TriggerKeyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV2(const TriggerKeyDataV2 &p_other);
    TriggerKeyDataV2 &operator=(const TriggerKeyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV2 {
    qword musicCue;
    helpers::Ptr<AudioSettingsDataV2> audioSettings;
    helpers::Array<HandlerDataV2> handler;
    helpers::Array<MetaSoundDataV2> metaSound;
    helpers::Array<ScriptRefDataV2> scriptRef;
    helpers::Array<TriggerKeyDataV2> triggerKey;
    dword flags;
    float fadeInTime;
    float volume;

public:
    ScriptFileDataV2();
    ScriptFileDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV2(const ScriptFileDataV2 &p_other);
    ScriptFileDataV2 &operator=(const ScriptFileDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<1>{
struct EnvelopePointDataV1 {
    float offset;
    float value;

public:
    EnvelopePointDataV1();
    EnvelopePointDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV1(const EnvelopePointDataV1 &p_other);
    EnvelopePointDataV1 &operator=(const EnvelopePointDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV1 {
    helpers::Array<EnvelopePointDataV1> envelopePoint;
    byte offsetType;
    qword offsetParameter;

public:
    EnvelopeDataV1();
    EnvelopeDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV1(const EnvelopeDataV1 &p_other);
    EnvelopeDataV1 &operator=(const EnvelopeDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV1 {
    float max;
    float min;
    byte min;

public:
    RangeDataV1();
    RangeDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV1(const RangeDataV1 &p_other);
    RangeDataV1 &operator=(const RangeDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV1 {
    RangeDataV1 time;
    RangeDataV1 value;

public:
    RandomParamDataV1();
    RandomParamDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV1(const RandomParamDataV1 &p_other);
    RandomParamDataV1 &operator=(const RandomParamDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV1 {
    helpers::Ptr<EnvelopeDataV1> envelopeData;
    helpers::Ptr<RandomParamDataV1> randomParamData;
    byte type;
    float value;

public:
    DynamicParamDataV1();
    DynamicParamDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV1(const DynamicParamDataV1 &p_other);
    DynamicParamDataV1 &operator=(const DynamicParamDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV1 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV1 lowPass;
    DynamicParamDataV1 pan3D;
    DynamicParamDataV1 spread3D;
    DynamicParamDataV1 volumeA;

public:
    AttenuationDataV1();
    AttenuationDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV1(const AttenuationDataV1 &p_other);
    AttenuationDataV1 &operator=(const AttenuationDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CategoryDataV1 {
    helpers::Ptr<AttenuationDataV1> attenuation;
    dword flags;
    dword maxAudible;
    byte maxAudibleBehavior;
    float muteFadeTime;
    qword name;
    float volumeA;
    float volumeAThreshold;
    float volumeB;
    float volumeBThreshold;
    float volumeChangeRate;
    float volumeDucking;
    float volumeDuckingTimeAttack;
    float volumeDuckingTimeRelease;
    qword volumeGroupName;

public:
    CategoryDataV1();
    CategoryDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CategoryDataV1(const CategoryDataV1 &p_other);
    CategoryDataV1 &operator=(const CategoryDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct VolumeGroupDataV1 {
    dword flags;
    qword name;
    qword parentName;
    float volume;

public:
    VolumeGroupDataV1();
    VolumeGroupDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    VolumeGroupDataV1(const VolumeGroupDataV1 &p_other);
    VolumeGroupDataV1 &operator=(const VolumeGroupDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AudioSettingsDataV1 {
    helpers::Array<CategoryDataV1> category;
    float distanceScale;
    helpers::FileName voiceBankFileName;
    helpers::Array<VolumeGroupDataV1> volumeGroup;

public:
    AudioSettingsDataV1();
    AudioSettingsDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AudioSettingsDataV1(const AudioSettingsDataV1 &p_other);
    AudioSettingsDataV1 &operator=(const AudioSettingsDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct HandlerDataV1 {
    helpers::Array<byte> byteCode;
    dword flags;
    qword name;

public:
    HandlerDataV1();
    HandlerDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV1(const HandlerDataV1 &p_other);
    HandlerDataV1 &operator=(const HandlerDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV1 {
    helpers::Array<DynamicParamDataV1> param;
    byte type;

public:
    DspDataV1();
    DspDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV1(const DspDataV1 &p_other);
    DspDataV1 &operator=(const DspDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV1 {
    byte audioType;
    helpers::FileName fileName;
    qword language;
    float weight;

public:
    FileNameDataV1();
    FileNameDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV1(const FileNameDataV1 &p_other);
    FileNameDataV1 &operator=(const FileNameDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV1 {
    helpers::Ptr<AttenuationDataV1> attenuation;
    qword category;
    byte channelMode;
    byte channelPriority;
    DynamicParamDataV1 depth;
    helpers::Array<DspDataV1> dsp;
    qword endCue;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    byte fileIterateMode;
    helpers::Array<FileNameDataV1> fileName;
    dword flags;
    RangeDataV1 initialDelay;
    dword loopCount;
    byte loopMode;
    qword name;
    DynamicParamDataV1 pan;
    DynamicParamDataV1 pitch;
    byte playbackMode;
    RangeDataV1 playLength;
    qword playlistId;
    byte positionMode;
    float3 positionOffset;
    RangeDataV1 positionOffsetAngle;
    RangeDataV1 positionRange;
    RangeDataV1 repeatCount;
    RangeDataV1 repeatTime;
    RangeDataV1 startTimeOffset;
    byte repeatTimeFrom;
    DynamicParamDataV1 volume;

public:
    MetaSoundDataV1();
    MetaSoundDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV1(const MetaSoundDataV1 &p_other);
    MetaSoundDataV1 &operator=(const MetaSoundDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV1 {
    helpers::FileName fileName;
    qword name;

public:
    ScriptRefDataV1();
    ScriptRefDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV1(const ScriptRefDataV1 &p_other);
    ScriptRefDataV1 &operator=(const ScriptRefDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV1 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV1();
    TriggerMarkerDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV1(const TriggerMarkerDataV1 &p_other);
    TriggerMarkerDataV1 &operator=(const TriggerMarkerDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV1 {
    qword name;
    helpers::Array<TriggerMarkerDataV1> triggerMarker;

public:
    TriggerKeyDataV1();
    TriggerKeyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV1(const TriggerKeyDataV1 &p_other);
    TriggerKeyDataV1 &operator=(const TriggerKeyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV1 {
    helpers::Ptr<AudioSettingsDataV1> audioSettings;
    float fadeInTime;
    dword flags;
    helpers::Array<HandlerDataV1> handler;
    helpers::Array<MetaSoundDataV1> metaSound;
    helpers::Array<ScriptRefDataV1> scriptRef;
    helpers::Array<TriggerKeyDataV1> triggerKey;
    float volume;

public:
    ScriptFileDataV1();
    ScriptFileDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV1(const ScriptFileDataV1 &p_other);
    ScriptFileDataV1 &operator=(const ScriptFileDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructAMSP<0>{
struct HandlerDataV0 {
    helpers::Array<byte> byteCode;
    dword flags;
    qword name;

public:
    HandlerDataV0();
    HandlerDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    HandlerDataV0(const HandlerDataV0 &p_other);
    HandlerDataV0 &operator=(const HandlerDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopePointDataV0 {
    float offset;
    float value;

public:
    EnvelopePointDataV0();
    EnvelopePointDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopePointDataV0(const EnvelopePointDataV0 &p_other);
    EnvelopePointDataV0 &operator=(const EnvelopePointDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct EnvelopeDataV0 {
    helpers::Array<EnvelopePointDataV0> envelopePoint;
    byte offsetType;
    qword offsetParameter;

public:
    EnvelopeDataV0();
    EnvelopeDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    EnvelopeDataV0(const EnvelopeDataV0 &p_other);
    EnvelopeDataV0 &operator=(const EnvelopeDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RangeDataV0 {
    float max;
    float min;
    byte min;

public:
    RangeDataV0();
    RangeDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RangeDataV0(const RangeDataV0 &p_other);
    RangeDataV0 &operator=(const RangeDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct RandomParamDataV0 {
    RangeDataV0 time;
    RangeDataV0 value;

public:
    RandomParamDataV0();
    RandomParamDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    RandomParamDataV0(const RandomParamDataV0 &p_other);
    RandomParamDataV0 &operator=(const RandomParamDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DynamicParamDataV0 {
    helpers::Ptr<EnvelopeDataV0> envelopeData;
    helpers::Ptr<RandomParamDataV0> randomParamData;
    byte type;
    float value;

public:
    DynamicParamDataV0();
    DynamicParamDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DynamicParamDataV0(const DynamicParamDataV0 &p_other);
    DynamicParamDataV0 &operator=(const DynamicParamDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AttenuationDataV0 {
    float coneInsideAngle;
    float coneOutsideAngle;
    float coneOutsideVolume;
    DynamicParamDataV0 lowPass;
    DynamicParamDataV0 pan3D;
    DynamicParamDataV0 spread3D;
    DynamicParamDataV0 volumeA;

public:
    AttenuationDataV0();
    AttenuationDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AttenuationDataV0(const AttenuationDataV0 &p_other);
    AttenuationDataV0 &operator=(const AttenuationDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct DspDataV0 {
    helpers::Array<DynamicParamDataV0> param;
    byte type;

public:
    DspDataV0();
    DspDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    DspDataV0(const DspDataV0 &p_other);
    DspDataV0 &operator=(const DspDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameDataV0 {
    byte audioType;
    helpers::FileName fileName;
    qword language;
    float weight;

public:
    FileNameDataV0();
    FileNameDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameDataV0(const FileNameDataV0 &p_other);
    FileNameDataV0 &operator=(const FileNameDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MetaSoundDataV0 {
    helpers::Ptr<AttenuationDataV0> attenuation;
    qword category;
    byte channelMode;
    byte channelPriority;
    DynamicParamDataV0 depth;
    helpers::Array<DspDataV0> dsp;
    qword endCue;
    float endCueOffset;
    float fadeInTime;
    float fadeOutTime;
    byte fileIterateMode;
    helpers::Array<FileNameDataV0> fileName;
    dword flags;
    RangeDataV0 initialDelay;
    dword loopCount;
    byte loopMode;
    qword name;
    DynamicParamDataV0 pan;
    DynamicParamDataV0 pitch;
    byte playbackMode;
    RangeDataV0 playLength;
    qword playlistId;
    byte positionMode;
    float3 positionOffset;
    RangeDataV0 positionOffsetAngle;
    RangeDataV0 positionRange;
    RangeDataV0 repeatCount;
    RangeDataV0 repeatTime;
    RangeDataV0 startTimeOffset;
    byte repeatTimeFrom;
    DynamicParamDataV0 volume;

public:
    MetaSoundDataV0();
    MetaSoundDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MetaSoundDataV0(const MetaSoundDataV0 &p_other);
    MetaSoundDataV0 &operator=(const MetaSoundDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptRefDataV0 {
    helpers::FileName fileName;
    qword name;

public:
    ScriptRefDataV0();
    ScriptRefDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptRefDataV0(const ScriptRefDataV0 &p_other);
    ScriptRefDataV0 &operator=(const ScriptRefDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerMarkerDataV0 {
    qword cue;
    qword end;
    float time;
    byte type;

public:
    TriggerMarkerDataV0();
    TriggerMarkerDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerMarkerDataV0(const TriggerMarkerDataV0 &p_other);
    TriggerMarkerDataV0 &operator=(const TriggerMarkerDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV0 {
    qword name;
    helpers::Array<TriggerMarkerDataV0> triggerMarker;

public:
    TriggerKeyDataV0();
    TriggerKeyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV0(const TriggerKeyDataV0 &p_other);
    TriggerKeyDataV0 &operator=(const TriggerKeyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptFileDataV0 {
    float fadeInTime;
    dword flags;
    helpers::Array<HandlerDataV0> handler;
    helpers::Array<MetaSoundDataV0> metaSound;
    helpers::Array<ScriptRefDataV0> scriptRef;
    helpers::Array<TriggerKeyDataV0> triggerKey;
    float volume;

public:
    ScriptFileDataV0();
    ScriptFileDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptFileDataV0(const ScriptFileDataV0 &p_other);
    ScriptFileDataV0 &operator=(const ScriptFileDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ScriptFileDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: BKCK, versions: 3, strucTab: 0x141FD59A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructBKCK;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructBKCK<2>{
struct AsndFileDataV2 {
    dword voiceId;
    dword flags;
    dword reserved1;
    dword reserved2;
    dword reserved3;
    dword reserved4;
    float length;
    float offset;
    byte reserved5;
    byte reserved6;
    byte reserved7;
    byte reserved8;
    helpers::Array<byte> audioData;

public:
    AsndFileDataV2();
    AsndFileDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AsndFileDataV2(const AsndFileDataV2 &p_other);
    AsndFileDataV2 &operator=(const AsndFileDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ReservedBankDataV2 {
    dword reserved1;
    dword reserved2;
    dword reserved3;
    dword reserved4;

public:
    ReservedBankDataV2();
    ReservedBankDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReservedBankDataV2(const ReservedBankDataV2 &p_other);
    ReservedBankDataV2 &operator=(const ReservedBankDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BankFileDataV2 {
    dword reserved1;
    dword reserved2;
    dword reserved3;
    dword reserved4;
    helpers::Array<AsndFileDataV2> asndFile;
    helpers::Ptr<ReservedBankDataV2> reservedData;

public:
    BankFileDataV2();
    BankFileDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankFileDataV2(const BankFileDataV2 &p_other);
    BankFileDataV2 &operator=(const BankFileDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef BankFileDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructBKCK<1>{
struct AsndFileDataV1 {
    dword voiceId;
    dword flags;
    dword reserved1;
    dword reserved2;
    float length;
    float offset;
    helpers::Array<byte> audioData;

public:
    AsndFileDataV1();
    AsndFileDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AsndFileDataV1(const AsndFileDataV1 &p_other);
    AsndFileDataV1 &operator=(const AsndFileDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BankFileDataV1 {
    dword reserved1;
    dword reserved2;
    helpers::Array<AsndFileDataV1> asndFile;

public:
    BankFileDataV1();
    BankFileDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankFileDataV1(const BankFileDataV1 &p_other);
    BankFileDataV1 &operator=(const BankFileDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef BankFileDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructBKCK<0>{
struct AsndFileDataV0 {
    dword voiceId;
    dword flags;
    dword reserved1;
    dword reserved2;
    float length;
    float offset;
    helpers::Array<byte> audioData;

public:
    AsndFileDataV0();
    AsndFileDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AsndFileDataV0(const AsndFileDataV0 &p_other);
    AsndFileDataV0 &operator=(const AsndFileDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BankFileDataV0 {
    dword reserved1;
    dword reserved2;
    helpers::Array<AsndFileDataV0> asndFile;

public:
    BankFileDataV0();
    BankFileDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankFileDataV0(const BankFileDataV0 &p_other);
    BankFileDataV0 &operator=(const BankFileDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef BankFileDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: BIDX, versions: 1, strucTab: 0x141FD5BB0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructBIDX;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructBIDX<0>{
struct BankFileNameDataV0 {
    helpers::FileName fileName;

public:
    BankFileNameDataV0();
    BankFileNameDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankFileNameDataV0(const BankFileNameDataV0 &p_other);
    BankFileNameDataV0 &operator=(const BankFileNameDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BankLanguageDataV0 {
    helpers::Array<BankFileNameDataV0> bankFileName;

public:
    BankLanguageDataV0();
    BankLanguageDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankLanguageDataV0(const BankLanguageDataV0 &p_other);
    BankLanguageDataV0 &operator=(const BankLanguageDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct BankIndexDataV0 {
    helpers::Array<BankLanguageDataV0> bankLanguage;

public:
    BankIndexDataV0();
    BankIndexDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    BankIndexDataV0(const BankIndexDataV0 &p_other);
    BankIndexDataV0 &operator=(const BankIndexDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef BankIndexDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: ASND, versions: 3, strucTab: 0x141FD5BF0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructASND;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructASND<2>{
struct ReservedWaveformDataV2 {
    dword reserved1;
    dword reserved2;
    dword reserved3;
    dword reserved4;

public:
    ReservedWaveformDataV2();
    ReservedWaveformDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ReservedWaveformDataV2(const ReservedWaveformDataV2 &p_other);
    ReservedWaveformDataV2 &operator=(const ReservedWaveformDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct WaveformDataV2 {
    float length;
    float offset;
    helpers::Ptr<ReservedWaveformDataV2> reservedData;
    dword reserved1;
    dword reserved2;
    dword crc;
    dword numSamples;
    dword loopStart;
    dword loopEnd;
    dword flags;
    byte format;
    byte reserved3;
    byte reserved4;
    byte reserved5;
    byte numChannels;
    byte reserved6;
    byte reserved7;
    byte reserved8;
    helpers::Array<byte> audioData;
    helpers::Array<byte> otherData;

public:
    WaveformDataV2();
    WaveformDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    WaveformDataV2(const WaveformDataV2 &p_other);
    WaveformDataV2 &operator=(const WaveformDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef WaveformDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x40F84B4000000001 */

template <>
struct Gw2StructASND<1>{
struct WaveformDataV1 {
    float length;
    float offset;
    dword crc;
    dword numSamples;
    dword loopStart;
    dword loopEnd;
    dword flags;
    byte format;
    byte noteBase;
    byte noteHigh;
    byte noteLow;
    byte numChannels;
    byte reserved1;
    byte reserved2;
    byte reserved3;
    helpers::Array<byte> audioData;
    helpers::Array<byte> otherData;

public:
    WaveformDataV1();
    WaveformDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    WaveformDataV1(const WaveformDataV1 &p_other);
    WaveformDataV1 &operator=(const WaveformDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef WaveformDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructASND<0>{
struct WaveformDataV0 {
    helpers::Array<byte> data;
    dword flags;
    float length;
    byte noteBase;
    byte noteHigh;
    byte noteLow;
    byte numChannels;
    dword numSamples;
    byte waveformDataType;

public:
    WaveformDataV0();
    WaveformDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    WaveformDataV0(const WaveformDataV0 &p_other);
    WaveformDataV0 &operator=(const WaveformDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef WaveformDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: CSCN, versions: 37, strucTab: 0x141FE1160
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructCSCN;

/* Version: 36, ReferencedFunction: 0x40F9FD1000000001 */

template <>
struct Gw2StructCSCN<36>{
struct PropertyDataV36 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV36();
    PropertyDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV36(const PropertyDataV36 &p_other);
    PropertyDataV36 &operator=(const PropertyDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV36 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV36();
    CurveKeyDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV36(const CurveKeyDataV36 &p_other);
    CurveKeyDataV36 &operator=(const CurveKeyDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV36 {
    float time;
    float value;

public:
    FlagKeyDataV36();
    FlagKeyDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV36(const FlagKeyDataV36 &p_other);
    FlagKeyDataV36 &operator=(const FlagKeyDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV36 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV36();
    TriggerKeyDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV36(const TriggerKeyDataV36 &p_other);
    TriggerKeyDataV36 &operator=(const TriggerKeyDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV36 {
    qword name;
    helpers::Array<CurveKeyDataV36> curveKey;
    helpers::Array<FlagKeyDataV36> flagKey;
    helpers::Array<TriggerKeyDataV36> triggerKey;
    byte type;

public:
    TrackDataV36();
    TrackDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV36(const TrackDataV36 &p_other);
    TrackDataV36 &operator=(const TrackDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV36 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV36> prop;
    helpers::Array<TrackDataV36> track;
    byte type;

public:
    TrackGroupDataV36();
    TrackGroupDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV36(const TrackGroupDataV36 &p_other);
    TrackGroupDataV36 &operator=(const TrackGroupDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV36 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV36> trackGroup;

public:
    SequenceDataV36();
    SequenceDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV36(const SequenceDataV36 &p_other);
    SequenceDataV36 &operator=(const SequenceDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV36 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV36();
    ColorDefDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV36(const ColorDefDataV36 &p_other);
    ColorDefDataV36 &operator=(const ColorDefDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV36 {
    ColorDefDataV36 ambientGroundColor;
    ColorDefDataV36 ambientSkyColor;
    ColorDefDataV36 fillColor;
    ColorDefDataV36 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV36();
    AmbientLightDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV36(const AmbientLightDataV36 &p_other);
    AmbientLightDataV36 &operator=(const AmbientLightDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV36 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV36();
    FileNameRefDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV36(const FileNameRefDataV36 &p_other);
    FileNameRefDataV36 &operator=(const FileNameRefDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV36 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV36();
    ScriptDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV36(const ScriptDataV36 &p_other);
    ScriptDataV36 &operator=(const ScriptDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV36 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV36();
    TextEntryDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV36(const TextEntryDataV36 &p_other);
    TextEntryDataV36 &operator=(const TextEntryDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV36 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV36> textEntry;

public:
    TextResourceDataV36();
    TextResourceDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV36(const TextResourceDataV36 &p_other);
    TextResourceDataV36 &operator=(const TextResourceDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SpeciesResourceDataV36 {
    byte16 speciesId;
    qword name;
    qword modelId;
    qword modelVariant;

public:
    SpeciesResourceDataV36();
    SpeciesResourceDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SpeciesResourceDataV36(const SpeciesResourceDataV36 &p_other);
    SpeciesResourceDataV36 &operator=(const SpeciesResourceDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV36 {
    helpers::Array<AmbientLightDataV36> ambientLightResource;
    helpers::Array<FileNameRefDataV36> fileNameRef;
    helpers::Array<ScriptDataV36> script;
    helpers::Array<TextResourceDataV36> textResource;
    helpers::Array<SpeciesResourceDataV36> speciesResource;

public:
    ResourceDataV36();
    ResourceDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV36(const ResourceDataV36 &p_other);
    ResourceDataV36 &operator=(const ResourceDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV36 {
    qword startingSequence;
    helpers::Array<SequenceDataV36> sequence;
    ResourceDataV36 resources;
    helpers::Ptr<TrackGroupDataV36> trackGroup;

public:
    SceneDataV36();
    SceneDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV36(const SceneDataV36 &p_other);
    SceneDataV36 &operator=(const SceneDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV36 Gw2Struct;
};

/* Version: 35, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<35>{
struct PropertyDataV35 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV35();
    PropertyDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV35(const PropertyDataV35 &p_other);
    PropertyDataV35 &operator=(const PropertyDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV35 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV35();
    CurveKeyDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV35(const CurveKeyDataV35 &p_other);
    CurveKeyDataV35 &operator=(const CurveKeyDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV35 {
    float time;
    float value;

public:
    FlagKeyDataV35();
    FlagKeyDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV35(const FlagKeyDataV35 &p_other);
    FlagKeyDataV35 &operator=(const FlagKeyDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV35 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV35();
    TriggerKeyDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV35(const TriggerKeyDataV35 &p_other);
    TriggerKeyDataV35 &operator=(const TriggerKeyDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV35 {
    qword name;
    helpers::Array<CurveKeyDataV35> curveKey;
    helpers::Array<FlagKeyDataV35> flagKey;
    helpers::Array<TriggerKeyDataV35> triggerKey;
    byte type;

public:
    TrackDataV35();
    TrackDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV35(const TrackDataV35 &p_other);
    TrackDataV35 &operator=(const TrackDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV35 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV35> prop;
    helpers::Array<TrackDataV35> track;
    byte type;

public:
    TrackGroupDataV35();
    TrackGroupDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV35(const TrackGroupDataV35 &p_other);
    TrackGroupDataV35 &operator=(const TrackGroupDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV35 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV35> trackGroup;

public:
    SequenceDataV35();
    SequenceDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV35(const SequenceDataV35 &p_other);
    SequenceDataV35 &operator=(const SequenceDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV35 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV35();
    ColorDefDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV35(const ColorDefDataV35 &p_other);
    ColorDefDataV35 &operator=(const ColorDefDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV35 {
    ColorDefDataV35 ambientGroundColor;
    ColorDefDataV35 ambientSkyColor;
    ColorDefDataV35 fillColor;
    ColorDefDataV35 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV35();
    AmbientLightDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV35(const AmbientLightDataV35 &p_other);
    AmbientLightDataV35 &operator=(const AmbientLightDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV35 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV35();
    FileNameRefDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV35(const FileNameRefDataV35 &p_other);
    FileNameRefDataV35 &operator=(const FileNameRefDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV35 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV35();
    ScriptDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV35(const ScriptDataV35 &p_other);
    ScriptDataV35 &operator=(const ScriptDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV35 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV35();
    TextEntryDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV35(const TextEntryDataV35 &p_other);
    TextEntryDataV35 &operator=(const TextEntryDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV35 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV35> textEntry;

public:
    TextResourceDataV35();
    TextResourceDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV35(const TextResourceDataV35 &p_other);
    TextResourceDataV35 &operator=(const TextResourceDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SpeciesResourceDataV35 {
    byte16 speciesId;
    qword name;
    qword modelId;
    qword modelVariant;

public:
    SpeciesResourceDataV35();
    SpeciesResourceDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SpeciesResourceDataV35(const SpeciesResourceDataV35 &p_other);
    SpeciesResourceDataV35 &operator=(const SpeciesResourceDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV35 {
    helpers::Array<AmbientLightDataV35> ambientLightResource;
    helpers::Array<FileNameRefDataV35> fileNameRef;
    helpers::Array<ScriptDataV35> script;
    helpers::Array<TextResourceDataV35> textResource;
    helpers::Array<SpeciesResourceDataV35> speciesResource;

public:
    ResourceDataV35();
    ResourceDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV35(const ResourceDataV35 &p_other);
    ResourceDataV35 &operator=(const ResourceDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV35 {
    qword startingSequence;
    helpers::Array<SequenceDataV35> sequence;
    ResourceDataV35 resources;
    helpers::Ptr<TrackGroupDataV35> trackGroup;

public:
    SceneDataV35();
    SceneDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV35(const SceneDataV35 &p_other);
    SceneDataV35 &operator=(const SceneDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV35 Gw2Struct;
};

/* Version: 34, ReferencedFunction: 0x40F9FC5000000001 */

template <>
struct Gw2StructCSCN<34>{
struct PropertyDataV34 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV34();
    PropertyDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV34(const PropertyDataV34 &p_other);
    PropertyDataV34 &operator=(const PropertyDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV34 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV34();
    CurveKeyDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV34(const CurveKeyDataV34 &p_other);
    CurveKeyDataV34 &operator=(const CurveKeyDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV34 {
    float time;
    float value;

public:
    FlagKeyDataV34();
    FlagKeyDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV34(const FlagKeyDataV34 &p_other);
    FlagKeyDataV34 &operator=(const FlagKeyDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV34 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV34();
    TriggerKeyDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV34(const TriggerKeyDataV34 &p_other);
    TriggerKeyDataV34 &operator=(const TriggerKeyDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV34 {
    qword name;
    helpers::Array<CurveKeyDataV34> curveKey;
    helpers::Array<FlagKeyDataV34> flagKey;
    helpers::Array<TriggerKeyDataV34> triggerKey;
    byte type;

public:
    TrackDataV34();
    TrackDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV34(const TrackDataV34 &p_other);
    TrackDataV34 &operator=(const TrackDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV34 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV34> prop;
    helpers::Array<TrackDataV34> track;
    byte type;

public:
    TrackGroupDataV34();
    TrackGroupDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV34(const TrackGroupDataV34 &p_other);
    TrackGroupDataV34 &operator=(const TrackGroupDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV34 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV34> trackGroup;

public:
    SequenceDataV34();
    SequenceDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV34(const SequenceDataV34 &p_other);
    SequenceDataV34 &operator=(const SequenceDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV34 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV34();
    ColorDefDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV34(const ColorDefDataV34 &p_other);
    ColorDefDataV34 &operator=(const ColorDefDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV34 {
    ColorDefDataV34 ambientGroundColor;
    ColorDefDataV34 ambientSkyColor;
    ColorDefDataV34 fillColor;
    ColorDefDataV34 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV34();
    AmbientLightDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV34(const AmbientLightDataV34 &p_other);
    AmbientLightDataV34 &operator=(const AmbientLightDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV34 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV34();
    FileNameRefDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV34(const FileNameRefDataV34 &p_other);
    FileNameRefDataV34 &operator=(const FileNameRefDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV34 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV34();
    ScriptDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV34(const ScriptDataV34 &p_other);
    ScriptDataV34 &operator=(const ScriptDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV34 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV34();
    TextEntryDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV34(const TextEntryDataV34 &p_other);
    TextEntryDataV34 &operator=(const TextEntryDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV34 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV34> textEntry;

public:
    TextResourceDataV34();
    TextResourceDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV34(const TextResourceDataV34 &p_other);
    TextResourceDataV34 &operator=(const TextResourceDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SpeciesResourceDataV34 {
    byte16 speciesId;
    qword modelId;
    qword modelVariant;

public:
    SpeciesResourceDataV34();
    SpeciesResourceDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SpeciesResourceDataV34(const SpeciesResourceDataV34 &p_other);
    SpeciesResourceDataV34 &operator=(const SpeciesResourceDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV34 {
    helpers::Array<AmbientLightDataV34> ambientLightResource;
    helpers::Array<FileNameRefDataV34> fileNameRef;
    helpers::Array<ScriptDataV34> script;
    helpers::Array<TextResourceDataV34> textResource;
    helpers::Array<SpeciesResourceDataV34> speciesResource;

public:
    ResourceDataV34();
    ResourceDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV34(const ResourceDataV34 &p_other);
    ResourceDataV34 &operator=(const ResourceDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV34 {
    qword startingSequence;
    helpers::Array<SequenceDataV34> sequence;
    ResourceDataV34 resources;
    helpers::Ptr<TrackGroupDataV34> trackGroup;

public:
    SceneDataV34();
    SceneDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV34(const SceneDataV34 &p_other);
    SceneDataV34 &operator=(const SceneDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV34 Gw2Struct;
};

/* Version: 33, ReferencedFunction: 0x40F9FB9000000001 */

template <>
struct Gw2StructCSCN<33>{
struct PropertyDataV33 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV33();
    PropertyDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV33(const PropertyDataV33 &p_other);
    PropertyDataV33 &operator=(const PropertyDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV33 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV33();
    CurveKeyDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV33(const CurveKeyDataV33 &p_other);
    CurveKeyDataV33 &operator=(const CurveKeyDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV33 {
    float time;
    float value;

public:
    FlagKeyDataV33();
    FlagKeyDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV33(const FlagKeyDataV33 &p_other);
    FlagKeyDataV33 &operator=(const FlagKeyDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV33 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV33();
    TriggerKeyDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV33(const TriggerKeyDataV33 &p_other);
    TriggerKeyDataV33 &operator=(const TriggerKeyDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV33 {
    qword name;
    helpers::Array<CurveKeyDataV33> curveKey;
    helpers::Array<FlagKeyDataV33> flagKey;
    helpers::Array<TriggerKeyDataV33> triggerKey;
    byte type;

public:
    TrackDataV33();
    TrackDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV33(const TrackDataV33 &p_other);
    TrackDataV33 &operator=(const TrackDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV33 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV33> prop;
    helpers::Array<TrackDataV33> track;
    byte type;

public:
    TrackGroupDataV33();
    TrackGroupDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV33(const TrackGroupDataV33 &p_other);
    TrackGroupDataV33 &operator=(const TrackGroupDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV33 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV33> trackGroup;

public:
    SequenceDataV33();
    SequenceDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV33(const SequenceDataV33 &p_other);
    SequenceDataV33 &operator=(const SequenceDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV33 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV33();
    ColorDefDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV33(const ColorDefDataV33 &p_other);
    ColorDefDataV33 &operator=(const ColorDefDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV33 {
    ColorDefDataV33 ambientGroundColor;
    ColorDefDataV33 ambientSkyColor;
    ColorDefDataV33 fillColor;
    ColorDefDataV33 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV33();
    AmbientLightDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV33(const AmbientLightDataV33 &p_other);
    AmbientLightDataV33 &operator=(const AmbientLightDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV33 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV33();
    FileNameRefDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV33(const FileNameRefDataV33 &p_other);
    FileNameRefDataV33 &operator=(const FileNameRefDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV33 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV33();
    ScriptDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV33(const ScriptDataV33 &p_other);
    ScriptDataV33 &operator=(const ScriptDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV33 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV33();
    TextEntryDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV33(const TextEntryDataV33 &p_other);
    TextEntryDataV33 &operator=(const TextEntryDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV33 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV33> textEntry;

public:
    TextResourceDataV33();
    TextResourceDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV33(const TextResourceDataV33 &p_other);
    TextResourceDataV33 &operator=(const TextResourceDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV33 {
    dword crc;
    helpers::Array<AmbientLightDataV33> ambientLightResource;
    helpers::Array<FileNameRefDataV33> fileNameRef;
    helpers::Array<ScriptDataV33> script;
    helpers::Array<TextResourceDataV33> textResource;

public:
    ResourceDataV33();
    ResourceDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV33(const ResourceDataV33 &p_other);
    ResourceDataV33 &operator=(const ResourceDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV33 {
    qword startingSequence;
    helpers::Array<SequenceDataV33> sequence;
    ResourceDataV33 resources;
    helpers::Ptr<TrackGroupDataV33> trackGroup;

public:
    SceneDataV33();
    SceneDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV33(const SceneDataV33 &p_other);
    SceneDataV33 &operator=(const SceneDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV33 Gw2Struct;
};

/* Version: 32, ReferencedFunction: 0x40F9FAD000000001 */

template <>
struct Gw2StructCSCN<32>{
struct PropertyDataV32 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV32();
    PropertyDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV32(const PropertyDataV32 &p_other);
    PropertyDataV32 &operator=(const PropertyDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV32 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV32();
    CurveKeyDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV32(const CurveKeyDataV32 &p_other);
    CurveKeyDataV32 &operator=(const CurveKeyDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV32 {
    float time;
    float value;

public:
    FlagKeyDataV32();
    FlagKeyDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV32(const FlagKeyDataV32 &p_other);
    FlagKeyDataV32 &operator=(const FlagKeyDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV32 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV32();
    TriggerKeyDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV32(const TriggerKeyDataV32 &p_other);
    TriggerKeyDataV32 &operator=(const TriggerKeyDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV32 {
    qword name;
    helpers::Array<CurveKeyDataV32> curveKey;
    helpers::Array<FlagKeyDataV32> flagKey;
    helpers::Array<TriggerKeyDataV32> triggerKey;
    byte type;

public:
    TrackDataV32();
    TrackDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV32(const TrackDataV32 &p_other);
    TrackDataV32 &operator=(const TrackDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV32 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV32> prop;
    helpers::Array<TrackDataV32> track;
    byte type;

public:
    TrackGroupDataV32();
    TrackGroupDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV32(const TrackGroupDataV32 &p_other);
    TrackGroupDataV32 &operator=(const TrackGroupDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV32 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV32> trackGroup;

public:
    SequenceDataV32();
    SequenceDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV32(const SequenceDataV32 &p_other);
    SequenceDataV32 &operator=(const SequenceDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV32 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV32();
    ColorDefDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV32(const ColorDefDataV32 &p_other);
    ColorDefDataV32 &operator=(const ColorDefDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV32 {
    ColorDefDataV32 ambientGroundColor;
    ColorDefDataV32 ambientSkyColor;
    ColorDefDataV32 fillColor;
    ColorDefDataV32 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV32();
    AmbientLightDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV32(const AmbientLightDataV32 &p_other);
    AmbientLightDataV32 &operator=(const AmbientLightDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV32 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV32();
    FileNameRefDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV32(const FileNameRefDataV32 &p_other);
    FileNameRefDataV32 &operator=(const FileNameRefDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV32 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV32();
    ScriptDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV32(const ScriptDataV32 &p_other);
    ScriptDataV32 &operator=(const ScriptDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV32 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV32();
    TextEntryDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV32(const TextEntryDataV32 &p_other);
    TextEntryDataV32 &operator=(const TextEntryDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV32 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV32> textEntry;

public:
    TextResourceDataV32();
    TextResourceDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV32(const TextResourceDataV32 &p_other);
    TextResourceDataV32 &operator=(const TextResourceDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV32 {
    dword crc;
    helpers::Array<AmbientLightDataV32> ambientLightResource;
    helpers::Array<FileNameRefDataV32> fileNameRef;
    helpers::Array<ScriptDataV32> script;
    helpers::Array<TextResourceDataV32> textResource;

public:
    ResourceDataV32();
    ResourceDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV32(const ResourceDataV32 &p_other);
    ResourceDataV32 &operator=(const ResourceDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV32 {
    qword startingSequence;
    helpers::Array<SequenceDataV32> sequence;
    ResourceDataV32 resources;
    helpers::Ptr<TrackGroupDataV32> trackGroup;

public:
    SceneDataV32();
    SceneDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV32(const SceneDataV32 &p_other);
    SceneDataV32 &operator=(const SceneDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV32 Gw2Struct;
};

/* Version: 31, ReferencedFunction: 0x40F9FA1000000001 */

template <>
struct Gw2StructCSCN<31>{
struct PropertyDataV31 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV31();
    PropertyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV31(const PropertyDataV31 &p_other);
    PropertyDataV31 &operator=(const PropertyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV31 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV31();
    CurveKeyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV31(const CurveKeyDataV31 &p_other);
    CurveKeyDataV31 &operator=(const CurveKeyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV31 {
    float time;
    float value;

public:
    FlagKeyDataV31();
    FlagKeyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV31(const FlagKeyDataV31 &p_other);
    FlagKeyDataV31 &operator=(const FlagKeyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV31 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV31();
    TriggerKeyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV31(const TriggerKeyDataV31 &p_other);
    TriggerKeyDataV31 &operator=(const TriggerKeyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV31 {
    qword name;
    helpers::Array<CurveKeyDataV31> curveKey;
    helpers::Array<FlagKeyDataV31> flagKey;
    helpers::Array<TriggerKeyDataV31> triggerKey;
    byte type;

public:
    TrackDataV31();
    TrackDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV31(const TrackDataV31 &p_other);
    TrackDataV31 &operator=(const TrackDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV31 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV31> prop;
    helpers::Array<TrackDataV31> track;
    byte type;

public:
    TrackGroupDataV31();
    TrackGroupDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV31(const TrackGroupDataV31 &p_other);
    TrackGroupDataV31 &operator=(const TrackGroupDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV31 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV31> trackGroup;

public:
    SequenceDataV31();
    SequenceDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV31(const SequenceDataV31 &p_other);
    SequenceDataV31 &operator=(const SequenceDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV31 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV31();
    ColorDefDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV31(const ColorDefDataV31 &p_other);
    ColorDefDataV31 &operator=(const ColorDefDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV31 {
    ColorDefDataV31 ambientGroundColor;
    ColorDefDataV31 ambientSkyColor;
    ColorDefDataV31 fillColor;
    ColorDefDataV31 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV31();
    AmbientLightDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV31(const AmbientLightDataV31 &p_other);
    AmbientLightDataV31 &operator=(const AmbientLightDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV31 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV31();
    FileNameRefDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV31(const FileNameRefDataV31 &p_other);
    FileNameRefDataV31 &operator=(const FileNameRefDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV31 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV31();
    ScriptDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV31(const ScriptDataV31 &p_other);
    ScriptDataV31 &operator=(const ScriptDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV31 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV31();
    TextEntryDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV31(const TextEntryDataV31 &p_other);
    TextEntryDataV31 &operator=(const TextEntryDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV31 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV31> textEntry;

public:
    TextResourceDataV31();
    TextResourceDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV31(const TextResourceDataV31 &p_other);
    TextResourceDataV31 &operator=(const TextResourceDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV31 {
    dword crc;
    helpers::Array<AmbientLightDataV31> ambientLightResource;
    helpers::Array<FileNameRefDataV31> fileNameRef;
    helpers::Array<ScriptDataV31> script;
    helpers::Array<TextResourceDataV31> textResource;

public:
    ResourceDataV31();
    ResourceDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV31(const ResourceDataV31 &p_other);
    ResourceDataV31 &operator=(const ResourceDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV31 {
    qword startingSequence;
    helpers::Array<SequenceDataV31> sequence;
    ResourceDataV31 resources;
    helpers::Ptr<TrackGroupDataV31> trackGroup;

public:
    SceneDataV31();
    SceneDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV31(const SceneDataV31 &p_other);
    SceneDataV31 &operator=(const SceneDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV31 Gw2Struct;
};

/* Version: 30, ReferencedFunction: 0x40F9F9C000000001 */

template <>
struct Gw2StructCSCN<30>{
struct PropertyDataV30 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV30();
    PropertyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV30(const PropertyDataV30 &p_other);
    PropertyDataV30 &operator=(const PropertyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV30 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV30();
    CurveKeyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV30(const CurveKeyDataV30 &p_other);
    CurveKeyDataV30 &operator=(const CurveKeyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV30 {
    float time;
    float value;

public:
    FlagKeyDataV30();
    FlagKeyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV30(const FlagKeyDataV30 &p_other);
    FlagKeyDataV30 &operator=(const FlagKeyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV30 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV30();
    TriggerKeyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV30(const TriggerKeyDataV30 &p_other);
    TriggerKeyDataV30 &operator=(const TriggerKeyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV30 {
    qword name;
    helpers::Array<CurveKeyDataV30> curveKey;
    helpers::Array<FlagKeyDataV30> flagKey;
    helpers::Array<TriggerKeyDataV30> triggerKey;
    byte type;

public:
    TrackDataV30();
    TrackDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV30(const TrackDataV30 &p_other);
    TrackDataV30 &operator=(const TrackDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV30 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV30> prop;
    helpers::Array<TrackDataV30> track;
    byte type;

public:
    TrackGroupDataV30();
    TrackGroupDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV30(const TrackGroupDataV30 &p_other);
    TrackGroupDataV30 &operator=(const TrackGroupDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV30 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV30> trackGroup;

public:
    SequenceDataV30();
    SequenceDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV30(const SequenceDataV30 &p_other);
    SequenceDataV30 &operator=(const SequenceDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV30 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV30();
    ColorDefDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV30(const ColorDefDataV30 &p_other);
    ColorDefDataV30 &operator=(const ColorDefDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV30 {
    ColorDefDataV30 ambientGroundColor;
    ColorDefDataV30 ambientSkyColor;
    ColorDefDataV30 fillColor;
    ColorDefDataV30 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV30();
    AmbientLightDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV30(const AmbientLightDataV30 &p_other);
    AmbientLightDataV30 &operator=(const AmbientLightDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV30 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV30();
    FileNameRefDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV30(const FileNameRefDataV30 &p_other);
    FileNameRefDataV30 &operator=(const FileNameRefDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV30 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV30();
    ScriptDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV30(const ScriptDataV30 &p_other);
    ScriptDataV30 &operator=(const ScriptDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV30 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV30();
    TextEntryDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV30(const TextEntryDataV30 &p_other);
    TextEntryDataV30 &operator=(const TextEntryDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV30 {
    qword name;
    dword index;
    dword voiceId;
    helpers::Array<TextEntryDataV30> textEntry;

public:
    TextResourceDataV30();
    TextResourceDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV30(const TextResourceDataV30 &p_other);
    TextResourceDataV30 &operator=(const TextResourceDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV30 {
    dword crc;
    helpers::Array<AmbientLightDataV30> ambientLightResource;
    helpers::Array<FileNameRefDataV30> fileNameRef;
    helpers::Array<ScriptDataV30> script;
    helpers::Array<TextResourceDataV30> textResource;

public:
    ResourceDataV30();
    ResourceDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV30(const ResourceDataV30 &p_other);
    ResourceDataV30 &operator=(const ResourceDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV30 {
    qword startingSequence;
    helpers::Array<SequenceDataV30> sequence;
    ResourceDataV30 resources;
    helpers::Ptr<TrackGroupDataV30> trackGroup;

public:
    SceneDataV30();
    SceneDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV30(const SceneDataV30 &p_other);
    SceneDataV30 &operator=(const SceneDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV30 Gw2Struct;
};

/* Version: 29, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<29>{
struct PropertyDataV29 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV29();
    PropertyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV29(const PropertyDataV29 &p_other);
    PropertyDataV29 &operator=(const PropertyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV29 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV29();
    CurveKeyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV29(const CurveKeyDataV29 &p_other);
    CurveKeyDataV29 &operator=(const CurveKeyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV29 {
    float time;
    float value;

public:
    FlagKeyDataV29();
    FlagKeyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV29(const FlagKeyDataV29 &p_other);
    FlagKeyDataV29 &operator=(const FlagKeyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV29 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV29();
    TriggerKeyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV29(const TriggerKeyDataV29 &p_other);
    TriggerKeyDataV29 &operator=(const TriggerKeyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV29 {
    qword name;
    helpers::Array<CurveKeyDataV29> curveKey;
    helpers::Array<FlagKeyDataV29> flagKey;
    helpers::Array<TriggerKeyDataV29> triggerKey;
    byte type;

public:
    TrackDataV29();
    TrackDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV29(const TrackDataV29 &p_other);
    TrackDataV29 &operator=(const TrackDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV29 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV29> prop;
    helpers::Array<TrackDataV29> track;
    byte type;

public:
    TrackGroupDataV29();
    TrackGroupDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV29(const TrackGroupDataV29 &p_other);
    TrackGroupDataV29 &operator=(const TrackGroupDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV29 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV29> trackGroup;

public:
    SequenceDataV29();
    SequenceDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV29(const SequenceDataV29 &p_other);
    SequenceDataV29 &operator=(const SequenceDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV29 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV29();
    ColorDefDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV29(const ColorDefDataV29 &p_other);
    ColorDefDataV29 &operator=(const ColorDefDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV29 {
    ColorDefDataV29 ambientGroundColor;
    ColorDefDataV29 ambientSkyColor;
    ColorDefDataV29 fillColor;
    ColorDefDataV29 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV29();
    AmbientLightDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV29(const AmbientLightDataV29 &p_other);
    AmbientLightDataV29 &operator=(const AmbientLightDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV29 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV29();
    FileNameRefDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV29(const FileNameRefDataV29 &p_other);
    FileNameRefDataV29 &operator=(const FileNameRefDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV29 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV29();
    ScriptDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV29(const ScriptDataV29 &p_other);
    ScriptDataV29 &operator=(const ScriptDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV29 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV29();
    TextEntryDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV29(const TextEntryDataV29 &p_other);
    TextEntryDataV29 &operator=(const TextEntryDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV29 {
    byte16 guid;
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV29> textEntry;

public:
    TextResourceDataV29();
    TextResourceDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV29(const TextResourceDataV29 &p_other);
    TextResourceDataV29 &operator=(const TextResourceDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV29 {
    dword crc;
    helpers::Array<AmbientLightDataV29> ambientLightResource;
    helpers::Array<FileNameRefDataV29> fileNameRef;
    helpers::Array<ScriptDataV29> script;
    helpers::Array<TextResourceDataV29> textResource;

public:
    ResourceDataV29();
    ResourceDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV29(const ResourceDataV29 &p_other);
    ResourceDataV29 &operator=(const ResourceDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV29 {
    qword startingSequence;
    helpers::Array<SequenceDataV29> sequence;
    ResourceDataV29 resources;
    helpers::Ptr<TrackGroupDataV29> trackGroup;

public:
    SceneDataV29();
    SceneDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV29(const SceneDataV29 &p_other);
    SceneDataV29 &operator=(const SceneDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV29 Gw2Struct;
};

/* Version: 28, ReferencedFunction: 0x40F9F90000000001 */

template <>
struct Gw2StructCSCN<28>{
struct PropertyDataV28 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV28();
    PropertyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV28(const PropertyDataV28 &p_other);
    PropertyDataV28 &operator=(const PropertyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV28 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV28();
    CurveKeyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV28(const CurveKeyDataV28 &p_other);
    CurveKeyDataV28 &operator=(const CurveKeyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV28 {
    float time;
    float value;

public:
    FlagKeyDataV28();
    FlagKeyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV28(const FlagKeyDataV28 &p_other);
    FlagKeyDataV28 &operator=(const FlagKeyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV28 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV28();
    TriggerKeyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV28(const TriggerKeyDataV28 &p_other);
    TriggerKeyDataV28 &operator=(const TriggerKeyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV28 {
    qword name;
    helpers::Array<CurveKeyDataV28> curveKey;
    helpers::Array<FlagKeyDataV28> flagKey;
    helpers::Array<TriggerKeyDataV28> triggerKey;
    byte type;

public:
    TrackDataV28();
    TrackDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV28(const TrackDataV28 &p_other);
    TrackDataV28 &operator=(const TrackDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV28 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV28> prop;
    helpers::Array<TrackDataV28> track;
    byte type;

public:
    TrackGroupDataV28();
    TrackGroupDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV28(const TrackGroupDataV28 &p_other);
    TrackGroupDataV28 &operator=(const TrackGroupDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV28 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV28> trackGroup;

public:
    SequenceDataV28();
    SequenceDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV28(const SequenceDataV28 &p_other);
    SequenceDataV28 &operator=(const SequenceDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV28 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV28();
    ColorDefDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV28(const ColorDefDataV28 &p_other);
    ColorDefDataV28 &operator=(const ColorDefDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV28 {
    ColorDefDataV28 ambientGroundColor;
    ColorDefDataV28 ambientSkyColor;
    ColorDefDataV28 fillColor;
    ColorDefDataV28 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV28();
    AmbientLightDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV28(const AmbientLightDataV28 &p_other);
    AmbientLightDataV28 &operator=(const AmbientLightDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV28 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV28();
    FileNameRefDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV28(const FileNameRefDataV28 &p_other);
    FileNameRefDataV28 &operator=(const FileNameRefDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV28 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV28();
    ScriptDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV28(const ScriptDataV28 &p_other);
    ScriptDataV28 &operator=(const ScriptDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV28 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV28();
    TextEntryDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV28(const TextEntryDataV28 &p_other);
    TextEntryDataV28 &operator=(const TextEntryDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV28 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV28> textEntry;

public:
    TextResourceDataV28();
    TextResourceDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV28(const TextResourceDataV28 &p_other);
    TextResourceDataV28 &operator=(const TextResourceDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV28 {
    dword crc;
    helpers::Array<AmbientLightDataV28> ambientLightResource;
    helpers::Array<FileNameRefDataV28> fileNameRef;
    helpers::Array<ScriptDataV28> script;
    helpers::Array<TextResourceDataV28> textResource;

public:
    ResourceDataV28();
    ResourceDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV28(const ResourceDataV28 &p_other);
    ResourceDataV28 &operator=(const ResourceDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV28 {
    qword startingSequence;
    helpers::Array<SequenceDataV28> sequence;
    ResourceDataV28 resources;
    helpers::Ptr<TrackGroupDataV28> trackGroup;

public:
    SceneDataV28();
    SceneDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV28(const SceneDataV28 &p_other);
    SceneDataV28 &operator=(const SceneDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV28 Gw2Struct;
};

/* Version: 27, ReferencedFunction: 0x40F9F82000000001 */

template <>
struct Gw2StructCSCN<27>{
struct PropertyDataV27 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV27();
    PropertyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV27(const PropertyDataV27 &p_other);
    PropertyDataV27 &operator=(const PropertyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV27 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV27();
    CurveKeyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV27(const CurveKeyDataV27 &p_other);
    CurveKeyDataV27 &operator=(const CurveKeyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV27 {
    float time;
    float value;

public:
    FlagKeyDataV27();
    FlagKeyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV27(const FlagKeyDataV27 &p_other);
    FlagKeyDataV27 &operator=(const FlagKeyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV27 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV27();
    TriggerKeyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV27(const TriggerKeyDataV27 &p_other);
    TriggerKeyDataV27 &operator=(const TriggerKeyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV27 {
    qword name;
    helpers::Array<CurveKeyDataV27> curveKey;
    helpers::Array<FlagKeyDataV27> flagKey;
    helpers::Array<TriggerKeyDataV27> triggerKey;
    byte type;

public:
    TrackDataV27();
    TrackDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV27(const TrackDataV27 &p_other);
    TrackDataV27 &operator=(const TrackDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV27 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV27> prop;
    helpers::Array<TrackDataV27> track;
    byte type;

public:
    TrackGroupDataV27();
    TrackGroupDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV27(const TrackGroupDataV27 &p_other);
    TrackGroupDataV27 &operator=(const TrackGroupDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV27 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV27> trackGroup;

public:
    SequenceDataV27();
    SequenceDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV27(const SequenceDataV27 &p_other);
    SequenceDataV27 &operator=(const SequenceDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV27 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV27();
    ColorDefDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV27(const ColorDefDataV27 &p_other);
    ColorDefDataV27 &operator=(const ColorDefDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV27 {
    ColorDefDataV27 ambientGroundColor;
    ColorDefDataV27 ambientSkyColor;
    ColorDefDataV27 fillColor;
    ColorDefDataV27 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV27();
    AmbientLightDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV27(const AmbientLightDataV27 &p_other);
    AmbientLightDataV27 &operator=(const AmbientLightDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV27 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV27();
    FileNameRefDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV27(const FileNameRefDataV27 &p_other);
    FileNameRefDataV27 &operator=(const FileNameRefDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV27 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV27();
    ScriptDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV27(const ScriptDataV27 &p_other);
    ScriptDataV27 &operator=(const ScriptDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV27 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV27();
    TextEntryDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV27(const TextEntryDataV27 &p_other);
    TextEntryDataV27 &operator=(const TextEntryDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV27 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV27> textEntry;

public:
    TextResourceDataV27();
    TextResourceDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV27(const TextResourceDataV27 &p_other);
    TextResourceDataV27 &operator=(const TextResourceDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV27 {
    dword crc;
    helpers::Array<AmbientLightDataV27> ambientLightResource;
    helpers::Array<FileNameRefDataV27> fileNameRef;
    helpers::Array<ScriptDataV27> script;
    helpers::Array<TextResourceDataV27> textResource;

public:
    ResourceDataV27();
    ResourceDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV27(const ResourceDataV27 &p_other);
    ResourceDataV27 &operator=(const ResourceDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV27 {
    qword startingSequence;
    helpers::Array<SequenceDataV27> sequence;
    ResourceDataV27 resources;
    helpers::Ptr<TrackGroupDataV27> trackGroup;

public:
    SceneDataV27();
    SceneDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV27(const SceneDataV27 &p_other);
    SceneDataV27 &operator=(const SceneDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV27 Gw2Struct;
};

/* Version: 26, ReferencedFunction: 0x40F9F76000000001 */

template <>
struct Gw2StructCSCN<26>{
struct PropertyDataV26 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV26();
    PropertyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV26(const PropertyDataV26 &p_other);
    PropertyDataV26 &operator=(const PropertyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV26 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV26();
    CurveKeyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV26(const CurveKeyDataV26 &p_other);
    CurveKeyDataV26 &operator=(const CurveKeyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV26 {
    float time;
    float value;

public:
    FlagKeyDataV26();
    FlagKeyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV26(const FlagKeyDataV26 &p_other);
    FlagKeyDataV26 &operator=(const FlagKeyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV26 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV26();
    TriggerKeyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV26(const TriggerKeyDataV26 &p_other);
    TriggerKeyDataV26 &operator=(const TriggerKeyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV26 {
    qword name;
    helpers::Array<CurveKeyDataV26> curveKey;
    helpers::Array<FlagKeyDataV26> flagKey;
    helpers::Array<TriggerKeyDataV26> triggerKey;
    byte type;

public:
    TrackDataV26();
    TrackDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV26(const TrackDataV26 &p_other);
    TrackDataV26 &operator=(const TrackDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV26 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV26> prop;
    helpers::Array<TrackDataV26> track;
    byte type;

public:
    TrackGroupDataV26();
    TrackGroupDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV26(const TrackGroupDataV26 &p_other);
    TrackGroupDataV26 &operator=(const TrackGroupDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV26 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV26> trackGroup;

public:
    SequenceDataV26();
    SequenceDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV26(const SequenceDataV26 &p_other);
    SequenceDataV26 &operator=(const SequenceDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV26 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV26();
    ColorDefDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV26(const ColorDefDataV26 &p_other);
    ColorDefDataV26 &operator=(const ColorDefDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV26 {
    ColorDefDataV26 ambientGroundColor;
    ColorDefDataV26 ambientSkyColor;
    ColorDefDataV26 fillColor;
    ColorDefDataV26 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV26();
    AmbientLightDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV26(const AmbientLightDataV26 &p_other);
    AmbientLightDataV26 &operator=(const AmbientLightDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV26 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV26();
    FileNameRefDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV26(const FileNameRefDataV26 &p_other);
    FileNameRefDataV26 &operator=(const FileNameRefDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV26 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV26();
    ScriptDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV26(const ScriptDataV26 &p_other);
    ScriptDataV26 &operator=(const ScriptDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV26 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV26();
    TextEntryDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV26(const TextEntryDataV26 &p_other);
    TextEntryDataV26 &operator=(const TextEntryDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV26 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV26> textEntry;

public:
    TextResourceDataV26();
    TextResourceDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV26(const TextResourceDataV26 &p_other);
    TextResourceDataV26 &operator=(const TextResourceDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV26 {
    dword crc;
    helpers::Array<AmbientLightDataV26> ambientLightResource;
    helpers::Array<FileNameRefDataV26> fileNameRef;
    helpers::Array<ScriptDataV26> script;
    helpers::Array<TextResourceDataV26> textResource;

public:
    ResourceDataV26();
    ResourceDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV26(const ResourceDataV26 &p_other);
    ResourceDataV26 &operator=(const ResourceDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV26 {
    qword startingSequence;
    helpers::Array<SequenceDataV26> sequence;
    ResourceDataV26 resources;
    helpers::Ptr<TrackGroupDataV26> trackGroup;

public:
    SceneDataV26();
    SceneDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV26(const SceneDataV26 &p_other);
    SceneDataV26 &operator=(const SceneDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV26 Gw2Struct;
};

/* Version: 25, ReferencedFunction: 0x40F9F6A000000001 */

template <>
struct Gw2StructCSCN<25>{
struct PropertyDataV25 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV25();
    PropertyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV25(const PropertyDataV25 &p_other);
    PropertyDataV25 &operator=(const PropertyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV25 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV25();
    CurveKeyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV25(const CurveKeyDataV25 &p_other);
    CurveKeyDataV25 &operator=(const CurveKeyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV25 {
    float time;
    float value;

public:
    FlagKeyDataV25();
    FlagKeyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV25(const FlagKeyDataV25 &p_other);
    FlagKeyDataV25 &operator=(const FlagKeyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV25 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV25();
    TriggerKeyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV25(const TriggerKeyDataV25 &p_other);
    TriggerKeyDataV25 &operator=(const TriggerKeyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV25 {
    qword name;
    helpers::Array<CurveKeyDataV25> curveKey;
    helpers::Array<FlagKeyDataV25> flagKey;
    helpers::Array<TriggerKeyDataV25> triggerKey;
    byte type;

public:
    TrackDataV25();
    TrackDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV25(const TrackDataV25 &p_other);
    TrackDataV25 &operator=(const TrackDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV25 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV25> prop;
    helpers::Array<TrackDataV25> track;
    byte type;

public:
    TrackGroupDataV25();
    TrackGroupDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV25(const TrackGroupDataV25 &p_other);
    TrackGroupDataV25 &operator=(const TrackGroupDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV25 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV25> trackGroup;

public:
    SequenceDataV25();
    SequenceDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV25(const SequenceDataV25 &p_other);
    SequenceDataV25 &operator=(const SequenceDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV25 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV25();
    ColorDefDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV25(const ColorDefDataV25 &p_other);
    ColorDefDataV25 &operator=(const ColorDefDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV25 {
    ColorDefDataV25 ambientGroundColor;
    ColorDefDataV25 ambientSkyColor;
    ColorDefDataV25 fillColor;
    ColorDefDataV25 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV25();
    AmbientLightDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV25(const AmbientLightDataV25 &p_other);
    AmbientLightDataV25 &operator=(const AmbientLightDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV25 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV25();
    FileNameRefDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV25(const FileNameRefDataV25 &p_other);
    FileNameRefDataV25 &operator=(const FileNameRefDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV25 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV25();
    ScriptDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV25(const ScriptDataV25 &p_other);
    ScriptDataV25 &operator=(const ScriptDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV25 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV25();
    TextEntryDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV25(const TextEntryDataV25 &p_other);
    TextEntryDataV25 &operator=(const TextEntryDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV25 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV25> textEntry;

public:
    TextResourceDataV25();
    TextResourceDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV25(const TextResourceDataV25 &p_other);
    TextResourceDataV25 &operator=(const TextResourceDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV25 {
    dword crc;
    helpers::Array<AmbientLightDataV25> ambientLightResource;
    helpers::Array<FileNameRefDataV25> fileNameRef;
    helpers::Array<ScriptDataV25> script;
    helpers::Array<TextResourceDataV25> textResource;

public:
    ResourceDataV25();
    ResourceDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV25(const ResourceDataV25 &p_other);
    ResourceDataV25 &operator=(const ResourceDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV25 {
    qword startingSequence;
    helpers::Array<SequenceDataV25> sequence;
    ResourceDataV25 resources;
    helpers::Ptr<TrackGroupDataV25> trackGroup;

public:
    SceneDataV25();
    SceneDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV25(const SceneDataV25 &p_other);
    SceneDataV25 &operator=(const SceneDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV25 Gw2Struct;
};

/* Version: 24, ReferencedFunction: 0x40F9F5E000000001 */

template <>
struct Gw2StructCSCN<24>{
struct PropertyDataV24 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV24();
    PropertyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV24(const PropertyDataV24 &p_other);
    PropertyDataV24 &operator=(const PropertyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV24 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV24();
    CurveKeyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV24(const CurveKeyDataV24 &p_other);
    CurveKeyDataV24 &operator=(const CurveKeyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV24 {
    float time;
    float value;

public:
    FlagKeyDataV24();
    FlagKeyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV24(const FlagKeyDataV24 &p_other);
    FlagKeyDataV24 &operator=(const FlagKeyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV24 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV24();
    TriggerKeyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV24(const TriggerKeyDataV24 &p_other);
    TriggerKeyDataV24 &operator=(const TriggerKeyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV24 {
    qword name;
    helpers::Array<CurveKeyDataV24> curveKey;
    helpers::Array<FlagKeyDataV24> flagKey;
    helpers::Array<TriggerKeyDataV24> triggerKey;
    byte type;

public:
    TrackDataV24();
    TrackDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV24(const TrackDataV24 &p_other);
    TrackDataV24 &operator=(const TrackDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV24 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV24> prop;
    helpers::Array<TrackDataV24> track;
    byte type;

public:
    TrackGroupDataV24();
    TrackGroupDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV24(const TrackGroupDataV24 &p_other);
    TrackGroupDataV24 &operator=(const TrackGroupDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV24 {
    qword name;
    qword playScript;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV24> trackGroup;

public:
    SequenceDataV24();
    SequenceDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV24(const SequenceDataV24 &p_other);
    SequenceDataV24 &operator=(const SequenceDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV24 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV24();
    ColorDefDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV24(const ColorDefDataV24 &p_other);
    ColorDefDataV24 &operator=(const ColorDefDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV24 {
    ColorDefDataV24 ambientGroundColor;
    ColorDefDataV24 ambientSkyColor;
    ColorDefDataV24 fillColor;
    ColorDefDataV24 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV24();
    AmbientLightDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV24(const AmbientLightDataV24 &p_other);
    AmbientLightDataV24 &operator=(const AmbientLightDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV24 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV24();
    FileNameRefDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV24(const FileNameRefDataV24 &p_other);
    FileNameRefDataV24 &operator=(const FileNameRefDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV24 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV24();
    ScriptDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV24(const ScriptDataV24 &p_other);
    ScriptDataV24 &operator=(const ScriptDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV24 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV24();
    TextEntryDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV24(const TextEntryDataV24 &p_other);
    TextEntryDataV24 &operator=(const TextEntryDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV24 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV24> textEntry;

public:
    TextResourceDataV24();
    TextResourceDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV24(const TextResourceDataV24 &p_other);
    TextResourceDataV24 &operator=(const TextResourceDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV24 {
    dword crc;
    helpers::Array<AmbientLightDataV24> ambientLightResource;
    helpers::Array<FileNameRefDataV24> fileNameRef;
    helpers::Array<ScriptDataV24> script;
    helpers::Array<TextResourceDataV24> textResource;

public:
    ResourceDataV24();
    ResourceDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV24(const ResourceDataV24 &p_other);
    ResourceDataV24 &operator=(const ResourceDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV24 {
    qword startingSequence;
    helpers::Array<SequenceDataV24> sequence;
    ResourceDataV24 resources;
    helpers::Ptr<TrackGroupDataV24> trackGroup;

public:
    SceneDataV24();
    SceneDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV24(const SceneDataV24 &p_other);
    SceneDataV24 &operator=(const SceneDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV24 Gw2Struct;
};

/* Version: 23, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<23>{
struct PropertyDataV23 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV23();
    PropertyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV23(const PropertyDataV23 &p_other);
    PropertyDataV23 &operator=(const PropertyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV23 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV23();
    CurveKeyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV23(const CurveKeyDataV23 &p_other);
    CurveKeyDataV23 &operator=(const CurveKeyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV23 {
    float time;
    float value;

public:
    FlagKeyDataV23();
    FlagKeyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV23(const FlagKeyDataV23 &p_other);
    FlagKeyDataV23 &operator=(const FlagKeyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV23 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV23();
    TriggerKeyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV23(const TriggerKeyDataV23 &p_other);
    TriggerKeyDataV23 &operator=(const TriggerKeyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV23 {
    qword name;
    helpers::Array<CurveKeyDataV23> curveKey;
    helpers::Array<FlagKeyDataV23> flagKey;
    helpers::Array<TriggerKeyDataV23> triggerKey;
    byte type;

public:
    TrackDataV23();
    TrackDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV23(const TrackDataV23 &p_other);
    TrackDataV23 &operator=(const TrackDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV23 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV23> prop;
    helpers::Array<TrackDataV23> track;
    byte type;

public:
    TrackGroupDataV23();
    TrackGroupDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV23(const TrackGroupDataV23 &p_other);
    TrackGroupDataV23 &operator=(const TrackGroupDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV23 {
    qword name;
    qword updateScript;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    dword flags;
    helpers::Array<TrackGroupDataV23> trackGroup;

public:
    SequenceDataV23();
    SequenceDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV23(const SequenceDataV23 &p_other);
    SequenceDataV23 &operator=(const SequenceDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV23 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV23();
    ColorDefDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV23(const ColorDefDataV23 &p_other);
    ColorDefDataV23 &operator=(const ColorDefDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV23 {
    ColorDefDataV23 ambientGroundColor;
    ColorDefDataV23 ambientSkyColor;
    ColorDefDataV23 fillColor;
    ColorDefDataV23 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV23();
    AmbientLightDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV23(const AmbientLightDataV23 &p_other);
    AmbientLightDataV23 &operator=(const AmbientLightDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV23 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV23();
    FileNameRefDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV23(const FileNameRefDataV23 &p_other);
    FileNameRefDataV23 &operator=(const FileNameRefDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV23 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV23();
    ScriptDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV23(const ScriptDataV23 &p_other);
    ScriptDataV23 &operator=(const ScriptDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV23 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV23();
    TextEntryDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV23(const TextEntryDataV23 &p_other);
    TextEntryDataV23 &operator=(const TextEntryDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV23 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV23> textEntry;

public:
    TextResourceDataV23();
    TextResourceDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV23(const TextResourceDataV23 &p_other);
    TextResourceDataV23 &operator=(const TextResourceDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV23 {
    dword crc;
    helpers::Array<AmbientLightDataV23> ambientLightResource;
    helpers::Array<FileNameRefDataV23> fileNameRef;
    helpers::Array<ScriptDataV23> script;
    helpers::Array<TextResourceDataV23> textResource;

public:
    ResourceDataV23();
    ResourceDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV23(const ResourceDataV23 &p_other);
    ResourceDataV23 &operator=(const ResourceDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV23 {
    qword startingSequence;
    helpers::Array<SequenceDataV23> sequence;
    ResourceDataV23 resources;
    helpers::Ptr<TrackGroupDataV23> trackGroup;

public:
    SceneDataV23();
    SceneDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV23(const SceneDataV23 &p_other);
    SceneDataV23 &operator=(const SceneDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV23 Gw2Struct;
};

/* Version: 22, ReferencedFunction: 0x40F9F52000000001 */

template <>
struct Gw2StructCSCN<22>{
struct PropertyDataV22 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV22();
    PropertyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV22(const PropertyDataV22 &p_other);
    PropertyDataV22 &operator=(const PropertyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV22 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV22();
    CurveKeyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV22(const CurveKeyDataV22 &p_other);
    CurveKeyDataV22 &operator=(const CurveKeyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV22 {
    float time;
    float value;

public:
    FlagKeyDataV22();
    FlagKeyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV22(const FlagKeyDataV22 &p_other);
    FlagKeyDataV22 &operator=(const FlagKeyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV22 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV22();
    TriggerKeyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV22(const TriggerKeyDataV22 &p_other);
    TriggerKeyDataV22 &operator=(const TriggerKeyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV22 {
    qword name;
    helpers::Array<CurveKeyDataV22> curveKey;
    helpers::Array<FlagKeyDataV22> flagKey;
    helpers::Array<TriggerKeyDataV22> triggerKey;
    byte type;

public:
    TrackDataV22();
    TrackDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV22(const TrackDataV22 &p_other);
    TrackDataV22 &operator=(const TrackDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV22 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV22> prop;
    helpers::Array<TrackDataV22> track;
    byte type;

public:
    TrackGroupDataV22();
    TrackGroupDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV22(const TrackGroupDataV22 &p_other);
    TrackGroupDataV22 &operator=(const TrackGroupDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV22 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV22> trackGroup;

public:
    SequenceDataV22();
    SequenceDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV22(const SequenceDataV22 &p_other);
    SequenceDataV22 &operator=(const SequenceDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV22 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV22();
    ColorDefDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV22(const ColorDefDataV22 &p_other);
    ColorDefDataV22 &operator=(const ColorDefDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV22 {
    ColorDefDataV22 ambientGroundColor;
    ColorDefDataV22 ambientSkyColor;
    ColorDefDataV22 fillColor;
    ColorDefDataV22 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV22();
    AmbientLightDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV22(const AmbientLightDataV22 &p_other);
    AmbientLightDataV22 &operator=(const AmbientLightDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV22 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV22();
    FileNameRefDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV22(const FileNameRefDataV22 &p_other);
    FileNameRefDataV22 &operator=(const FileNameRefDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV22 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV22();
    ScriptDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV22(const ScriptDataV22 &p_other);
    ScriptDataV22 &operator=(const ScriptDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV22 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV22();
    TextEntryDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV22(const TextEntryDataV22 &p_other);
    TextEntryDataV22 &operator=(const TextEntryDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV22 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV22> textEntry;

public:
    TextResourceDataV22();
    TextResourceDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV22(const TextResourceDataV22 &p_other);
    TextResourceDataV22 &operator=(const TextResourceDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV22 {
    dword crc;
    helpers::Array<AmbientLightDataV22> ambientLightResource;
    helpers::Array<FileNameRefDataV22> fileNameRef;
    helpers::Array<ScriptDataV22> script;
    helpers::Array<TextResourceDataV22> textResource;

public:
    ResourceDataV22();
    ResourceDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV22(const ResourceDataV22 &p_other);
    ResourceDataV22 &operator=(const ResourceDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV22 {
    qword startingSequence;
    helpers::Array<SequenceDataV22> sequence;
    ResourceDataV22 resources;
    helpers::Ptr<TrackGroupDataV22> trackGroup;

public:
    SceneDataV22();
    SceneDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV22(const SceneDataV22 &p_other);
    SceneDataV22 &operator=(const SceneDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV22 Gw2Struct;
};

/* Version: 21, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<21>{
struct PropertyDataV21 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV21();
    PropertyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV21(const PropertyDataV21 &p_other);
    PropertyDataV21 &operator=(const PropertyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV21 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV21();
    CurveKeyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV21(const CurveKeyDataV21 &p_other);
    CurveKeyDataV21 &operator=(const CurveKeyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV21 {
    float time;
    float value;

public:
    FlagKeyDataV21();
    FlagKeyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV21(const FlagKeyDataV21 &p_other);
    FlagKeyDataV21 &operator=(const FlagKeyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV21 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV21();
    TriggerKeyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV21(const TriggerKeyDataV21 &p_other);
    TriggerKeyDataV21 &operator=(const TriggerKeyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV21 {
    qword name;
    helpers::Array<CurveKeyDataV21> curveKey;
    helpers::Array<FlagKeyDataV21> flagKey;
    helpers::Array<TriggerKeyDataV21> triggerKey;
    byte type;

public:
    TrackDataV21();
    TrackDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV21(const TrackDataV21 &p_other);
    TrackDataV21 &operator=(const TrackDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV21 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV21> prop;
    helpers::Array<TrackDataV21> track;
    byte type;

public:
    TrackGroupDataV21();
    TrackGroupDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV21(const TrackGroupDataV21 &p_other);
    TrackGroupDataV21 &operator=(const TrackGroupDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV21 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV21> trackGroup;

public:
    SequenceDataV21();
    SequenceDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV21(const SequenceDataV21 &p_other);
    SequenceDataV21 &operator=(const SequenceDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV21 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV21();
    ColorDefDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV21(const ColorDefDataV21 &p_other);
    ColorDefDataV21 &operator=(const ColorDefDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV21 {
    ColorDefDataV21 ambientGroundColor;
    ColorDefDataV21 ambientSkyColor;
    ColorDefDataV21 fillColor;
    ColorDefDataV21 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV21();
    AmbientLightDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV21(const AmbientLightDataV21 &p_other);
    AmbientLightDataV21 &operator=(const AmbientLightDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV21 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV21();
    FileNameRefDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV21(const FileNameRefDataV21 &p_other);
    FileNameRefDataV21 &operator=(const FileNameRefDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV21 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV21();
    ScriptDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV21(const ScriptDataV21 &p_other);
    ScriptDataV21 &operator=(const ScriptDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV21 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV21();
    TextEntryDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV21(const TextEntryDataV21 &p_other);
    TextEntryDataV21 &operator=(const TextEntryDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV21 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV21> textEntry;

public:
    TextResourceDataV21();
    TextResourceDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV21(const TextResourceDataV21 &p_other);
    TextResourceDataV21 &operator=(const TextResourceDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV21 {
    dword crc;
    helpers::Array<AmbientLightDataV21> ambientLightResource;
    helpers::Array<FileNameRefDataV21> fileNameRef;
    helpers::Array<ScriptDataV21> script;
    helpers::Array<TextResourceDataV21> textResource;

public:
    ResourceDataV21();
    ResourceDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV21(const ResourceDataV21 &p_other);
    ResourceDataV21 &operator=(const ResourceDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV21 {
    qword startingSequence;
    helpers::Array<SequenceDataV21> sequence;
    ResourceDataV21 resources;
    helpers::Ptr<TrackGroupDataV21> trackGroup;

public:
    SceneDataV21();
    SceneDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV21(const SceneDataV21 &p_other);
    SceneDataV21 &operator=(const SceneDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV21 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x40F9F46000000001 */

template <>
struct Gw2StructCSCN<20>{
struct PropertyDataV20 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV20();
    PropertyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV20(const PropertyDataV20 &p_other);
    PropertyDataV20 &operator=(const PropertyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV20 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV20();
    CurveKeyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV20(const CurveKeyDataV20 &p_other);
    CurveKeyDataV20 &operator=(const CurveKeyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV20 {
    float time;
    float value;

public:
    FlagKeyDataV20();
    FlagKeyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV20(const FlagKeyDataV20 &p_other);
    FlagKeyDataV20 &operator=(const FlagKeyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV20 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV20();
    TriggerKeyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV20(const TriggerKeyDataV20 &p_other);
    TriggerKeyDataV20 &operator=(const TriggerKeyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV20 {
    qword name;
    helpers::Array<CurveKeyDataV20> curveKey;
    helpers::Array<FlagKeyDataV20> flagKey;
    helpers::Array<TriggerKeyDataV20> triggerKey;
    byte type;

public:
    TrackDataV20();
    TrackDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV20(const TrackDataV20 &p_other);
    TrackDataV20 &operator=(const TrackDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV20 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV20> prop;
    helpers::Array<TrackDataV20> track;
    byte type;

public:
    TrackGroupDataV20();
    TrackGroupDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV20(const TrackGroupDataV20 &p_other);
    TrackGroupDataV20 &operator=(const TrackGroupDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV20 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV20> trackGroup;

public:
    SequenceDataV20();
    SequenceDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV20(const SequenceDataV20 &p_other);
    SequenceDataV20 &operator=(const SequenceDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV20 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV20();
    ColorDefDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV20(const ColorDefDataV20 &p_other);
    ColorDefDataV20 &operator=(const ColorDefDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV20 {
    ColorDefDataV20 ambientGroundColor;
    ColorDefDataV20 ambientSkyColor;
    ColorDefDataV20 fillColor;
    ColorDefDataV20 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV20();
    AmbientLightDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV20(const AmbientLightDataV20 &p_other);
    AmbientLightDataV20 &operator=(const AmbientLightDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV20 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV20();
    FileNameRefDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV20(const FileNameRefDataV20 &p_other);
    FileNameRefDataV20 &operator=(const FileNameRefDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV20 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV20();
    ScriptDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV20(const ScriptDataV20 &p_other);
    ScriptDataV20 &operator=(const ScriptDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV20 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV20();
    TextEntryDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV20(const TextEntryDataV20 &p_other);
    TextEntryDataV20 &operator=(const TextEntryDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV20 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV20> textEntry;

public:
    TextResourceDataV20();
    TextResourceDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV20(const TextResourceDataV20 &p_other);
    TextResourceDataV20 &operator=(const TextResourceDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV20 {
    dword crc;
    helpers::Array<AmbientLightDataV20> ambientLightResource;
    helpers::Array<FileNameRefDataV20> fileNameRef;
    helpers::Array<ScriptDataV20> script;
    helpers::Array<TextResourceDataV20> textResource;

public:
    ResourceDataV20();
    ResourceDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV20(const ResourceDataV20 &p_other);
    ResourceDataV20 &operator=(const ResourceDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV20 {
    qword startingSequence;
    helpers::Array<SequenceDataV20> sequence;
    ResourceDataV20 resources;

public:
    SceneDataV20();
    SceneDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV20(const SceneDataV20 &p_other);
    SceneDataV20 &operator=(const SceneDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV20 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x40F9F3A000000001 */

template <>
struct Gw2StructCSCN<19>{
struct PropertyDataV19 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV19();
    PropertyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV19(const PropertyDataV19 &p_other);
    PropertyDataV19 &operator=(const PropertyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV19 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV19();
    CurveKeyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV19(const CurveKeyDataV19 &p_other);
    CurveKeyDataV19 &operator=(const CurveKeyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV19 {
    float time;
    float value;

public:
    FlagKeyDataV19();
    FlagKeyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV19(const FlagKeyDataV19 &p_other);
    FlagKeyDataV19 &operator=(const FlagKeyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV19 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV19();
    TriggerKeyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV19(const TriggerKeyDataV19 &p_other);
    TriggerKeyDataV19 &operator=(const TriggerKeyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV19 {
    qword name;
    helpers::Array<CurveKeyDataV19> curveKey;
    helpers::Array<FlagKeyDataV19> flagKey;
    helpers::Array<TriggerKeyDataV19> triggerKey;
    byte type;

public:
    TrackDataV19();
    TrackDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV19(const TrackDataV19 &p_other);
    TrackDataV19 &operator=(const TrackDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV19 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV19> prop;
    helpers::Array<TrackDataV19> track;
    byte type;

public:
    TrackGroupDataV19();
    TrackGroupDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV19(const TrackGroupDataV19 &p_other);
    TrackGroupDataV19 &operator=(const TrackGroupDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV19 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV19> trackGroup;

public:
    SequenceDataV19();
    SequenceDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV19(const SequenceDataV19 &p_other);
    SequenceDataV19 &operator=(const SequenceDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV19 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV19();
    ColorDefDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV19(const ColorDefDataV19 &p_other);
    ColorDefDataV19 &operator=(const ColorDefDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV19 {
    ColorDefDataV19 ambientGroundColor;
    ColorDefDataV19 ambientSkyColor;
    ColorDefDataV19 fillColor;
    ColorDefDataV19 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV19();
    AmbientLightDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV19(const AmbientLightDataV19 &p_other);
    AmbientLightDataV19 &operator=(const AmbientLightDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV19 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV19();
    FileNameRefDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV19(const FileNameRefDataV19 &p_other);
    FileNameRefDataV19 &operator=(const FileNameRefDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV19 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV19();
    ScriptDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV19(const ScriptDataV19 &p_other);
    ScriptDataV19 &operator=(const ScriptDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV19 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV19();
    TextEntryDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV19(const TextEntryDataV19 &p_other);
    TextEntryDataV19 &operator=(const TextEntryDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV19 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV19> textEntry;

public:
    TextResourceDataV19();
    TextResourceDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV19(const TextResourceDataV19 &p_other);
    TextResourceDataV19 &operator=(const TextResourceDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV19 {
    dword crc;
    helpers::Array<AmbientLightDataV19> ambientLightResource;
    helpers::Array<FileNameRefDataV19> fileNameRef;
    helpers::Array<ScriptDataV19> script;
    helpers::Array<TextResourceDataV19> textResource;

public:
    ResourceDataV19();
    ResourceDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV19(const ResourceDataV19 &p_other);
    ResourceDataV19 &operator=(const ResourceDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV19 {
    qword startingSequence;
    helpers::Array<SequenceDataV19> sequence;
    ResourceDataV19 resources;

public:
    SceneDataV19();
    SceneDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV19(const SceneDataV19 &p_other);
    SceneDataV19 &operator=(const SceneDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV19 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x40F9F3A000000001 */

template <>
struct Gw2StructCSCN<18>{
struct PropertyDataV18 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV18();
    PropertyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV18(const PropertyDataV18 &p_other);
    PropertyDataV18 &operator=(const PropertyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV18 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV18();
    CurveKeyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV18(const CurveKeyDataV18 &p_other);
    CurveKeyDataV18 &operator=(const CurveKeyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV18 {
    float time;
    float value;

public:
    FlagKeyDataV18();
    FlagKeyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV18(const FlagKeyDataV18 &p_other);
    FlagKeyDataV18 &operator=(const FlagKeyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV18 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV18();
    TriggerKeyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV18(const TriggerKeyDataV18 &p_other);
    TriggerKeyDataV18 &operator=(const TriggerKeyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV18 {
    qword name;
    helpers::Array<CurveKeyDataV18> curveKey;
    helpers::Array<FlagKeyDataV18> flagKey;
    helpers::Array<TriggerKeyDataV18> triggerKey;
    byte type;

public:
    TrackDataV18();
    TrackDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV18(const TrackDataV18 &p_other);
    TrackDataV18 &operator=(const TrackDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV18 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV18> prop;
    helpers::Array<TrackDataV18> track;
    byte type;

public:
    TrackGroupDataV18();
    TrackGroupDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV18(const TrackGroupDataV18 &p_other);
    TrackGroupDataV18 &operator=(const TrackGroupDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV18 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV18> trackGroup;

public:
    SequenceDataV18();
    SequenceDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV18(const SequenceDataV18 &p_other);
    SequenceDataV18 &operator=(const SequenceDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV18 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV18();
    ColorDefDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV18(const ColorDefDataV18 &p_other);
    ColorDefDataV18 &operator=(const ColorDefDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV18 {
    ColorDefDataV18 ambientGroundColor;
    ColorDefDataV18 ambientSkyColor;
    ColorDefDataV18 fillColor;
    ColorDefDataV18 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV18();
    AmbientLightDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV18(const AmbientLightDataV18 &p_other);
    AmbientLightDataV18 &operator=(const AmbientLightDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV18 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV18();
    FileNameRefDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV18(const FileNameRefDataV18 &p_other);
    FileNameRefDataV18 &operator=(const FileNameRefDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV18 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV18();
    ScriptDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV18(const ScriptDataV18 &p_other);
    ScriptDataV18 &operator=(const ScriptDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV18 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV18();
    TextEntryDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV18(const TextEntryDataV18 &p_other);
    TextEntryDataV18 &operator=(const TextEntryDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV18 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV18> textEntry;

public:
    TextResourceDataV18();
    TextResourceDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV18(const TextResourceDataV18 &p_other);
    TextResourceDataV18 &operator=(const TextResourceDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV18 {
    dword crc;
    helpers::Array<AmbientLightDataV18> ambientLightResource;
    helpers::Array<FileNameRefDataV18> fileNameRef;
    helpers::Array<ScriptDataV18> script;
    helpers::Array<TextResourceDataV18> textResource;

public:
    ResourceDataV18();
    ResourceDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV18(const ResourceDataV18 &p_other);
    ResourceDataV18 &operator=(const ResourceDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV18 {
    qword startingSequence;
    helpers::Array<SequenceDataV18> sequence;
    ResourceDataV18 resources;

public:
    SceneDataV18();
    SceneDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV18(const SceneDataV18 &p_other);
    SceneDataV18 &operator=(const SceneDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x40F9F2E000000001 */

template <>
struct Gw2StructCSCN<17>{
struct PropertyDataV17 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV17();
    PropertyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV17(const PropertyDataV17 &p_other);
    PropertyDataV17 &operator=(const PropertyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV17 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV17();
    CurveKeyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV17(const CurveKeyDataV17 &p_other);
    CurveKeyDataV17 &operator=(const CurveKeyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV17 {
    float time;
    float value;

public:
    FlagKeyDataV17();
    FlagKeyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV17(const FlagKeyDataV17 &p_other);
    FlagKeyDataV17 &operator=(const FlagKeyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV17 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV17();
    TriggerKeyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV17(const TriggerKeyDataV17 &p_other);
    TriggerKeyDataV17 &operator=(const TriggerKeyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV17 {
    qword name;
    helpers::Array<CurveKeyDataV17> curveKey;
    helpers::Array<FlagKeyDataV17> flagKey;
    helpers::Array<TriggerKeyDataV17> triggerKey;
    byte type;

public:
    TrackDataV17();
    TrackDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV17(const TrackDataV17 &p_other);
    TrackDataV17 &operator=(const TrackDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV17 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV17> prop;
    helpers::Array<TrackDataV17> track;
    byte type;

public:
    TrackGroupDataV17();
    TrackGroupDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV17(const TrackGroupDataV17 &p_other);
    TrackGroupDataV17 &operator=(const TrackGroupDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV17 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV17> trackGroup;

public:
    SequenceDataV17();
    SequenceDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV17(const SequenceDataV17 &p_other);
    SequenceDataV17 &operator=(const SequenceDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV17 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV17();
    ColorDefDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV17(const ColorDefDataV17 &p_other);
    ColorDefDataV17 &operator=(const ColorDefDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV17 {
    ColorDefDataV17 ambientGroundColor;
    ColorDefDataV17 ambientSkyColor;
    ColorDefDataV17 fillColor;
    ColorDefDataV17 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV17();
    AmbientLightDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV17(const AmbientLightDataV17 &p_other);
    AmbientLightDataV17 &operator=(const AmbientLightDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV17 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV17();
    FileNameRefDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV17(const FileNameRefDataV17 &p_other);
    FileNameRefDataV17 &operator=(const FileNameRefDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV17 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV17();
    ScriptDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV17(const ScriptDataV17 &p_other);
    ScriptDataV17 &operator=(const ScriptDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV17 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV17();
    TextEntryDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV17(const TextEntryDataV17 &p_other);
    TextEntryDataV17 &operator=(const TextEntryDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV17 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV17> textEntry;

public:
    TextResourceDataV17();
    TextResourceDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV17(const TextResourceDataV17 &p_other);
    TextResourceDataV17 &operator=(const TextResourceDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV17 {
    dword crc;
    helpers::Array<AmbientLightDataV17> ambientLightResource;
    helpers::Array<FileNameRefDataV17> fileNameRef;
    helpers::Array<ScriptDataV17> script;
    helpers::Array<TextResourceDataV17> textResource;

public:
    ResourceDataV17();
    ResourceDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV17(const ResourceDataV17 &p_other);
    ResourceDataV17 &operator=(const ResourceDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV17 {
    qword startingSequence;
    helpers::Array<SequenceDataV17> sequence;
    ResourceDataV17 resources;

public:
    SceneDataV17();
    SceneDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV17(const SceneDataV17 &p_other);
    SceneDataV17 &operator=(const SceneDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x40F9F22000000001 */

template <>
struct Gw2StructCSCN<16>{
struct PropertyDataV16 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV16();
    PropertyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV16(const PropertyDataV16 &p_other);
    PropertyDataV16 &operator=(const PropertyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV16 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV16();
    CurveKeyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV16(const CurveKeyDataV16 &p_other);
    CurveKeyDataV16 &operator=(const CurveKeyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV16 {
    float time;
    float value;

public:
    FlagKeyDataV16();
    FlagKeyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV16(const FlagKeyDataV16 &p_other);
    FlagKeyDataV16 &operator=(const FlagKeyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV16 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV16();
    TriggerKeyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV16(const TriggerKeyDataV16 &p_other);
    TriggerKeyDataV16 &operator=(const TriggerKeyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV16 {
    qword name;
    helpers::Array<CurveKeyDataV16> curveKey;
    helpers::Array<FlagKeyDataV16> flagKey;
    helpers::Array<TriggerKeyDataV16> triggerKey;
    byte type;

public:
    TrackDataV16();
    TrackDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV16(const TrackDataV16 &p_other);
    TrackDataV16 &operator=(const TrackDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV16 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV16> prop;
    helpers::Array<TrackDataV16> track;
    byte type;

public:
    TrackGroupDataV16();
    TrackGroupDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV16(const TrackGroupDataV16 &p_other);
    TrackGroupDataV16 &operator=(const TrackGroupDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV16 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV16> trackGroup;

public:
    SequenceDataV16();
    SequenceDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV16(const SequenceDataV16 &p_other);
    SequenceDataV16 &operator=(const SequenceDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV16 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV16();
    ColorDefDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV16(const ColorDefDataV16 &p_other);
    ColorDefDataV16 &operator=(const ColorDefDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV16 {
    ColorDefDataV16 ambientGroundColor;
    ColorDefDataV16 ambientSkyColor;
    ColorDefDataV16 fillColor;
    ColorDefDataV16 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV16();
    AmbientLightDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV16(const AmbientLightDataV16 &p_other);
    AmbientLightDataV16 &operator=(const AmbientLightDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV16 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV16();
    FileNameRefDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV16(const FileNameRefDataV16 &p_other);
    FileNameRefDataV16 &operator=(const FileNameRefDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV16 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV16();
    ScriptDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV16(const ScriptDataV16 &p_other);
    ScriptDataV16 &operator=(const ScriptDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV16 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV16();
    TextEntryDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV16(const TextEntryDataV16 &p_other);
    TextEntryDataV16 &operator=(const TextEntryDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV16 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV16> textEntry;

public:
    TextResourceDataV16();
    TextResourceDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV16(const TextResourceDataV16 &p_other);
    TextResourceDataV16 &operator=(const TextResourceDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV16 {
    dword crc;
    helpers::Array<AmbientLightDataV16> ambientLightResource;
    helpers::Array<FileNameRefDataV16> fileNameRef;
    helpers::Array<ScriptDataV16> script;
    helpers::Array<TextResourceDataV16> textResource;

public:
    ResourceDataV16();
    ResourceDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV16(const ResourceDataV16 &p_other);
    ResourceDataV16 &operator=(const ResourceDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV16 {
    qword startingSequence;
    helpers::Array<SequenceDataV16> sequence;
    ResourceDataV16 resources;

public:
    SceneDataV16();
    SceneDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV16(const SceneDataV16 &p_other);
    SceneDataV16 &operator=(const SceneDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<15>{
struct PropertyDataV15 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV15();
    PropertyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV15(const PropertyDataV15 &p_other);
    PropertyDataV15 &operator=(const PropertyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV15 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV15();
    CurveKeyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV15(const CurveKeyDataV15 &p_other);
    CurveKeyDataV15 &operator=(const CurveKeyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV15 {
    float time;
    float value;

public:
    FlagKeyDataV15();
    FlagKeyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV15(const FlagKeyDataV15 &p_other);
    FlagKeyDataV15 &operator=(const FlagKeyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV15 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV15();
    TriggerKeyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV15(const TriggerKeyDataV15 &p_other);
    TriggerKeyDataV15 &operator=(const TriggerKeyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV15 {
    qword name;
    helpers::Array<CurveKeyDataV15> curveKey;
    helpers::Array<FlagKeyDataV15> flagKey;
    helpers::Array<TriggerKeyDataV15> triggerKey;
    byte type;

public:
    TrackDataV15();
    TrackDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV15(const TrackDataV15 &p_other);
    TrackDataV15 &operator=(const TrackDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV15 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV15> prop;
    helpers::Array<TrackDataV15> track;
    byte type;

public:
    TrackGroupDataV15();
    TrackGroupDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV15(const TrackGroupDataV15 &p_other);
    TrackGroupDataV15 &operator=(const TrackGroupDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV15 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword updateScript;
    float length;
    helpers::Array<TrackGroupDataV15> trackGroup;

public:
    SequenceDataV15();
    SequenceDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV15(const SequenceDataV15 &p_other);
    SequenceDataV15 &operator=(const SequenceDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV15 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV15();
    ColorDefDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV15(const ColorDefDataV15 &p_other);
    ColorDefDataV15 &operator=(const ColorDefDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV15 {
    ColorDefDataV15 ambientGroundColor;
    ColorDefDataV15 ambientSkyColor;
    ColorDefDataV15 fillColor;
    ColorDefDataV15 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV15();
    AmbientLightDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV15(const AmbientLightDataV15 &p_other);
    AmbientLightDataV15 &operator=(const AmbientLightDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV15 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV15();
    FileNameRefDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV15(const FileNameRefDataV15 &p_other);
    FileNameRefDataV15 &operator=(const FileNameRefDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV15 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV15();
    ScriptDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV15(const ScriptDataV15 &p_other);
    ScriptDataV15 &operator=(const ScriptDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV15 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV15();
    TextEntryDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV15(const TextEntryDataV15 &p_other);
    TextEntryDataV15 &operator=(const TextEntryDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV15 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV15> textEntry;

public:
    TextResourceDataV15();
    TextResourceDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV15(const TextResourceDataV15 &p_other);
    TextResourceDataV15 &operator=(const TextResourceDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV15 {
    dword crc;
    helpers::Array<AmbientLightDataV15> ambientLightResource;
    helpers::Array<FileNameRefDataV15> fileNameRef;
    helpers::Array<ScriptDataV15> script;
    helpers::Array<TextResourceDataV15> textResource;

public:
    ResourceDataV15();
    ResourceDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV15(const ResourceDataV15 &p_other);
    ResourceDataV15 &operator=(const ResourceDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV15 {
    qword startingSequence;
    helpers::Array<SequenceDataV15> sequence;
    ResourceDataV15 resources;

public:
    SceneDataV15();
    SceneDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV15(const SceneDataV15 &p_other);
    SceneDataV15 &operator=(const SceneDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<14>{
struct PropertyDataV14 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV14();
    PropertyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV14(const PropertyDataV14 &p_other);
    PropertyDataV14 &operator=(const PropertyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV14 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV14();
    CurveKeyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV14(const CurveKeyDataV14 &p_other);
    CurveKeyDataV14 &operator=(const CurveKeyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV14 {
    float time;
    float value;

public:
    FlagKeyDataV14();
    FlagKeyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV14(const FlagKeyDataV14 &p_other);
    FlagKeyDataV14 &operator=(const FlagKeyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV14 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV14();
    TriggerKeyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV14(const TriggerKeyDataV14 &p_other);
    TriggerKeyDataV14 &operator=(const TriggerKeyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV14 {
    qword name;
    helpers::Array<CurveKeyDataV14> curveKey;
    helpers::Array<FlagKeyDataV14> flagKey;
    helpers::Array<TriggerKeyDataV14> triggerKey;
    byte type;

public:
    TrackDataV14();
    TrackDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV14(const TrackDataV14 &p_other);
    TrackDataV14 &operator=(const TrackDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV14 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV14> prop;
    helpers::Array<TrackDataV14> track;
    byte type;

public:
    TrackGroupDataV14();
    TrackGroupDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV14(const TrackGroupDataV14 &p_other);
    TrackGroupDataV14 &operator=(const TrackGroupDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV14 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    helpers::Array<TrackGroupDataV14> trackGroup;

public:
    SequenceDataV14();
    SequenceDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV14(const SequenceDataV14 &p_other);
    SequenceDataV14 &operator=(const SequenceDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV14 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV14();
    ColorDefDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV14(const ColorDefDataV14 &p_other);
    ColorDefDataV14 &operator=(const ColorDefDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV14 {
    ColorDefDataV14 ambientGroundColor;
    ColorDefDataV14 ambientSkyColor;
    ColorDefDataV14 fillColor;
    ColorDefDataV14 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV14();
    AmbientLightDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV14(const AmbientLightDataV14 &p_other);
    AmbientLightDataV14 &operator=(const AmbientLightDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV14 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV14();
    FileNameRefDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV14(const FileNameRefDataV14 &p_other);
    FileNameRefDataV14 &operator=(const FileNameRefDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV14 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV14();
    ScriptDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV14(const ScriptDataV14 &p_other);
    ScriptDataV14 &operator=(const ScriptDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV14 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV14();
    TextEntryDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV14(const TextEntryDataV14 &p_other);
    TextEntryDataV14 &operator=(const TextEntryDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV14 {
    qword name;
    dword id;
    dword voiceId;
    helpers::Array<TextEntryDataV14> textEntry;

public:
    TextResourceDataV14();
    TextResourceDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV14(const TextResourceDataV14 &p_other);
    TextResourceDataV14 &operator=(const TextResourceDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV14 {
    dword crc;
    helpers::Array<AmbientLightDataV14> ambientLightResource;
    helpers::Array<FileNameRefDataV14> fileNameRef;
    helpers::Array<ScriptDataV14> script;
    helpers::Array<TextResourceDataV14> textResource;

public:
    ResourceDataV14();
    ResourceDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV14(const ResourceDataV14 &p_other);
    ResourceDataV14 &operator=(const ResourceDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV14 {
    qword startingSequence;
    helpers::Array<SequenceDataV14> sequence;
    ResourceDataV14 resources;

public:
    SceneDataV14();
    SceneDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV14(const SceneDataV14 &p_other);
    SceneDataV14 &operator=(const SceneDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x40F9F18000000001 */

template <>
struct Gw2StructCSCN<13>{
struct PropertyDataV13 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV13();
    PropertyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV13(const PropertyDataV13 &p_other);
    PropertyDataV13 &operator=(const PropertyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV13 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV13();
    CurveKeyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV13(const CurveKeyDataV13 &p_other);
    CurveKeyDataV13 &operator=(const CurveKeyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV13 {
    float time;
    float value;

public:
    FlagKeyDataV13();
    FlagKeyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV13(const FlagKeyDataV13 &p_other);
    FlagKeyDataV13 &operator=(const FlagKeyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV13 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV13();
    TriggerKeyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV13(const TriggerKeyDataV13 &p_other);
    TriggerKeyDataV13 &operator=(const TriggerKeyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV13 {
    qword name;
    helpers::Array<CurveKeyDataV13> curveKey;
    helpers::Array<FlagKeyDataV13> flagKey;
    helpers::Array<TriggerKeyDataV13> triggerKey;
    byte type;

public:
    TrackDataV13();
    TrackDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV13(const TrackDataV13 &p_other);
    TrackDataV13 &operator=(const TrackDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV13 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV13> prop;
    helpers::Array<TrackDataV13> track;
    byte type;

public:
    TrackGroupDataV13();
    TrackGroupDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV13(const TrackGroupDataV13 &p_other);
    TrackGroupDataV13 &operator=(const TrackGroupDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV13 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    helpers::Array<TrackGroupDataV13> trackGroup;

public:
    SequenceDataV13();
    SequenceDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV13(const SequenceDataV13 &p_other);
    SequenceDataV13 &operator=(const SequenceDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV13 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV13();
    ColorDefDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV13(const ColorDefDataV13 &p_other);
    ColorDefDataV13 &operator=(const ColorDefDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV13 {
    ColorDefDataV13 ambientGroundColor;
    ColorDefDataV13 ambientSkyColor;
    ColorDefDataV13 fillColor;
    ColorDefDataV13 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV13();
    AmbientLightDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV13(const AmbientLightDataV13 &p_other);
    AmbientLightDataV13 &operator=(const AmbientLightDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV13 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV13();
    FileNameRefDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV13(const FileNameRefDataV13 &p_other);
    FileNameRefDataV13 &operator=(const FileNameRefDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV13 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV13();
    ScriptDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV13(const ScriptDataV13 &p_other);
    ScriptDataV13 &operator=(const ScriptDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV13 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV13();
    TextEntryDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV13(const TextEntryDataV13 &p_other);
    TextEntryDataV13 &operator=(const TextEntryDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV13 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV13> textEntry;

public:
    TextResourceDataV13();
    TextResourceDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV13(const TextResourceDataV13 &p_other);
    TextResourceDataV13 &operator=(const TextResourceDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV13 {
    dword crc;
    helpers::Array<AmbientLightDataV13> ambientLightResource;
    helpers::Array<FileNameRefDataV13> fileNameRef;
    helpers::Array<ScriptDataV13> script;
    helpers::Array<TextResourceDataV13> textResource;

public:
    ResourceDataV13();
    ResourceDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV13(const ResourceDataV13 &p_other);
    ResourceDataV13 &operator=(const ResourceDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV13 {
    qword startingSequence;
    helpers::Array<SequenceDataV13> sequence;
    ResourceDataV13 resources;

public:
    SceneDataV13();
    SceneDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV13(const SceneDataV13 &p_other);
    SceneDataV13 &operator=(const SceneDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x40F9F03000000001 */

template <>
struct Gw2StructCSCN<12>{
struct PropertyDataV12 {
    qword value;
    helpers::FileName pathVal;
    byte type;

public:
    PropertyDataV12();
    PropertyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV12(const PropertyDataV12 &p_other);
    PropertyDataV12 &operator=(const PropertyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV12 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV12();
    CurveKeyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV12(const CurveKeyDataV12 &p_other);
    CurveKeyDataV12 &operator=(const CurveKeyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV12 {
    float time;
    float value;

public:
    FlagKeyDataV12();
    FlagKeyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV12(const FlagKeyDataV12 &p_other);
    FlagKeyDataV12 &operator=(const FlagKeyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV12 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV12();
    TriggerKeyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV12(const TriggerKeyDataV12 &p_other);
    TriggerKeyDataV12 &operator=(const TriggerKeyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV12 {
    qword name;
    helpers::Array<CurveKeyDataV12> curveKey;
    helpers::Array<FlagKeyDataV12> flagKey;
    helpers::Array<TriggerKeyDataV12> triggerKey;
    byte type;

public:
    TrackDataV12();
    TrackDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV12(const TrackDataV12 &p_other);
    TrackDataV12 &operator=(const TrackDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV12 {
    qword name;
    dword flags;
    helpers::Array<PropertyDataV12> prop;
    helpers::Array<TrackDataV12> track;
    byte type;

public:
    TrackGroupDataV12();
    TrackGroupDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV12(const TrackGroupDataV12 &p_other);
    TrackGroupDataV12 &operator=(const TrackGroupDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV12 {
    qword name;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    float length;
    helpers::Array<TrackGroupDataV12> trackGroup;

public:
    SequenceDataV12();
    SequenceDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV12(const SequenceDataV12 &p_other);
    SequenceDataV12 &operator=(const SequenceDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV12 {
    float intensity;
    byte3 color;

public:
    ColorDefDataV12();
    ColorDefDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV12(const ColorDefDataV12 &p_other);
    ColorDefDataV12 &operator=(const ColorDefDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV12 {
    ColorDefDataV12 ambientGroundColor;
    ColorDefDataV12 ambientSkyColor;
    ColorDefDataV12 fillColor;
    ColorDefDataV12 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV12();
    AmbientLightDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV12(const AmbientLightDataV12 &p_other);
    AmbientLightDataV12 &operator=(const AmbientLightDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV12 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV12();
    FileNameRefDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV12(const FileNameRefDataV12 &p_other);
    FileNameRefDataV12 &operator=(const FileNameRefDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV12 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV12();
    ScriptDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV12(const ScriptDataV12 &p_other);
    ScriptDataV12 &operator=(const ScriptDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV12 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV12();
    TextEntryDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV12(const TextEntryDataV12 &p_other);
    TextEntryDataV12 &operator=(const TextEntryDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV12 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV12> textEntry;

public:
    TextResourceDataV12();
    TextResourceDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV12(const TextResourceDataV12 &p_other);
    TextResourceDataV12 &operator=(const TextResourceDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV12 {
    dword crc;
    helpers::Array<AmbientLightDataV12> ambientLightResource;
    helpers::Array<FileNameRefDataV12> fileNameRef;
    helpers::Array<ScriptDataV12> script;
    helpers::Array<TextResourceDataV12> textResource;

public:
    ResourceDataV12();
    ResourceDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV12(const ResourceDataV12 &p_other);
    ResourceDataV12 &operator=(const ResourceDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV12 {
    qword startingSequence;
    helpers::Array<SequenceDataV12> sequence;
    ResourceDataV12 resources;

public:
    SceneDataV12();
    SceneDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV12(const SceneDataV12 &p_other);
    SceneDataV12 &operator=(const SceneDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x40F9EF7000000001 */

template <>
struct Gw2StructCSCN<11>{
struct PropertyDataV11 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV11();
    PropertyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV11(const PropertyDataV11 &p_other);
    PropertyDataV11 &operator=(const PropertyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV11 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV11();
    CurveKeyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV11(const CurveKeyDataV11 &p_other);
    CurveKeyDataV11 &operator=(const CurveKeyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV11 {
    float time;
    float value;

public:
    FlagKeyDataV11();
    FlagKeyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV11(const FlagKeyDataV11 &p_other);
    FlagKeyDataV11 &operator=(const FlagKeyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV11 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV11();
    TriggerKeyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV11(const TriggerKeyDataV11 &p_other);
    TriggerKeyDataV11 &operator=(const TriggerKeyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV11 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV11> curveKey;
    helpers::Array<FlagKeyDataV11> flagKey;
    helpers::Array<TriggerKeyDataV11> triggerKey;

public:
    TrackDataV11();
    TrackDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV11(const TrackDataV11 &p_other);
    TrackDataV11 &operator=(const TrackDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV11 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV11> prop;
    helpers::Array<TrackDataV11> track;

public:
    TrackGroupDataV11();
    TrackGroupDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV11(const TrackGroupDataV11 &p_other);
    TrackGroupDataV11 &operator=(const TrackGroupDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV11 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV11> trackGroup;

public:
    SequenceDataV11();
    SequenceDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV11(const SequenceDataV11 &p_other);
    SequenceDataV11 &operator=(const SequenceDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV11 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV11();
    ColorDefDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV11(const ColorDefDataV11 &p_other);
    ColorDefDataV11 &operator=(const ColorDefDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV11 {
    ColorDefDataV11 ambientGroundColor;
    ColorDefDataV11 ambientSkyColor;
    ColorDefDataV11 fillColor;
    ColorDefDataV11 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV11();
    AmbientLightDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV11(const AmbientLightDataV11 &p_other);
    AmbientLightDataV11 &operator=(const AmbientLightDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV11 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV11();
    FileNameRefDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV11(const FileNameRefDataV11 &p_other);
    FileNameRefDataV11 &operator=(const FileNameRefDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV11 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV11();
    ScriptDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV11(const ScriptDataV11 &p_other);
    ScriptDataV11 &operator=(const ScriptDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV11 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV11();
    TextEntryDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV11(const TextEntryDataV11 &p_other);
    TextEntryDataV11 &operator=(const TextEntryDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV11 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV11> textEntry;

public:
    TextResourceDataV11();
    TextResourceDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV11(const TextResourceDataV11 &p_other);
    TextResourceDataV11 &operator=(const TextResourceDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV11 {
    dword crc;
    helpers::Array<AmbientLightDataV11> ambientLightResource;
    helpers::Array<FileNameRefDataV11> fileNameRef;
    helpers::Array<ScriptDataV11> script;
    helpers::Array<TextResourceDataV11> textResource;

public:
    ResourceDataV11();
    ResourceDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV11(const ResourceDataV11 &p_other);
    ResourceDataV11 &operator=(const ResourceDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV11 {
    qword startingSequence;
    helpers::Array<SequenceDataV11> sequence;
    ResourceDataV11 resources;

public:
    SceneDataV11();
    SceneDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV11(const SceneDataV11 &p_other);
    SceneDataV11 &operator=(const SceneDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x40F9EF1000000001 */

template <>
struct Gw2StructCSCN<10>{
struct PropertyDataV10 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV10();
    PropertyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV10(const PropertyDataV10 &p_other);
    PropertyDataV10 &operator=(const PropertyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV10 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV10();
    CurveKeyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV10(const CurveKeyDataV10 &p_other);
    CurveKeyDataV10 &operator=(const CurveKeyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV10 {
    float time;
    float value;

public:
    FlagKeyDataV10();
    FlagKeyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV10(const FlagKeyDataV10 &p_other);
    FlagKeyDataV10 &operator=(const FlagKeyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV10 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV10();
    TriggerKeyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV10(const TriggerKeyDataV10 &p_other);
    TriggerKeyDataV10 &operator=(const TriggerKeyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV10 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV10> curveKey;
    helpers::Array<FlagKeyDataV10> flagKey;
    helpers::Array<TriggerKeyDataV10> triggerKey;

public:
    TrackDataV10();
    TrackDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV10(const TrackDataV10 &p_other);
    TrackDataV10 &operator=(const TrackDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV10 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV10> prop;
    helpers::Array<TrackDataV10> track;

public:
    TrackGroupDataV10();
    TrackGroupDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV10(const TrackGroupDataV10 &p_other);
    TrackGroupDataV10 &operator=(const TrackGroupDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV10 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV10> trackGroup;

public:
    SequenceDataV10();
    SequenceDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV10(const SequenceDataV10 &p_other);
    SequenceDataV10 &operator=(const SequenceDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV10 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV10();
    ColorDefDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV10(const ColorDefDataV10 &p_other);
    ColorDefDataV10 &operator=(const ColorDefDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV10 {
    ColorDefDataV10 ambientGroundColor;
    ColorDefDataV10 ambientSkyColor;
    ColorDefDataV10 fillColor;
    ColorDefDataV10 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV10();
    AmbientLightDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV10(const AmbientLightDataV10 &p_other);
    AmbientLightDataV10 &operator=(const AmbientLightDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV10 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV10();
    FileNameRefDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV10(const FileNameRefDataV10 &p_other);
    FileNameRefDataV10 &operator=(const FileNameRefDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV10 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV10();
    ScriptDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV10(const ScriptDataV10 &p_other);
    ScriptDataV10 &operator=(const ScriptDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV10 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV10();
    TextEntryDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV10(const TextEntryDataV10 &p_other);
    TextEntryDataV10 &operator=(const TextEntryDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV10 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV10> textEntry;

public:
    TextResourceDataV10();
    TextResourceDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV10(const TextResourceDataV10 &p_other);
    TextResourceDataV10 &operator=(const TextResourceDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV10 {
    dword crc;
    helpers::Array<AmbientLightDataV10> ambientLightResource;
    helpers::Array<FileNameRefDataV10> fileNameRef;
    helpers::Array<ScriptDataV10> script;
    helpers::Array<TextResourceDataV10> textResource;

public:
    ResourceDataV10();
    ResourceDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV10(const ResourceDataV10 &p_other);
    ResourceDataV10 &operator=(const ResourceDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV10 {
    qword startingSequence;
    helpers::Array<SequenceDataV10> sequence;
    ResourceDataV10 resources;

public:
    SceneDataV10();
    SceneDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV10(const SceneDataV10 &p_other);
    SceneDataV10 &operator=(const SceneDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x40F9EE5000000001 */

template <>
struct Gw2StructCSCN<9>{
struct PropertyDataV9 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV9();
    PropertyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV9(const PropertyDataV9 &p_other);
    PropertyDataV9 &operator=(const PropertyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV9 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV9();
    CurveKeyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV9(const CurveKeyDataV9 &p_other);
    CurveKeyDataV9 &operator=(const CurveKeyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV9 {
    float time;
    float value;

public:
    FlagKeyDataV9();
    FlagKeyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV9(const FlagKeyDataV9 &p_other);
    FlagKeyDataV9 &operator=(const FlagKeyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV9 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV9();
    TriggerKeyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV9(const TriggerKeyDataV9 &p_other);
    TriggerKeyDataV9 &operator=(const TriggerKeyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV9 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV9> curveKey;
    helpers::Array<FlagKeyDataV9> flagKey;
    helpers::Array<TriggerKeyDataV9> triggerKey;

public:
    TrackDataV9();
    TrackDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV9(const TrackDataV9 &p_other);
    TrackDataV9 &operator=(const TrackDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV9 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV9> prop;
    helpers::Array<TrackDataV9> track;

public:
    TrackGroupDataV9();
    TrackGroupDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV9(const TrackGroupDataV9 &p_other);
    TrackGroupDataV9 &operator=(const TrackGroupDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV9 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV9> trackGroup;

public:
    SequenceDataV9();
    SequenceDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV9(const SequenceDataV9 &p_other);
    SequenceDataV9 &operator=(const SequenceDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV9 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV9();
    ColorDefDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV9(const ColorDefDataV9 &p_other);
    ColorDefDataV9 &operator=(const ColorDefDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV9 {
    ColorDefDataV9 ambientGroundColor;
    ColorDefDataV9 ambientSkyColor;
    ColorDefDataV9 fillColor;
    ColorDefDataV9 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV9();
    AmbientLightDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV9(const AmbientLightDataV9 &p_other);
    AmbientLightDataV9 &operator=(const AmbientLightDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV9 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV9();
    FileNameRefDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV9(const FileNameRefDataV9 &p_other);
    FileNameRefDataV9 &operator=(const FileNameRefDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV9 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV9();
    ScriptDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV9(const ScriptDataV9 &p_other);
    ScriptDataV9 &operator=(const ScriptDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV9 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV9();
    TextEntryDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV9(const TextEntryDataV9 &p_other);
    TextEntryDataV9 &operator=(const TextEntryDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV9 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV9> textEntry;

public:
    TextResourceDataV9();
    TextResourceDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV9(const TextResourceDataV9 &p_other);
    TextResourceDataV9 &operator=(const TextResourceDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV9 {
    dword crc;
    helpers::Array<AmbientLightDataV9> ambientLightResource;
    helpers::Array<FileNameRefDataV9> fileNameRef;
    helpers::Array<ScriptDataV9> script;
    helpers::Array<TextResourceDataV9> textResource;

public:
    ResourceDataV9();
    ResourceDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV9(const ResourceDataV9 &p_other);
    ResourceDataV9 &operator=(const ResourceDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV9 {
    qword startingSequence;
    helpers::Array<SequenceDataV9> sequence;
    ResourceDataV9 resources;

public:
    SceneDataV9();
    SceneDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV9(const SceneDataV9 &p_other);
    SceneDataV9 &operator=(const SceneDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<8>{
struct PropertyDataV8 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV8();
    PropertyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV8(const PropertyDataV8 &p_other);
    PropertyDataV8 &operator=(const PropertyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV8 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV8();
    CurveKeyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV8(const CurveKeyDataV8 &p_other);
    CurveKeyDataV8 &operator=(const CurveKeyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV8 {
    float time;
    float value;

public:
    FlagKeyDataV8();
    FlagKeyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV8(const FlagKeyDataV8 &p_other);
    FlagKeyDataV8 &operator=(const FlagKeyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV8 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV8();
    TriggerKeyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV8(const TriggerKeyDataV8 &p_other);
    TriggerKeyDataV8 &operator=(const TriggerKeyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV8 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV8> curveKey;
    helpers::Array<FlagKeyDataV8> flagKey;
    helpers::Array<TriggerKeyDataV8> triggerKey;

public:
    TrackDataV8();
    TrackDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV8(const TrackDataV8 &p_other);
    TrackDataV8 &operator=(const TrackDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV8 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV8> prop;
    helpers::Array<TrackDataV8> track;

public:
    TrackGroupDataV8();
    TrackGroupDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV8(const TrackGroupDataV8 &p_other);
    TrackGroupDataV8 &operator=(const TrackGroupDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV8 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV8> trackGroup;

public:
    SequenceDataV8();
    SequenceDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV8(const SequenceDataV8 &p_other);
    SequenceDataV8 &operator=(const SequenceDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV8 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV8();
    ColorDefDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV8(const ColorDefDataV8 &p_other);
    ColorDefDataV8 &operator=(const ColorDefDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV8 {
    ColorDefDataV8 ambientGroundColor;
    ColorDefDataV8 ambientSkyColor;
    ColorDefDataV8 fillColor;
    ColorDefDataV8 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV8();
    AmbientLightDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV8(const AmbientLightDataV8 &p_other);
    AmbientLightDataV8 &operator=(const AmbientLightDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FileNameRefDataV8 {
    qword name;
    helpers::FileName fileName;

public:
    FileNameRefDataV8();
    FileNameRefDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FileNameRefDataV8(const FileNameRefDataV8 &p_other);
    FileNameRefDataV8 &operator=(const FileNameRefDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV8 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV8();
    ScriptDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV8(const ScriptDataV8 &p_other);
    ScriptDataV8 &operator=(const ScriptDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV8 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV8();
    TextEntryDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV8(const TextEntryDataV8 &p_other);
    TextEntryDataV8 &operator=(const TextEntryDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV8 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV8> textEntry;

public:
    TextResourceDataV8();
    TextResourceDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV8(const TextResourceDataV8 &p_other);
    TextResourceDataV8 &operator=(const TextResourceDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV8 {
    helpers::Array<AmbientLightDataV8> ambientLightResource;
    helpers::Array<FileNameRefDataV8> fileNameRef;
    helpers::Array<ScriptDataV8> script;
    helpers::Array<TextResourceDataV8> textResource;

public:
    ResourceDataV8();
    ResourceDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV8(const ResourceDataV8 &p_other);
    ResourceDataV8 &operator=(const ResourceDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV8 {
    qword startingSequence;
    helpers::Array<SequenceDataV8> sequence;
    ResourceDataV8 resources;

public:
    SceneDataV8();
    SceneDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV8(const SceneDataV8 &p_other);
    SceneDataV8 &operator=(const SceneDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x40F9ED4000000001 */

template <>
struct Gw2StructCSCN<7>{
struct PropertyDataV7 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV7();
    PropertyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV7(const PropertyDataV7 &p_other);
    PropertyDataV7 &operator=(const PropertyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV7 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV7();
    CurveKeyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV7(const CurveKeyDataV7 &p_other);
    CurveKeyDataV7 &operator=(const CurveKeyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV7 {
    float time;
    float value;

public:
    FlagKeyDataV7();
    FlagKeyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV7(const FlagKeyDataV7 &p_other);
    FlagKeyDataV7 &operator=(const FlagKeyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV7 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV7();
    TriggerKeyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV7(const TriggerKeyDataV7 &p_other);
    TriggerKeyDataV7 &operator=(const TriggerKeyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV7 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV7> curveKey;
    helpers::Array<FlagKeyDataV7> flagKey;
    helpers::Array<TriggerKeyDataV7> triggerKey;

public:
    TrackDataV7();
    TrackDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV7(const TrackDataV7 &p_other);
    TrackDataV7 &operator=(const TrackDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV7 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV7> prop;
    helpers::Array<TrackDataV7> track;

public:
    TrackGroupDataV7();
    TrackGroupDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV7(const TrackGroupDataV7 &p_other);
    TrackGroupDataV7 &operator=(const TrackGroupDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV7 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV7> trackGroup;

public:
    SequenceDataV7();
    SequenceDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV7(const SequenceDataV7 &p_other);
    SequenceDataV7 &operator=(const SequenceDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV7 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV7();
    ColorDefDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV7(const ColorDefDataV7 &p_other);
    ColorDefDataV7 &operator=(const ColorDefDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV7 {
    ColorDefDataV7 ambientGroundColor;
    ColorDefDataV7 ambientSkyColor;
    ColorDefDataV7 fillColor;
    ColorDefDataV7 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV7();
    AmbientLightDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV7(const AmbientLightDataV7 &p_other);
    AmbientLightDataV7 &operator=(const AmbientLightDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV7 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV7();
    ScriptDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV7(const ScriptDataV7 &p_other);
    ScriptDataV7 &operator=(const ScriptDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV7 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV7();
    TextEntryDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV7(const TextEntryDataV7 &p_other);
    TextEntryDataV7 &operator=(const TextEntryDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV7 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV7> textEntry;

public:
    TextResourceDataV7();
    TextResourceDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV7(const TextResourceDataV7 &p_other);
    TextResourceDataV7 &operator=(const TextResourceDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV7 {
    helpers::Array<AmbientLightDataV7> ambientLightResource;
    helpers::Array<ScriptDataV7> script;
    helpers::Array<TextResourceDataV7> textResource;

public:
    ResourceDataV7();
    ResourceDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV7(const ResourceDataV7 &p_other);
    ResourceDataV7 &operator=(const ResourceDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV7 {
    qword startingSequence;
    helpers::Array<SequenceDataV7> sequence;
    ResourceDataV7 resources;

public:
    SceneDataV7();
    SceneDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV7(const SceneDataV7 &p_other);
    SceneDataV7 &operator=(const SceneDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x40F9EC2000000001 */

template <>
struct Gw2StructCSCN<6>{
struct PropertyDataV6 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV6();
    PropertyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV6(const PropertyDataV6 &p_other);
    PropertyDataV6 &operator=(const PropertyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV6 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV6();
    CurveKeyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV6(const CurveKeyDataV6 &p_other);
    CurveKeyDataV6 &operator=(const CurveKeyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV6 {
    float time;
    float value;

public:
    FlagKeyDataV6();
    FlagKeyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV6(const FlagKeyDataV6 &p_other);
    FlagKeyDataV6 &operator=(const FlagKeyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV6 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV6();
    TriggerKeyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV6(const TriggerKeyDataV6 &p_other);
    TriggerKeyDataV6 &operator=(const TriggerKeyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV6 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV6> curveKey;
    helpers::Array<FlagKeyDataV6> flagKey;
    helpers::Array<TriggerKeyDataV6> triggerKey;

public:
    TrackDataV6();
    TrackDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV6(const TrackDataV6 &p_other);
    TrackDataV6 &operator=(const TrackDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV6 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV6> prop;
    helpers::Array<TrackDataV6> track;

public:
    TrackGroupDataV6();
    TrackGroupDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV6(const TrackGroupDataV6 &p_other);
    TrackGroupDataV6 &operator=(const TrackGroupDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV6 {
    qword name;
    float length;
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    helpers::Array<TrackGroupDataV6> trackGroup;

public:
    SequenceDataV6();
    SequenceDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV6(const SequenceDataV6 &p_other);
    SequenceDataV6 &operator=(const SequenceDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV6 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV6();
    ColorDefDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV6(const ColorDefDataV6 &p_other);
    ColorDefDataV6 &operator=(const ColorDefDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV6 {
    ColorDefDataV6 ambientGroundColor;
    ColorDefDataV6 ambientSkyColor;
    ColorDefDataV6 fillColor;
    ColorDefDataV6 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV6();
    AmbientLightDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV6(const AmbientLightDataV6 &p_other);
    AmbientLightDataV6 &operator=(const AmbientLightDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV6 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV6();
    ScriptDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV6(const ScriptDataV6 &p_other);
    ScriptDataV6 &operator=(const ScriptDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV6 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV6();
    TextEntryDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV6(const TextEntryDataV6 &p_other);
    TextEntryDataV6 &operator=(const TextEntryDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV6 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV6> textEntry;

public:
    TextResourceDataV6();
    TextResourceDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV6(const TextResourceDataV6 &p_other);
    TextResourceDataV6 &operator=(const TextResourceDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV6 {
    helpers::Array<AmbientLightDataV6> ambientLightResource;
    helpers::Array<ScriptDataV6> script;
    helpers::Array<TextResourceDataV6> textResource;

public:
    ResourceDataV6();
    ResourceDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV6(const ResourceDataV6 &p_other);
    ResourceDataV6 &operator=(const ResourceDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV6 {
    qword startingSequence;
    helpers::Array<SequenceDataV6> sequence;
    ResourceDataV6 resources;

public:
    SceneDataV6();
    SceneDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV6(const SceneDataV6 &p_other);
    SceneDataV6 &operator=(const SceneDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x40F9EB6000000001 */

template <>
struct Gw2StructCSCN<5>{
struct PropertyDataV5 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV5();
    PropertyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV5(const PropertyDataV5 &p_other);
    PropertyDataV5 &operator=(const PropertyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV5 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV5();
    CurveKeyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV5(const CurveKeyDataV5 &p_other);
    CurveKeyDataV5 &operator=(const CurveKeyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV5 {
    float time;
    float value;

public:
    FlagKeyDataV5();
    FlagKeyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV5(const FlagKeyDataV5 &p_other);
    FlagKeyDataV5 &operator=(const FlagKeyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV5 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV5();
    TriggerKeyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV5(const TriggerKeyDataV5 &p_other);
    TriggerKeyDataV5 &operator=(const TriggerKeyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV5 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV5> curveKey;
    helpers::Array<FlagKeyDataV5> flagKey;
    helpers::Array<TriggerKeyDataV5> triggerKey;

public:
    TrackDataV5();
    TrackDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV5(const TrackDataV5 &p_other);
    TrackDataV5 &operator=(const TrackDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV5 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV5> prop;
    helpers::Array<TrackDataV5> track;

public:
    TrackGroupDataV5();
    TrackGroupDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV5(const TrackGroupDataV5 &p_other);
    TrackGroupDataV5 &operator=(const TrackGroupDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV5 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV5> trackGroup;

public:
    SequenceDataV5();
    SequenceDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV5(const SequenceDataV5 &p_other);
    SequenceDataV5 &operator=(const SequenceDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV5 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV5();
    ColorDefDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV5(const ColorDefDataV5 &p_other);
    ColorDefDataV5 &operator=(const ColorDefDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV5 {
    ColorDefDataV5 ambientGroundColor;
    ColorDefDataV5 ambientSkyColor;
    ColorDefDataV5 fillColor;
    ColorDefDataV5 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV5();
    AmbientLightDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV5(const AmbientLightDataV5 &p_other);
    AmbientLightDataV5 &operator=(const AmbientLightDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV5 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV5();
    ScriptDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV5(const ScriptDataV5 &p_other);
    ScriptDataV5 &operator=(const ScriptDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV5 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV5();
    TextEntryDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV5(const TextEntryDataV5 &p_other);
    TextEntryDataV5 &operator=(const TextEntryDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV5 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV5> textEntry;

public:
    TextResourceDataV5();
    TextResourceDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV5(const TextResourceDataV5 &p_other);
    TextResourceDataV5 &operator=(const TextResourceDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV5 {
    helpers::Array<AmbientLightDataV5> ambientLightResource;
    helpers::Array<ScriptDataV5> script;
    helpers::Array<TextResourceDataV5> textResource;

public:
    ResourceDataV5();
    ResourceDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV5(const ResourceDataV5 &p_other);
    ResourceDataV5 &operator=(const ResourceDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV5 {
    qword startingSequence;
    helpers::Array<SequenceDataV5> sequence;
    ResourceDataV5 resources;

public:
    SceneDataV5();
    SceneDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV5(const SceneDataV5 &p_other);
    SceneDataV5 &operator=(const SceneDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x40F9EAA000000001 */

template <>
struct Gw2StructCSCN<4>{
struct PropertyDataV4 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV4();
    PropertyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV4(const PropertyDataV4 &p_other);
    PropertyDataV4 &operator=(const PropertyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV4 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV4();
    CurveKeyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV4(const CurveKeyDataV4 &p_other);
    CurveKeyDataV4 &operator=(const CurveKeyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV4 {
    float time;
    float value;

public:
    FlagKeyDataV4();
    FlagKeyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV4(const FlagKeyDataV4 &p_other);
    FlagKeyDataV4 &operator=(const FlagKeyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV4 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV4();
    TriggerKeyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV4(const TriggerKeyDataV4 &p_other);
    TriggerKeyDataV4 &operator=(const TriggerKeyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV4 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV4> curveKey;
    helpers::Array<FlagKeyDataV4> flagKey;
    helpers::Array<TriggerKeyDataV4> triggerKey;

public:
    TrackDataV4();
    TrackDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV4(const TrackDataV4 &p_other);
    TrackDataV4 &operator=(const TrackDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV4 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV4> prop;
    helpers::Array<TrackDataV4> track;

public:
    TrackGroupDataV4();
    TrackGroupDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV4(const TrackGroupDataV4 &p_other);
    TrackGroupDataV4 &operator=(const TrackGroupDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV4 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV4> trackGroup;

public:
    SequenceDataV4();
    SequenceDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV4(const SequenceDataV4 &p_other);
    SequenceDataV4 &operator=(const SequenceDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV4 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV4();
    ColorDefDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV4(const ColorDefDataV4 &p_other);
    ColorDefDataV4 &operator=(const ColorDefDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV4 {
    ColorDefDataV4 ambientGroundColor;
    ColorDefDataV4 ambientSkyColor;
    ColorDefDataV4 fillColor;
    ColorDefDataV4 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV4();
    AmbientLightDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV4(const AmbientLightDataV4 &p_other);
    AmbientLightDataV4 &operator=(const AmbientLightDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV4 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV4();
    ScriptDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV4(const ScriptDataV4 &p_other);
    ScriptDataV4 &operator=(const ScriptDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV4 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV4();
    TextEntryDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV4(const TextEntryDataV4 &p_other);
    TextEntryDataV4 &operator=(const TextEntryDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV4 {
    qword name;
    dword id;
    helpers::Array<TextEntryDataV4> textEntry;

public:
    TextResourceDataV4();
    TextResourceDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV4(const TextResourceDataV4 &p_other);
    TextResourceDataV4 &operator=(const TextResourceDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV4 {
    helpers::Array<AmbientLightDataV4> ambientLightResource;
    helpers::Array<ScriptDataV4> script;
    helpers::Array<TextResourceDataV4> textResource;

public:
    ResourceDataV4();
    ResourceDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV4(const ResourceDataV4 &p_other);
    ResourceDataV4 &operator=(const ResourceDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV4 {
    qword startingSequence;
    helpers::Array<SequenceDataV4> sequence;
    ResourceDataV4 resources;

public:
    SceneDataV4();
    SceneDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV4(const SceneDataV4 &p_other);
    SceneDataV4 &operator=(const SceneDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x40F9E9C000000001 */

template <>
struct Gw2StructCSCN<3>{
struct PropertyDataV3 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV3();
    PropertyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV3(const PropertyDataV3 &p_other);
    PropertyDataV3 &operator=(const PropertyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV3 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV3();
    CurveKeyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV3(const CurveKeyDataV3 &p_other);
    CurveKeyDataV3 &operator=(const CurveKeyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV3 {
    float time;
    float value;

public:
    FlagKeyDataV3();
    FlagKeyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV3(const FlagKeyDataV3 &p_other);
    FlagKeyDataV3 &operator=(const FlagKeyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV3 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV3();
    TriggerKeyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV3(const TriggerKeyDataV3 &p_other);
    TriggerKeyDataV3 &operator=(const TriggerKeyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV3 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV3> curveKey;
    helpers::Array<FlagKeyDataV3> flagKey;
    helpers::Array<TriggerKeyDataV3> triggerKey;

public:
    TrackDataV3();
    TrackDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV3(const TrackDataV3 &p_other);
    TrackDataV3 &operator=(const TrackDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV3 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV3> prop;
    helpers::Array<TrackDataV3> track;

public:
    TrackGroupDataV3();
    TrackGroupDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV3(const TrackGroupDataV3 &p_other);
    TrackGroupDataV3 &operator=(const TrackGroupDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV3 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV3> trackGroup;

public:
    SequenceDataV3();
    SequenceDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV3(const SequenceDataV3 &p_other);
    SequenceDataV3 &operator=(const SequenceDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV3 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV3();
    ColorDefDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV3(const ColorDefDataV3 &p_other);
    ColorDefDataV3 &operator=(const ColorDefDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV3 {
    ColorDefDataV3 ambientGroundColor;
    ColorDefDataV3 ambientSkyColor;
    ColorDefDataV3 fillColor;
    ColorDefDataV3 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV3();
    AmbientLightDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV3(const AmbientLightDataV3 &p_other);
    AmbientLightDataV3 &operator=(const AmbientLightDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV3 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV3();
    ScriptDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV3(const ScriptDataV3 &p_other);
    ScriptDataV3 &operator=(const ScriptDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV3 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV3();
    TextEntryDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV3(const TextEntryDataV3 &p_other);
    TextEntryDataV3 &operator=(const TextEntryDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV3 {
    qword name;
    helpers::Array<TextEntryDataV3> textEntry;

public:
    TextResourceDataV3();
    TextResourceDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV3(const TextResourceDataV3 &p_other);
    TextResourceDataV3 &operator=(const TextResourceDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV3 {
    helpers::Array<AmbientLightDataV3> ambientLightResource;
    helpers::Array<ScriptDataV3> script;
    helpers::Array<TextResourceDataV3> textResource;

public:
    ResourceDataV3();
    ResourceDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV3(const ResourceDataV3 &p_other);
    ResourceDataV3 &operator=(const ResourceDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV3 {
    qword startingSequence;
    helpers::Array<SequenceDataV3> sequence;
    ResourceDataV3 resources;

public:
    SceneDataV3();
    SceneDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV3(const SceneDataV3 &p_other);
    SceneDataV3 &operator=(const SceneDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<2>{
struct PropertyDataV2 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV2();
    PropertyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV2(const PropertyDataV2 &p_other);
    PropertyDataV2 &operator=(const PropertyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV2 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV2();
    CurveKeyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV2(const CurveKeyDataV2 &p_other);
    CurveKeyDataV2 &operator=(const CurveKeyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV2 {
    float time;
    float value;

public:
    FlagKeyDataV2();
    FlagKeyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV2(const FlagKeyDataV2 &p_other);
    FlagKeyDataV2 &operator=(const FlagKeyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV2 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV2();
    TriggerKeyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV2(const TriggerKeyDataV2 &p_other);
    TriggerKeyDataV2 &operator=(const TriggerKeyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV2 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV2> curveKey;
    helpers::Array<FlagKeyDataV2> flagKey;
    helpers::Array<TriggerKeyDataV2> triggerKey;

public:
    TrackDataV2();
    TrackDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV2(const TrackDataV2 &p_other);
    TrackDataV2 &operator=(const TrackDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV2 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV2> prop;
    helpers::Array<TrackDataV2> track;

public:
    TrackGroupDataV2();
    TrackGroupDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV2(const TrackGroupDataV2 &p_other);
    TrackGroupDataV2 &operator=(const TrackGroupDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV2 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV2> trackGroup;

public:
    SequenceDataV2();
    SequenceDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV2(const SequenceDataV2 &p_other);
    SequenceDataV2 &operator=(const SequenceDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV2 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV2();
    ColorDefDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV2(const ColorDefDataV2 &p_other);
    ColorDefDataV2 &operator=(const ColorDefDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV2 {
    ColorDefDataV2 ambientGroundColor;
    ColorDefDataV2 ambientSkyColor;
    ColorDefDataV2 fillColor;
    ColorDefDataV2 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV2();
    AmbientLightDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV2(const AmbientLightDataV2 &p_other);
    AmbientLightDataV2 &operator=(const AmbientLightDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV2 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV2();
    ScriptDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV2(const ScriptDataV2 &p_other);
    ScriptDataV2 &operator=(const ScriptDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV2 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV2();
    TextEntryDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV2(const TextEntryDataV2 &p_other);
    TextEntryDataV2 &operator=(const TextEntryDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV2 {
    qword name;
    helpers::Array<TextEntryDataV2> textEntry;

public:
    TextResourceDataV2();
    TextResourceDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV2(const TextResourceDataV2 &p_other);
    TextResourceDataV2 &operator=(const TextResourceDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV2 {
    helpers::Array<AmbientLightDataV2> ambientLightResource;
    helpers::Array<ScriptDataV2> script;
    helpers::Array<TextResourceDataV2> textResource;

public:
    ResourceDataV2();
    ResourceDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV2(const ResourceDataV2 &p_other);
    ResourceDataV2 &operator=(const ResourceDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV2 {
    qword startingSequence;
    helpers::Array<SequenceDataV2> sequence;
    ResourceDataV2 resources;

public:
    SceneDataV2();
    SceneDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV2(const SceneDataV2 &p_other);
    SceneDataV2 &operator=(const SceneDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x40F9E87000000001 */

template <>
struct Gw2StructCSCN<1>{
struct PropertyDataV1 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV1();
    PropertyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV1(const PropertyDataV1 &p_other);
    PropertyDataV1 &operator=(const PropertyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV1 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV1();
    CurveKeyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV1(const CurveKeyDataV1 &p_other);
    CurveKeyDataV1 &operator=(const CurveKeyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV1 {
    float time;
    float value;

public:
    FlagKeyDataV1();
    FlagKeyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV1(const FlagKeyDataV1 &p_other);
    FlagKeyDataV1 &operator=(const FlagKeyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV1 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV1();
    TriggerKeyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV1(const TriggerKeyDataV1 &p_other);
    TriggerKeyDataV1 &operator=(const TriggerKeyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV1 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV1> curveKey;
    helpers::Array<FlagKeyDataV1> flagKey;
    helpers::Array<TriggerKeyDataV1> triggerKey;

public:
    TrackDataV1();
    TrackDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV1(const TrackDataV1 &p_other);
    TrackDataV1 &operator=(const TrackDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV1 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV1> prop;
    helpers::Array<TrackDataV1> track;

public:
    TrackGroupDataV1();
    TrackGroupDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV1(const TrackGroupDataV1 &p_other);
    TrackGroupDataV1 &operator=(const TrackGroupDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV1 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV1> trackGroup;

public:
    SequenceDataV1();
    SequenceDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV1(const SequenceDataV1 &p_other);
    SequenceDataV1 &operator=(const SequenceDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV1 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV1();
    ColorDefDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV1(const ColorDefDataV1 &p_other);
    ColorDefDataV1 &operator=(const ColorDefDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV1 {
    ColorDefDataV1 ambientGroundColor;
    ColorDefDataV1 ambientSkyColor;
    ColorDefDataV1 fillColor;
    ColorDefDataV1 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV1();
    AmbientLightDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV1(const AmbientLightDataV1 &p_other);
    AmbientLightDataV1 &operator=(const AmbientLightDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScriptDataV1 {
    qword name;
    helpers::Array<byte> byteCode;

public:
    ScriptDataV1();
    ScriptDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScriptDataV1(const ScriptDataV1 &p_other);
    ScriptDataV1 &operator=(const ScriptDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV1 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV1();
    TextEntryDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV1(const TextEntryDataV1 &p_other);
    TextEntryDataV1 &operator=(const TextEntryDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV1 {
    qword name;
    helpers::Array<TextEntryDataV1> textEntry;

public:
    TextResourceDataV1();
    TextResourceDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV1(const TextResourceDataV1 &p_other);
    TextResourceDataV1 &operator=(const TextResourceDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV1 {
    helpers::Array<AmbientLightDataV1> ambientLightResource;
    helpers::Array<ScriptDataV1> script;
    helpers::Array<TextResourceDataV1> textResource;

public:
    ResourceDataV1();
    ResourceDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV1(const ResourceDataV1 &p_other);
    ResourceDataV1 &operator=(const ResourceDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV1 {
    helpers::Array<SequenceDataV1> sequence;
    ResourceDataV1 resources;

public:
    SceneDataV1();
    SceneDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV1(const SceneDataV1 &p_other);
    SceneDataV1 &operator=(const SceneDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCSCN<0>{
struct PropertyDataV0 {
    byte type;
    qword value;
    helpers::FileName pathVal;

public:
    PropertyDataV0();
    PropertyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PropertyDataV0(const PropertyDataV0 &p_other);
    PropertyDataV0 &operator=(const PropertyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CurveKeyDataV0 {
    float time;
    float value;
    float inTangent;
    float outTangent;

public:
    CurveKeyDataV0();
    CurveKeyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CurveKeyDataV0(const CurveKeyDataV0 &p_other);
    CurveKeyDataV0 &operator=(const CurveKeyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct FlagKeyDataV0 {
    float time;
    float value;

public:
    FlagKeyDataV0();
    FlagKeyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    FlagKeyDataV0(const FlagKeyDataV0 &p_other);
    FlagKeyDataV0 &operator=(const FlagKeyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TriggerKeyDataV0 {
    float time;
    byte flags1;
    byte flags2;
    byte flags3;
    byte flags4;
    qword token1;
    qword token2;
    float value1;
    float value2;
    float value3;
    float value4;

public:
    TriggerKeyDataV0();
    TriggerKeyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TriggerKeyDataV0(const TriggerKeyDataV0 &p_other);
    TriggerKeyDataV0 &operator=(const TriggerKeyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackDataV0 {
    qword name;
    byte type;
    helpers::Array<CurveKeyDataV0> curveKey;
    helpers::Array<FlagKeyDataV0> flagKey;
    helpers::Array<TriggerKeyDataV0> triggerKey;

public:
    TrackDataV0();
    TrackDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackDataV0(const TrackDataV0 &p_other);
    TrackDataV0 &operator=(const TrackDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TrackGroupDataV0 {
    qword name;
    byte type;
    dword flags;
    helpers::Array<PropertyDataV0> prop;
    helpers::Array<TrackDataV0> track;

public:
    TrackGroupDataV0();
    TrackGroupDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TrackGroupDataV0(const TrackGroupDataV0 &p_other);
    TrackGroupDataV0 &operator=(const TrackGroupDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SequenceDataV0 {
    helpers::FileName environmentMap;
    helpers::WString map;
    helpers::WString clientMap;
    qword name;
    float length;
    helpers::Array<TrackGroupDataV0> trackGroup;

public:
    SequenceDataV0();
    SequenceDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SequenceDataV0(const SequenceDataV0 &p_other);
    SequenceDataV0 &operator=(const SequenceDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ColorDefDataV0 {
    byte3 color;
    float intensity;

public:
    ColorDefDataV0();
    ColorDefDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ColorDefDataV0(const ColorDefDataV0 &p_other);
    ColorDefDataV0 &operator=(const ColorDefDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct AmbientLightDataV0 {
    ColorDefDataV0 ambientGroundColor;
    ColorDefDataV0 ambientSkyColor;
    ColorDefDataV0 fillColor;
    ColorDefDataV0 hemisphericalColor;
    qword name;

public:
    AmbientLightDataV0();
    AmbientLightDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    AmbientLightDataV0(const AmbientLightDataV0 &p_other);
    AmbientLightDataV0 &operator=(const AmbientLightDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextEntryDataV0 {
    helpers::WString text;
    byte language;

public:
    TextEntryDataV0();
    TextEntryDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextEntryDataV0(const TextEntryDataV0 &p_other);
    TextEntryDataV0 &operator=(const TextEntryDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct TextResourceDataV0 {
    qword name;
    helpers::Array<TextEntryDataV0> textEntry;

public:
    TextResourceDataV0();
    TextResourceDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    TextResourceDataV0(const TextResourceDataV0 &p_other);
    TextResourceDataV0 &operator=(const TextResourceDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ResourceDataV0 {
    helpers::Array<AmbientLightDataV0> ambientLightResource;
    helpers::Array<TextResourceDataV0> textResource;

public:
    ResourceDataV0();
    ResourceDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ResourceDataV0(const ResourceDataV0 &p_other);
    ResourceDataV0 &operator=(const ResourceDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneDataV0 {
    helpers::Array<SequenceDataV0> sequence;
    ResourceDataV0 resources;

public:
    SceneDataV0();
    SceneDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneDataV0(const SceneDataV0 &p_other);
    SceneDataV0 &operator=(const SceneDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: havk, versions: 17, strucTab: 0x1420EFFE0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structhavk;

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<16>{
struct PackMoppType {
    helpers::Array<byte> moppData;

public:
    PackMoppType();
    PackMoppType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMoppType(const PackMoppType &p_other);
    PackMoppType &operator=(const PackMoppType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideCollisionV16 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<word> surfaces;
    PackMoppType moppCodeData;

public:
    PackMapCollideCollisionV16();
    PackMapCollideCollisionV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideCollisionV16(const PackMapCollideCollisionV16 &p_other);
    PackMapCollideCollisionV16 &operator=(const PackMapCollideCollisionV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideBlockerV16 {
    helpers::Array<float3> vertices;

public:
    PackMapCollideBlockerV16();
    PackMapCollideBlockerV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideBlockerV16(const PackMapCollideBlockerV16 &p_other);
    PackMapCollideBlockerV16 &operator=(const PackMapCollideBlockerV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAnimationV16 {
    qword sequence;
    helpers::Array<dword> collisionIndices;
    helpers::Array<dword> blockerIndices;

public:
    PackMapCollideAnimationV16();
    PackMapCollideAnimationV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAnimationV16(const PackMapCollideAnimationV16 &p_other);
    PackMapCollideAnimationV16 &operator=(const PackMapCollideAnimationV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV16 {
    byte quantizedExtents;
    helpers::Array<dword> animations;
    word navMeshIndex;

public:
    PackMapCollideGeometryV16();
    PackMapCollideGeometryV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV16(const PackMapCollideGeometryV16 &p_other);
    PackMapCollideGeometryV16 &operator=(const PackMapCollideGeometryV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV16 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV16();
    PackMapCollideModelObsV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV16(const PackMapCollideModelObsV16 &p_other);
    PackMapCollideModelObsV16 &operator=(const PackMapCollideModelObsV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV16 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV16();
    PackMapCollideModelPropV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV16(const PackMapCollideModelPropV16 &p_other);
    PackMapCollideModelPropV16 &operator=(const PackMapCollideModelPropV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV16 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV16();
    PackMapCollideModelZoneV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV16(const PackMapCollideModelZoneV16 &p_other);
    PackMapCollideModelZoneV16 &operator=(const PackMapCollideModelZoneV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideWaterVolumeV16 {
    qword guid;
    helpers::WString name;
    dword flags;
    float2 verticalRange;
    helpers::Array<float2> vertices;

public:
    PackMapCollideWaterVolumeV16();
    PackMapCollideWaterVolumeV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideWaterVolumeV16(const PackMapCollideWaterVolumeV16 &p_other);
    PackMapCollideWaterVolumeV16 &operator=(const PackMapCollideWaterVolumeV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV16 {
    float3 boundsMin;
    float3 boundsMax;
    dword flags;
    float waterSurfaceZ;
    helpers::Array<PackMapCollideCollisionV16> collisions;
    helpers::Array<PackMapCollideBlockerV16> blockers;
    helpers::Array<PackMapCollideAnimationV16> animations;
    helpers::Array<PackMapCollideGeometryV16> geometries;
    helpers::Array<PackMapCollideModelObsV16> obsModels;
    helpers::Array<PackMapCollideModelPropV16> propModels;
    helpers::Array<PackMapCollideModelZoneV16> zoneModels;
    helpers::Array<PackMapCollideWaterVolumeV16> waterVolumes;

public:
    PackMapCollideV16();
    PackMapCollideV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV16(const PackMapCollideV16 &p_other);
    PackMapCollideV16 &operator=(const PackMapCollideV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x4104FEC000000001 */

template <>
struct Gw2Structhavk<15>{
struct PackMoppType {
    helpers::Array<byte> moppData;

public:
    PackMoppType();
    PackMoppType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMoppType(const PackMoppType &p_other);
    PackMoppType &operator=(const PackMoppType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideCollisionV15 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<word> surfaces;
    PackMoppType moppCodeData;

public:
    PackMapCollideCollisionV15();
    PackMapCollideCollisionV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideCollisionV15(const PackMapCollideCollisionV15 &p_other);
    PackMapCollideCollisionV15 &operator=(const PackMapCollideCollisionV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideBlockerV15 {
    helpers::Array<float3> vertices;

public:
    PackMapCollideBlockerV15();
    PackMapCollideBlockerV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideBlockerV15(const PackMapCollideBlockerV15 &p_other);
    PackMapCollideBlockerV15 &operator=(const PackMapCollideBlockerV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAnimationV15 {
    qword sequence;
    helpers::Array<dword> collisionIndices;
    helpers::Array<dword> blockerIndices;

public:
    PackMapCollideAnimationV15();
    PackMapCollideAnimationV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAnimationV15(const PackMapCollideAnimationV15 &p_other);
    PackMapCollideAnimationV15 &operator=(const PackMapCollideAnimationV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV15 {
    byte quantizedExtents;
    helpers::Array<dword> animations;
    word navMeshIndex;

public:
    PackMapCollideGeometryV15();
    PackMapCollideGeometryV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV15(const PackMapCollideGeometryV15 &p_other);
    PackMapCollideGeometryV15 &operator=(const PackMapCollideGeometryV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV15 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV15();
    PackMapCollideModelObsV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV15(const PackMapCollideModelObsV15 &p_other);
    PackMapCollideModelObsV15 &operator=(const PackMapCollideModelObsV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV15 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV15();
    PackMapCollideModelPropV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV15(const PackMapCollideModelPropV15 &p_other);
    PackMapCollideModelPropV15 &operator=(const PackMapCollideModelPropV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV15 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV15();
    PackMapCollideModelZoneV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV15(const PackMapCollideModelZoneV15 &p_other);
    PackMapCollideModelZoneV15 &operator=(const PackMapCollideModelZoneV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideWaterVolumeV15 {
    qword guid;
    dword flags;
    float2 verticalRange;
    helpers::Array<float2> vertices;

public:
    PackMapCollideWaterVolumeV15();
    PackMapCollideWaterVolumeV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideWaterVolumeV15(const PackMapCollideWaterVolumeV15 &p_other);
    PackMapCollideWaterVolumeV15 &operator=(const PackMapCollideWaterVolumeV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV15 {
    float3 boundsMin;
    float3 boundsMax;
    dword flags;
    float waterSurfaceZ;
    helpers::Array<PackMapCollideCollisionV15> collisions;
    helpers::Array<PackMapCollideBlockerV15> blockers;
    helpers::Array<PackMapCollideAnimationV15> animations;
    helpers::Array<PackMapCollideGeometryV15> geometries;
    helpers::Array<PackMapCollideModelObsV15> obsModels;
    helpers::Array<PackMapCollideModelPropV15> propModels;
    helpers::Array<PackMapCollideModelZoneV15> zoneModels;
    helpers::Array<PackMapCollideWaterVolumeV15> waterVolumes;

public:
    PackMapCollideV15();
    PackMapCollideV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV15(const PackMapCollideV15 &p_other);
    PackMapCollideV15 &operator=(const PackMapCollideV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x4104FE3000000001 */

template <>
struct Gw2Structhavk<14>{
struct PackMoppType {
    helpers::Array<byte> moppData;

public:
    PackMoppType();
    PackMoppType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMoppType(const PackMoppType &p_other);
    PackMoppType &operator=(const PackMoppType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideCollisionV14 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<word> surfaces;
    PackMoppType moppCodeData;

public:
    PackMapCollideCollisionV14();
    PackMapCollideCollisionV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideCollisionV14(const PackMapCollideCollisionV14 &p_other);
    PackMapCollideCollisionV14 &operator=(const PackMapCollideCollisionV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideBlockerV14 {
    helpers::Array<float3> vertices;

public:
    PackMapCollideBlockerV14();
    PackMapCollideBlockerV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideBlockerV14(const PackMapCollideBlockerV14 &p_other);
    PackMapCollideBlockerV14 &operator=(const PackMapCollideBlockerV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideNavMeshV14 {
    helpers::Array<byte> navMesh;
    helpers::Array<byte> graph;
    helpers::Array<byte> mediator;

public:
    PackMapCollideNavMeshV14();
    PackMapCollideNavMeshV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideNavMeshV14(const PackMapCollideNavMeshV14 &p_other);
    PackMapCollideNavMeshV14 &operator=(const PackMapCollideNavMeshV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAnimationV14 {
    qword sequence;
    helpers::Array<dword> collisionIndices;
    helpers::Array<dword> blockerIndices;

public:
    PackMapCollideAnimationV14();
    PackMapCollideAnimationV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAnimationV14(const PackMapCollideAnimationV14 &p_other);
    PackMapCollideAnimationV14 &operator=(const PackMapCollideAnimationV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV14 {
    byte quantizedExtents;
    helpers::Array<dword> animations;
    word navMeshIndex;

public:
    PackMapCollideGeometryV14();
    PackMapCollideGeometryV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV14(const PackMapCollideGeometryV14 &p_other);
    PackMapCollideGeometryV14 &operator=(const PackMapCollideGeometryV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV14 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV14();
    PackMapCollideModelObsV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV14(const PackMapCollideModelObsV14 &p_other);
    PackMapCollideModelObsV14 &operator=(const PackMapCollideModelObsV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV14 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV14();
    PackMapCollideModelPropV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV14(const PackMapCollideModelPropV14 &p_other);
    PackMapCollideModelPropV14 &operator=(const PackMapCollideModelPropV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV14 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV14();
    PackMapCollideModelZoneV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV14(const PackMapCollideModelZoneV14 &p_other);
    PackMapCollideModelZoneV14 &operator=(const PackMapCollideModelZoneV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV14 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideCollisionV14> collisions;
    helpers::Array<PackMapCollideBlockerV14> blockers;
    helpers::Array<PackMapCollideNavMeshV14> navMeshes;
    helpers::Array<PackMapCollideAnimationV14> animations;
    helpers::Array<PackMapCollideGeometryV14> geometries;
    helpers::Array<PackMapCollideModelObsV14> obsModels;
    helpers::Array<PackMapCollideModelPropV14> propModels;
    helpers::Array<PackMapCollideModelZoneV14> zoneModels;

public:
    PackMapCollideV14();
    PackMapCollideV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV14(const PackMapCollideV14 &p_other);
    PackMapCollideV14 &operator=(const PackMapCollideV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x4104F9F000000001 */

template <>
struct Gw2Structhavk<13>{
struct PackMapCollideCollisionV13 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<word> surfaces;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideCollisionV13();
    PackMapCollideCollisionV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideCollisionV13(const PackMapCollideCollisionV13 &p_other);
    PackMapCollideCollisionV13 &operator=(const PackMapCollideCollisionV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideBlockerV13 {
    helpers::Array<float3> vertices;

public:
    PackMapCollideBlockerV13();
    PackMapCollideBlockerV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideBlockerV13(const PackMapCollideBlockerV13 &p_other);
    PackMapCollideBlockerV13 &operator=(const PackMapCollideBlockerV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAnimationV13 {
    qword sequence;
    helpers::Array<dword> collisionIndices;
    helpers::Array<dword> blockerIndices;

public:
    PackMapCollideAnimationV13();
    PackMapCollideAnimationV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAnimationV13(const PackMapCollideAnimationV13 &p_other);
    PackMapCollideAnimationV13 &operator=(const PackMapCollideAnimationV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV13 {
    byte quantizedExtents;
    helpers::Array<dword> animations;

public:
    PackMapCollideGeometryV13();
    PackMapCollideGeometryV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV13(const PackMapCollideGeometryV13 &p_other);
    PackMapCollideGeometryV13 &operator=(const PackMapCollideGeometryV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV13 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV13();
    PackMapCollideModelObsV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV13(const PackMapCollideModelObsV13 &p_other);
    PackMapCollideModelObsV13 &operator=(const PackMapCollideModelObsV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV13 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV13();
    PackMapCollideModelPropV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV13(const PackMapCollideModelPropV13 &p_other);
    PackMapCollideModelPropV13 &operator=(const PackMapCollideModelPropV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV13 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV13();
    PackMapCollideModelZoneV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV13(const PackMapCollideModelZoneV13 &p_other);
    PackMapCollideModelZoneV13 &operator=(const PackMapCollideModelZoneV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV13 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideCollisionV13> collisions;
    helpers::Array<PackMapCollideBlockerV13> blockers;
    helpers::Array<PackMapCollideAnimationV13> animations;
    helpers::Array<PackMapCollideGeometryV13> geometries;
    helpers::Array<PackMapCollideModelObsV13> obsModels;
    helpers::Array<PackMapCollideModelPropV13> propModels;
    helpers::Array<PackMapCollideModelZoneV13> zoneModels;

public:
    PackMapCollideV13();
    PackMapCollideV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV13(const PackMapCollideV13 &p_other);
    PackMapCollideV13 &operator=(const PackMapCollideV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<12>{
struct PackMapCollideMeshV12 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<word> surfaces;
    float moppCodeScale;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideMeshV12();
    PackMapCollideMeshV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV12(const PackMapCollideMeshV12 &p_other);
    PackMapCollideMeshV12 &operator=(const PackMapCollideMeshV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV12 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV12();
    PackMapCollideMeshRefV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV12(const PackMapCollideMeshRefV12 &p_other);
    PackMapCollideMeshRefV12 &operator=(const PackMapCollideMeshRefV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV12 {
    byte quantizedExtents;
    helpers::Array<PackMapCollideMeshRefV12> meshRefs;

public:
    PackMapCollideGeometryV12();
    PackMapCollideGeometryV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV12(const PackMapCollideGeometryV12 &p_other);
    PackMapCollideGeometryV12 &operator=(const PackMapCollideGeometryV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV12 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV12();
    PackMapCollideModelObsV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV12(const PackMapCollideModelObsV12 &p_other);
    PackMapCollideModelObsV12 &operator=(const PackMapCollideModelObsV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV12 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV12();
    PackMapCollideModelPropV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV12(const PackMapCollideModelPropV12 &p_other);
    PackMapCollideModelPropV12 &operator=(const PackMapCollideModelPropV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV12 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV12();
    PackMapCollideModelZoneV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV12(const PackMapCollideModelZoneV12 &p_other);
    PackMapCollideModelZoneV12 &operator=(const PackMapCollideModelZoneV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV12 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapCollideAiChunkV12();
    PackMapCollideAiChunkV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV12(const PackMapCollideAiChunkV12 &p_other);
    PackMapCollideAiChunkV12 &operator=(const PackMapCollideAiChunkV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV12 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMeshV12> meshes;
    helpers::Array<PackMapCollideGeometryV12> geometries;
    helpers::Array<PackMapCollideModelObsV12> obsModels;
    helpers::Array<PackMapCollideModelPropV12> propModels;
    helpers::Array<PackMapCollideModelZoneV12> zoneModels;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV12> aiChunks;

public:
    PackMapCollideV12();
    PackMapCollideV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV12(const PackMapCollideV12 &p_other);
    PackMapCollideV12 &operator=(const PackMapCollideV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<11>{
struct PackMapCollideMeshV11 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float moppCodeScale;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideMeshV11();
    PackMapCollideMeshV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV11(const PackMapCollideMeshV11 &p_other);
    PackMapCollideMeshV11 &operator=(const PackMapCollideMeshV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV11 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV11();
    PackMapCollideMeshRefV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV11(const PackMapCollideMeshRefV11 &p_other);
    PackMapCollideMeshRefV11 &operator=(const PackMapCollideMeshRefV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV11 {
    byte quantizedExtents;
    helpers::Array<PackMapCollideMeshRefV11> meshRefs;

public:
    PackMapCollideGeometryV11();
    PackMapCollideGeometryV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV11(const PackMapCollideGeometryV11 &p_other);
    PackMapCollideGeometryV11 &operator=(const PackMapCollideGeometryV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV11 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapCollideModelObsV11();
    PackMapCollideModelObsV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV11(const PackMapCollideModelObsV11 &p_other);
    PackMapCollideModelObsV11 &operator=(const PackMapCollideModelObsV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV11 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV11();
    PackMapCollideModelPropV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV11(const PackMapCollideModelPropV11 &p_other);
    PackMapCollideModelPropV11 &operator=(const PackMapCollideModelPropV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV11 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV11();
    PackMapCollideModelZoneV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV11(const PackMapCollideModelZoneV11 &p_other);
    PackMapCollideModelZoneV11 &operator=(const PackMapCollideModelZoneV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV11 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapCollideAiChunkV11();
    PackMapCollideAiChunkV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV11(const PackMapCollideAiChunkV11 &p_other);
    PackMapCollideAiChunkV11 &operator=(const PackMapCollideAiChunkV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV11 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMeshV11> meshes;
    helpers::Array<PackMapCollideGeometryV11> geometries;
    helpers::Array<PackMapCollideModelObsV11> obsModels;
    helpers::Array<PackMapCollideModelPropV11> propModels;
    helpers::Array<PackMapCollideModelZoneV11> zoneModels;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV11> aiChunks;

public:
    PackMapCollideV11();
    PackMapCollideV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV11(const PackMapCollideV11 &p_other);
    PackMapCollideV11 &operator=(const PackMapCollideV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<10>{
struct PackMapCollideMeshV10 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float moppCodeScale;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideMeshV10();
    PackMapCollideMeshV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV10(const PackMapCollideMeshV10 &p_other);
    PackMapCollideMeshV10 &operator=(const PackMapCollideMeshV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV10 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV10();
    PackMapCollideMeshRefV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV10(const PackMapCollideMeshRefV10 &p_other);
    PackMapCollideMeshRefV10 &operator=(const PackMapCollideMeshRefV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV10 {
    helpers::Array<PackMapCollideMeshRefV10> meshRefs;

public:
    PackMapCollideGeometryV10();
    PackMapCollideGeometryV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV10(const PackMapCollideGeometryV10 &p_other);
    PackMapCollideGeometryV10 &operator=(const PackMapCollideGeometryV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV10 {
    dword geometryIndex;

public:
    PackMapCollideModelObsV10();
    PackMapCollideModelObsV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV10(const PackMapCollideModelObsV10 &p_other);
    PackMapCollideModelObsV10 &operator=(const PackMapCollideModelObsV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV10 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV10();
    PackMapCollideModelPropV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV10(const PackMapCollideModelPropV10 &p_other);
    PackMapCollideModelPropV10 &operator=(const PackMapCollideModelPropV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV10 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV10();
    PackMapCollideModelZoneV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV10(const PackMapCollideModelZoneV10 &p_other);
    PackMapCollideModelZoneV10 &operator=(const PackMapCollideModelZoneV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV10 {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapCollideAiChunkV10();
    PackMapCollideAiChunkV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV10(const PackMapCollideAiChunkV10 &p_other);
    PackMapCollideAiChunkV10 &operator=(const PackMapCollideAiChunkV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV10 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMeshV10> meshes;
    helpers::Array<PackMapCollideGeometryV10> geometries;
    helpers::Array<PackMapCollideModelObsV10> obsModels;
    helpers::Array<PackMapCollideModelPropV10> propModels;
    helpers::Array<PackMapCollideModelZoneV10> zoneModels;
    float3 aiBoundaryMin;
    float3 aiBoundaryMax;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV10> aiChunks;

public:
    PackMapCollideV10();
    PackMapCollideV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV10(const PackMapCollideV10 &p_other);
    PackMapCollideV10 &operator=(const PackMapCollideV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<9>{
struct PackMapCollideMeshV9 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float moppCodeScale;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideMeshV9();
    PackMapCollideMeshV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV9(const PackMapCollideMeshV9 &p_other);
    PackMapCollideMeshV9 &operator=(const PackMapCollideMeshV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV9 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV9();
    PackMapCollideMeshRefV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV9(const PackMapCollideMeshRefV9 &p_other);
    PackMapCollideMeshRefV9 &operator=(const PackMapCollideMeshRefV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV9 {
    helpers::Array<PackMapCollideMeshRefV9> meshRefs;

public:
    PackMapCollideGeometryV9();
    PackMapCollideGeometryV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV9(const PackMapCollideGeometryV9 &p_other);
    PackMapCollideGeometryV9 &operator=(const PackMapCollideGeometryV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelObsV9 {
    dword geometryIndex;

public:
    PackMapCollideModelObsV9();
    PackMapCollideModelObsV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelObsV9(const PackMapCollideModelObsV9 &p_other);
    PackMapCollideModelObsV9 &operator=(const PackMapCollideModelObsV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV9 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV9();
    PackMapCollideModelPropV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV9(const PackMapCollideModelPropV9 &p_other);
    PackMapCollideModelPropV9 &operator=(const PackMapCollideModelPropV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV9 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV9();
    PackMapCollideModelZoneV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV9(const PackMapCollideModelZoneV9 &p_other);
    PackMapCollideModelZoneV9 &operator=(const PackMapCollideModelZoneV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV9 {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;

public:
    PackMapCollideAiChunkV9();
    PackMapCollideAiChunkV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV9(const PackMapCollideAiChunkV9 &p_other);
    PackMapCollideAiChunkV9 &operator=(const PackMapCollideAiChunkV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV9 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMeshV9> meshes;
    helpers::Array<PackMapCollideGeometryV9> geometries;
    helpers::Array<PackMapCollideModelObsV9> obsModels;
    helpers::Array<PackMapCollideModelPropV9> propModels;
    helpers::Array<PackMapCollideModelZoneV9> zoneModels;
    float3 aiBoundaryMin;
    float3 aiBoundaryMax;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV9> aiChunks;

public:
    PackMapCollideV9();
    PackMapCollideV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV9(const PackMapCollideV9 &p_other);
    PackMapCollideV9 &operator=(const PackMapCollideV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x4104FED000000001 */

template <>
struct Gw2Structhavk<8>{
struct PackMapCollideMeshV8 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float moppCodeScale;
    helpers::Array<byte> moppCodeData;

public:
    PackMapCollideMeshV8();
    PackMapCollideMeshV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV8(const PackMapCollideMeshV8 &p_other);
    PackMapCollideMeshV8 &operator=(const PackMapCollideMeshV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV8 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV8();
    PackMapCollideMeshRefV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV8(const PackMapCollideMeshRefV8 &p_other);
    PackMapCollideMeshRefV8 &operator=(const PackMapCollideMeshRefV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV8 {
    helpers::Array<PackMapCollideMeshRefV8> meshRefs;

public:
    PackMapCollideGeometryV8();
    PackMapCollideGeometryV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV8(const PackMapCollideGeometryV8 &p_other);
    PackMapCollideGeometryV8 &operator=(const PackMapCollideGeometryV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV8 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV8();
    PackMapCollideModelPropV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV8(const PackMapCollideModelPropV8 &p_other);
    PackMapCollideModelPropV8 &operator=(const PackMapCollideModelPropV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV8 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV8();
    PackMapCollideModelZoneV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV8(const PackMapCollideModelZoneV8 &p_other);
    PackMapCollideModelZoneV8 &operator=(const PackMapCollideModelZoneV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV8 {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;

public:
    PackMapCollideAiChunkV8();
    PackMapCollideAiChunkV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV8(const PackMapCollideAiChunkV8 &p_other);
    PackMapCollideAiChunkV8 &operator=(const PackMapCollideAiChunkV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV8 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMeshV8> meshes;
    helpers::Array<PackMapCollideGeometryV8> geometries;
    helpers::Array<PackMapCollideModelPropV8> propModels;
    helpers::Array<PackMapCollideModelZoneV8> zoneModels;
    float3 aiBoundaryMin;
    float3 aiBoundaryMax;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV8> aiChunks;

public:
    PackMapCollideV8();
    PackMapCollideV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV8(const PackMapCollideV8 &p_other);
    PackMapCollideV8 &operator=(const PackMapCollideV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<7>{
struct PackMapCollideMoppCodeV7 {
    helpers::Array<byte> cookedData;

public:
    PackMapCollideMoppCodeV7();
    PackMapCollideMoppCodeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMoppCodeV7(const PackMapCollideMoppCodeV7 &p_other);
    PackMapCollideMoppCodeV7 &operator=(const PackMapCollideMoppCodeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshSizeV7 {
    float scale;
    dword moppCodeIndex;

public:
    PackMapCollideMeshSizeV7();
    PackMapCollideMeshSizeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshSizeV7(const PackMapCollideMeshSizeV7 &p_other);
    PackMapCollideMeshSizeV7 &operator=(const PackMapCollideMeshSizeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<PackMapCollideMeshSizeV7> sizes;

public:
    PackMapCollideMeshV7();
    PackMapCollideMeshV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV7(const PackMapCollideMeshV7 &p_other);
    PackMapCollideMeshV7 &operator=(const PackMapCollideMeshV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV7 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV7();
    PackMapCollideMeshRefV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV7(const PackMapCollideMeshRefV7 &p_other);
    PackMapCollideMeshRefV7 &operator=(const PackMapCollideMeshRefV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV7 {
    helpers::Array<PackMapCollideMeshRefV7> meshRefs;

public:
    PackMapCollideGeometryV7();
    PackMapCollideGeometryV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV7(const PackMapCollideGeometryV7 &p_other);
    PackMapCollideGeometryV7 &operator=(const PackMapCollideGeometryV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV7 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV7();
    PackMapCollideModelPropV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV7(const PackMapCollideModelPropV7 &p_other);
    PackMapCollideModelPropV7 &operator=(const PackMapCollideModelPropV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV7 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV7();
    PackMapCollideModelZoneV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV7(const PackMapCollideModelZoneV7 &p_other);
    PackMapCollideModelZoneV7 &operator=(const PackMapCollideModelZoneV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideAiChunkV7 {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;

public:
    PackMapCollideAiChunkV7();
    PackMapCollideAiChunkV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideAiChunkV7(const PackMapCollideAiChunkV7 &p_other);
    PackMapCollideAiChunkV7 &operator=(const PackMapCollideAiChunkV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV7 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMoppCodeV7> moppCodes;
    helpers::Array<PackMapCollideMeshV7> meshes;
    helpers::Array<PackMapCollideGeometryV7> geometries;
    helpers::Array<PackMapCollideModelPropV7> propModels;
    helpers::Array<PackMapCollideModelZoneV7> zoneModels;
    float3 aiBoundaryMin;
    float3 aiBoundaryMax;
    dword2 aiChunkDims;
    helpers::Array<PackMapCollideAiChunkV7> aiChunks;

public:
    PackMapCollideV7();
    PackMapCollideV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV7(const PackMapCollideV7 &p_other);
    PackMapCollideV7 &operator=(const PackMapCollideV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structhavk<6>{
struct PackMapCollideMoppCodeV6 {
    helpers::Array<byte> cookedData;

public:
    PackMapCollideMoppCodeV6();
    PackMapCollideMoppCodeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMoppCodeV6(const PackMapCollideMoppCodeV6 &p_other);
    PackMapCollideMoppCodeV6 &operator=(const PackMapCollideMoppCodeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshSizeV6 {
    float scale;
    dword moppCodeIndex;

public:
    PackMapCollideMeshSizeV6();
    PackMapCollideMeshSizeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshSizeV6(const PackMapCollideMeshSizeV6 &p_other);
    PackMapCollideMeshSizeV6 &operator=(const PackMapCollideMeshSizeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshV6 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<PackMapCollideMeshSizeV6> sizes;

public:
    PackMapCollideMeshV6();
    PackMapCollideMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshV6(const PackMapCollideMeshV6 &p_other);
    PackMapCollideMeshV6 &operator=(const PackMapCollideMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideMeshRefV6 {
    qword sequence;
    dword meshIndex;

public:
    PackMapCollideMeshRefV6();
    PackMapCollideMeshRefV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideMeshRefV6(const PackMapCollideMeshRefV6 &p_other);
    PackMapCollideMeshRefV6 &operator=(const PackMapCollideMeshRefV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideGeometryV6 {
    helpers::Array<PackMapCollideMeshRefV6> meshRefs;

public:
    PackMapCollideGeometryV6();
    PackMapCollideGeometryV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideGeometryV6(const PackMapCollideGeometryV6 &p_other);
    PackMapCollideGeometryV6 &operator=(const PackMapCollideGeometryV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelPropV6 {
    qword token;
    qword sequence;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelPropV6();
    PackMapCollideModelPropV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelPropV6(const PackMapCollideModelPropV6 &p_other);
    PackMapCollideModelPropV6 &operator=(const PackMapCollideModelPropV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideModelZoneV6 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapCollideModelZoneV6();
    PackMapCollideModelZoneV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideModelZoneV6(const PackMapCollideModelZoneV6 &p_other);
    PackMapCollideModelZoneV6 &operator=(const PackMapCollideModelZoneV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCollideV6 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapCollideMoppCodeV6> moppCodes;
    helpers::Array<PackMapCollideMeshV6> meshes;
    helpers::Array<PackMapCollideGeometryV6> geometries;
    helpers::Array<PackMapCollideModelPropV6> propModels;
    helpers::Array<PackMapCollideModelZoneV6> zoneModels;

public:
    PackMapCollideV6();
    PackMapCollideV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCollideV6(const PackMapCollideV6 &p_other);
    PackMapCollideV6 &operator=(const PackMapCollideV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCollideV6 Gw2Struct;
};


/* ===============================================
 * Chunk: nm15, versions: 4, strucTab: 0x1420F0450
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structnm15;

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnm15<3>{
struct PackMapNavMeshChunkV3 {
    dword chunkIndex;
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV3();
    PackMapNavMeshChunkV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV3(const PackMapNavMeshChunkV3 &p_other);
    PackMapNavMeshChunkV3 &operator=(const PackMapNavMeshChunkV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshChunkV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnm15<2>{
struct PackMapNavMeshChunkV2 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV2();
    PackMapNavMeshChunkV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV2(const PackMapNavMeshChunkV2 &p_other);
    PackMapNavMeshChunkV2 &operator=(const PackMapNavMeshChunkV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshChunkV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x4105499000000001 */

template <>
struct Gw2Structnm15<1>{
struct PackMapNavMeshChunkV1 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV1();
    PackMapNavMeshChunkV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV1(const PackMapNavMeshChunkV1 &p_other);
    PackMapNavMeshChunkV1 &operator=(const PackMapNavMeshChunkV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshChunkV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnm15<0>{
struct PackMapNavMeshChunkV0 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV0();
    PackMapNavMeshChunkV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV0(const PackMapNavMeshChunkV0 &p_other);
    PackMapNavMeshChunkV0 &operator=(const PackMapNavMeshChunkV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshChunkV0 Gw2Struct;
};


/* ===============================================
 * Chunk: area, versions: 5, strucTab: 0x1420EFC00
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structarea;

/* Version: 4, ReferencedFunction: 0x410548D000000001 */

template <>
struct Gw2Structarea<4>{
struct PackMapAreaPolygonV4 {
    helpers::Array<float3> points;
    float height;

public:
    PackMapAreaPolygonV4();
    PackMapAreaPolygonV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPolygonV4(const PackMapAreaPolygonV4 &p_other);
    PackMapAreaPolygonV4 &operator=(const PackMapAreaPolygonV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaPortalV4 {
    float3 position;
    float3 extents;
    float3 rotation;

public:
    PackMapAreaPortalV4();
    PackMapAreaPortalV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPortalV4(const PackMapAreaPortalV4 &p_other);
    PackMapAreaPortalV4 &operator=(const PackMapAreaPortalV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaVolumeV4 {
    helpers::Array<PackMapAreaPortalV4> portals;
    float3 position;
    float3 extents;
    float3 pointInterior;
    float3 pointExterior;

public:
    PackMapAreaVolumeV4();
    PackMapAreaVolumeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaVolumeV4(const PackMapAreaVolumeV4 &p_other);
    PackMapAreaVolumeV4 &operator=(const PackMapAreaVolumeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaV4 {
    qword token;
    byte type;
    byte floor;
    dword flags;
    PackMapAreaPolygonV4 polygon;
    PackMapAreaVolumeV4 volume;

public:
    PackMapAreaV4();
    PackMapAreaV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaV4(const PackMapAreaV4 &p_other);
    PackMapAreaV4 &operator=(const PackMapAreaV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaToolV4 {
    helpers::WString annotation;
    float renderOffset;

public:
    PackMapAreaToolV4();
    PackMapAreaToolV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaToolV4(const PackMapAreaToolV4 &p_other);
    PackMapAreaToolV4 &operator=(const PackMapAreaToolV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreasV4 {
    helpers::Array<PackMapAreaV4> areas;
    helpers::Array<PackMapAreaToolV4> areaTools;

public:
    PackMapAreasV4();
    PackMapAreasV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreasV4(const PackMapAreasV4 &p_other);
    PackMapAreasV4 &operator=(const PackMapAreasV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapAreasV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structarea<3>{
struct PackMapAreaPolygonV3 {
    helpers::Array<float3> points;
    float height;

public:
    PackMapAreaPolygonV3();
    PackMapAreaPolygonV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPolygonV3(const PackMapAreaPolygonV3 &p_other);
    PackMapAreaPolygonV3 &operator=(const PackMapAreaPolygonV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaPortalV3 {
    float3 position;
    float3 extents;
    float3 rotation;

public:
    PackMapAreaPortalV3();
    PackMapAreaPortalV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPortalV3(const PackMapAreaPortalV3 &p_other);
    PackMapAreaPortalV3 &operator=(const PackMapAreaPortalV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaVolumeV3 {
    helpers::Array<PackMapAreaPortalV3> portals;
    float3 position;
    float3 extents;
    float3 pointInterior;
    float3 pointExterior;

public:
    PackMapAreaVolumeV3();
    PackMapAreaVolumeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaVolumeV3(const PackMapAreaVolumeV3 &p_other);
    PackMapAreaVolumeV3 &operator=(const PackMapAreaVolumeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaV3 {
    qword token;
    byte type;
    byte floor;
    dword flags;
    PackMapAreaPolygonV3 polygon;
    PackMapAreaVolumeV3 volume;

public:
    PackMapAreaV3();
    PackMapAreaV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaV3(const PackMapAreaV3 &p_other);
    PackMapAreaV3 &operator=(const PackMapAreaV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaToolV3 {
    helpers::WString annotation;
    float renderOffset;

public:
    PackMapAreaToolV3();
    PackMapAreaToolV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaToolV3(const PackMapAreaToolV3 &p_other);
    PackMapAreaToolV3 &operator=(const PackMapAreaToolV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreasV3 {
    helpers::Array<PackMapAreaV3> areas;
    helpers::Array<PackMapAreaToolV3> areaTools;

public:
    PackMapAreasV3();
    PackMapAreasV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreasV3(const PackMapAreasV3 &p_other);
    PackMapAreasV3 &operator=(const PackMapAreasV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapAreasV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structarea<2>{
struct PackMapAreaPolygonV2 {
    helpers::Array<float3> points;
    float height;

public:
    PackMapAreaPolygonV2();
    PackMapAreaPolygonV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPolygonV2(const PackMapAreaPolygonV2 &p_other);
    PackMapAreaPolygonV2 &operator=(const PackMapAreaPolygonV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaPortalV2 {
    float3 position;
    float3 extents;
    float3 rotation;

public:
    PackMapAreaPortalV2();
    PackMapAreaPortalV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPortalV2(const PackMapAreaPortalV2 &p_other);
    PackMapAreaPortalV2 &operator=(const PackMapAreaPortalV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaVolumeV2 {
    helpers::Array<PackMapAreaPortalV2> portals;
    float3 position;
    float3 extents;
    float3 pointInterior;
    float3 pointExterior;

public:
    PackMapAreaVolumeV2();
    PackMapAreaVolumeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaVolumeV2(const PackMapAreaVolumeV2 &p_other);
    PackMapAreaVolumeV2 &operator=(const PackMapAreaVolumeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaV2 {
    qword token;
    byte type;
    byte floor;
    dword flags;
    PackMapAreaPolygonV2 polygon;
    PackMapAreaVolumeV2 volume;

public:
    PackMapAreaV2();
    PackMapAreaV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaV2(const PackMapAreaV2 &p_other);
    PackMapAreaV2 &operator=(const PackMapAreaV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaToolV2 {
    helpers::WString annotation;

public:
    PackMapAreaToolV2();
    PackMapAreaToolV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaToolV2(const PackMapAreaToolV2 &p_other);
    PackMapAreaToolV2 &operator=(const PackMapAreaToolV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreasV2 {
    helpers::Array<PackMapAreaV2> areas;
    helpers::Array<PackMapAreaToolV2> areaTools;

public:
    PackMapAreasV2();
    PackMapAreasV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreasV2(const PackMapAreasV2 &p_other);
    PackMapAreasV2 &operator=(const PackMapAreasV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapAreasV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x410548C000000001 */

template <>
struct Gw2Structarea<1>{
struct PackMapAreaPolygonV1 {
    helpers::Array<float3> points;
    float height;

public:
    PackMapAreaPolygonV1();
    PackMapAreaPolygonV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPolygonV1(const PackMapAreaPolygonV1 &p_other);
    PackMapAreaPolygonV1 &operator=(const PackMapAreaPolygonV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaPortalV1 {
    float3 position;
    float3 extents;
    float3 rotation;

public:
    PackMapAreaPortalV1();
    PackMapAreaPortalV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaPortalV1(const PackMapAreaPortalV1 &p_other);
    PackMapAreaPortalV1 &operator=(const PackMapAreaPortalV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaVolumeV1 {
    helpers::Array<PackMapAreaPortalV1> portals;
    float3 position;
    float3 extents;
    float3 pointInterior;
    float3 pointExterior;

public:
    PackMapAreaVolumeV1();
    PackMapAreaVolumeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaVolumeV1(const PackMapAreaVolumeV1 &p_other);
    PackMapAreaVolumeV1 &operator=(const PackMapAreaVolumeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreaV1 {
    qword token;
    byte type;
    byte floor;
    PackMapAreaPolygonV1 polygon;
    PackMapAreaVolumeV1 volume;

public:
    PackMapAreaV1();
    PackMapAreaV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaV1(const PackMapAreaV1 &p_other);
    PackMapAreaV1 &operator=(const PackMapAreaV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreasV1 {
    helpers::Array<PackMapAreaV1> areas;

public:
    PackMapAreasV1();
    PackMapAreasV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreasV1(const PackMapAreasV1 &p_other);
    PackMapAreasV1 &operator=(const PackMapAreasV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapAreasV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structarea<0>{
struct PackMapAreaV0 {
    float3 min;
    float3 max;
    float3 internal;
    float3 external;
    dword token;
    dword flags;

public:
    PackMapAreaV0();
    PackMapAreaV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreaV0(const PackMapAreaV0 &p_other);
    PackMapAreaV0 &operator=(const PackMapAreaV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalV0 {
    helpers::Array<float3> portalVerts;

public:
    PackMapPortalV0();
    PackMapPortalV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalV0(const PackMapPortalV0 &p_other);
    PackMapPortalV0 &operator=(const PackMapPortalV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAreasV0 {
    helpers::Array<PackMapAreaV0> areas;
    helpers::Array<PackMapPortalV0> portals;

public:
    PackMapAreasV0();
    PackMapAreasV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAreasV0(const PackMapAreasV0 &p_other);
    PackMapAreasV0 &operator=(const PackMapAreasV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapAreasV0 Gw2Struct;
};


/* ===============================================
 * Chunk: audi, versions: 9, strucTab: 0x1420EFE20
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structaudi;

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<8>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::FileName filenameInterior;
    float exteriorVolume;
    dword priority;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;
    qword guid;
    dword flags;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAudioRegionTool {
    helpers::WString annotation;

public:
    PackMapAudioRegionTool();
    PackMapAudioRegionTool(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegionTool(const PackMapAudioRegionTool &p_other);
    PackMapAudioRegionTool &operator=(const PackMapAudioRegionTool &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAudioDep {
    helpers::FileName dependency;
    dword flags;

public:
    PackMapAudioDep();
    PackMapAudioDep(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioDep(const PackMapAudioDep &p_other);
    PackMapAudioDep &operator=(const PackMapAudioDep &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;
    helpers::Array<PackMapAudioRegionTool> audioRegionTools;
    helpers::Array<PackMapAudioDep> audioDepArray;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<7>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::FileName filenameInterior;
    float exteriorVolume;
    dword priority;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;
    qword guid;
    dword flags;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapAudioRegionTool {
    helpers::WString annotation;

public:
    PackMapAudioRegionTool();
    PackMapAudioRegionTool(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegionTool(const PackMapAudioRegionTool &p_other);
    PackMapAudioRegionTool &operator=(const PackMapAudioRegionTool &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;
    helpers::Array<PackMapAudioRegionTool> audioRegionTools;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<6>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::FileName filenameInterior;
    float exteriorVolume;
    dword priority;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;
    qword guid;
    dword flags;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<5>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;
    qword guid;
    dword flags;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x4104D26000000001 */

template <>
struct Gw2Structaudi<4>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameMusicDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::FileName filenameMusicNight;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;
    qword guid;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameMusicDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameMusicDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameMusicNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::FileName filenameMusicNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x4104D13000000001 */

template <>
struct Gw2Structaudi<3>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSourceDay;
    helpers::FileName filenameAmbientDay;
    helpers::FileName filenameMusicDay;
    helpers::FileName filenameSourceNight;
    helpers::FileName filenameAmbientNight;
    helpers::FileName filenameMusicNight;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName filenameAmbientDaySurface;
    helpers::FileName filenameMusicDaySurface;
    helpers::FileName filenameAmbientDayUnderwater;
    helpers::FileName filenameMusicDayUnderwater;
    helpers::FileName filenameAmbientNightSurface;
    helpers::FileName filenameMusicNightSurface;
    helpers::FileName filenameAmbientNightUnderwater;
    helpers::FileName filenameMusicNightUnderwater;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<2>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSource;
    helpers::FileName filenameAmbient;
    helpers::FileName filenameMusic;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName globalAmbientScriptFilename;
    helpers::FileName globalMusicScriptFilename;
    helpers::FileName globalAmbientUnderwaterScriptFilename;
    helpers::FileName globalMusicUnderwaterScriptFilename;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<1>{
struct PackMapAudioRegion {
    dword regionType;
    dword overrideMode;
    helpers::FileName filenameSource;
    helpers::FileName filenameAmbient;
    helpers::FileName filenameMusic;
    helpers::Array<float3> points;
    float3 position;
    float3 orientation;
    float fadeBand;
    float height;
    float radius;

public:
    PackMapAudioRegion();
    PackMapAudioRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapAudioRegion(const PackMapAudioRegion &p_other);
    PackMapAudioRegion &operator=(const PackMapAudioRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapAudio {
    helpers::FileName globalAmbientScriptFilename;
    helpers::FileName globalMusicScriptFilename;
    helpers::Array<PackMapAudioRegion> audioRegions;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structaudi<0>{
struct MapAudio {
    helpers::FileName globalAmbientScriptFilename;
    helpers::FileName globalMusicScriptFilename;

public:
    MapAudio();
    MapAudio(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapAudio(const MapAudio &p_other);
    MapAudio &operator=(const MapAudio &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapAudio Gw2Struct;
};


/* ===============================================
 * Chunk: bloc, versions: 1, strucTab: 0x1420F06E0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structbloc;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structbloc<0>{
struct PackMapBlockRecord {
    helpers::FileName filename;

public:
    PackMapBlockRecord();
    PackMapBlockRecord(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapBlockRecord(const PackMapBlockRecord &p_other);
    PackMapBlockRecord &operator=(const PackMapBlockRecord &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapBlock {
    dword2 blockDims;
    helpers::Array<PackMapBlockRecord> blockRecordArray;

public:
    PackMapBlock();
    PackMapBlock(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapBlock(const PackMapBlock &p_other);
    PackMapBlock &operator=(const PackMapBlock &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapBlock Gw2Struct;
};


/* ===============================================
 * Chunk: cg15, versions: 1, strucTab: 0x1420F0660
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structcg15;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcg15<0>{
struct PackMapCoarseNavGraphNodeV0 {
    dword materialId;
    float3 bottomLeftBound;
    float3 topRightBound;
    float3 centroid;
    helpers::Array<dword> faces;

public:
    PackMapCoarseNavGraphNodeV0();
    PackMapCoarseNavGraphNodeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphNodeV0(const PackMapCoarseNavGraphNodeV0 &p_other);
    PackMapCoarseNavGraphNodeV0 &operator=(const PackMapCoarseNavGraphNodeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCoarseNavGraphConnectionEdgeV0 {
    float3 edgeStart;
    float3 edgeEnd;

public:
    PackMapCoarseNavGraphConnectionEdgeV0();
    PackMapCoarseNavGraphConnectionEdgeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphConnectionEdgeV0(const PackMapCoarseNavGraphConnectionEdgeV0 &p_other);
    PackMapCoarseNavGraphConnectionEdgeV0 &operator=(const PackMapCoarseNavGraphConnectionEdgeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCoarseNavGraphConnectionV0 {
    dword targetSectionUid;
    dword targetNodeIndex;
    helpers::Array<PackMapCoarseNavGraphConnectionEdgeV0> edges;

public:
    PackMapCoarseNavGraphConnectionV0();
    PackMapCoarseNavGraphConnectionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphConnectionV0(const PackMapCoarseNavGraphConnectionV0 &p_other);
    PackMapCoarseNavGraphConnectionV0 &operator=(const PackMapCoarseNavGraphConnectionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCoarseNavGraphNodeConnectionsV0 {
    dword nodeIndex;
    helpers::Array<PackMapCoarseNavGraphConnectionV0> connections;

public:
    PackMapCoarseNavGraphNodeConnectionsV0();
    PackMapCoarseNavGraphNodeConnectionsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphNodeConnectionsV0(const PackMapCoarseNavGraphNodeConnectionsV0 &p_other);
    PackMapCoarseNavGraphNodeConnectionsV0 &operator=(const PackMapCoarseNavGraphNodeConnectionsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCoarseNavGraphSectionV0 {
    dword sectionUid;
    helpers::Array<PackMapCoarseNavGraphNodeV0> nodes;
    helpers::Array<PackMapCoarseNavGraphNodeConnectionsV0> nodeConnections;

public:
    PackMapCoarseNavGraphSectionV0();
    PackMapCoarseNavGraphSectionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphSectionV0(const PackMapCoarseNavGraphSectionV0 &p_other);
    PackMapCoarseNavGraphSectionV0 &operator=(const PackMapCoarseNavGraphSectionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCoarseNavGraphV0 {
    helpers::Array<PackMapCoarseNavGraphSectionV0> sections;

public:
    PackMapCoarseNavGraphV0();
    PackMapCoarseNavGraphV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCoarseNavGraphV0(const PackMapCoarseNavGraphV0 &p_other);
    PackMapCoarseNavGraphV0 &operator=(const PackMapCoarseNavGraphV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCoarseNavGraphV0 Gw2Struct;
};


/* ===============================================
 * Chunk: cube, versions: 5, strucTab: 0x1420F07C0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structcube;

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcube<4>{
struct PackMapCubeMapSampleV4 {
    float3 position;
    helpers::FileName filenameDayDefault;
    helpers::FileName filenameNightDefault;
    helpers::FileName filenameDayScript;
    helpers::FileName filenameNightScript;
    helpers::FileName filenameDayDefaultHiRes;
    helpers::FileName filenameNightDefaultHiRes;
    helpers::FileName filenameDayScriptHiRes;
    helpers::FileName filenameNightScriptHiRes;
    qword envID;

public:
    PackMapCubeMapSampleV4();
    PackMapCubeMapSampleV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapSampleV4(const PackMapCubeMapSampleV4 &p_other);
    PackMapCubeMapSampleV4 &operator=(const PackMapCubeMapSampleV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapParamsV4 {
    dword modulateColor;
    float brightness;
    float contrast;
    dword blurPasses;
    helpers::WString envVolume;

public:
    PackMapCubeMapParamsV4();
    PackMapCubeMapParamsV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapParamsV4(const PackMapCubeMapParamsV4 &p_other);
    PackMapCubeMapParamsV4 &operator=(const PackMapCubeMapParamsV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapV4 {
    helpers::Array<PackMapCubeMapSampleV4> sampleArray;
    helpers::Array<PackMapCubeMapParamsV4> paramsArray;

public:
    PackMapCubeMapV4();
    PackMapCubeMapV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapV4(const PackMapCubeMapV4 &p_other);
    PackMapCubeMapV4 &operator=(const PackMapCubeMapV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCubeMapV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcube<3>{
struct PackMapCubeMapSampleV3 {
    float3 position;
    helpers::FileName filenameDayDefault;
    helpers::FileName filenameNightDefault;
    helpers::FileName filenameDayScript;
    helpers::FileName filenameNightScript;
    qword envID;

public:
    PackMapCubeMapSampleV3();
    PackMapCubeMapSampleV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapSampleV3(const PackMapCubeMapSampleV3 &p_other);
    PackMapCubeMapSampleV3 &operator=(const PackMapCubeMapSampleV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapParamsV3 {
    dword modulateColor;
    float brightness;
    float contrast;
    dword blurPasses;
    helpers::WString envVolume;

public:
    PackMapCubeMapParamsV3();
    PackMapCubeMapParamsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapParamsV3(const PackMapCubeMapParamsV3 &p_other);
    PackMapCubeMapParamsV3 &operator=(const PackMapCubeMapParamsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapV3 {
    helpers::Array<PackMapCubeMapSampleV3> sampleArray;
    helpers::Array<PackMapCubeMapParamsV3> paramsArray;

public:
    PackMapCubeMapV3();
    PackMapCubeMapV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapV3(const PackMapCubeMapV3 &p_other);
    PackMapCubeMapV3 &operator=(const PackMapCubeMapV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCubeMapV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structcube<2>{
struct PackMapCubeMapSampleV2 {
    float3 position;
    helpers::FileName filenameDayDefault;
    helpers::FileName filenameNightDefault;
    helpers::FileName filenameDayScript;
    helpers::FileName filenameNightScript;

public:
    PackMapCubeMapSampleV2();
    PackMapCubeMapSampleV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapSampleV2(const PackMapCubeMapSampleV2 &p_other);
    PackMapCubeMapSampleV2 &operator=(const PackMapCubeMapSampleV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapParamsV2 {
    dword modulateColor;
    float brightness;
    float contrast;
    dword blurPasses;

public:
    PackMapCubeMapParamsV2();
    PackMapCubeMapParamsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapParamsV2(const PackMapCubeMapParamsV2 &p_other);
    PackMapCubeMapParamsV2 &operator=(const PackMapCubeMapParamsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapV2 {
    helpers::Array<PackMapCubeMapSampleV2> sampleArray;
    helpers::Array<PackMapCubeMapParamsV2> paramsArray;

public:
    PackMapCubeMapV2();
    PackMapCubeMapV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapV2(const PackMapCubeMapV2 &p_other);
    PackMapCubeMapV2 &operator=(const PackMapCubeMapV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCubeMapV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x4105292000000001 */

template <>
struct Gw2Structcube<1>{
struct PackMapCubeMapSampleV1 {
    float3 position;
    dword flags;
    helpers::Array<byte> dayPtr;
    helpers::Array<byte> nightPtr;

public:
    PackMapCubeMapSampleV1();
    PackMapCubeMapSampleV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapSampleV1(const PackMapCubeMapSampleV1 &p_other);
    PackMapCubeMapSampleV1 &operator=(const PackMapCubeMapSampleV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapParamsV1 {
    dword modulateColor;
    float brightness;
    float contrast;
    dword blurPasses;

public:
    PackMapCubeMapParamsV1();
    PackMapCubeMapParamsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapParamsV1(const PackMapCubeMapParamsV1 &p_other);
    PackMapCubeMapParamsV1 &operator=(const PackMapCubeMapParamsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapV1 {
    helpers::Array<PackMapCubeMapSampleV1> sampleArray;
    helpers::Array<PackMapCubeMapParamsV1> paramsArray;

public:
    PackMapCubeMapV1();
    PackMapCubeMapV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapV1(const PackMapCubeMapV1 &p_other);
    PackMapCubeMapV1 &operator=(const PackMapCubeMapV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCubeMapV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcube<0>{
struct PackMapCubeMapSampleV0 {
    float3 position;
    dword flags;
    helpers::Array<byte> dataPtr;

public:
    PackMapCubeMapSampleV0();
    PackMapCubeMapSampleV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapSampleV0(const PackMapCubeMapSampleV0 &p_other);
    PackMapCubeMapSampleV0 &operator=(const PackMapCubeMapSampleV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapParamsV0 {
    dword modulateColor;
    float brightness;
    float contrast;
    dword blurPasses;

public:
    PackMapCubeMapParamsV0();
    PackMapCubeMapParamsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapParamsV0(const PackMapCubeMapParamsV0 &p_other);
    PackMapCubeMapParamsV0 &operator=(const PackMapCubeMapParamsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCubeMapV0 {
    helpers::Array<PackMapCubeMapSampleV0> sampleArray;
    helpers::Array<PackMapCubeMapParamsV0> paramsArray;

public:
    PackMapCubeMapV0();
    PackMapCubeMapV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCubeMapV0(const PackMapCubeMapV0 &p_other);
    PackMapCubeMapV0 &operator=(const PackMapCubeMapV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapCubeMapV0 Gw2Struct;
};


/* ===============================================
 * Chunk: env, versions: 78, strucTab: 0x1420F17B0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structenv;

/* Version: 77, ReferencedFunction: 0x4104F9E000000001 */

template <>
struct Gw2Structenv<77>{
struct PackMapEnvDataLightV76 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV76();
    PackMapEnvDataLightV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV76(const PackMapEnvDataLightV76 &p_other);
    PackMapEnvDataLightV76 &operator=(const PackMapEnvDataLightV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV76 {
    helpers::Ptr<PackMapEnvDataLightV76> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV76();
    PackMapEnvDataLightingV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV76(const PackMapEnvDataLightingV76 &p_other);
    PackMapEnvDataLightingV76 &operator=(const PackMapEnvDataLightingV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV47 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV47();
    PackMapEnvDataLightingCharV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV47(const PackMapEnvDataLightingCharV47 &p_other);
    PackMapEnvDataLightingCharV47 &operator=(const PackMapEnvDataLightingCharV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV47 {
    helpers::Array<PackMapEnvDataLightingCharV47> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV47();
    PackMapEnvDataLightingCharGroupV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV47(const PackMapEnvDataLightingCharGroupV47 &p_other);
    PackMapEnvDataLightingCharGroupV47 &operator=(const PackMapEnvDataLightingCharGroupV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV76 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;
    dword reserved;

public:
    PackMapEnvDataLayerAttributesV76();
    PackMapEnvDataLayerAttributesV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV76(const PackMapEnvDataLayerAttributesV76 &p_other);
    PackMapEnvDataLayerAttributesV76 &operator=(const PackMapEnvDataLayerAttributesV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV76 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV76> attributes;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataLayerV76();
    PackMapEnvDataLayerV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV76(const PackMapEnvDataLayerV76 &p_other);
    PackMapEnvDataLayerV76 &operator=(const PackMapEnvDataLayerV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV76 {
    helpers::Array<PackMapEnvDataLayerV76> layers;

public:
    PackMapEnvDataCloudsV76();
    PackMapEnvDataCloudsV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV76(const PackMapEnvDataCloudsV76 &p_other);
    PackMapEnvDataCloudsV76 &operator=(const PackMapEnvDataCloudsV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV47 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV47();
    PackMapEnvDataColoredLightRingsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV47(const PackMapEnvDataColoredLightRingsV47 &p_other);
    PackMapEnvDataColoredLightRingsV47 &operator=(const PackMapEnvDataColoredLightRingsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectExV47 {
    dword dummy;

public:
    PackMapEnvDataEffectExV47();
    PackMapEnvDataEffectExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectExV47(const PackMapEnvDataEffectExV47 &p_other);
    PackMapEnvDataEffectExV47 &operator=(const PackMapEnvDataEffectExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV76 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float ssaoAmount;
    float ssaoBrighten;
    float ssaoContrast;
    float ssaoSunScale;
    dword flags;
    helpers::FileName clutTexturePath;
    helpers::Ptr<PackMapEnvDataEffectExV47> ext;

public:
    PackMapEnvDataEffectV76();
    PackMapEnvDataEffectV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV76(const PackMapEnvDataEffectV76 &p_other);
    PackMapEnvDataEffectV76 &operator=(const PackMapEnvDataEffectV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV76 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV76();
    PackMapEnvDataHazeV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV76(const PackMapEnvDataHazeV76 &p_other);
    PackMapEnvDataHazeV76 &operator=(const PackMapEnvDataHazeV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV76 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataPFieldV76();
    PackMapEnvDataPFieldV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV76(const PackMapEnvDataPFieldV76 &p_other);
    PackMapEnvDataPFieldV76 &operator=(const PackMapEnvDataPFieldV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV47 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV47();
    PackMapEnvDataPFieldCutoutV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV47(const PackMapEnvDataPFieldCutoutV47 &p_other);
    PackMapEnvDataPFieldCutoutV47 &operator=(const PackMapEnvDataPFieldCutoutV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV76 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV76();
    PackMapEnvDataSkyV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV76(const PackMapEnvDataSkyV76 &p_other);
    PackMapEnvDataSkyV76 &operator=(const PackMapEnvDataSkyV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareAtomV47 {
    dword rows;
    dword columns;
    dword start;
    float fps;
    byte4 color;
    float2 offset;
    float2 scale;
    float baseRotation;
    float cameraRotation;
    byte flags;

public:
    PackMapEnvLensFlareAtomV47();
    PackMapEnvLensFlareAtomV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareAtomV47(const PackMapEnvLensFlareAtomV47 &p_other);
    PackMapEnvLensFlareAtomV47 &operator=(const PackMapEnvLensFlareAtomV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareTextureV47 {
    helpers::FileName texture;

public:
    PackMapEnvLensFlareTextureV47();
    PackMapEnvLensFlareTextureV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareTextureV47(const PackMapEnvLensFlareTextureV47 &p_other);
    PackMapEnvLensFlareTextureV47 &operator=(const PackMapEnvLensFlareTextureV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderConstantV47 {
    dword token;
    float4 value;

public:
    PackMapEnvDataShaderConstantV47();
    PackMapEnvDataShaderConstantV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderConstantV47(const PackMapEnvDataShaderConstantV47 &p_other);
    PackMapEnvDataShaderConstantV47 &operator=(const PackMapEnvDataShaderConstantV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareV47 {
    helpers::Array<PackMapEnvLensFlareAtomV47> atoms;
    helpers::Array<PackMapEnvLensFlareTextureV47> textures;
    helpers::FileName material;
    float2 fadeBand;
    float2 reverseFadeBand;
    float opacityCoeff;
    byte flags;
    helpers::Array<PackMapEnvDataShaderConstantV47> constants;

public:
    PackMapEnvLensFlareV47();
    PackMapEnvLensFlareV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareV47(const PackMapEnvLensFlareV47 &p_other);
    PackMapEnvLensFlareV47 &operator=(const PackMapEnvLensFlareV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesExV47 {
    dword dummy;

public:
    PackMapEnvDataSkyCardAttributesExV47();
    PackMapEnvDataSkyCardAttributesExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesExV47(const PackMapEnvDataSkyCardAttributesExV47 &p_other);
    PackMapEnvDataSkyCardAttributesExV47 &operator=(const PackMapEnvDataSkyCardAttributesExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV76 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;
    helpers::Ptr<PackMapEnvLensFlareV47> lensFlare;
    helpers::Ptr<PackMapEnvDataSkyCardAttributesExV47> ext;

public:
    PackMapEnvDataSkyCardAttributesV76();
    PackMapEnvDataSkyCardAttributesV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV76(const PackMapEnvDataSkyCardAttributesV76 &p_other);
    PackMapEnvDataSkyCardAttributesV76 &operator=(const PackMapEnvDataSkyCardAttributesV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderTextureV47 {
    helpers::FileName filename;
    float4 textureUV;

public:
    PackMapEnvDataShaderTextureV47();
    PackMapEnvDataShaderTextureV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderTextureV47(const PackMapEnvDataShaderTextureV47 &p_other);
    PackMapEnvDataShaderTextureV47 &operator=(const PackMapEnvDataShaderTextureV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEnvDataSkyCardAnimationV47 {
    float2 textureAnimTranslation;
    float2 textureAnimScaleRangeX;
    float2 textureAnimScaleRangeY;
    float2 textureAnimScaleSpeed;
    float textureAnimRotation;
    dword texCoords;

public:
    PackEnvDataSkyCardAnimationV47();
    PackEnvDataSkyCardAnimationV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEnvDataSkyCardAnimationV47(const PackEnvDataSkyCardAnimationV47 &p_other);
    PackEnvDataSkyCardAnimationV47 &operator=(const PackEnvDataSkyCardAnimationV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkycardFlipbookV47 {
    dword rows;
    dword columns;
    dword start;
    dword count;
    float fps;

public:
    PackMapEnvDataSkycardFlipbookV47();
    PackMapEnvDataSkycardFlipbookV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkycardFlipbookV47(const PackMapEnvDataSkycardFlipbookV47 &p_other);
    PackMapEnvDataSkycardFlipbookV47 &operator=(const PackMapEnvDataSkycardFlipbookV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardMaterialV47 {
    helpers::FileName filename;
    helpers::Array<PackMapEnvDataShaderConstantV47> constants;
    helpers::Array<PackMapEnvDataShaderTextureV47> textures;
    PackEnvDataSkyCardAnimationV47 textureAnimation;
    PackMapEnvDataSkycardFlipbookV47 flipbook;

public:
    PackMapEnvDataSkyCardMaterialV47();
    PackMapEnvDataSkyCardMaterialV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardMaterialV47(const PackMapEnvDataSkyCardMaterialV47 &p_other);
    PackMapEnvDataSkyCardMaterialV47 &operator=(const PackMapEnvDataSkyCardMaterialV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardExV47 {
    dword dummy;

public:
    PackMapEnvDataSkyCardExV47();
    PackMapEnvDataSkyCardExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardExV47(const PackMapEnvDataSkyCardExV47 &p_other);
    PackMapEnvDataSkyCardExV47 &operator=(const PackMapEnvDataSkyCardExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV76 {
    PackMapEnvDataSkyCardAttributesV76 day;
    PackMapEnvDataSkyCardAttributesV76 night;
    dword flags;
    helpers::WString name;
    float3 location;
    helpers::Ptr<PackMapEnvDataSkyCardMaterialV47> material;
    helpers::Ptr<PackMapEnvDataSkyCardExV47> ext;

public:
    PackMapEnvDataSkyCardV76();
    PackMapEnvDataSkyCardV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV76(const PackMapEnvDataSkyCardV76 &p_other);
    PackMapEnvDataSkyCardV76 &operator=(const PackMapEnvDataSkyCardV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV76 {
    helpers::Array<PackMapEnvDataSkyCardV76> cards;

public:
    PackMapEnvDataSkyCardsV76();
    PackMapEnvDataSkyCardsV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV76(const PackMapEnvDataSkyCardsV76 &p_other);
    PackMapEnvDataSkyCardsV76 &operator=(const PackMapEnvDataSkyCardsV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV47 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV47();
    PackMapEnvDataSpawnModelDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV47(const PackMapEnvDataSpawnModelDataV47 &p_other);
    PackMapEnvDataSpawnModelDataV47 &operator=(const PackMapEnvDataSpawnModelDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV47 {
    helpers::Array<PackMapEnvDataSpawnModelDataV47> spawns;

public:
    PackMapEnvDataSpawnListV47();
    PackMapEnvDataSpawnListV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV47(const PackMapEnvDataSpawnListV47 &p_other);
    PackMapEnvDataSpawnListV47 &operator=(const PackMapEnvDataSpawnListV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV47 {
    helpers::Array<PackMapEnvDataSpawnListV47> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV47();
    PackMapEnvDataSpawnGroupsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV47(const PackMapEnvDataSpawnGroupsV47 &p_other);
    PackMapEnvDataSpawnGroupsV47 &operator=(const PackMapEnvDataSpawnGroupsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV76 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV76();
    PackMapEnvDataWaterV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV76(const PackMapEnvDataWaterV76 &p_other);
    PackMapEnvDataWaterV76 &operator=(const PackMapEnvDataWaterV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV76 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV76();
    PackMapEnvDataWindV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV76(const PackMapEnvDataWindV76 &p_other);
    PackMapEnvDataWindV76 &operator=(const PackMapEnvDataWindV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataAudioV47 {
    qword token;

public:
    PackMapEnvDataAudioV47();
    PackMapEnvDataAudioV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataAudioV47(const PackMapEnvDataAudioV47 &p_other);
    PackMapEnvDataAudioV47 &operator=(const PackMapEnvDataAudioV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseEx2V47 {
    dword dummy;

public:
    PackMapEnvDataBaseEx2V47();
    PackMapEnvDataBaseEx2V47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseEx2V47(const PackMapEnvDataBaseEx2V47 &p_other);
    PackMapEnvDataBaseEx2V47 &operator=(const PackMapEnvDataBaseEx2V47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseExV47 {
    helpers::Ptr<PackMapEnvDataBaseEx2V47> ext2;
    float brightTime;
    float dimTime;
    float darkCoeff;
    float darkExp;
    float darkMin;
    float darkMax;
    float brightMin;
    float brightMax;
    float brightScale;
    float darkScale;
    float4 waterReflectionParams;

public:
    PackMapEnvDataBaseExV47();
    PackMapEnvDataBaseExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseExV47(const PackMapEnvDataBaseExV47 &p_other);
    PackMapEnvDataBaseExV47 &operator=(const PackMapEnvDataBaseExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV47 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV47();
    PackMapEnvDataShapeV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV47(const PackMapEnvDataShapeV47 &p_other);
    PackMapEnvDataShapeV47 &operator=(const PackMapEnvDataShapeV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV76 {
    helpers::Array<PackMapEnvDataLightingV76> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV47> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV76> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV47> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV76> effect;
    helpers::Ptr<PackMapEnvDataHazeV76> haze;
    helpers::Ptr<PackMapEnvDataPFieldV76> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV47> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV76> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV76> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV47> spawns;
    helpers::Ptr<PackMapEnvDataWaterV76> water;
    helpers::Ptr<PackMapEnvDataWindV76> wind;
    helpers::Ptr<PackMapEnvDataAudioV47> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV47> ext;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV47> shapeArray;

public:
    PackMapEnvDataLocalV76();
    PackMapEnvDataLocalV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV76(const PackMapEnvDataLocalV76 &p_other);
    PackMapEnvDataLocalV76 &operator=(const PackMapEnvDataLocalV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV76 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV76();
    PackMapEnvDataSkyModeTexV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV76(const PackMapEnvDataSkyModeTexV76 &p_other);
    PackMapEnvDataSkyModeTexV76 &operator=(const PackMapEnvDataSkyModeTexV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeCubeTexV47 {
    helpers::FileName texPathE;
    helpers::FileName texPathW;
    helpers::FileName texPathN;
    helpers::FileName texPathS;
    helpers::FileName texPathB;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeCubeTexV47();
    PackMapEnvDataSkyModeCubeTexV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeCubeTexV47(const PackMapEnvDataSkyModeCubeTexV47 &p_other);
    PackMapEnvDataSkyModeCubeTexV47 &operator=(const PackMapEnvDataSkyModeCubeTexV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV76 {
    helpers::Array<PackMapEnvDataLightingV76> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV47> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV76> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV47> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV76> effect;
    helpers::Ptr<PackMapEnvDataHazeV76> haze;
    helpers::Ptr<PackMapEnvDataPFieldV76> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV47> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV76> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV76> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV47> spawns;
    helpers::Ptr<PackMapEnvDataWaterV76> water;
    helpers::Ptr<PackMapEnvDataWindV76> wind;
    helpers::Ptr<PackMapEnvDataAudioV47> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV47> ext;
    helpers::Array<PackMapEnvDataSkyModeTexV76> skyModeTex;
    helpers::FileName starFile;
    helpers::Array<PackMapEnvDataSkyModeCubeTexV47> skyModeCubeTex;

public:
    PackMapEnvDataGlobalV76();
    PackMapEnvDataGlobalV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV76(const PackMapEnvDataGlobalV76 &p_other);
    PackMapEnvDataGlobalV76 &operator=(const PackMapEnvDataGlobalV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataOverrideV77 {
    helpers::Array<PackMapEnvDataLightingV76> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV47> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV76> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV47> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV76> effect;
    helpers::Ptr<PackMapEnvDataHazeV76> haze;
    helpers::Ptr<PackMapEnvDataPFieldV76> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV47> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV76> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV76> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV47> spawns;
    helpers::Ptr<PackMapEnvDataWaterV76> water;
    helpers::Ptr<PackMapEnvDataWindV76> wind;
    helpers::Ptr<PackMapEnvDataAudioV47> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV47> ext;
    helpers::Array<PackMapEnvDataSkyModeTexV76> skyModeTex;
    helpers::FileName starFile;
    helpers::Array<PackMapEnvDataSkyModeCubeTexV47> skyModeCubeTex;
    qword token;
    qword guid;

public:
    PackMapEnvDataOverrideV77();
    PackMapEnvDataOverrideV77(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataOverrideV77(const PackMapEnvDataOverrideV77 &p_other);
    PackMapEnvDataOverrideV77 &operator=(const PackMapEnvDataOverrideV77 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV77 {
    helpers::Array<PackMapEnvDataLocalV76> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV76> dataGlobal;
    helpers::Array<PackMapEnvDataOverrideV77> dataOverrideArray;

public:
    PackMapEnvironmentV77();
    PackMapEnvironmentV77(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV77(const PackMapEnvironmentV77 &p_other);
    PackMapEnvironmentV77 &operator=(const PackMapEnvironmentV77 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV77 Gw2Struct;
};

/* Version: 76, ReferencedFunction: 0x4104F9C000000001 */

template <>
struct Gw2Structenv<76>{
struct PackMapEnvDataLightV76 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV76();
    PackMapEnvDataLightV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV76(const PackMapEnvDataLightV76 &p_other);
    PackMapEnvDataLightV76 &operator=(const PackMapEnvDataLightV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV76 {
    helpers::Ptr<PackMapEnvDataLightV76> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV76();
    PackMapEnvDataLightingV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV76(const PackMapEnvDataLightingV76 &p_other);
    PackMapEnvDataLightingV76 &operator=(const PackMapEnvDataLightingV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV47 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV47();
    PackMapEnvDataLightingCharV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV47(const PackMapEnvDataLightingCharV47 &p_other);
    PackMapEnvDataLightingCharV47 &operator=(const PackMapEnvDataLightingCharV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV47 {
    helpers::Array<PackMapEnvDataLightingCharV47> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV47();
    PackMapEnvDataLightingCharGroupV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV47(const PackMapEnvDataLightingCharGroupV47 &p_other);
    PackMapEnvDataLightingCharGroupV47 &operator=(const PackMapEnvDataLightingCharGroupV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV76 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;
    dword reserved;

public:
    PackMapEnvDataLayerAttributesV76();
    PackMapEnvDataLayerAttributesV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV76(const PackMapEnvDataLayerAttributesV76 &p_other);
    PackMapEnvDataLayerAttributesV76 &operator=(const PackMapEnvDataLayerAttributesV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV76 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV76> attributes;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataLayerV76();
    PackMapEnvDataLayerV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV76(const PackMapEnvDataLayerV76 &p_other);
    PackMapEnvDataLayerV76 &operator=(const PackMapEnvDataLayerV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV76 {
    helpers::Array<PackMapEnvDataLayerV76> layers;

public:
    PackMapEnvDataCloudsV76();
    PackMapEnvDataCloudsV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV76(const PackMapEnvDataCloudsV76 &p_other);
    PackMapEnvDataCloudsV76 &operator=(const PackMapEnvDataCloudsV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV47 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV47();
    PackMapEnvDataColoredLightRingsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV47(const PackMapEnvDataColoredLightRingsV47 &p_other);
    PackMapEnvDataColoredLightRingsV47 &operator=(const PackMapEnvDataColoredLightRingsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectExV47 {
    dword dummy;

public:
    PackMapEnvDataEffectExV47();
    PackMapEnvDataEffectExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectExV47(const PackMapEnvDataEffectExV47 &p_other);
    PackMapEnvDataEffectExV47 &operator=(const PackMapEnvDataEffectExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV76 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float ssaoAmount;
    float ssaoBrighten;
    float ssaoContrast;
    float ssaoSunScale;
    dword flags;
    helpers::FileName clutTexturePath;
    helpers::Ptr<PackMapEnvDataEffectExV47> ext;

public:
    PackMapEnvDataEffectV76();
    PackMapEnvDataEffectV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV76(const PackMapEnvDataEffectV76 &p_other);
    PackMapEnvDataEffectV76 &operator=(const PackMapEnvDataEffectV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV76 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV76();
    PackMapEnvDataHazeV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV76(const PackMapEnvDataHazeV76 &p_other);
    PackMapEnvDataHazeV76 &operator=(const PackMapEnvDataHazeV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV76 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataPFieldV76();
    PackMapEnvDataPFieldV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV76(const PackMapEnvDataPFieldV76 &p_other);
    PackMapEnvDataPFieldV76 &operator=(const PackMapEnvDataPFieldV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV47 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV47();
    PackMapEnvDataPFieldCutoutV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV47(const PackMapEnvDataPFieldCutoutV47 &p_other);
    PackMapEnvDataPFieldCutoutV47 &operator=(const PackMapEnvDataPFieldCutoutV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV76 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV76();
    PackMapEnvDataSkyV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV76(const PackMapEnvDataSkyV76 &p_other);
    PackMapEnvDataSkyV76 &operator=(const PackMapEnvDataSkyV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareAtomV47 {
    dword rows;
    dword columns;
    dword start;
    float fps;
    byte4 color;
    float2 offset;
    float2 scale;
    float baseRotation;
    float cameraRotation;
    byte flags;

public:
    PackMapEnvLensFlareAtomV47();
    PackMapEnvLensFlareAtomV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareAtomV47(const PackMapEnvLensFlareAtomV47 &p_other);
    PackMapEnvLensFlareAtomV47 &operator=(const PackMapEnvLensFlareAtomV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareTextureV47 {
    helpers::FileName texture;

public:
    PackMapEnvLensFlareTextureV47();
    PackMapEnvLensFlareTextureV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareTextureV47(const PackMapEnvLensFlareTextureV47 &p_other);
    PackMapEnvLensFlareTextureV47 &operator=(const PackMapEnvLensFlareTextureV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderConstantV47 {
    dword token;
    float4 value;

public:
    PackMapEnvDataShaderConstantV47();
    PackMapEnvDataShaderConstantV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderConstantV47(const PackMapEnvDataShaderConstantV47 &p_other);
    PackMapEnvDataShaderConstantV47 &operator=(const PackMapEnvDataShaderConstantV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareV47 {
    helpers::Array<PackMapEnvLensFlareAtomV47> atoms;
    helpers::Array<PackMapEnvLensFlareTextureV47> textures;
    helpers::FileName material;
    float2 fadeBand;
    float2 reverseFadeBand;
    float opacityCoeff;
    byte flags;
    helpers::Array<PackMapEnvDataShaderConstantV47> constants;

public:
    PackMapEnvLensFlareV47();
    PackMapEnvLensFlareV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareV47(const PackMapEnvLensFlareV47 &p_other);
    PackMapEnvLensFlareV47 &operator=(const PackMapEnvLensFlareV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesExV47 {
    dword dummy;

public:
    PackMapEnvDataSkyCardAttributesExV47();
    PackMapEnvDataSkyCardAttributesExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesExV47(const PackMapEnvDataSkyCardAttributesExV47 &p_other);
    PackMapEnvDataSkyCardAttributesExV47 &operator=(const PackMapEnvDataSkyCardAttributesExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV76 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;
    helpers::Ptr<PackMapEnvLensFlareV47> lensFlare;
    helpers::Ptr<PackMapEnvDataSkyCardAttributesExV47> ext;

public:
    PackMapEnvDataSkyCardAttributesV76();
    PackMapEnvDataSkyCardAttributesV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV76(const PackMapEnvDataSkyCardAttributesV76 &p_other);
    PackMapEnvDataSkyCardAttributesV76 &operator=(const PackMapEnvDataSkyCardAttributesV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderTextureV47 {
    helpers::FileName filename;
    float4 textureUV;

public:
    PackMapEnvDataShaderTextureV47();
    PackMapEnvDataShaderTextureV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderTextureV47(const PackMapEnvDataShaderTextureV47 &p_other);
    PackMapEnvDataShaderTextureV47 &operator=(const PackMapEnvDataShaderTextureV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEnvDataSkyCardAnimationV47 {
    float2 textureAnimTranslation;
    float2 textureAnimScaleRangeX;
    float2 textureAnimScaleRangeY;
    float2 textureAnimScaleSpeed;
    float textureAnimRotation;
    dword texCoords;

public:
    PackEnvDataSkyCardAnimationV47();
    PackEnvDataSkyCardAnimationV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEnvDataSkyCardAnimationV47(const PackEnvDataSkyCardAnimationV47 &p_other);
    PackEnvDataSkyCardAnimationV47 &operator=(const PackEnvDataSkyCardAnimationV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkycardFlipbookV47 {
    dword rows;
    dword columns;
    dword start;
    dword count;
    float fps;

public:
    PackMapEnvDataSkycardFlipbookV47();
    PackMapEnvDataSkycardFlipbookV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkycardFlipbookV47(const PackMapEnvDataSkycardFlipbookV47 &p_other);
    PackMapEnvDataSkycardFlipbookV47 &operator=(const PackMapEnvDataSkycardFlipbookV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardMaterialV47 {
    helpers::FileName filename;
    helpers::Array<PackMapEnvDataShaderConstantV47> constants;
    helpers::Array<PackMapEnvDataShaderTextureV47> textures;
    PackEnvDataSkyCardAnimationV47 textureAnimation;
    PackMapEnvDataSkycardFlipbookV47 flipbook;

public:
    PackMapEnvDataSkyCardMaterialV47();
    PackMapEnvDataSkyCardMaterialV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardMaterialV47(const PackMapEnvDataSkyCardMaterialV47 &p_other);
    PackMapEnvDataSkyCardMaterialV47 &operator=(const PackMapEnvDataSkyCardMaterialV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardExV47 {
    dword dummy;

public:
    PackMapEnvDataSkyCardExV47();
    PackMapEnvDataSkyCardExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardExV47(const PackMapEnvDataSkyCardExV47 &p_other);
    PackMapEnvDataSkyCardExV47 &operator=(const PackMapEnvDataSkyCardExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV76 {
    PackMapEnvDataSkyCardAttributesV76 day;
    PackMapEnvDataSkyCardAttributesV76 night;
    dword flags;
    helpers::WString name;
    float3 location;
    helpers::Ptr<PackMapEnvDataSkyCardMaterialV47> material;
    helpers::Ptr<PackMapEnvDataSkyCardExV47> ext;

public:
    PackMapEnvDataSkyCardV76();
    PackMapEnvDataSkyCardV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV76(const PackMapEnvDataSkyCardV76 &p_other);
    PackMapEnvDataSkyCardV76 &operator=(const PackMapEnvDataSkyCardV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV76 {
    helpers::Array<PackMapEnvDataSkyCardV76> cards;

public:
    PackMapEnvDataSkyCardsV76();
    PackMapEnvDataSkyCardsV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV76(const PackMapEnvDataSkyCardsV76 &p_other);
    PackMapEnvDataSkyCardsV76 &operator=(const PackMapEnvDataSkyCardsV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV47 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV47();
    PackMapEnvDataSpawnModelDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV47(const PackMapEnvDataSpawnModelDataV47 &p_other);
    PackMapEnvDataSpawnModelDataV47 &operator=(const PackMapEnvDataSpawnModelDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV47 {
    helpers::Array<PackMapEnvDataSpawnModelDataV47> spawns;

public:
    PackMapEnvDataSpawnListV47();
    PackMapEnvDataSpawnListV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV47(const PackMapEnvDataSpawnListV47 &p_other);
    PackMapEnvDataSpawnListV47 &operator=(const PackMapEnvDataSpawnListV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV47 {
    helpers::Array<PackMapEnvDataSpawnListV47> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV47();
    PackMapEnvDataSpawnGroupsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV47(const PackMapEnvDataSpawnGroupsV47 &p_other);
    PackMapEnvDataSpawnGroupsV47 &operator=(const PackMapEnvDataSpawnGroupsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV76 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV76();
    PackMapEnvDataWaterV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV76(const PackMapEnvDataWaterV76 &p_other);
    PackMapEnvDataWaterV76 &operator=(const PackMapEnvDataWaterV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV76 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV76();
    PackMapEnvDataWindV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV76(const PackMapEnvDataWindV76 &p_other);
    PackMapEnvDataWindV76 &operator=(const PackMapEnvDataWindV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataAudioV47 {
    qword token;

public:
    PackMapEnvDataAudioV47();
    PackMapEnvDataAudioV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataAudioV47(const PackMapEnvDataAudioV47 &p_other);
    PackMapEnvDataAudioV47 &operator=(const PackMapEnvDataAudioV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseEx2V47 {
    dword dummy;

public:
    PackMapEnvDataBaseEx2V47();
    PackMapEnvDataBaseEx2V47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseEx2V47(const PackMapEnvDataBaseEx2V47 &p_other);
    PackMapEnvDataBaseEx2V47 &operator=(const PackMapEnvDataBaseEx2V47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseExV47 {
    helpers::Ptr<PackMapEnvDataBaseEx2V47> ext2;
    float brightTime;
    float dimTime;
    float darkCoeff;
    float darkExp;
    float darkMin;
    float darkMax;
    float brightMin;
    float brightMax;
    float brightScale;
    float darkScale;
    float4 waterReflectionParams;

public:
    PackMapEnvDataBaseExV47();
    PackMapEnvDataBaseExV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseExV47(const PackMapEnvDataBaseExV47 &p_other);
    PackMapEnvDataBaseExV47 &operator=(const PackMapEnvDataBaseExV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV47 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV47();
    PackMapEnvDataShapeV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV47(const PackMapEnvDataShapeV47 &p_other);
    PackMapEnvDataShapeV47 &operator=(const PackMapEnvDataShapeV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV76 {
    helpers::Array<PackMapEnvDataLightingV76> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV47> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV76> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV47> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV76> effect;
    helpers::Ptr<PackMapEnvDataHazeV76> haze;
    helpers::Ptr<PackMapEnvDataPFieldV76> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV47> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV76> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV76> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV47> spawns;
    helpers::Ptr<PackMapEnvDataWaterV76> water;
    helpers::Ptr<PackMapEnvDataWindV76> wind;
    helpers::Ptr<PackMapEnvDataAudioV47> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV47> ext;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV47> shapeArray;

public:
    PackMapEnvDataLocalV76();
    PackMapEnvDataLocalV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV76(const PackMapEnvDataLocalV76 &p_other);
    PackMapEnvDataLocalV76 &operator=(const PackMapEnvDataLocalV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV76 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV76();
    PackMapEnvDataSkyModeTexV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV76(const PackMapEnvDataSkyModeTexV76 &p_other);
    PackMapEnvDataSkyModeTexV76 &operator=(const PackMapEnvDataSkyModeTexV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeCubeTexV47 {
    helpers::FileName texPathE;
    helpers::FileName texPathW;
    helpers::FileName texPathN;
    helpers::FileName texPathS;
    helpers::FileName texPathB;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeCubeTexV47();
    PackMapEnvDataSkyModeCubeTexV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeCubeTexV47(const PackMapEnvDataSkyModeCubeTexV47 &p_other);
    PackMapEnvDataSkyModeCubeTexV47 &operator=(const PackMapEnvDataSkyModeCubeTexV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV76 {
    helpers::Array<PackMapEnvDataLightingV76> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV47> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV76> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV47> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV76> effect;
    helpers::Ptr<PackMapEnvDataHazeV76> haze;
    helpers::Ptr<PackMapEnvDataPFieldV76> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV47> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV76> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV76> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV47> spawns;
    helpers::Ptr<PackMapEnvDataWaterV76> water;
    helpers::Ptr<PackMapEnvDataWindV76> wind;
    helpers::Ptr<PackMapEnvDataAudioV47> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV47> ext;
    helpers::Array<PackMapEnvDataSkyModeTexV76> skyModeTex;
    helpers::FileName starFile;
    helpers::Array<PackMapEnvDataSkyModeCubeTexV47> skyModeCubeTex;

public:
    PackMapEnvDataGlobalV76();
    PackMapEnvDataGlobalV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV76(const PackMapEnvDataGlobalV76 &p_other);
    PackMapEnvDataGlobalV76 &operator=(const PackMapEnvDataGlobalV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV76 {
    helpers::Array<PackMapEnvDataLocalV76> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV76> dataGlobal;

public:
    PackMapEnvironmentV76();
    PackMapEnvironmentV76(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV76(const PackMapEnvironmentV76 &p_other);
    PackMapEnvironmentV76 &operator=(const PackMapEnvironmentV76 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV76 Gw2Struct;
};

/* Version: 75, ReferencedFunction: 0x4104F91000000001 */

template <>
struct Gw2Structenv<75>{
struct PackMapEnvDataLightV75 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV75();
    PackMapEnvDataLightV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV75(const PackMapEnvDataLightV75 &p_other);
    PackMapEnvDataLightV75 &operator=(const PackMapEnvDataLightV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV75 {
    helpers::Ptr<PackMapEnvDataLightV75> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV75();
    PackMapEnvDataLightingV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV75(const PackMapEnvDataLightingV75 &p_other);
    PackMapEnvDataLightingV75 &operator=(const PackMapEnvDataLightingV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV46 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV46();
    PackMapEnvDataLightingCharV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV46(const PackMapEnvDataLightingCharV46 &p_other);
    PackMapEnvDataLightingCharV46 &operator=(const PackMapEnvDataLightingCharV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV46 {
    helpers::Array<PackMapEnvDataLightingCharV46> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV46();
    PackMapEnvDataLightingCharGroupV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV46(const PackMapEnvDataLightingCharGroupV46 &p_other);
    PackMapEnvDataLightingCharGroupV46 &operator=(const PackMapEnvDataLightingCharGroupV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV75 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;
    dword reserved;

public:
    PackMapEnvDataLayerAttributesV75();
    PackMapEnvDataLayerAttributesV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV75(const PackMapEnvDataLayerAttributesV75 &p_other);
    PackMapEnvDataLayerAttributesV75 &operator=(const PackMapEnvDataLayerAttributesV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV75 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV75> attributes;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataLayerV75();
    PackMapEnvDataLayerV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV75(const PackMapEnvDataLayerV75 &p_other);
    PackMapEnvDataLayerV75 &operator=(const PackMapEnvDataLayerV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV75 {
    helpers::Array<PackMapEnvDataLayerV75> layers;

public:
    PackMapEnvDataCloudsV75();
    PackMapEnvDataCloudsV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV75(const PackMapEnvDataCloudsV75 &p_other);
    PackMapEnvDataCloudsV75 &operator=(const PackMapEnvDataCloudsV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV46 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV46();
    PackMapEnvDataColoredLightRingsV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV46(const PackMapEnvDataColoredLightRingsV46 &p_other);
    PackMapEnvDataColoredLightRingsV46 &operator=(const PackMapEnvDataColoredLightRingsV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectExV46 {
    dword dummy;

public:
    PackMapEnvDataEffectExV46();
    PackMapEnvDataEffectExV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectExV46(const PackMapEnvDataEffectExV46 &p_other);
    PackMapEnvDataEffectExV46 &operator=(const PackMapEnvDataEffectExV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV75 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float ssaoAmount;
    float ssaoBrighten;
    float ssaoContrast;
    float ssaoSunScale;
    dword flags;
    helpers::FileName clutTexturePath;
    helpers::Ptr<PackMapEnvDataEffectExV46> ext;

public:
    PackMapEnvDataEffectV75();
    PackMapEnvDataEffectV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV75(const PackMapEnvDataEffectV75 &p_other);
    PackMapEnvDataEffectV75 &operator=(const PackMapEnvDataEffectV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV75 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV75();
    PackMapEnvDataHazeV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV75(const PackMapEnvDataHazeV75 &p_other);
    PackMapEnvDataHazeV75 &operator=(const PackMapEnvDataHazeV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV75 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataPFieldV75();
    PackMapEnvDataPFieldV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV75(const PackMapEnvDataPFieldV75 &p_other);
    PackMapEnvDataPFieldV75 &operator=(const PackMapEnvDataPFieldV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV46 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV46();
    PackMapEnvDataPFieldCutoutV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV46(const PackMapEnvDataPFieldCutoutV46 &p_other);
    PackMapEnvDataPFieldCutoutV46 &operator=(const PackMapEnvDataPFieldCutoutV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV75 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV75();
    PackMapEnvDataSkyV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV75(const PackMapEnvDataSkyV75 &p_other);
    PackMapEnvDataSkyV75 &operator=(const PackMapEnvDataSkyV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareAtomV46 {
    dword rows;
    dword columns;
    dword start;
    float fps;
    byte4 color;
    float2 offset;
    float2 scale;
    float baseRotation;
    float cameraRotation;
    byte flags;

public:
    PackMapEnvLensFlareAtomV46();
    PackMapEnvLensFlareAtomV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareAtomV46(const PackMapEnvLensFlareAtomV46 &p_other);
    PackMapEnvLensFlareAtomV46 &operator=(const PackMapEnvLensFlareAtomV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareTextureV46 {
    helpers::FileName texture;

public:
    PackMapEnvLensFlareTextureV46();
    PackMapEnvLensFlareTextureV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareTextureV46(const PackMapEnvLensFlareTextureV46 &p_other);
    PackMapEnvLensFlareTextureV46 &operator=(const PackMapEnvLensFlareTextureV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderConstantV46 {
    dword token;
    float4 value;

public:
    PackMapEnvDataShaderConstantV46();
    PackMapEnvDataShaderConstantV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderConstantV46(const PackMapEnvDataShaderConstantV46 &p_other);
    PackMapEnvDataShaderConstantV46 &operator=(const PackMapEnvDataShaderConstantV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvLensFlareV46 {
    helpers::Array<PackMapEnvLensFlareAtomV46> atoms;
    helpers::Array<PackMapEnvLensFlareTextureV46> textures;
    helpers::FileName material;
    float2 fadeBand;
    float2 reverseFadeBand;
    float opacityCoeff;
    byte flags;
    helpers::Array<PackMapEnvDataShaderConstantV46> constants;

public:
    PackMapEnvLensFlareV46();
    PackMapEnvLensFlareV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvLensFlareV46(const PackMapEnvLensFlareV46 &p_other);
    PackMapEnvLensFlareV46 &operator=(const PackMapEnvLensFlareV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesExV46 {
    dword dummy;

public:
    PackMapEnvDataSkyCardAttributesExV46();
    PackMapEnvDataSkyCardAttributesExV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesExV46(const PackMapEnvDataSkyCardAttributesExV46 &p_other);
    PackMapEnvDataSkyCardAttributesExV46 &operator=(const PackMapEnvDataSkyCardAttributesExV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV75 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;
    helpers::Ptr<PackMapEnvLensFlareV46> lensFlare;
    helpers::Ptr<PackMapEnvDataSkyCardAttributesExV46> ext;

public:
    PackMapEnvDataSkyCardAttributesV75();
    PackMapEnvDataSkyCardAttributesV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV75(const PackMapEnvDataSkyCardAttributesV75 &p_other);
    PackMapEnvDataSkyCardAttributesV75 &operator=(const PackMapEnvDataSkyCardAttributesV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShaderTextureV46 {
    helpers::FileName filename;
    float4 textureUV;

public:
    PackMapEnvDataShaderTextureV46();
    PackMapEnvDataShaderTextureV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShaderTextureV46(const PackMapEnvDataShaderTextureV46 &p_other);
    PackMapEnvDataShaderTextureV46 &operator=(const PackMapEnvDataShaderTextureV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEnvDataSkyCardAnimationV46 {
    float2 textureAnimTranslation;
    float2 textureAnimScaleRangeX;
    float2 textureAnimScaleRangeY;
    float2 textureAnimScaleSpeed;
    float textureAnimRotation;
    dword texCoords;

public:
    PackEnvDataSkyCardAnimationV46();
    PackEnvDataSkyCardAnimationV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEnvDataSkyCardAnimationV46(const PackEnvDataSkyCardAnimationV46 &p_other);
    PackEnvDataSkyCardAnimationV46 &operator=(const PackEnvDataSkyCardAnimationV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkycardFlipbookV46 {
    dword rows;
    dword columns;
    dword start;
    dword count;
    float fps;

public:
    PackMapEnvDataSkycardFlipbookV46();
    PackMapEnvDataSkycardFlipbookV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkycardFlipbookV46(const PackMapEnvDataSkycardFlipbookV46 &p_other);
    PackMapEnvDataSkycardFlipbookV46 &operator=(const PackMapEnvDataSkycardFlipbookV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardMaterialV46 {
    helpers::FileName filename;
    helpers::Array<PackMapEnvDataShaderConstantV46> constants;
    helpers::Array<PackMapEnvDataShaderTextureV46> textures;
    PackEnvDataSkyCardAnimationV46 textureAnimation;
    PackMapEnvDataSkycardFlipbookV46 flipbook;

public:
    PackMapEnvDataSkyCardMaterialV46();
    PackMapEnvDataSkyCardMaterialV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardMaterialV46(const PackMapEnvDataSkyCardMaterialV46 &p_other);
    PackMapEnvDataSkyCardMaterialV46 &operator=(const PackMapEnvDataSkyCardMaterialV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardExV46 {
    dword dummy;

public:
    PackMapEnvDataSkyCardExV46();
    PackMapEnvDataSkyCardExV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardExV46(const PackMapEnvDataSkyCardExV46 &p_other);
    PackMapEnvDataSkyCardExV46 &operator=(const PackMapEnvDataSkyCardExV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV75 {
    PackMapEnvDataSkyCardAttributesV75 day;
    PackMapEnvDataSkyCardAttributesV75 night;
    dword flags;
    helpers::WString name;
    float3 location;
    helpers::Ptr<PackMapEnvDataSkyCardMaterialV46> material;
    helpers::Ptr<PackMapEnvDataSkyCardExV46> ext;

public:
    PackMapEnvDataSkyCardV75();
    PackMapEnvDataSkyCardV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV75(const PackMapEnvDataSkyCardV75 &p_other);
    PackMapEnvDataSkyCardV75 &operator=(const PackMapEnvDataSkyCardV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV75 {
    helpers::Array<PackMapEnvDataSkyCardV75> cards;

public:
    PackMapEnvDataSkyCardsV75();
    PackMapEnvDataSkyCardsV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV75(const PackMapEnvDataSkyCardsV75 &p_other);
    PackMapEnvDataSkyCardsV75 &operator=(const PackMapEnvDataSkyCardsV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV46 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV46();
    PackMapEnvDataSpawnModelDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV46(const PackMapEnvDataSpawnModelDataV46 &p_other);
    PackMapEnvDataSpawnModelDataV46 &operator=(const PackMapEnvDataSpawnModelDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV46 {
    helpers::Array<PackMapEnvDataSpawnModelDataV46> spawns;

public:
    PackMapEnvDataSpawnListV46();
    PackMapEnvDataSpawnListV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV46(const PackMapEnvDataSpawnListV46 &p_other);
    PackMapEnvDataSpawnListV46 &operator=(const PackMapEnvDataSpawnListV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV46 {
    helpers::Array<PackMapEnvDataSpawnListV46> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV46();
    PackMapEnvDataSpawnGroupsV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV46(const PackMapEnvDataSpawnGroupsV46 &p_other);
    PackMapEnvDataSpawnGroupsV46 &operator=(const PackMapEnvDataSpawnGroupsV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV75 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV75();
    PackMapEnvDataWaterV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV75(const PackMapEnvDataWaterV75 &p_other);
    PackMapEnvDataWaterV75 &operator=(const PackMapEnvDataWaterV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV75 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV75();
    PackMapEnvDataWindV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV75(const PackMapEnvDataWindV75 &p_other);
    PackMapEnvDataWindV75 &operator=(const PackMapEnvDataWindV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataAudioV46 {
    qword token;

public:
    PackMapEnvDataAudioV46();
    PackMapEnvDataAudioV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataAudioV46(const PackMapEnvDataAudioV46 &p_other);
    PackMapEnvDataAudioV46 &operator=(const PackMapEnvDataAudioV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseEx2V46 {
    dword dummy;

public:
    PackMapEnvDataBaseEx2V46();
    PackMapEnvDataBaseEx2V46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseEx2V46(const PackMapEnvDataBaseEx2V46 &p_other);
    PackMapEnvDataBaseEx2V46 &operator=(const PackMapEnvDataBaseEx2V46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataBaseExV46 {
    helpers::Ptr<PackMapEnvDataBaseEx2V46> ext2;
    float brightTime;
    float dimTime;
    float darkCoeff;
    float darkExp;
    float darkMin;
    float darkMax;
    float brightMin;
    float brightMax;
    float brightScale;
    float darkScale;
    float4 waterReflectionParams;

public:
    PackMapEnvDataBaseExV46();
    PackMapEnvDataBaseExV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataBaseExV46(const PackMapEnvDataBaseExV46 &p_other);
    PackMapEnvDataBaseExV46 &operator=(const PackMapEnvDataBaseExV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV46 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV46();
    PackMapEnvDataShapeV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV46(const PackMapEnvDataShapeV46 &p_other);
    PackMapEnvDataShapeV46 &operator=(const PackMapEnvDataShapeV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV75 {
    helpers::Array<PackMapEnvDataLightingV75> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV46> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV75> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV46> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV75> effect;
    helpers::Ptr<PackMapEnvDataHazeV75> haze;
    helpers::Ptr<PackMapEnvDataPFieldV75> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV46> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV75> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV75> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV46> spawns;
    helpers::Ptr<PackMapEnvDataWaterV75> water;
    helpers::Ptr<PackMapEnvDataWindV75> wind;
    helpers::Ptr<PackMapEnvDataAudioV46> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV46> ext;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV46> shapeArray;

public:
    PackMapEnvDataLocalV75();
    PackMapEnvDataLocalV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV75(const PackMapEnvDataLocalV75 &p_other);
    PackMapEnvDataLocalV75 &operator=(const PackMapEnvDataLocalV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV75 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV75();
    PackMapEnvDataSkyModeTexV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV75(const PackMapEnvDataSkyModeTexV75 &p_other);
    PackMapEnvDataSkyModeTexV75 &operator=(const PackMapEnvDataSkyModeTexV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV75 {
    helpers::Array<PackMapEnvDataLightingV75> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV46> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV75> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV46> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV75> effect;
    helpers::Ptr<PackMapEnvDataHazeV75> haze;
    helpers::Ptr<PackMapEnvDataPFieldV75> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV46> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV75> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV75> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV46> spawns;
    helpers::Ptr<PackMapEnvDataWaterV75> water;
    helpers::Ptr<PackMapEnvDataWindV75> wind;
    helpers::Ptr<PackMapEnvDataAudioV46> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    dword flags;
    helpers::Ptr<PackMapEnvDataBaseExV46> ext;
    helpers::Array<PackMapEnvDataSkyModeTexV75> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV75();
    PackMapEnvDataGlobalV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV75(const PackMapEnvDataGlobalV75 &p_other);
    PackMapEnvDataGlobalV75 &operator=(const PackMapEnvDataGlobalV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV75 {
    helpers::Array<PackMapEnvDataLocalV75> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV75> dataGlobal;

public:
    PackMapEnvironmentV75();
    PackMapEnvironmentV75(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV75(const PackMapEnvironmentV75 &p_other);
    PackMapEnvironmentV75 &operator=(const PackMapEnvironmentV75 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV75 Gw2Struct;
};

/* Version: 74, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<74>{
struct PackMapEnvDataLightV74 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV74();
    PackMapEnvDataLightV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV74(const PackMapEnvDataLightV74 &p_other);
    PackMapEnvDataLightV74 &operator=(const PackMapEnvDataLightV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV74 {
    helpers::Ptr<PackMapEnvDataLightV74> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV74();
    PackMapEnvDataLightingV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV74(const PackMapEnvDataLightingV74 &p_other);
    PackMapEnvDataLightingV74 &operator=(const PackMapEnvDataLightingV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV45 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV45();
    PackMapEnvDataLightingCharV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV45(const PackMapEnvDataLightingCharV45 &p_other);
    PackMapEnvDataLightingCharV45 &operator=(const PackMapEnvDataLightingCharV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV45 {
    helpers::Array<PackMapEnvDataLightingCharV45> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV45();
    PackMapEnvDataLightingCharGroupV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV45(const PackMapEnvDataLightingCharGroupV45 &p_other);
    PackMapEnvDataLightingCharGroupV45 &operator=(const PackMapEnvDataLightingCharGroupV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV74 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;
    dword reserved;

public:
    PackMapEnvDataLayerAttributesV74();
    PackMapEnvDataLayerAttributesV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV74(const PackMapEnvDataLayerAttributesV74 &p_other);
    PackMapEnvDataLayerAttributesV74 &operator=(const PackMapEnvDataLayerAttributesV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV74 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV74> attributes;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataLayerV74();
    PackMapEnvDataLayerV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV74(const PackMapEnvDataLayerV74 &p_other);
    PackMapEnvDataLayerV74 &operator=(const PackMapEnvDataLayerV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV74 {
    helpers::Array<PackMapEnvDataLayerV74> layers;

public:
    PackMapEnvDataCloudsV74();
    PackMapEnvDataCloudsV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV74(const PackMapEnvDataCloudsV74 &p_other);
    PackMapEnvDataCloudsV74 &operator=(const PackMapEnvDataCloudsV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV45 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV45();
    PackMapEnvDataColoredLightRingsV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV45(const PackMapEnvDataColoredLightRingsV45 &p_other);
    PackMapEnvDataColoredLightRingsV45 &operator=(const PackMapEnvDataColoredLightRingsV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV74 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV74();
    PackMapEnvDataEffectV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV74(const PackMapEnvDataEffectV74 &p_other);
    PackMapEnvDataEffectV74 &operator=(const PackMapEnvDataEffectV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV74 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV74();
    PackMapEnvDataHazeV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV74(const PackMapEnvDataHazeV74 &p_other);
    PackMapEnvDataHazeV74 &operator=(const PackMapEnvDataHazeV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV74 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;
    dword reserved;

public:
    PackMapEnvDataPFieldV74();
    PackMapEnvDataPFieldV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV74(const PackMapEnvDataPFieldV74 &p_other);
    PackMapEnvDataPFieldV74 &operator=(const PackMapEnvDataPFieldV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV45 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV45();
    PackMapEnvDataPFieldCutoutV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV45(const PackMapEnvDataPFieldCutoutV45 &p_other);
    PackMapEnvDataPFieldCutoutV45 &operator=(const PackMapEnvDataPFieldCutoutV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV74 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV74();
    PackMapEnvDataSkyV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV74(const PackMapEnvDataSkyV74 &p_other);
    PackMapEnvDataSkyV74 &operator=(const PackMapEnvDataSkyV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV74 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV74();
    PackMapEnvDataSkyCardAttributesV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV74(const PackMapEnvDataSkyCardAttributesV74 &p_other);
    PackMapEnvDataSkyCardAttributesV74 &operator=(const PackMapEnvDataSkyCardAttributesV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV74 {
    PackMapEnvDataSkyCardAttributesV74 day;
    PackMapEnvDataSkyCardAttributesV74 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV74();
    PackMapEnvDataSkyCardV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV74(const PackMapEnvDataSkyCardV74 &p_other);
    PackMapEnvDataSkyCardV74 &operator=(const PackMapEnvDataSkyCardV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV74 {
    helpers::Array<PackMapEnvDataSkyCardV74> cards;

public:
    PackMapEnvDataSkyCardsV74();
    PackMapEnvDataSkyCardsV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV74(const PackMapEnvDataSkyCardsV74 &p_other);
    PackMapEnvDataSkyCardsV74 &operator=(const PackMapEnvDataSkyCardsV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV45 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV45();
    PackMapEnvDataSpawnModelDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV45(const PackMapEnvDataSpawnModelDataV45 &p_other);
    PackMapEnvDataSpawnModelDataV45 &operator=(const PackMapEnvDataSpawnModelDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV45 {
    helpers::Array<PackMapEnvDataSpawnModelDataV45> spawns;

public:
    PackMapEnvDataSpawnListV45();
    PackMapEnvDataSpawnListV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV45(const PackMapEnvDataSpawnListV45 &p_other);
    PackMapEnvDataSpawnListV45 &operator=(const PackMapEnvDataSpawnListV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV45 {
    helpers::Array<PackMapEnvDataSpawnListV45> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV45();
    PackMapEnvDataSpawnGroupsV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV45(const PackMapEnvDataSpawnGroupsV45 &p_other);
    PackMapEnvDataSpawnGroupsV45 &operator=(const PackMapEnvDataSpawnGroupsV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV74 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV74();
    PackMapEnvDataWaterV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV74(const PackMapEnvDataWaterV74 &p_other);
    PackMapEnvDataWaterV74 &operator=(const PackMapEnvDataWaterV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV74 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV74();
    PackMapEnvDataWindV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV74(const PackMapEnvDataWindV74 &p_other);
    PackMapEnvDataWindV74 &operator=(const PackMapEnvDataWindV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataAudioV45 {
    qword token;

public:
    PackMapEnvDataAudioV45();
    PackMapEnvDataAudioV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataAudioV45(const PackMapEnvDataAudioV45 &p_other);
    PackMapEnvDataAudioV45 &operator=(const PackMapEnvDataAudioV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV45 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV45();
    PackMapEnvDataShapeV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV45(const PackMapEnvDataShapeV45 &p_other);
    PackMapEnvDataShapeV45 &operator=(const PackMapEnvDataShapeV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV74 {
    helpers::Array<PackMapEnvDataLightingV74> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV45> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV74> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV45> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV74> effect;
    helpers::Ptr<PackMapEnvDataHazeV74> haze;
    helpers::Ptr<PackMapEnvDataPFieldV74> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV45> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV74> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV74> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV45> spawns;
    helpers::Ptr<PackMapEnvDataWaterV74> water;
    helpers::Ptr<PackMapEnvDataWindV74> wind;
    helpers::Ptr<PackMapEnvDataAudioV45> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::WString reserved;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV45> shapeArray;

public:
    PackMapEnvDataLocalV74();
    PackMapEnvDataLocalV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV74(const PackMapEnvDataLocalV74 &p_other);
    PackMapEnvDataLocalV74 &operator=(const PackMapEnvDataLocalV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV74 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV74();
    PackMapEnvDataSkyModeTexV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV74(const PackMapEnvDataSkyModeTexV74 &p_other);
    PackMapEnvDataSkyModeTexV74 &operator=(const PackMapEnvDataSkyModeTexV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV74 {
    helpers::Array<PackMapEnvDataLightingV74> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV45> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV74> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV45> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV74> effect;
    helpers::Ptr<PackMapEnvDataHazeV74> haze;
    helpers::Ptr<PackMapEnvDataPFieldV74> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV45> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV74> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV74> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV45> spawns;
    helpers::Ptr<PackMapEnvDataWaterV74> water;
    helpers::Ptr<PackMapEnvDataWindV74> wind;
    helpers::Ptr<PackMapEnvDataAudioV45> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::WString reserved;
    helpers::Array<PackMapEnvDataSkyModeTexV74> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV74();
    PackMapEnvDataGlobalV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV74(const PackMapEnvDataGlobalV74 &p_other);
    PackMapEnvDataGlobalV74 &operator=(const PackMapEnvDataGlobalV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV74 {
    helpers::Array<PackMapEnvDataLocalV74> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV74> dataGlobal;

public:
    PackMapEnvironmentV74();
    PackMapEnvironmentV74(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV74(const PackMapEnvironmentV74 &p_other);
    PackMapEnvironmentV74 &operator=(const PackMapEnvironmentV74 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV74 Gw2Struct;
};

/* Version: 73, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<73>{
struct PackMapEnvDataLightV73 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV73();
    PackMapEnvDataLightV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV73(const PackMapEnvDataLightV73 &p_other);
    PackMapEnvDataLightV73 &operator=(const PackMapEnvDataLightV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV73 {
    helpers::Ptr<PackMapEnvDataLightV73> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV73();
    PackMapEnvDataLightingV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV73(const PackMapEnvDataLightingV73 &p_other);
    PackMapEnvDataLightingV73 &operator=(const PackMapEnvDataLightingV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV44 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV44();
    PackMapEnvDataLightingCharV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV44(const PackMapEnvDataLightingCharV44 &p_other);
    PackMapEnvDataLightingCharV44 &operator=(const PackMapEnvDataLightingCharV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV44 {
    helpers::Array<PackMapEnvDataLightingCharV44> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV44();
    PackMapEnvDataLightingCharGroupV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV44(const PackMapEnvDataLightingCharGroupV44 &p_other);
    PackMapEnvDataLightingCharGroupV44 &operator=(const PackMapEnvDataLightingCharGroupV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV73 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV73();
    PackMapEnvDataLayerAttributesV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV73(const PackMapEnvDataLayerAttributesV73 &p_other);
    PackMapEnvDataLayerAttributesV73 &operator=(const PackMapEnvDataLayerAttributesV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV73 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV73> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV73();
    PackMapEnvDataLayerV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV73(const PackMapEnvDataLayerV73 &p_other);
    PackMapEnvDataLayerV73 &operator=(const PackMapEnvDataLayerV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV73 {
    helpers::Array<PackMapEnvDataLayerV73> layers;

public:
    PackMapEnvDataCloudsV73();
    PackMapEnvDataCloudsV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV73(const PackMapEnvDataCloudsV73 &p_other);
    PackMapEnvDataCloudsV73 &operator=(const PackMapEnvDataCloudsV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV44 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV44();
    PackMapEnvDataColoredLightRingsV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV44(const PackMapEnvDataColoredLightRingsV44 &p_other);
    PackMapEnvDataColoredLightRingsV44 &operator=(const PackMapEnvDataColoredLightRingsV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV73 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV73();
    PackMapEnvDataEffectV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV73(const PackMapEnvDataEffectV73 &p_other);
    PackMapEnvDataEffectV73 &operator=(const PackMapEnvDataEffectV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV73 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV73();
    PackMapEnvDataHazeV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV73(const PackMapEnvDataHazeV73 &p_other);
    PackMapEnvDataHazeV73 &operator=(const PackMapEnvDataHazeV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV73 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV73();
    PackMapEnvDataPFieldV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV73(const PackMapEnvDataPFieldV73 &p_other);
    PackMapEnvDataPFieldV73 &operator=(const PackMapEnvDataPFieldV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV44 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV44();
    PackMapEnvDataPFieldCutoutV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV44(const PackMapEnvDataPFieldCutoutV44 &p_other);
    PackMapEnvDataPFieldCutoutV44 &operator=(const PackMapEnvDataPFieldCutoutV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV73 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV73();
    PackMapEnvDataSkyV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV73(const PackMapEnvDataSkyV73 &p_other);
    PackMapEnvDataSkyV73 &operator=(const PackMapEnvDataSkyV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV73 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV73();
    PackMapEnvDataSkyCardAttributesV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV73(const PackMapEnvDataSkyCardAttributesV73 &p_other);
    PackMapEnvDataSkyCardAttributesV73 &operator=(const PackMapEnvDataSkyCardAttributesV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV73 {
    PackMapEnvDataSkyCardAttributesV73 day;
    PackMapEnvDataSkyCardAttributesV73 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV73();
    PackMapEnvDataSkyCardV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV73(const PackMapEnvDataSkyCardV73 &p_other);
    PackMapEnvDataSkyCardV73 &operator=(const PackMapEnvDataSkyCardV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV73 {
    helpers::Array<PackMapEnvDataSkyCardV73> cards;

public:
    PackMapEnvDataSkyCardsV73();
    PackMapEnvDataSkyCardsV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV73(const PackMapEnvDataSkyCardsV73 &p_other);
    PackMapEnvDataSkyCardsV73 &operator=(const PackMapEnvDataSkyCardsV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV44 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV44();
    PackMapEnvDataSpawnModelDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV44(const PackMapEnvDataSpawnModelDataV44 &p_other);
    PackMapEnvDataSpawnModelDataV44 &operator=(const PackMapEnvDataSpawnModelDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV44 {
    helpers::Array<PackMapEnvDataSpawnModelDataV44> spawns;

public:
    PackMapEnvDataSpawnListV44();
    PackMapEnvDataSpawnListV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV44(const PackMapEnvDataSpawnListV44 &p_other);
    PackMapEnvDataSpawnListV44 &operator=(const PackMapEnvDataSpawnListV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV44 {
    helpers::Array<PackMapEnvDataSpawnListV44> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV44();
    PackMapEnvDataSpawnGroupsV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV44(const PackMapEnvDataSpawnGroupsV44 &p_other);
    PackMapEnvDataSpawnGroupsV44 &operator=(const PackMapEnvDataSpawnGroupsV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV73 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV73();
    PackMapEnvDataWaterV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV73(const PackMapEnvDataWaterV73 &p_other);
    PackMapEnvDataWaterV73 &operator=(const PackMapEnvDataWaterV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV73 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV73();
    PackMapEnvDataWindV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV73(const PackMapEnvDataWindV73 &p_other);
    PackMapEnvDataWindV73 &operator=(const PackMapEnvDataWindV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataAudioV44 {
    qword token;

public:
    PackMapEnvDataAudioV44();
    PackMapEnvDataAudioV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataAudioV44(const PackMapEnvDataAudioV44 &p_other);
    PackMapEnvDataAudioV44 &operator=(const PackMapEnvDataAudioV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV44 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV44();
    PackMapEnvDataShapeV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV44(const PackMapEnvDataShapeV44 &p_other);
    PackMapEnvDataShapeV44 &operator=(const PackMapEnvDataShapeV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV73 {
    helpers::Array<PackMapEnvDataLightingV73> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV44> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV73> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV44> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV73> effect;
    helpers::Ptr<PackMapEnvDataHazeV73> haze;
    helpers::Ptr<PackMapEnvDataPFieldV73> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV44> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV73> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV73> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV44> spawns;
    helpers::Ptr<PackMapEnvDataWaterV73> water;
    helpers::Ptr<PackMapEnvDataWindV73> wind;
    helpers::Ptr<PackMapEnvDataAudioV44> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV44> shapeArray;

public:
    PackMapEnvDataLocalV73();
    PackMapEnvDataLocalV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV73(const PackMapEnvDataLocalV73 &p_other);
    PackMapEnvDataLocalV73 &operator=(const PackMapEnvDataLocalV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV73 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV73();
    PackMapEnvDataSkyModeTexV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV73(const PackMapEnvDataSkyModeTexV73 &p_other);
    PackMapEnvDataSkyModeTexV73 &operator=(const PackMapEnvDataSkyModeTexV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV73 {
    helpers::Array<PackMapEnvDataLightingV73> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV44> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV73> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV44> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV73> effect;
    helpers::Ptr<PackMapEnvDataHazeV73> haze;
    helpers::Ptr<PackMapEnvDataPFieldV73> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV44> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV73> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV73> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV44> spawns;
    helpers::Ptr<PackMapEnvDataWaterV73> water;
    helpers::Ptr<PackMapEnvDataWindV73> wind;
    helpers::Ptr<PackMapEnvDataAudioV44> audio;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV73> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV73();
    PackMapEnvDataGlobalV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV73(const PackMapEnvDataGlobalV73 &p_other);
    PackMapEnvDataGlobalV73 &operator=(const PackMapEnvDataGlobalV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV73 {
    helpers::Array<PackMapEnvDataLocalV73> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV73> dataGlobal;

public:
    PackMapEnvironmentV73();
    PackMapEnvironmentV73(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV73(const PackMapEnvironmentV73 &p_other);
    PackMapEnvironmentV73 &operator=(const PackMapEnvironmentV73 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV73 Gw2Struct;
};

/* Version: 72, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<72>{
struct PackMapEnvDataLightV72 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV72();
    PackMapEnvDataLightV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV72(const PackMapEnvDataLightV72 &p_other);
    PackMapEnvDataLightV72 &operator=(const PackMapEnvDataLightV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV72 {
    helpers::Ptr<PackMapEnvDataLightV72> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV72();
    PackMapEnvDataLightingV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV72(const PackMapEnvDataLightingV72 &p_other);
    PackMapEnvDataLightingV72 &operator=(const PackMapEnvDataLightingV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV43 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV43();
    PackMapEnvDataLightingCharV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV43(const PackMapEnvDataLightingCharV43 &p_other);
    PackMapEnvDataLightingCharV43 &operator=(const PackMapEnvDataLightingCharV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV43 {
    helpers::Array<PackMapEnvDataLightingCharV43> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV43();
    PackMapEnvDataLightingCharGroupV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV43(const PackMapEnvDataLightingCharGroupV43 &p_other);
    PackMapEnvDataLightingCharGroupV43 &operator=(const PackMapEnvDataLightingCharGroupV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV72 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV72();
    PackMapEnvDataLayerAttributesV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV72(const PackMapEnvDataLayerAttributesV72 &p_other);
    PackMapEnvDataLayerAttributesV72 &operator=(const PackMapEnvDataLayerAttributesV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV72 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV72> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV72();
    PackMapEnvDataLayerV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV72(const PackMapEnvDataLayerV72 &p_other);
    PackMapEnvDataLayerV72 &operator=(const PackMapEnvDataLayerV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV72 {
    helpers::Array<PackMapEnvDataLayerV72> layers;

public:
    PackMapEnvDataCloudsV72();
    PackMapEnvDataCloudsV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV72(const PackMapEnvDataCloudsV72 &p_other);
    PackMapEnvDataCloudsV72 &operator=(const PackMapEnvDataCloudsV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV43 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV43();
    PackMapEnvDataColoredLightRingsV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV43(const PackMapEnvDataColoredLightRingsV43 &p_other);
    PackMapEnvDataColoredLightRingsV43 &operator=(const PackMapEnvDataColoredLightRingsV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV72 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV72();
    PackMapEnvDataEffectV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV72(const PackMapEnvDataEffectV72 &p_other);
    PackMapEnvDataEffectV72 &operator=(const PackMapEnvDataEffectV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV72 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV72();
    PackMapEnvDataHazeV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV72(const PackMapEnvDataHazeV72 &p_other);
    PackMapEnvDataHazeV72 &operator=(const PackMapEnvDataHazeV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV72 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV72();
    PackMapEnvDataPFieldV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV72(const PackMapEnvDataPFieldV72 &p_other);
    PackMapEnvDataPFieldV72 &operator=(const PackMapEnvDataPFieldV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV43 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV43();
    PackMapEnvDataPFieldCutoutV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV43(const PackMapEnvDataPFieldCutoutV43 &p_other);
    PackMapEnvDataPFieldCutoutV43 &operator=(const PackMapEnvDataPFieldCutoutV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV72 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV72();
    PackMapEnvDataSkyV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV72(const PackMapEnvDataSkyV72 &p_other);
    PackMapEnvDataSkyV72 &operator=(const PackMapEnvDataSkyV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV72 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV72();
    PackMapEnvDataSkyCardAttributesV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV72(const PackMapEnvDataSkyCardAttributesV72 &p_other);
    PackMapEnvDataSkyCardAttributesV72 &operator=(const PackMapEnvDataSkyCardAttributesV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV72 {
    PackMapEnvDataSkyCardAttributesV72 day;
    PackMapEnvDataSkyCardAttributesV72 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV72();
    PackMapEnvDataSkyCardV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV72(const PackMapEnvDataSkyCardV72 &p_other);
    PackMapEnvDataSkyCardV72 &operator=(const PackMapEnvDataSkyCardV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV72 {
    helpers::Array<PackMapEnvDataSkyCardV72> cards;

public:
    PackMapEnvDataSkyCardsV72();
    PackMapEnvDataSkyCardsV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV72(const PackMapEnvDataSkyCardsV72 &p_other);
    PackMapEnvDataSkyCardsV72 &operator=(const PackMapEnvDataSkyCardsV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV43 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV43();
    PackMapEnvDataSpawnModelDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV43(const PackMapEnvDataSpawnModelDataV43 &p_other);
    PackMapEnvDataSpawnModelDataV43 &operator=(const PackMapEnvDataSpawnModelDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV43 {
    helpers::Array<PackMapEnvDataSpawnModelDataV43> spawns;

public:
    PackMapEnvDataSpawnListV43();
    PackMapEnvDataSpawnListV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV43(const PackMapEnvDataSpawnListV43 &p_other);
    PackMapEnvDataSpawnListV43 &operator=(const PackMapEnvDataSpawnListV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV43 {
    helpers::Array<PackMapEnvDataSpawnListV43> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV43();
    PackMapEnvDataSpawnGroupsV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV43(const PackMapEnvDataSpawnGroupsV43 &p_other);
    PackMapEnvDataSpawnGroupsV43 &operator=(const PackMapEnvDataSpawnGroupsV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV72 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV72();
    PackMapEnvDataWaterV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV72(const PackMapEnvDataWaterV72 &p_other);
    PackMapEnvDataWaterV72 &operator=(const PackMapEnvDataWaterV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV72 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV72();
    PackMapEnvDataWindV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV72(const PackMapEnvDataWindV72 &p_other);
    PackMapEnvDataWindV72 &operator=(const PackMapEnvDataWindV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV43 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV43();
    PackMapEnvDataShapeV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV43(const PackMapEnvDataShapeV43 &p_other);
    PackMapEnvDataShapeV43 &operator=(const PackMapEnvDataShapeV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV72 {
    helpers::Array<PackMapEnvDataLightingV72> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV43> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV72> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV43> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV72> effect;
    helpers::Ptr<PackMapEnvDataHazeV72> haze;
    helpers::Ptr<PackMapEnvDataPFieldV72> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV43> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV72> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV72> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV43> spawns;
    helpers::Ptr<PackMapEnvDataWaterV72> water;
    helpers::Ptr<PackMapEnvDataWindV72> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    qword audioToken;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV43> shapeArray;

public:
    PackMapEnvDataLocalV72();
    PackMapEnvDataLocalV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV72(const PackMapEnvDataLocalV72 &p_other);
    PackMapEnvDataLocalV72 &operator=(const PackMapEnvDataLocalV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV72 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV72();
    PackMapEnvDataSkyModeTexV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV72(const PackMapEnvDataSkyModeTexV72 &p_other);
    PackMapEnvDataSkyModeTexV72 &operator=(const PackMapEnvDataSkyModeTexV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV72 {
    helpers::Array<PackMapEnvDataLightingV72> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV43> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV72> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV43> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV72> effect;
    helpers::Ptr<PackMapEnvDataHazeV72> haze;
    helpers::Ptr<PackMapEnvDataPFieldV72> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV43> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV72> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV72> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV43> spawns;
    helpers::Ptr<PackMapEnvDataWaterV72> water;
    helpers::Ptr<PackMapEnvDataWindV72> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    qword audioToken;
    helpers::Array<PackMapEnvDataSkyModeTexV72> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV72();
    PackMapEnvDataGlobalV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV72(const PackMapEnvDataGlobalV72 &p_other);
    PackMapEnvDataGlobalV72 &operator=(const PackMapEnvDataGlobalV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV72 {
    helpers::Array<PackMapEnvDataLocalV72> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV72> dataGlobal;

public:
    PackMapEnvironmentV72();
    PackMapEnvironmentV72(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV72(const PackMapEnvironmentV72 &p_other);
    PackMapEnvironmentV72 &operator=(const PackMapEnvironmentV72 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV72 Gw2Struct;
};

/* Version: 71, ReferencedFunction: 0x4104F84000000001 */

template <>
struct Gw2Structenv<71>{
struct PackMapEnvDataLightV71 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV71();
    PackMapEnvDataLightV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV71(const PackMapEnvDataLightV71 &p_other);
    PackMapEnvDataLightV71 &operator=(const PackMapEnvDataLightV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV71 {
    helpers::Ptr<PackMapEnvDataLightV71> lights;
    float shadowInfluence;
    byte3 backlightColor;
    float backlightIntensity;

public:
    PackMapEnvDataLightingV71();
    PackMapEnvDataLightingV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV71(const PackMapEnvDataLightingV71 &p_other);
    PackMapEnvDataLightingV71 &operator=(const PackMapEnvDataLightingV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV42 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV42();
    PackMapEnvDataLightingCharV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV42(const PackMapEnvDataLightingCharV42 &p_other);
    PackMapEnvDataLightingCharV42 &operator=(const PackMapEnvDataLightingCharV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV42 {
    helpers::Array<PackMapEnvDataLightingCharV42> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV42();
    PackMapEnvDataLightingCharGroupV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV42(const PackMapEnvDataLightingCharGroupV42 &p_other);
    PackMapEnvDataLightingCharGroupV42 &operator=(const PackMapEnvDataLightingCharGroupV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV71 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV71();
    PackMapEnvDataLayerAttributesV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV71(const PackMapEnvDataLayerAttributesV71 &p_other);
    PackMapEnvDataLayerAttributesV71 &operator=(const PackMapEnvDataLayerAttributesV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV71 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV71> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV71();
    PackMapEnvDataLayerV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV71(const PackMapEnvDataLayerV71 &p_other);
    PackMapEnvDataLayerV71 &operator=(const PackMapEnvDataLayerV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV71 {
    helpers::Array<PackMapEnvDataLayerV71> layers;

public:
    PackMapEnvDataCloudsV71();
    PackMapEnvDataCloudsV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV71(const PackMapEnvDataCloudsV71 &p_other);
    PackMapEnvDataCloudsV71 &operator=(const PackMapEnvDataCloudsV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV42 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV42();
    PackMapEnvDataColoredLightRingsV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV42(const PackMapEnvDataColoredLightRingsV42 &p_other);
    PackMapEnvDataColoredLightRingsV42 &operator=(const PackMapEnvDataColoredLightRingsV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV71 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV71();
    PackMapEnvDataEffectV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV71(const PackMapEnvDataEffectV71 &p_other);
    PackMapEnvDataEffectV71 &operator=(const PackMapEnvDataEffectV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV71 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV71();
    PackMapEnvDataHazeV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV71(const PackMapEnvDataHazeV71 &p_other);
    PackMapEnvDataHazeV71 &operator=(const PackMapEnvDataHazeV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV71 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV71();
    PackMapEnvDataPFieldV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV71(const PackMapEnvDataPFieldV71 &p_other);
    PackMapEnvDataPFieldV71 &operator=(const PackMapEnvDataPFieldV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV42 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV42();
    PackMapEnvDataPFieldCutoutV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV42(const PackMapEnvDataPFieldCutoutV42 &p_other);
    PackMapEnvDataPFieldCutoutV42 &operator=(const PackMapEnvDataPFieldCutoutV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV71 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV71();
    PackMapEnvDataSkyV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV71(const PackMapEnvDataSkyV71 &p_other);
    PackMapEnvDataSkyV71 &operator=(const PackMapEnvDataSkyV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV71 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV71();
    PackMapEnvDataSkyCardAttributesV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV71(const PackMapEnvDataSkyCardAttributesV71 &p_other);
    PackMapEnvDataSkyCardAttributesV71 &operator=(const PackMapEnvDataSkyCardAttributesV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV71 {
    PackMapEnvDataSkyCardAttributesV71 day;
    PackMapEnvDataSkyCardAttributesV71 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV71();
    PackMapEnvDataSkyCardV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV71(const PackMapEnvDataSkyCardV71 &p_other);
    PackMapEnvDataSkyCardV71 &operator=(const PackMapEnvDataSkyCardV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV71 {
    helpers::Array<PackMapEnvDataSkyCardV71> cards;

public:
    PackMapEnvDataSkyCardsV71();
    PackMapEnvDataSkyCardsV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV71(const PackMapEnvDataSkyCardsV71 &p_other);
    PackMapEnvDataSkyCardsV71 &operator=(const PackMapEnvDataSkyCardsV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV42 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV42();
    PackMapEnvDataSpawnModelDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV42(const PackMapEnvDataSpawnModelDataV42 &p_other);
    PackMapEnvDataSpawnModelDataV42 &operator=(const PackMapEnvDataSpawnModelDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV42 {
    helpers::Array<PackMapEnvDataSpawnModelDataV42> spawns;

public:
    PackMapEnvDataSpawnListV42();
    PackMapEnvDataSpawnListV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV42(const PackMapEnvDataSpawnListV42 &p_other);
    PackMapEnvDataSpawnListV42 &operator=(const PackMapEnvDataSpawnListV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV42 {
    helpers::Array<PackMapEnvDataSpawnListV42> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV42();
    PackMapEnvDataSpawnGroupsV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV42(const PackMapEnvDataSpawnGroupsV42 &p_other);
    PackMapEnvDataSpawnGroupsV42 &operator=(const PackMapEnvDataSpawnGroupsV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV71 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV71();
    PackMapEnvDataWaterV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV71(const PackMapEnvDataWaterV71 &p_other);
    PackMapEnvDataWaterV71 &operator=(const PackMapEnvDataWaterV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV71 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV71();
    PackMapEnvDataWindV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV71(const PackMapEnvDataWindV71 &p_other);
    PackMapEnvDataWindV71 &operator=(const PackMapEnvDataWindV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV42 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV42();
    PackMapEnvDataShapeV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV42(const PackMapEnvDataShapeV42 &p_other);
    PackMapEnvDataShapeV42 &operator=(const PackMapEnvDataShapeV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV71 {
    helpers::Array<PackMapEnvDataLightingV71> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV42> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV71> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV42> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV71> effect;
    helpers::Ptr<PackMapEnvDataHazeV71> haze;
    helpers::Ptr<PackMapEnvDataPFieldV71> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV42> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV71> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV71> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV42> spawns;
    helpers::Ptr<PackMapEnvDataWaterV71> water;
    helpers::Ptr<PackMapEnvDataWindV71> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV42> shapeArray;

public:
    PackMapEnvDataLocalV71();
    PackMapEnvDataLocalV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV71(const PackMapEnvDataLocalV71 &p_other);
    PackMapEnvDataLocalV71 &operator=(const PackMapEnvDataLocalV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV71 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV71();
    PackMapEnvDataSkyModeTexV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV71(const PackMapEnvDataSkyModeTexV71 &p_other);
    PackMapEnvDataSkyModeTexV71 &operator=(const PackMapEnvDataSkyModeTexV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV71 {
    helpers::Array<PackMapEnvDataLightingV71> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV42> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV71> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV42> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV71> effect;
    helpers::Ptr<PackMapEnvDataHazeV71> haze;
    helpers::Ptr<PackMapEnvDataPFieldV71> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV42> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV71> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV71> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV42> spawns;
    helpers::Ptr<PackMapEnvDataWaterV71> water;
    helpers::Ptr<PackMapEnvDataWindV71> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV71> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV71();
    PackMapEnvDataGlobalV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV71(const PackMapEnvDataGlobalV71 &p_other);
    PackMapEnvDataGlobalV71 &operator=(const PackMapEnvDataGlobalV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV71 {
    helpers::Array<PackMapEnvDataLocalV71> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV71> dataGlobal;

public:
    PackMapEnvironmentV71();
    PackMapEnvironmentV71(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV71(const PackMapEnvironmentV71 &p_other);
    PackMapEnvironmentV71 &operator=(const PackMapEnvironmentV71 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV71 Gw2Struct;
};

/* Version: 70, ReferencedFunction: 0x4104F7F000000001 */

template <>
struct Gw2Structenv<70>{
struct PackMapEnvDataLightV70 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV70();
    PackMapEnvDataLightV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV70(const PackMapEnvDataLightV70 &p_other);
    PackMapEnvDataLightV70 &operator=(const PackMapEnvDataLightV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV70 {
    helpers::Ptr<PackMapEnvDataLightV70> lights;
    float shadowInfluence;

public:
    PackMapEnvDataLightingV70();
    PackMapEnvDataLightingV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV70(const PackMapEnvDataLightingV70 &p_other);
    PackMapEnvDataLightingV70 &operator=(const PackMapEnvDataLightingV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV41 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV41();
    PackMapEnvDataLightingCharV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV41(const PackMapEnvDataLightingCharV41 &p_other);
    PackMapEnvDataLightingCharV41 &operator=(const PackMapEnvDataLightingCharV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV41 {
    helpers::Array<PackMapEnvDataLightingCharV41> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV41();
    PackMapEnvDataLightingCharGroupV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV41(const PackMapEnvDataLightingCharGroupV41 &p_other);
    PackMapEnvDataLightingCharGroupV41 &operator=(const PackMapEnvDataLightingCharGroupV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV70 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV70();
    PackMapEnvDataLayerAttributesV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV70(const PackMapEnvDataLayerAttributesV70 &p_other);
    PackMapEnvDataLayerAttributesV70 &operator=(const PackMapEnvDataLayerAttributesV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV70 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV70> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV70();
    PackMapEnvDataLayerV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV70(const PackMapEnvDataLayerV70 &p_other);
    PackMapEnvDataLayerV70 &operator=(const PackMapEnvDataLayerV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV70 {
    helpers::Array<PackMapEnvDataLayerV70> layers;

public:
    PackMapEnvDataCloudsV70();
    PackMapEnvDataCloudsV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV70(const PackMapEnvDataCloudsV70 &p_other);
    PackMapEnvDataCloudsV70 &operator=(const PackMapEnvDataCloudsV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV41 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV41();
    PackMapEnvDataColoredLightRingsV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV41(const PackMapEnvDataColoredLightRingsV41 &p_other);
    PackMapEnvDataColoredLightRingsV41 &operator=(const PackMapEnvDataColoredLightRingsV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV70 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV70();
    PackMapEnvDataEffectV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV70(const PackMapEnvDataEffectV70 &p_other);
    PackMapEnvDataEffectV70 &operator=(const PackMapEnvDataEffectV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV70 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV70();
    PackMapEnvDataHazeV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV70(const PackMapEnvDataHazeV70 &p_other);
    PackMapEnvDataHazeV70 &operator=(const PackMapEnvDataHazeV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV70 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    float texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV70();
    PackMapEnvDataPFieldV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV70(const PackMapEnvDataPFieldV70 &p_other);
    PackMapEnvDataPFieldV70 &operator=(const PackMapEnvDataPFieldV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV41 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV41();
    PackMapEnvDataPFieldCutoutV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV41(const PackMapEnvDataPFieldCutoutV41 &p_other);
    PackMapEnvDataPFieldCutoutV41 &operator=(const PackMapEnvDataPFieldCutoutV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV70 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV70();
    PackMapEnvDataSkyV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV70(const PackMapEnvDataSkyV70 &p_other);
    PackMapEnvDataSkyV70 &operator=(const PackMapEnvDataSkyV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV70 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV70();
    PackMapEnvDataSkyCardAttributesV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV70(const PackMapEnvDataSkyCardAttributesV70 &p_other);
    PackMapEnvDataSkyCardAttributesV70 &operator=(const PackMapEnvDataSkyCardAttributesV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV70 {
    PackMapEnvDataSkyCardAttributesV70 day;
    PackMapEnvDataSkyCardAttributesV70 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV70();
    PackMapEnvDataSkyCardV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV70(const PackMapEnvDataSkyCardV70 &p_other);
    PackMapEnvDataSkyCardV70 &operator=(const PackMapEnvDataSkyCardV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV70 {
    helpers::Array<PackMapEnvDataSkyCardV70> cards;

public:
    PackMapEnvDataSkyCardsV70();
    PackMapEnvDataSkyCardsV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV70(const PackMapEnvDataSkyCardsV70 &p_other);
    PackMapEnvDataSkyCardsV70 &operator=(const PackMapEnvDataSkyCardsV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV41 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV41();
    PackMapEnvDataSpawnModelDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV41(const PackMapEnvDataSpawnModelDataV41 &p_other);
    PackMapEnvDataSpawnModelDataV41 &operator=(const PackMapEnvDataSpawnModelDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV41 {
    helpers::Array<PackMapEnvDataSpawnModelDataV41> spawns;

public:
    PackMapEnvDataSpawnListV41();
    PackMapEnvDataSpawnListV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV41(const PackMapEnvDataSpawnListV41 &p_other);
    PackMapEnvDataSpawnListV41 &operator=(const PackMapEnvDataSpawnListV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV41 {
    helpers::Array<PackMapEnvDataSpawnListV41> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV41();
    PackMapEnvDataSpawnGroupsV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV41(const PackMapEnvDataSpawnGroupsV41 &p_other);
    PackMapEnvDataSpawnGroupsV41 &operator=(const PackMapEnvDataSpawnGroupsV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV70 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV70();
    PackMapEnvDataWaterV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV70(const PackMapEnvDataWaterV70 &p_other);
    PackMapEnvDataWaterV70 &operator=(const PackMapEnvDataWaterV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV70 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV70();
    PackMapEnvDataWindV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV70(const PackMapEnvDataWindV70 &p_other);
    PackMapEnvDataWindV70 &operator=(const PackMapEnvDataWindV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV41 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV41();
    PackMapEnvDataShapeV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV41(const PackMapEnvDataShapeV41 &p_other);
    PackMapEnvDataShapeV41 &operator=(const PackMapEnvDataShapeV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV70 {
    helpers::Array<PackMapEnvDataLightingV70> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV41> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV70> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV41> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV70> effect;
    helpers::Ptr<PackMapEnvDataHazeV70> haze;
    helpers::Ptr<PackMapEnvDataPFieldV70> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV41> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV70> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV70> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV41> spawns;
    helpers::Ptr<PackMapEnvDataWaterV70> water;
    helpers::Ptr<PackMapEnvDataWindV70> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV41> shapeArray;

public:
    PackMapEnvDataLocalV70();
    PackMapEnvDataLocalV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV70(const PackMapEnvDataLocalV70 &p_other);
    PackMapEnvDataLocalV70 &operator=(const PackMapEnvDataLocalV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV70 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV70();
    PackMapEnvDataSkyModeTexV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV70(const PackMapEnvDataSkyModeTexV70 &p_other);
    PackMapEnvDataSkyModeTexV70 &operator=(const PackMapEnvDataSkyModeTexV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV70 {
    helpers::Array<PackMapEnvDataLightingV70> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV41> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV70> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV41> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV70> effect;
    helpers::Ptr<PackMapEnvDataHazeV70> haze;
    helpers::Ptr<PackMapEnvDataPFieldV70> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV41> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV70> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV70> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV41> spawns;
    helpers::Ptr<PackMapEnvDataWaterV70> water;
    helpers::Ptr<PackMapEnvDataWindV70> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV70> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV70();
    PackMapEnvDataGlobalV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV70(const PackMapEnvDataGlobalV70 &p_other);
    PackMapEnvDataGlobalV70 &operator=(const PackMapEnvDataGlobalV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV70 {
    helpers::Array<PackMapEnvDataLocalV70> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV70> dataGlobal;

public:
    PackMapEnvironmentV70();
    PackMapEnvironmentV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV70(const PackMapEnvironmentV70 &p_other);
    PackMapEnvironmentV70 &operator=(const PackMapEnvironmentV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV70 Gw2Struct;
};

/* Version: 69, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<69>{
struct PackMapEnvDataLightV69 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV69();
    PackMapEnvDataLightV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV69(const PackMapEnvDataLightV69 &p_other);
    PackMapEnvDataLightV69 &operator=(const PackMapEnvDataLightV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV69 {
    helpers::Ptr<PackMapEnvDataLightV69> lights;
    float shadowInfluence;

public:
    PackMapEnvDataLightingV69();
    PackMapEnvDataLightingV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV69(const PackMapEnvDataLightingV69 &p_other);
    PackMapEnvDataLightingV69 &operator=(const PackMapEnvDataLightingV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV40 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV40();
    PackMapEnvDataLightingCharV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV40(const PackMapEnvDataLightingCharV40 &p_other);
    PackMapEnvDataLightingCharV40 &operator=(const PackMapEnvDataLightingCharV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV40 {
    helpers::Array<PackMapEnvDataLightingCharV40> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV40();
    PackMapEnvDataLightingCharGroupV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV40(const PackMapEnvDataLightingCharGroupV40 &p_other);
    PackMapEnvDataLightingCharGroupV40 &operator=(const PackMapEnvDataLightingCharGroupV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV69 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV69();
    PackMapEnvDataLayerAttributesV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV69(const PackMapEnvDataLayerAttributesV69 &p_other);
    PackMapEnvDataLayerAttributesV69 &operator=(const PackMapEnvDataLayerAttributesV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV69 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV69> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV69();
    PackMapEnvDataLayerV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV69(const PackMapEnvDataLayerV69 &p_other);
    PackMapEnvDataLayerV69 &operator=(const PackMapEnvDataLayerV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV69 {
    helpers::Array<PackMapEnvDataLayerV69> layers;

public:
    PackMapEnvDataCloudsV69();
    PackMapEnvDataCloudsV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV69(const PackMapEnvDataCloudsV69 &p_other);
    PackMapEnvDataCloudsV69 &operator=(const PackMapEnvDataCloudsV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV40 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV40();
    PackMapEnvDataColoredLightRingsV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV40(const PackMapEnvDataColoredLightRingsV40 &p_other);
    PackMapEnvDataColoredLightRingsV40 &operator=(const PackMapEnvDataColoredLightRingsV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV69 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV69();
    PackMapEnvDataEffectV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV69(const PackMapEnvDataEffectV69 &p_other);
    PackMapEnvDataEffectV69 &operator=(const PackMapEnvDataEffectV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV69 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV69();
    PackMapEnvDataHazeV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV69(const PackMapEnvDataHazeV69 &p_other);
    PackMapEnvDataHazeV69 &operator=(const PackMapEnvDataHazeV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV69 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV69();
    PackMapEnvDataPFieldV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV69(const PackMapEnvDataPFieldV69 &p_other);
    PackMapEnvDataPFieldV69 &operator=(const PackMapEnvDataPFieldV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV40 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV40();
    PackMapEnvDataPFieldCutoutV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV40(const PackMapEnvDataPFieldCutoutV40 &p_other);
    PackMapEnvDataPFieldCutoutV40 &operator=(const PackMapEnvDataPFieldCutoutV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV69 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV69();
    PackMapEnvDataSkyV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV69(const PackMapEnvDataSkyV69 &p_other);
    PackMapEnvDataSkyV69 &operator=(const PackMapEnvDataSkyV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV69 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV69();
    PackMapEnvDataSkyCardAttributesV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV69(const PackMapEnvDataSkyCardAttributesV69 &p_other);
    PackMapEnvDataSkyCardAttributesV69 &operator=(const PackMapEnvDataSkyCardAttributesV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV69 {
    PackMapEnvDataSkyCardAttributesV69 day;
    PackMapEnvDataSkyCardAttributesV69 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV69();
    PackMapEnvDataSkyCardV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV69(const PackMapEnvDataSkyCardV69 &p_other);
    PackMapEnvDataSkyCardV69 &operator=(const PackMapEnvDataSkyCardV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV69 {
    helpers::Array<PackMapEnvDataSkyCardV69> cards;

public:
    PackMapEnvDataSkyCardsV69();
    PackMapEnvDataSkyCardsV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV69(const PackMapEnvDataSkyCardsV69 &p_other);
    PackMapEnvDataSkyCardsV69 &operator=(const PackMapEnvDataSkyCardsV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV40 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV40();
    PackMapEnvDataSpawnModelDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV40(const PackMapEnvDataSpawnModelDataV40 &p_other);
    PackMapEnvDataSpawnModelDataV40 &operator=(const PackMapEnvDataSpawnModelDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV40 {
    helpers::Array<PackMapEnvDataSpawnModelDataV40> spawns;

public:
    PackMapEnvDataSpawnListV40();
    PackMapEnvDataSpawnListV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV40(const PackMapEnvDataSpawnListV40 &p_other);
    PackMapEnvDataSpawnListV40 &operator=(const PackMapEnvDataSpawnListV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV40 {
    helpers::Array<PackMapEnvDataSpawnListV40> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV40();
    PackMapEnvDataSpawnGroupsV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV40(const PackMapEnvDataSpawnGroupsV40 &p_other);
    PackMapEnvDataSpawnGroupsV40 &operator=(const PackMapEnvDataSpawnGroupsV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV69 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV69();
    PackMapEnvDataWaterV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV69(const PackMapEnvDataWaterV69 &p_other);
    PackMapEnvDataWaterV69 &operator=(const PackMapEnvDataWaterV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV69 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV69();
    PackMapEnvDataWindV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV69(const PackMapEnvDataWindV69 &p_other);
    PackMapEnvDataWindV69 &operator=(const PackMapEnvDataWindV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV40 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV40();
    PackMapEnvDataShapeV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV40(const PackMapEnvDataShapeV40 &p_other);
    PackMapEnvDataShapeV40 &operator=(const PackMapEnvDataShapeV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV69 {
    helpers::Array<PackMapEnvDataLightingV69> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV40> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV69> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV40> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV69> effect;
    helpers::Ptr<PackMapEnvDataHazeV69> haze;
    helpers::Ptr<PackMapEnvDataPFieldV69> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV40> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV69> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV69> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV40> spawns;
    helpers::Ptr<PackMapEnvDataWaterV69> water;
    helpers::Ptr<PackMapEnvDataWindV69> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV40> shapeArray;

public:
    PackMapEnvDataLocalV69();
    PackMapEnvDataLocalV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV69(const PackMapEnvDataLocalV69 &p_other);
    PackMapEnvDataLocalV69 &operator=(const PackMapEnvDataLocalV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV69 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV69();
    PackMapEnvDataSkyModeTexV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV69(const PackMapEnvDataSkyModeTexV69 &p_other);
    PackMapEnvDataSkyModeTexV69 &operator=(const PackMapEnvDataSkyModeTexV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV69 {
    helpers::Array<PackMapEnvDataLightingV69> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV40> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV69> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV40> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV69> effect;
    helpers::Ptr<PackMapEnvDataHazeV69> haze;
    helpers::Ptr<PackMapEnvDataPFieldV69> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV40> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV69> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV69> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV40> spawns;
    helpers::Ptr<PackMapEnvDataWaterV69> water;
    helpers::Ptr<PackMapEnvDataWindV69> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV69> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV69();
    PackMapEnvDataGlobalV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV69(const PackMapEnvDataGlobalV69 &p_other);
    PackMapEnvDataGlobalV69 &operator=(const PackMapEnvDataGlobalV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV69 {
    helpers::Array<PackMapEnvDataLocalV69> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV69> dataGlobal;

public:
    PackMapEnvironmentV69();
    PackMapEnvironmentV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV69(const PackMapEnvironmentV69 &p_other);
    PackMapEnvironmentV69 &operator=(const PackMapEnvironmentV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV69 Gw2Struct;
};

/* Version: 68, ReferencedFunction: 0x4104F64000000001 */

template <>
struct Gw2Structenv<68>{
struct PackMapEnvDataLightV68 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV68();
    PackMapEnvDataLightV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV68(const PackMapEnvDataLightV68 &p_other);
    PackMapEnvDataLightV68 &operator=(const PackMapEnvDataLightV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV68 {
    helpers::Ptr<PackMapEnvDataLightV68> lights;
    float shadowInfluence;
    helpers::Ptr<PackMapEnvDataLightV68> backlight;

public:
    PackMapEnvDataLightingV68();
    PackMapEnvDataLightingV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV68(const PackMapEnvDataLightingV68 &p_other);
    PackMapEnvDataLightingV68 &operator=(const PackMapEnvDataLightingV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV39 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV39();
    PackMapEnvDataLightingCharV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV39(const PackMapEnvDataLightingCharV39 &p_other);
    PackMapEnvDataLightingCharV39 &operator=(const PackMapEnvDataLightingCharV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV39 {
    helpers::Array<PackMapEnvDataLightingCharV39> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV39();
    PackMapEnvDataLightingCharGroupV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV39(const PackMapEnvDataLightingCharGroupV39 &p_other);
    PackMapEnvDataLightingCharGroupV39 &operator=(const PackMapEnvDataLightingCharGroupV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV68 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV68();
    PackMapEnvDataLayerAttributesV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV68(const PackMapEnvDataLayerAttributesV68 &p_other);
    PackMapEnvDataLayerAttributesV68 &operator=(const PackMapEnvDataLayerAttributesV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV68 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV68> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV68();
    PackMapEnvDataLayerV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV68(const PackMapEnvDataLayerV68 &p_other);
    PackMapEnvDataLayerV68 &operator=(const PackMapEnvDataLayerV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV68 {
    helpers::Array<PackMapEnvDataLayerV68> layers;

public:
    PackMapEnvDataCloudsV68();
    PackMapEnvDataCloudsV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV68(const PackMapEnvDataCloudsV68 &p_other);
    PackMapEnvDataCloudsV68 &operator=(const PackMapEnvDataCloudsV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV39 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV39();
    PackMapEnvDataColoredLightRingsV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV39(const PackMapEnvDataColoredLightRingsV39 &p_other);
    PackMapEnvDataColoredLightRingsV39 &operator=(const PackMapEnvDataColoredLightRingsV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV68 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV68();
    PackMapEnvDataEffectV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV68(const PackMapEnvDataEffectV68 &p_other);
    PackMapEnvDataEffectV68 &operator=(const PackMapEnvDataEffectV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV68 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV68();
    PackMapEnvDataHazeV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV68(const PackMapEnvDataHazeV68 &p_other);
    PackMapEnvDataHazeV68 &operator=(const PackMapEnvDataHazeV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV68 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV68();
    PackMapEnvDataPFieldV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV68(const PackMapEnvDataPFieldV68 &p_other);
    PackMapEnvDataPFieldV68 &operator=(const PackMapEnvDataPFieldV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV39 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV39();
    PackMapEnvDataPFieldCutoutV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV39(const PackMapEnvDataPFieldCutoutV39 &p_other);
    PackMapEnvDataPFieldCutoutV39 &operator=(const PackMapEnvDataPFieldCutoutV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV68 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV68();
    PackMapEnvDataSkyV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV68(const PackMapEnvDataSkyV68 &p_other);
    PackMapEnvDataSkyV68 &operator=(const PackMapEnvDataSkyV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV68 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV68();
    PackMapEnvDataSkyCardAttributesV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV68(const PackMapEnvDataSkyCardAttributesV68 &p_other);
    PackMapEnvDataSkyCardAttributesV68 &operator=(const PackMapEnvDataSkyCardAttributesV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV68 {
    PackMapEnvDataSkyCardAttributesV68 day;
    PackMapEnvDataSkyCardAttributesV68 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV68();
    PackMapEnvDataSkyCardV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV68(const PackMapEnvDataSkyCardV68 &p_other);
    PackMapEnvDataSkyCardV68 &operator=(const PackMapEnvDataSkyCardV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV68 {
    helpers::Array<PackMapEnvDataSkyCardV68> cards;

public:
    PackMapEnvDataSkyCardsV68();
    PackMapEnvDataSkyCardsV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV68(const PackMapEnvDataSkyCardsV68 &p_other);
    PackMapEnvDataSkyCardsV68 &operator=(const PackMapEnvDataSkyCardsV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV39 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV39();
    PackMapEnvDataSpawnModelDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV39(const PackMapEnvDataSpawnModelDataV39 &p_other);
    PackMapEnvDataSpawnModelDataV39 &operator=(const PackMapEnvDataSpawnModelDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV39 {
    helpers::Array<PackMapEnvDataSpawnModelDataV39> spawns;

public:
    PackMapEnvDataSpawnListV39();
    PackMapEnvDataSpawnListV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV39(const PackMapEnvDataSpawnListV39 &p_other);
    PackMapEnvDataSpawnListV39 &operator=(const PackMapEnvDataSpawnListV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV39 {
    helpers::Array<PackMapEnvDataSpawnListV39> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV39();
    PackMapEnvDataSpawnGroupsV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV39(const PackMapEnvDataSpawnGroupsV39 &p_other);
    PackMapEnvDataSpawnGroupsV39 &operator=(const PackMapEnvDataSpawnGroupsV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV68 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV68();
    PackMapEnvDataWaterV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV68(const PackMapEnvDataWaterV68 &p_other);
    PackMapEnvDataWaterV68 &operator=(const PackMapEnvDataWaterV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV68 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV68();
    PackMapEnvDataWindV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV68(const PackMapEnvDataWindV68 &p_other);
    PackMapEnvDataWindV68 &operator=(const PackMapEnvDataWindV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV39 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV39();
    PackMapEnvDataShapeV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV39(const PackMapEnvDataShapeV39 &p_other);
    PackMapEnvDataShapeV39 &operator=(const PackMapEnvDataShapeV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV68 {
    helpers::Array<PackMapEnvDataLightingV68> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV39> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV68> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV39> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV68> effect;
    helpers::Ptr<PackMapEnvDataHazeV68> haze;
    helpers::Ptr<PackMapEnvDataPFieldV68> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV39> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV68> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV68> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV39> spawns;
    helpers::Ptr<PackMapEnvDataWaterV68> water;
    helpers::Ptr<PackMapEnvDataWindV68> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV39> shapeArray;

public:
    PackMapEnvDataLocalV68();
    PackMapEnvDataLocalV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV68(const PackMapEnvDataLocalV68 &p_other);
    PackMapEnvDataLocalV68 &operator=(const PackMapEnvDataLocalV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV68 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV68();
    PackMapEnvDataSkyModeTexV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV68(const PackMapEnvDataSkyModeTexV68 &p_other);
    PackMapEnvDataSkyModeTexV68 &operator=(const PackMapEnvDataSkyModeTexV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV68 {
    helpers::Array<PackMapEnvDataLightingV68> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV39> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV68> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV39> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV68> effect;
    helpers::Ptr<PackMapEnvDataHazeV68> haze;
    helpers::Ptr<PackMapEnvDataPFieldV68> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV39> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV68> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV68> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV39> spawns;
    helpers::Ptr<PackMapEnvDataWaterV68> water;
    helpers::Ptr<PackMapEnvDataWindV68> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV68> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV68();
    PackMapEnvDataGlobalV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV68(const PackMapEnvDataGlobalV68 &p_other);
    PackMapEnvDataGlobalV68 &operator=(const PackMapEnvDataGlobalV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV68 {
    helpers::Array<PackMapEnvDataLocalV68> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV68> dataGlobal;

public:
    PackMapEnvironmentV68();
    PackMapEnvironmentV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV68(const PackMapEnvironmentV68 &p_other);
    PackMapEnvironmentV68 &operator=(const PackMapEnvironmentV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV68 Gw2Struct;
};

/* Version: 67, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<67>{
struct PackMapEnvDataLightV67 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV67();
    PackMapEnvDataLightV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV67(const PackMapEnvDataLightV67 &p_other);
    PackMapEnvDataLightV67 &operator=(const PackMapEnvDataLightV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV67 {
    helpers::Ptr<PackMapEnvDataLightV67> lights;
    float shadowInfluence;

public:
    PackMapEnvDataLightingV67();
    PackMapEnvDataLightingV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV67(const PackMapEnvDataLightingV67 &p_other);
    PackMapEnvDataLightingV67 &operator=(const PackMapEnvDataLightingV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV38 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV38();
    PackMapEnvDataLightingCharV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV38(const PackMapEnvDataLightingCharV38 &p_other);
    PackMapEnvDataLightingCharV38 &operator=(const PackMapEnvDataLightingCharV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV38 {
    helpers::Array<PackMapEnvDataLightingCharV38> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV38();
    PackMapEnvDataLightingCharGroupV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV38(const PackMapEnvDataLightingCharGroupV38 &p_other);
    PackMapEnvDataLightingCharGroupV38 &operator=(const PackMapEnvDataLightingCharGroupV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV67 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV67();
    PackMapEnvDataLayerAttributesV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV67(const PackMapEnvDataLayerAttributesV67 &p_other);
    PackMapEnvDataLayerAttributesV67 &operator=(const PackMapEnvDataLayerAttributesV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV67 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV67> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV67();
    PackMapEnvDataLayerV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV67(const PackMapEnvDataLayerV67 &p_other);
    PackMapEnvDataLayerV67 &operator=(const PackMapEnvDataLayerV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV67 {
    helpers::Array<PackMapEnvDataLayerV67> layers;

public:
    PackMapEnvDataCloudsV67();
    PackMapEnvDataCloudsV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV67(const PackMapEnvDataCloudsV67 &p_other);
    PackMapEnvDataCloudsV67 &operator=(const PackMapEnvDataCloudsV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV38 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV38();
    PackMapEnvDataColoredLightRingsV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV38(const PackMapEnvDataColoredLightRingsV38 &p_other);
    PackMapEnvDataColoredLightRingsV38 &operator=(const PackMapEnvDataColoredLightRingsV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV67 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV67();
    PackMapEnvDataEffectV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV67(const PackMapEnvDataEffectV67 &p_other);
    PackMapEnvDataEffectV67 &operator=(const PackMapEnvDataEffectV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV67 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV67();
    PackMapEnvDataHazeV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV67(const PackMapEnvDataHazeV67 &p_other);
    PackMapEnvDataHazeV67 &operator=(const PackMapEnvDataHazeV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV67 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV67();
    PackMapEnvDataPFieldV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV67(const PackMapEnvDataPFieldV67 &p_other);
    PackMapEnvDataPFieldV67 &operator=(const PackMapEnvDataPFieldV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV38 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV38();
    PackMapEnvDataPFieldCutoutV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV38(const PackMapEnvDataPFieldCutoutV38 &p_other);
    PackMapEnvDataPFieldCutoutV38 &operator=(const PackMapEnvDataPFieldCutoutV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV67 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV67();
    PackMapEnvDataSkyV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV67(const PackMapEnvDataSkyV67 &p_other);
    PackMapEnvDataSkyV67 &operator=(const PackMapEnvDataSkyV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV67 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV67();
    PackMapEnvDataSkyCardAttributesV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV67(const PackMapEnvDataSkyCardAttributesV67 &p_other);
    PackMapEnvDataSkyCardAttributesV67 &operator=(const PackMapEnvDataSkyCardAttributesV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV67 {
    PackMapEnvDataSkyCardAttributesV67 day;
    PackMapEnvDataSkyCardAttributesV67 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV67();
    PackMapEnvDataSkyCardV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV67(const PackMapEnvDataSkyCardV67 &p_other);
    PackMapEnvDataSkyCardV67 &operator=(const PackMapEnvDataSkyCardV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV67 {
    helpers::Array<PackMapEnvDataSkyCardV67> cards;

public:
    PackMapEnvDataSkyCardsV67();
    PackMapEnvDataSkyCardsV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV67(const PackMapEnvDataSkyCardsV67 &p_other);
    PackMapEnvDataSkyCardsV67 &operator=(const PackMapEnvDataSkyCardsV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV38 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    qword animSequence;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV38();
    PackMapEnvDataSpawnModelDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV38(const PackMapEnvDataSpawnModelDataV38 &p_other);
    PackMapEnvDataSpawnModelDataV38 &operator=(const PackMapEnvDataSpawnModelDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV38 {
    helpers::Array<PackMapEnvDataSpawnModelDataV38> spawns;

public:
    PackMapEnvDataSpawnListV38();
    PackMapEnvDataSpawnListV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV38(const PackMapEnvDataSpawnListV38 &p_other);
    PackMapEnvDataSpawnListV38 &operator=(const PackMapEnvDataSpawnListV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV38 {
    helpers::Array<PackMapEnvDataSpawnListV38> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV38();
    PackMapEnvDataSpawnGroupsV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV38(const PackMapEnvDataSpawnGroupsV38 &p_other);
    PackMapEnvDataSpawnGroupsV38 &operator=(const PackMapEnvDataSpawnGroupsV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV67 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV67();
    PackMapEnvDataWaterV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV67(const PackMapEnvDataWaterV67 &p_other);
    PackMapEnvDataWaterV67 &operator=(const PackMapEnvDataWaterV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV67 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV67();
    PackMapEnvDataWindV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV67(const PackMapEnvDataWindV67 &p_other);
    PackMapEnvDataWindV67 &operator=(const PackMapEnvDataWindV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV38 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV38();
    PackMapEnvDataShapeV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV38(const PackMapEnvDataShapeV38 &p_other);
    PackMapEnvDataShapeV38 &operator=(const PackMapEnvDataShapeV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV67 {
    helpers::Array<PackMapEnvDataLightingV67> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV38> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV67> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV38> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV67> effect;
    helpers::Ptr<PackMapEnvDataHazeV67> haze;
    helpers::Ptr<PackMapEnvDataPFieldV67> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV38> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV67> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV67> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV38> spawns;
    helpers::Ptr<PackMapEnvDataWaterV67> water;
    helpers::Ptr<PackMapEnvDataWindV67> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV38> shapeArray;

public:
    PackMapEnvDataLocalV67();
    PackMapEnvDataLocalV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV67(const PackMapEnvDataLocalV67 &p_other);
    PackMapEnvDataLocalV67 &operator=(const PackMapEnvDataLocalV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV67 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV67();
    PackMapEnvDataSkyModeTexV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV67(const PackMapEnvDataSkyModeTexV67 &p_other);
    PackMapEnvDataSkyModeTexV67 &operator=(const PackMapEnvDataSkyModeTexV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV67 {
    helpers::Array<PackMapEnvDataLightingV67> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV38> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV67> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV38> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV67> effect;
    helpers::Ptr<PackMapEnvDataHazeV67> haze;
    helpers::Ptr<PackMapEnvDataPFieldV67> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV38> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV67> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV67> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV38> spawns;
    helpers::Ptr<PackMapEnvDataWaterV67> water;
    helpers::Ptr<PackMapEnvDataWindV67> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV67> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV67();
    PackMapEnvDataGlobalV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV67(const PackMapEnvDataGlobalV67 &p_other);
    PackMapEnvDataGlobalV67 &operator=(const PackMapEnvDataGlobalV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV67 {
    helpers::Array<PackMapEnvDataLocalV67> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV67> dataGlobal;

public:
    PackMapEnvironmentV67();
    PackMapEnvironmentV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV67(const PackMapEnvironmentV67 &p_other);
    PackMapEnvironmentV67 &operator=(const PackMapEnvironmentV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV67 Gw2Struct;
};

/* Version: 66, ReferencedFunction: 0x4104F4A000000001 */

template <>
struct Gw2Structenv<66>{
struct PackMapEnvDataLightV66 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV66();
    PackMapEnvDataLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV66(const PackMapEnvDataLightV66 &p_other);
    PackMapEnvDataLightV66 &operator=(const PackMapEnvDataLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV66 {
    helpers::Ptr<PackMapEnvDataLightV66> lights;
    float shadowInfluence;

public:
    PackMapEnvDataLightingV66();
    PackMapEnvDataLightingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV66(const PackMapEnvDataLightingV66 &p_other);
    PackMapEnvDataLightingV66 &operator=(const PackMapEnvDataLightingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV37 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV37();
    PackMapEnvDataLightingCharV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV37(const PackMapEnvDataLightingCharV37 &p_other);
    PackMapEnvDataLightingCharV37 &operator=(const PackMapEnvDataLightingCharV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV37 {
    helpers::Array<PackMapEnvDataLightingCharV37> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV37();
    PackMapEnvDataLightingCharGroupV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV37(const PackMapEnvDataLightingCharGroupV37 &p_other);
    PackMapEnvDataLightingCharGroupV37 &operator=(const PackMapEnvDataLightingCharGroupV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV66 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV66();
    PackMapEnvDataLayerAttributesV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV66(const PackMapEnvDataLayerAttributesV66 &p_other);
    PackMapEnvDataLayerAttributesV66 &operator=(const PackMapEnvDataLayerAttributesV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV66 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV66> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV66();
    PackMapEnvDataLayerV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV66(const PackMapEnvDataLayerV66 &p_other);
    PackMapEnvDataLayerV66 &operator=(const PackMapEnvDataLayerV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV66 {
    helpers::Array<PackMapEnvDataLayerV66> layers;

public:
    PackMapEnvDataCloudsV66();
    PackMapEnvDataCloudsV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV66(const PackMapEnvDataCloudsV66 &p_other);
    PackMapEnvDataCloudsV66 &operator=(const PackMapEnvDataCloudsV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV37 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV37();
    PackMapEnvDataColoredLightRingsV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV37(const PackMapEnvDataColoredLightRingsV37 &p_other);
    PackMapEnvDataColoredLightRingsV37 &operator=(const PackMapEnvDataColoredLightRingsV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV66 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV66();
    PackMapEnvDataEffectV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV66(const PackMapEnvDataEffectV66 &p_other);
    PackMapEnvDataEffectV66 &operator=(const PackMapEnvDataEffectV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV66 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV66();
    PackMapEnvDataHazeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV66(const PackMapEnvDataHazeV66 &p_other);
    PackMapEnvDataHazeV66 &operator=(const PackMapEnvDataHazeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV66 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV66();
    PackMapEnvDataPFieldV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV66(const PackMapEnvDataPFieldV66 &p_other);
    PackMapEnvDataPFieldV66 &operator=(const PackMapEnvDataPFieldV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV37 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV37();
    PackMapEnvDataPFieldCutoutV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV37(const PackMapEnvDataPFieldCutoutV37 &p_other);
    PackMapEnvDataPFieldCutoutV37 &operator=(const PackMapEnvDataPFieldCutoutV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV66 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV66();
    PackMapEnvDataSkyV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV66(const PackMapEnvDataSkyV66 &p_other);
    PackMapEnvDataSkyV66 &operator=(const PackMapEnvDataSkyV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV66 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV66();
    PackMapEnvDataSkyCardAttributesV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV66(const PackMapEnvDataSkyCardAttributesV66 &p_other);
    PackMapEnvDataSkyCardAttributesV66 &operator=(const PackMapEnvDataSkyCardAttributesV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV66 {
    PackMapEnvDataSkyCardAttributesV66 day;
    PackMapEnvDataSkyCardAttributesV66 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV66();
    PackMapEnvDataSkyCardV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV66(const PackMapEnvDataSkyCardV66 &p_other);
    PackMapEnvDataSkyCardV66 &operator=(const PackMapEnvDataSkyCardV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV66 {
    helpers::Array<PackMapEnvDataSkyCardV66> cards;

public:
    PackMapEnvDataSkyCardsV66();
    PackMapEnvDataSkyCardsV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV66(const PackMapEnvDataSkyCardsV66 &p_other);
    PackMapEnvDataSkyCardsV66 &operator=(const PackMapEnvDataSkyCardsV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV37 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV37();
    PackMapEnvDataSpawnModelDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV37(const PackMapEnvDataSpawnModelDataV37 &p_other);
    PackMapEnvDataSpawnModelDataV37 &operator=(const PackMapEnvDataSpawnModelDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV37 {
    helpers::Array<PackMapEnvDataSpawnModelDataV37> spawns;

public:
    PackMapEnvDataSpawnListV37();
    PackMapEnvDataSpawnListV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV37(const PackMapEnvDataSpawnListV37 &p_other);
    PackMapEnvDataSpawnListV37 &operator=(const PackMapEnvDataSpawnListV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV37 {
    helpers::Array<PackMapEnvDataSpawnListV37> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV37();
    PackMapEnvDataSpawnGroupsV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV37(const PackMapEnvDataSpawnGroupsV37 &p_other);
    PackMapEnvDataSpawnGroupsV37 &operator=(const PackMapEnvDataSpawnGroupsV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV66 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV66();
    PackMapEnvDataWaterV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV66(const PackMapEnvDataWaterV66 &p_other);
    PackMapEnvDataWaterV66 &operator=(const PackMapEnvDataWaterV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV66 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV66();
    PackMapEnvDataWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV66(const PackMapEnvDataWindV66 &p_other);
    PackMapEnvDataWindV66 &operator=(const PackMapEnvDataWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataShapeV37 {
    float3 center;
    float height;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    helpers::Array<float2> vertexArray;
    byte shapeType;

public:
    PackMapEnvDataShapeV37();
    PackMapEnvDataShapeV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataShapeV37(const PackMapEnvDataShapeV37 &p_other);
    PackMapEnvDataShapeV37 &operator=(const PackMapEnvDataShapeV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV66 {
    helpers::Array<PackMapEnvDataLightingV66> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV37> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV66> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV37> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV66> effect;
    helpers::Ptr<PackMapEnvDataHazeV66> haze;
    helpers::Ptr<PackMapEnvDataPFieldV66> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV37> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV66> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV66> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV37> spawns;
    helpers::Ptr<PackMapEnvDataWaterV66> water;
    helpers::Ptr<PackMapEnvDataWindV66> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    byte type;
    qword guid;
    helpers::Array<PackMapEnvDataShapeV37> shapeArray;

public:
    PackMapEnvDataLocalV66();
    PackMapEnvDataLocalV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV66(const PackMapEnvDataLocalV66 &p_other);
    PackMapEnvDataLocalV66 &operator=(const PackMapEnvDataLocalV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV66 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV66();
    PackMapEnvDataSkyModeTexV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV66(const PackMapEnvDataSkyModeTexV66 &p_other);
    PackMapEnvDataSkyModeTexV66 &operator=(const PackMapEnvDataSkyModeTexV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV66 {
    helpers::Array<PackMapEnvDataLightingV66> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV37> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV66> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV37> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV66> effect;
    helpers::Ptr<PackMapEnvDataHazeV66> haze;
    helpers::Ptr<PackMapEnvDataPFieldV66> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV37> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV66> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV66> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV37> spawns;
    helpers::Ptr<PackMapEnvDataWaterV66> water;
    helpers::Ptr<PackMapEnvDataWindV66> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV66> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV66();
    PackMapEnvDataGlobalV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV66(const PackMapEnvDataGlobalV66 &p_other);
    PackMapEnvDataGlobalV66 &operator=(const PackMapEnvDataGlobalV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV66 {
    helpers::Array<PackMapEnvDataLocalV66> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV66> dataGlobal;

public:
    PackMapEnvironmentV66();
    PackMapEnvironmentV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV66(const PackMapEnvironmentV66 &p_other);
    PackMapEnvironmentV66 &operator=(const PackMapEnvironmentV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV66 Gw2Struct;
};

/* Version: 65, ReferencedFunction: 0x4104F42000000001 */

template <>
struct Gw2Structenv<65>{
struct PackMapEnvDataLightV65 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV65();
    PackMapEnvDataLightV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV65(const PackMapEnvDataLightV65 &p_other);
    PackMapEnvDataLightV65 &operator=(const PackMapEnvDataLightV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV65 {
    helpers::Ptr<PackMapEnvDataLightV65> lights;
    float shadowInfluence;

public:
    PackMapEnvDataLightingV65();
    PackMapEnvDataLightingV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV65(const PackMapEnvDataLightingV65 &p_other);
    PackMapEnvDataLightingV65 &operator=(const PackMapEnvDataLightingV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV36 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV36();
    PackMapEnvDataLightingCharV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV36(const PackMapEnvDataLightingCharV36 &p_other);
    PackMapEnvDataLightingCharV36 &operator=(const PackMapEnvDataLightingCharV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV36 {
    helpers::Array<PackMapEnvDataLightingCharV36> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV36();
    PackMapEnvDataLightingCharGroupV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV36(const PackMapEnvDataLightingCharGroupV36 &p_other);
    PackMapEnvDataLightingCharGroupV36 &operator=(const PackMapEnvDataLightingCharGroupV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV65 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV65();
    PackMapEnvDataLayerAttributesV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV65(const PackMapEnvDataLayerAttributesV65 &p_other);
    PackMapEnvDataLayerAttributesV65 &operator=(const PackMapEnvDataLayerAttributesV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV65 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV65> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV65();
    PackMapEnvDataLayerV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV65(const PackMapEnvDataLayerV65 &p_other);
    PackMapEnvDataLayerV65 &operator=(const PackMapEnvDataLayerV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV65 {
    helpers::Array<PackMapEnvDataLayerV65> layers;

public:
    PackMapEnvDataCloudsV65();
    PackMapEnvDataCloudsV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV65(const PackMapEnvDataCloudsV65 &p_other);
    PackMapEnvDataCloudsV65 &operator=(const PackMapEnvDataCloudsV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV36 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV36();
    PackMapEnvDataColoredLightRingsV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV36(const PackMapEnvDataColoredLightRingsV36 &p_other);
    PackMapEnvDataColoredLightRingsV36 &operator=(const PackMapEnvDataColoredLightRingsV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV65 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV65();
    PackMapEnvDataEffectV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV65(const PackMapEnvDataEffectV65 &p_other);
    PackMapEnvDataEffectV65 &operator=(const PackMapEnvDataEffectV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV65 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV65();
    PackMapEnvDataHazeV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV65(const PackMapEnvDataHazeV65 &p_other);
    PackMapEnvDataHazeV65 &operator=(const PackMapEnvDataHazeV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV65 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV65();
    PackMapEnvDataPFieldV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV65(const PackMapEnvDataPFieldV65 &p_other);
    PackMapEnvDataPFieldV65 &operator=(const PackMapEnvDataPFieldV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV36 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV36();
    PackMapEnvDataPFieldCutoutV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV36(const PackMapEnvDataPFieldCutoutV36 &p_other);
    PackMapEnvDataPFieldCutoutV36 &operator=(const PackMapEnvDataPFieldCutoutV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV65 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV65();
    PackMapEnvDataSkyV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV65(const PackMapEnvDataSkyV65 &p_other);
    PackMapEnvDataSkyV65 &operator=(const PackMapEnvDataSkyV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV65 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV65();
    PackMapEnvDataSkyCardAttributesV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV65(const PackMapEnvDataSkyCardAttributesV65 &p_other);
    PackMapEnvDataSkyCardAttributesV65 &operator=(const PackMapEnvDataSkyCardAttributesV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV65 {
    PackMapEnvDataSkyCardAttributesV65 day;
    PackMapEnvDataSkyCardAttributesV65 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV65();
    PackMapEnvDataSkyCardV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV65(const PackMapEnvDataSkyCardV65 &p_other);
    PackMapEnvDataSkyCardV65 &operator=(const PackMapEnvDataSkyCardV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV65 {
    helpers::Array<PackMapEnvDataSkyCardV65> cards;

public:
    PackMapEnvDataSkyCardsV65();
    PackMapEnvDataSkyCardsV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV65(const PackMapEnvDataSkyCardsV65 &p_other);
    PackMapEnvDataSkyCardsV65 &operator=(const PackMapEnvDataSkyCardsV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV36 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV36();
    PackMapEnvDataSpawnModelDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV36(const PackMapEnvDataSpawnModelDataV36 &p_other);
    PackMapEnvDataSpawnModelDataV36 &operator=(const PackMapEnvDataSpawnModelDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV36 {
    helpers::Array<PackMapEnvDataSpawnModelDataV36> spawns;

public:
    PackMapEnvDataSpawnListV36();
    PackMapEnvDataSpawnListV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV36(const PackMapEnvDataSpawnListV36 &p_other);
    PackMapEnvDataSpawnListV36 &operator=(const PackMapEnvDataSpawnListV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV36 {
    helpers::Array<PackMapEnvDataSpawnListV36> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV36();
    PackMapEnvDataSpawnGroupsV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV36(const PackMapEnvDataSpawnGroupsV36 &p_other);
    PackMapEnvDataSpawnGroupsV36 &operator=(const PackMapEnvDataSpawnGroupsV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV65 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV65();
    PackMapEnvDataWaterV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV65(const PackMapEnvDataWaterV65 &p_other);
    PackMapEnvDataWaterV65 &operator=(const PackMapEnvDataWaterV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV65 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV65();
    PackMapEnvDataWindV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV65(const PackMapEnvDataWindV65 &p_other);
    PackMapEnvDataWindV65 &operator=(const PackMapEnvDataWindV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV65 {
    helpers::Array<PackMapEnvDataLightingV65> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV36> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV65> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV36> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV65> effect;
    helpers::Ptr<PackMapEnvDataHazeV65> haze;
    helpers::Ptr<PackMapEnvDataPFieldV65> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV36> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV65> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV65> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV36> spawns;
    helpers::Ptr<PackMapEnvDataWaterV65> water;
    helpers::Ptr<PackMapEnvDataWindV65> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV65();
    PackMapEnvDataLocalV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV65(const PackMapEnvDataLocalV65 &p_other);
    PackMapEnvDataLocalV65 &operator=(const PackMapEnvDataLocalV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV65 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV65();
    PackMapEnvDataSkyModeTexV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV65(const PackMapEnvDataSkyModeTexV65 &p_other);
    PackMapEnvDataSkyModeTexV65 &operator=(const PackMapEnvDataSkyModeTexV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV65 {
    helpers::Array<PackMapEnvDataLightingV65> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV36> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV65> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV36> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV65> effect;
    helpers::Ptr<PackMapEnvDataHazeV65> haze;
    helpers::Ptr<PackMapEnvDataPFieldV65> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV36> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV65> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV65> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV36> spawns;
    helpers::Ptr<PackMapEnvDataWaterV65> water;
    helpers::Ptr<PackMapEnvDataWindV65> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV65> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV65();
    PackMapEnvDataGlobalV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV65(const PackMapEnvDataGlobalV65 &p_other);
    PackMapEnvDataGlobalV65 &operator=(const PackMapEnvDataGlobalV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV65 {
    helpers::Array<PackMapEnvDataLocalV65> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV65> dataGlobal;

public:
    PackMapEnvironmentV65();
    PackMapEnvironmentV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV65(const PackMapEnvironmentV65 &p_other);
    PackMapEnvironmentV65 &operator=(const PackMapEnvironmentV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV65 Gw2Struct;
};

/* Version: 64, ReferencedFunction: 0x4104F2E000000001 */

template <>
struct Gw2Structenv<64>{
struct PackMapEnvDataLightV64 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV64();
    PackMapEnvDataLightV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV64(const PackMapEnvDataLightV64 &p_other);
    PackMapEnvDataLightV64 &operator=(const PackMapEnvDataLightV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV64 {
    helpers::Ptr<PackMapEnvDataLightV64> lights;

public:
    PackMapEnvDataLightingV64();
    PackMapEnvDataLightingV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV64(const PackMapEnvDataLightingV64 &p_other);
    PackMapEnvDataLightingV64 &operator=(const PackMapEnvDataLightingV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV35 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV35();
    PackMapEnvDataLightingCharV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV35(const PackMapEnvDataLightingCharV35 &p_other);
    PackMapEnvDataLightingCharV35 &operator=(const PackMapEnvDataLightingCharV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV35 {
    helpers::Array<PackMapEnvDataLightingCharV35> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV35();
    PackMapEnvDataLightingCharGroupV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV35(const PackMapEnvDataLightingCharGroupV35 &p_other);
    PackMapEnvDataLightingCharGroupV35 &operator=(const PackMapEnvDataLightingCharGroupV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV64 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV64();
    PackMapEnvDataLayerAttributesV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV64(const PackMapEnvDataLayerAttributesV64 &p_other);
    PackMapEnvDataLayerAttributesV64 &operator=(const PackMapEnvDataLayerAttributesV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV64 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV64> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV64();
    PackMapEnvDataLayerV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV64(const PackMapEnvDataLayerV64 &p_other);
    PackMapEnvDataLayerV64 &operator=(const PackMapEnvDataLayerV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV64 {
    helpers::Array<PackMapEnvDataLayerV64> layers;

public:
    PackMapEnvDataCloudsV64();
    PackMapEnvDataCloudsV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV64(const PackMapEnvDataCloudsV64 &p_other);
    PackMapEnvDataCloudsV64 &operator=(const PackMapEnvDataCloudsV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV35 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV35();
    PackMapEnvDataColoredLightRingsV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV35(const PackMapEnvDataColoredLightRingsV35 &p_other);
    PackMapEnvDataColoredLightRingsV35 &operator=(const PackMapEnvDataColoredLightRingsV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV64 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV64();
    PackMapEnvDataEffectV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV64(const PackMapEnvDataEffectV64 &p_other);
    PackMapEnvDataEffectV64 &operator=(const PackMapEnvDataEffectV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV64 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV64();
    PackMapEnvDataHazeV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV64(const PackMapEnvDataHazeV64 &p_other);
    PackMapEnvDataHazeV64 &operator=(const PackMapEnvDataHazeV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV64 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV64();
    PackMapEnvDataPFieldV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV64(const PackMapEnvDataPFieldV64 &p_other);
    PackMapEnvDataPFieldV64 &operator=(const PackMapEnvDataPFieldV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV35 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV35();
    PackMapEnvDataPFieldCutoutV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV35(const PackMapEnvDataPFieldCutoutV35 &p_other);
    PackMapEnvDataPFieldCutoutV35 &operator=(const PackMapEnvDataPFieldCutoutV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV64 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;
    float verticalOffset;

public:
    PackMapEnvDataSkyV64();
    PackMapEnvDataSkyV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV64(const PackMapEnvDataSkyV64 &p_other);
    PackMapEnvDataSkyV64 &operator=(const PackMapEnvDataSkyV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV64 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV64();
    PackMapEnvDataSkyCardAttributesV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV64(const PackMapEnvDataSkyCardAttributesV64 &p_other);
    PackMapEnvDataSkyCardAttributesV64 &operator=(const PackMapEnvDataSkyCardAttributesV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV64 {
    PackMapEnvDataSkyCardAttributesV64 day;
    PackMapEnvDataSkyCardAttributesV64 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV64();
    PackMapEnvDataSkyCardV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV64(const PackMapEnvDataSkyCardV64 &p_other);
    PackMapEnvDataSkyCardV64 &operator=(const PackMapEnvDataSkyCardV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV64 {
    helpers::Array<PackMapEnvDataSkyCardV64> cards;

public:
    PackMapEnvDataSkyCardsV64();
    PackMapEnvDataSkyCardsV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV64(const PackMapEnvDataSkyCardsV64 &p_other);
    PackMapEnvDataSkyCardsV64 &operator=(const PackMapEnvDataSkyCardsV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV35 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV35();
    PackMapEnvDataSpawnModelDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV35(const PackMapEnvDataSpawnModelDataV35 &p_other);
    PackMapEnvDataSpawnModelDataV35 &operator=(const PackMapEnvDataSpawnModelDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV35 {
    helpers::Array<PackMapEnvDataSpawnModelDataV35> spawns;

public:
    PackMapEnvDataSpawnListV35();
    PackMapEnvDataSpawnListV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV35(const PackMapEnvDataSpawnListV35 &p_other);
    PackMapEnvDataSpawnListV35 &operator=(const PackMapEnvDataSpawnListV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV35 {
    helpers::Array<PackMapEnvDataSpawnListV35> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV35();
    PackMapEnvDataSpawnGroupsV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV35(const PackMapEnvDataSpawnGroupsV35 &p_other);
    PackMapEnvDataSpawnGroupsV35 &operator=(const PackMapEnvDataSpawnGroupsV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV64 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV64();
    PackMapEnvDataWaterV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV64(const PackMapEnvDataWaterV64 &p_other);
    PackMapEnvDataWaterV64 &operator=(const PackMapEnvDataWaterV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV64 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;
    byte gustSpeed;

public:
    PackMapEnvDataWindV64();
    PackMapEnvDataWindV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV64(const PackMapEnvDataWindV64 &p_other);
    PackMapEnvDataWindV64 &operator=(const PackMapEnvDataWindV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV64 {
    helpers::Array<PackMapEnvDataLightingV64> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV35> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV64> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV35> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV64> effect;
    helpers::Ptr<PackMapEnvDataHazeV64> haze;
    helpers::Ptr<PackMapEnvDataPFieldV64> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV35> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV64> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV64> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV35> spawns;
    helpers::Ptr<PackMapEnvDataWaterV64> water;
    helpers::Ptr<PackMapEnvDataWindV64> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV64();
    PackMapEnvDataLocalV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV64(const PackMapEnvDataLocalV64 &p_other);
    PackMapEnvDataLocalV64 &operator=(const PackMapEnvDataLocalV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV64 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV64();
    PackMapEnvDataSkyModeTexV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV64(const PackMapEnvDataSkyModeTexV64 &p_other);
    PackMapEnvDataSkyModeTexV64 &operator=(const PackMapEnvDataSkyModeTexV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV64 {
    helpers::Array<PackMapEnvDataLightingV64> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV35> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV64> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV35> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV64> effect;
    helpers::Ptr<PackMapEnvDataHazeV64> haze;
    helpers::Ptr<PackMapEnvDataPFieldV64> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV35> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV64> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV64> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV35> spawns;
    helpers::Ptr<PackMapEnvDataWaterV64> water;
    helpers::Ptr<PackMapEnvDataWindV64> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV64> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV64();
    PackMapEnvDataGlobalV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV64(const PackMapEnvDataGlobalV64 &p_other);
    PackMapEnvDataGlobalV64 &operator=(const PackMapEnvDataGlobalV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV64 {
    helpers::Array<PackMapEnvDataLocalV64> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV64> dataGlobal;

public:
    PackMapEnvironmentV64();
    PackMapEnvironmentV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV64(const PackMapEnvironmentV64 &p_other);
    PackMapEnvironmentV64 &operator=(const PackMapEnvironmentV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV64 Gw2Struct;
};

/* Version: 63, ReferencedFunction: 0x4104F1A000000001 */

template <>
struct Gw2Structenv<63>{
struct PackMapEnvDataLightV63 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV63();
    PackMapEnvDataLightV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV63(const PackMapEnvDataLightV63 &p_other);
    PackMapEnvDataLightV63 &operator=(const PackMapEnvDataLightV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV63 {
    helpers::Ptr<PackMapEnvDataLightV63> lights;

public:
    PackMapEnvDataLightingV63();
    PackMapEnvDataLightingV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV63(const PackMapEnvDataLightingV63 &p_other);
    PackMapEnvDataLightingV63 &operator=(const PackMapEnvDataLightingV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV34 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV34();
    PackMapEnvDataLightingCharV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV34(const PackMapEnvDataLightingCharV34 &p_other);
    PackMapEnvDataLightingCharV34 &operator=(const PackMapEnvDataLightingCharV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV34 {
    helpers::Array<PackMapEnvDataLightingCharV34> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV34();
    PackMapEnvDataLightingCharGroupV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV34(const PackMapEnvDataLightingCharGroupV34 &p_other);
    PackMapEnvDataLightingCharGroupV34 &operator=(const PackMapEnvDataLightingCharGroupV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV63 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV63();
    PackMapEnvDataLayerAttributesV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV63(const PackMapEnvDataLayerAttributesV63 &p_other);
    PackMapEnvDataLayerAttributesV63 &operator=(const PackMapEnvDataLayerAttributesV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV63 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV63> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV63();
    PackMapEnvDataLayerV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV63(const PackMapEnvDataLayerV63 &p_other);
    PackMapEnvDataLayerV63 &operator=(const PackMapEnvDataLayerV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV63 {
    helpers::Array<PackMapEnvDataLayerV63> layers;

public:
    PackMapEnvDataCloudsV63();
    PackMapEnvDataCloudsV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV63(const PackMapEnvDataCloudsV63 &p_other);
    PackMapEnvDataCloudsV63 &operator=(const PackMapEnvDataCloudsV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV34 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV34();
    PackMapEnvDataColoredLightRingsV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV34(const PackMapEnvDataColoredLightRingsV34 &p_other);
    PackMapEnvDataColoredLightRingsV34 &operator=(const PackMapEnvDataColoredLightRingsV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV63 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV63();
    PackMapEnvDataEffectV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV63(const PackMapEnvDataEffectV63 &p_other);
    PackMapEnvDataEffectV63 &operator=(const PackMapEnvDataEffectV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV63 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV63();
    PackMapEnvDataHazeV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV63(const PackMapEnvDataHazeV63 &p_other);
    PackMapEnvDataHazeV63 &operator=(const PackMapEnvDataHazeV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV63 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV63();
    PackMapEnvDataPFieldV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV63(const PackMapEnvDataPFieldV63 &p_other);
    PackMapEnvDataPFieldV63 &operator=(const PackMapEnvDataPFieldV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV34 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV34();
    PackMapEnvDataPFieldCutoutV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV34(const PackMapEnvDataPFieldCutoutV34 &p_other);
    PackMapEnvDataPFieldCutoutV34 &operator=(const PackMapEnvDataPFieldCutoutV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV63 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV63();
    PackMapEnvDataSkyV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV63(const PackMapEnvDataSkyV63 &p_other);
    PackMapEnvDataSkyV63 &operator=(const PackMapEnvDataSkyV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV63 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV63();
    PackMapEnvDataSkyCardAttributesV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV63(const PackMapEnvDataSkyCardAttributesV63 &p_other);
    PackMapEnvDataSkyCardAttributesV63 &operator=(const PackMapEnvDataSkyCardAttributesV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV63 {
    PackMapEnvDataSkyCardAttributesV63 day;
    PackMapEnvDataSkyCardAttributesV63 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV63();
    PackMapEnvDataSkyCardV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV63(const PackMapEnvDataSkyCardV63 &p_other);
    PackMapEnvDataSkyCardV63 &operator=(const PackMapEnvDataSkyCardV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV63 {
    helpers::Array<PackMapEnvDataSkyCardV63> cards;

public:
    PackMapEnvDataSkyCardsV63();
    PackMapEnvDataSkyCardsV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV63(const PackMapEnvDataSkyCardsV63 &p_other);
    PackMapEnvDataSkyCardsV63 &operator=(const PackMapEnvDataSkyCardsV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV34 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV34();
    PackMapEnvDataSpawnModelDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV34(const PackMapEnvDataSpawnModelDataV34 &p_other);
    PackMapEnvDataSpawnModelDataV34 &operator=(const PackMapEnvDataSpawnModelDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV34 {
    helpers::Array<PackMapEnvDataSpawnModelDataV34> spawns;

public:
    PackMapEnvDataSpawnListV34();
    PackMapEnvDataSpawnListV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV34(const PackMapEnvDataSpawnListV34 &p_other);
    PackMapEnvDataSpawnListV34 &operator=(const PackMapEnvDataSpawnListV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV34 {
    helpers::Array<PackMapEnvDataSpawnListV34> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV34();
    PackMapEnvDataSpawnGroupsV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV34(const PackMapEnvDataSpawnGroupsV34 &p_other);
    PackMapEnvDataSpawnGroupsV34 &operator=(const PackMapEnvDataSpawnGroupsV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV63 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    float foamSpawn;
    float foamDissolve;
    float foamDepthAttenuation;
    byte4 foamColor0;
    byte4 foamColor1;

public:
    PackMapEnvDataWaterV63();
    PackMapEnvDataWaterV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV63(const PackMapEnvDataWaterV63 &p_other);
    PackMapEnvDataWaterV63 &operator=(const PackMapEnvDataWaterV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV63 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV63();
    PackMapEnvDataWindV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV63(const PackMapEnvDataWindV63 &p_other);
    PackMapEnvDataWindV63 &operator=(const PackMapEnvDataWindV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV63 {
    helpers::Array<PackMapEnvDataLightingV63> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV34> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV63> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV34> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV63> effect;
    helpers::Ptr<PackMapEnvDataHazeV63> haze;
    helpers::Ptr<PackMapEnvDataPFieldV63> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV34> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV63> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV63> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV34> spawns;
    helpers::Ptr<PackMapEnvDataWaterV63> water;
    helpers::Ptr<PackMapEnvDataWindV63> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV63();
    PackMapEnvDataLocalV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV63(const PackMapEnvDataLocalV63 &p_other);
    PackMapEnvDataLocalV63 &operator=(const PackMapEnvDataLocalV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV63 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV63();
    PackMapEnvDataSkyModeTexV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV63(const PackMapEnvDataSkyModeTexV63 &p_other);
    PackMapEnvDataSkyModeTexV63 &operator=(const PackMapEnvDataSkyModeTexV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV63 {
    helpers::Array<PackMapEnvDataLightingV63> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV34> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV63> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV34> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV63> effect;
    helpers::Ptr<PackMapEnvDataHazeV63> haze;
    helpers::Ptr<PackMapEnvDataPFieldV63> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV34> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV63> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV63> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV34> spawns;
    helpers::Ptr<PackMapEnvDataWaterV63> water;
    helpers::Ptr<PackMapEnvDataWindV63> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV63> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV63();
    PackMapEnvDataGlobalV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV63(const PackMapEnvDataGlobalV63 &p_other);
    PackMapEnvDataGlobalV63 &operator=(const PackMapEnvDataGlobalV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV63 {
    helpers::Array<PackMapEnvDataLocalV63> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV63> dataGlobal;

public:
    PackMapEnvironmentV63();
    PackMapEnvironmentV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV63(const PackMapEnvironmentV63 &p_other);
    PackMapEnvironmentV63 &operator=(const PackMapEnvironmentV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV63 Gw2Struct;
};

/* Version: 62, ReferencedFunction: 0x4104F16000000001 */

template <>
struct Gw2Structenv<62>{
struct PackMapEnvDataLightV62 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV62();
    PackMapEnvDataLightV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV62(const PackMapEnvDataLightV62 &p_other);
    PackMapEnvDataLightV62 &operator=(const PackMapEnvDataLightV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV62 {
    helpers::Ptr<PackMapEnvDataLightV62> lights;

public:
    PackMapEnvDataLightingV62();
    PackMapEnvDataLightingV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV62(const PackMapEnvDataLightingV62 &p_other);
    PackMapEnvDataLightingV62 &operator=(const PackMapEnvDataLightingV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV33 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV33();
    PackMapEnvDataLightingCharV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV33(const PackMapEnvDataLightingCharV33 &p_other);
    PackMapEnvDataLightingCharV33 &operator=(const PackMapEnvDataLightingCharV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV33 {
    helpers::Array<PackMapEnvDataLightingCharV33> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV33();
    PackMapEnvDataLightingCharGroupV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV33(const PackMapEnvDataLightingCharGroupV33 &p_other);
    PackMapEnvDataLightingCharGroupV33 &operator=(const PackMapEnvDataLightingCharGroupV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV62 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV62();
    PackMapEnvDataLayerAttributesV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV62(const PackMapEnvDataLayerAttributesV62 &p_other);
    PackMapEnvDataLayerAttributesV62 &operator=(const PackMapEnvDataLayerAttributesV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV62 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV62> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV62();
    PackMapEnvDataLayerV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV62(const PackMapEnvDataLayerV62 &p_other);
    PackMapEnvDataLayerV62 &operator=(const PackMapEnvDataLayerV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV62 {
    helpers::Array<PackMapEnvDataLayerV62> layers;

public:
    PackMapEnvDataCloudsV62();
    PackMapEnvDataCloudsV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV62(const PackMapEnvDataCloudsV62 &p_other);
    PackMapEnvDataCloudsV62 &operator=(const PackMapEnvDataCloudsV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV33 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV33();
    PackMapEnvDataColoredLightRingsV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV33(const PackMapEnvDataColoredLightRingsV33 &p_other);
    PackMapEnvDataColoredLightRingsV33 &operator=(const PackMapEnvDataColoredLightRingsV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV62 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV62();
    PackMapEnvDataEffectV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV62(const PackMapEnvDataEffectV62 &p_other);
    PackMapEnvDataEffectV62 &operator=(const PackMapEnvDataEffectV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV62 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;
    float2 sunDirRange;

public:
    PackMapEnvDataHazeV62();
    PackMapEnvDataHazeV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV62(const PackMapEnvDataHazeV62 &p_other);
    PackMapEnvDataHazeV62 &operator=(const PackMapEnvDataHazeV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV62 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV62();
    PackMapEnvDataPFieldV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV62(const PackMapEnvDataPFieldV62 &p_other);
    PackMapEnvDataPFieldV62 &operator=(const PackMapEnvDataPFieldV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV33 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV33();
    PackMapEnvDataPFieldCutoutV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV33(const PackMapEnvDataPFieldCutoutV33 &p_other);
    PackMapEnvDataPFieldCutoutV33 &operator=(const PackMapEnvDataPFieldCutoutV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV62 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV62();
    PackMapEnvDataSkyV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV62(const PackMapEnvDataSkyV62 &p_other);
    PackMapEnvDataSkyV62 &operator=(const PackMapEnvDataSkyV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV62 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV62();
    PackMapEnvDataSkyCardAttributesV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV62(const PackMapEnvDataSkyCardAttributesV62 &p_other);
    PackMapEnvDataSkyCardAttributesV62 &operator=(const PackMapEnvDataSkyCardAttributesV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV62 {
    PackMapEnvDataSkyCardAttributesV62 day;
    PackMapEnvDataSkyCardAttributesV62 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV62();
    PackMapEnvDataSkyCardV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV62(const PackMapEnvDataSkyCardV62 &p_other);
    PackMapEnvDataSkyCardV62 &operator=(const PackMapEnvDataSkyCardV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV62 {
    helpers::Array<PackMapEnvDataSkyCardV62> cards;

public:
    PackMapEnvDataSkyCardsV62();
    PackMapEnvDataSkyCardsV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV62(const PackMapEnvDataSkyCardsV62 &p_other);
    PackMapEnvDataSkyCardsV62 &operator=(const PackMapEnvDataSkyCardsV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV33 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV33();
    PackMapEnvDataSpawnModelDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV33(const PackMapEnvDataSpawnModelDataV33 &p_other);
    PackMapEnvDataSpawnModelDataV33 &operator=(const PackMapEnvDataSpawnModelDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV33 {
    helpers::Array<PackMapEnvDataSpawnModelDataV33> spawns;

public:
    PackMapEnvDataSpawnListV33();
    PackMapEnvDataSpawnListV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV33(const PackMapEnvDataSpawnListV33 &p_other);
    PackMapEnvDataSpawnListV33 &operator=(const PackMapEnvDataSpawnListV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV33 {
    helpers::Array<PackMapEnvDataSpawnListV33> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV33();
    PackMapEnvDataSpawnGroupsV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV33(const PackMapEnvDataSpawnGroupsV33 &p_other);
    PackMapEnvDataSpawnGroupsV33 &operator=(const PackMapEnvDataSpawnGroupsV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV62 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV62();
    PackMapEnvDataWaterV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV62(const PackMapEnvDataWaterV62 &p_other);
    PackMapEnvDataWaterV62 &operator=(const PackMapEnvDataWaterV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV62 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV62();
    PackMapEnvDataWindV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV62(const PackMapEnvDataWindV62 &p_other);
    PackMapEnvDataWindV62 &operator=(const PackMapEnvDataWindV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV62 {
    helpers::Array<PackMapEnvDataLightingV62> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV33> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV62> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV33> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV62> effect;
    helpers::Ptr<PackMapEnvDataHazeV62> haze;
    helpers::Ptr<PackMapEnvDataPFieldV62> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV33> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV62> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV62> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV33> spawns;
    helpers::Ptr<PackMapEnvDataWaterV62> water;
    helpers::Ptr<PackMapEnvDataWindV62> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV62();
    PackMapEnvDataLocalV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV62(const PackMapEnvDataLocalV62 &p_other);
    PackMapEnvDataLocalV62 &operator=(const PackMapEnvDataLocalV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV62 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV62();
    PackMapEnvDataSkyModeTexV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV62(const PackMapEnvDataSkyModeTexV62 &p_other);
    PackMapEnvDataSkyModeTexV62 &operator=(const PackMapEnvDataSkyModeTexV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV62 {
    helpers::Array<PackMapEnvDataLightingV62> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV33> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV62> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV33> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV62> effect;
    helpers::Ptr<PackMapEnvDataHazeV62> haze;
    helpers::Ptr<PackMapEnvDataPFieldV62> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV33> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV62> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV62> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV33> spawns;
    helpers::Ptr<PackMapEnvDataWaterV62> water;
    helpers::Ptr<PackMapEnvDataWindV62> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV62> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV62();
    PackMapEnvDataGlobalV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV62(const PackMapEnvDataGlobalV62 &p_other);
    PackMapEnvDataGlobalV62 &operator=(const PackMapEnvDataGlobalV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV62 {
    helpers::Array<PackMapEnvDataLocalV62> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV62> dataGlobal;

public:
    PackMapEnvironmentV62();
    PackMapEnvironmentV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV62(const PackMapEnvironmentV62 &p_other);
    PackMapEnvironmentV62 &operator=(const PackMapEnvironmentV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV62 Gw2Struct;
};

/* Version: 61, ReferencedFunction: 0x4104F13000000001 */

template <>
struct Gw2Structenv<61>{
struct PackMapEnvDataLightV61 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV61();
    PackMapEnvDataLightV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV61(const PackMapEnvDataLightV61 &p_other);
    PackMapEnvDataLightV61 &operator=(const PackMapEnvDataLightV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV61 {
    helpers::Ptr<PackMapEnvDataLightV61> lights;

public:
    PackMapEnvDataLightingV61();
    PackMapEnvDataLightingV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV61(const PackMapEnvDataLightingV61 &p_other);
    PackMapEnvDataLightingV61 &operator=(const PackMapEnvDataLightingV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV32 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV32();
    PackMapEnvDataLightingCharV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV32(const PackMapEnvDataLightingCharV32 &p_other);
    PackMapEnvDataLightingCharV32 &operator=(const PackMapEnvDataLightingCharV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV32 {
    helpers::Array<PackMapEnvDataLightingCharV32> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV32();
    PackMapEnvDataLightingCharGroupV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV32(const PackMapEnvDataLightingCharGroupV32 &p_other);
    PackMapEnvDataLightingCharGroupV32 &operator=(const PackMapEnvDataLightingCharGroupV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV61 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV61();
    PackMapEnvDataLayerAttributesV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV61(const PackMapEnvDataLayerAttributesV61 &p_other);
    PackMapEnvDataLayerAttributesV61 &operator=(const PackMapEnvDataLayerAttributesV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV61 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV61> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV61();
    PackMapEnvDataLayerV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV61(const PackMapEnvDataLayerV61 &p_other);
    PackMapEnvDataLayerV61 &operator=(const PackMapEnvDataLayerV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV61 {
    helpers::Array<PackMapEnvDataLayerV61> layers;

public:
    PackMapEnvDataCloudsV61();
    PackMapEnvDataCloudsV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV61(const PackMapEnvDataCloudsV61 &p_other);
    PackMapEnvDataCloudsV61 &operator=(const PackMapEnvDataCloudsV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV32 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV32();
    PackMapEnvDataColoredLightRingsV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV32(const PackMapEnvDataColoredLightRingsV32 &p_other);
    PackMapEnvDataColoredLightRingsV32 &operator=(const PackMapEnvDataColoredLightRingsV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV61 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;
    float2 flatteningCharacterRange;

public:
    PackMapEnvDataEffectV61();
    PackMapEnvDataEffectV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV61(const PackMapEnvDataEffectV61 &p_other);
    PackMapEnvDataEffectV61 &operator=(const PackMapEnvDataEffectV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV61 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV61();
    PackMapEnvDataHazeV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV61(const PackMapEnvDataHazeV61 &p_other);
    PackMapEnvDataHazeV61 &operator=(const PackMapEnvDataHazeV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV61 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV61();
    PackMapEnvDataPFieldV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV61(const PackMapEnvDataPFieldV61 &p_other);
    PackMapEnvDataPFieldV61 &operator=(const PackMapEnvDataPFieldV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV32 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV32();
    PackMapEnvDataPFieldCutoutV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV32(const PackMapEnvDataPFieldCutoutV32 &p_other);
    PackMapEnvDataPFieldCutoutV32 &operator=(const PackMapEnvDataPFieldCutoutV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV61 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV61();
    PackMapEnvDataSkyV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV61(const PackMapEnvDataSkyV61 &p_other);
    PackMapEnvDataSkyV61 &operator=(const PackMapEnvDataSkyV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV61 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV61();
    PackMapEnvDataSkyCardAttributesV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV61(const PackMapEnvDataSkyCardAttributesV61 &p_other);
    PackMapEnvDataSkyCardAttributesV61 &operator=(const PackMapEnvDataSkyCardAttributesV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV61 {
    PackMapEnvDataSkyCardAttributesV61 day;
    PackMapEnvDataSkyCardAttributesV61 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV61();
    PackMapEnvDataSkyCardV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV61(const PackMapEnvDataSkyCardV61 &p_other);
    PackMapEnvDataSkyCardV61 &operator=(const PackMapEnvDataSkyCardV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV61 {
    helpers::Array<PackMapEnvDataSkyCardV61> cards;

public:
    PackMapEnvDataSkyCardsV61();
    PackMapEnvDataSkyCardsV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV61(const PackMapEnvDataSkyCardsV61 &p_other);
    PackMapEnvDataSkyCardsV61 &operator=(const PackMapEnvDataSkyCardsV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV32 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV32();
    PackMapEnvDataSpawnModelDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV32(const PackMapEnvDataSpawnModelDataV32 &p_other);
    PackMapEnvDataSpawnModelDataV32 &operator=(const PackMapEnvDataSpawnModelDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV32 {
    helpers::Array<PackMapEnvDataSpawnModelDataV32> spawns;

public:
    PackMapEnvDataSpawnListV32();
    PackMapEnvDataSpawnListV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV32(const PackMapEnvDataSpawnListV32 &p_other);
    PackMapEnvDataSpawnListV32 &operator=(const PackMapEnvDataSpawnListV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV32 {
    helpers::Array<PackMapEnvDataSpawnListV32> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV32();
    PackMapEnvDataSpawnGroupsV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV32(const PackMapEnvDataSpawnGroupsV32 &p_other);
    PackMapEnvDataSpawnGroupsV32 &operator=(const PackMapEnvDataSpawnGroupsV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV61 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV61();
    PackMapEnvDataWaterV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV61(const PackMapEnvDataWaterV61 &p_other);
    PackMapEnvDataWaterV61 &operator=(const PackMapEnvDataWaterV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV61 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV61();
    PackMapEnvDataWindV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV61(const PackMapEnvDataWindV61 &p_other);
    PackMapEnvDataWindV61 &operator=(const PackMapEnvDataWindV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV61 {
    helpers::Array<PackMapEnvDataLightingV61> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV32> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV61> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV32> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV61> effect;
    helpers::Ptr<PackMapEnvDataHazeV61> haze;
    helpers::Ptr<PackMapEnvDataPFieldV61> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV32> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV61> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV61> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV32> spawns;
    helpers::Ptr<PackMapEnvDataWaterV61> water;
    helpers::Ptr<PackMapEnvDataWindV61> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV61();
    PackMapEnvDataLocalV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV61(const PackMapEnvDataLocalV61 &p_other);
    PackMapEnvDataLocalV61 &operator=(const PackMapEnvDataLocalV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV61 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV61();
    PackMapEnvDataSkyModeTexV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV61(const PackMapEnvDataSkyModeTexV61 &p_other);
    PackMapEnvDataSkyModeTexV61 &operator=(const PackMapEnvDataSkyModeTexV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV61 {
    helpers::Array<PackMapEnvDataLightingV61> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV32> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV61> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV32> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV61> effect;
    helpers::Ptr<PackMapEnvDataHazeV61> haze;
    helpers::Ptr<PackMapEnvDataPFieldV61> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV32> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV61> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV61> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV32> spawns;
    helpers::Ptr<PackMapEnvDataWaterV61> water;
    helpers::Ptr<PackMapEnvDataWindV61> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV61> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV61();
    PackMapEnvDataGlobalV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV61(const PackMapEnvDataGlobalV61 &p_other);
    PackMapEnvDataGlobalV61 &operator=(const PackMapEnvDataGlobalV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV61 {
    helpers::Array<PackMapEnvDataLocalV61> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV61> dataGlobal;

public:
    PackMapEnvironmentV61();
    PackMapEnvironmentV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV61(const PackMapEnvironmentV61 &p_other);
    PackMapEnvironmentV61 &operator=(const PackMapEnvironmentV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV61 Gw2Struct;
};

/* Version: 60, ReferencedFunction: 0x4104F0F000000001 */

template <>
struct Gw2Structenv<60>{
struct PackMapEnvDataLightV60 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV60();
    PackMapEnvDataLightV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV60(const PackMapEnvDataLightV60 &p_other);
    PackMapEnvDataLightV60 &operator=(const PackMapEnvDataLightV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV60 {
    helpers::Ptr<PackMapEnvDataLightV60> lights;

public:
    PackMapEnvDataLightingV60();
    PackMapEnvDataLightingV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV60(const PackMapEnvDataLightingV60 &p_other);
    PackMapEnvDataLightingV60 &operator=(const PackMapEnvDataLightingV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV31 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV31();
    PackMapEnvDataLightingCharV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV31(const PackMapEnvDataLightingCharV31 &p_other);
    PackMapEnvDataLightingCharV31 &operator=(const PackMapEnvDataLightingCharV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV31 {
    helpers::Array<PackMapEnvDataLightingCharV31> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV31();
    PackMapEnvDataLightingCharGroupV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV31(const PackMapEnvDataLightingCharGroupV31 &p_other);
    PackMapEnvDataLightingCharGroupV31 &operator=(const PackMapEnvDataLightingCharGroupV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV60 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV60();
    PackMapEnvDataLayerAttributesV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV60(const PackMapEnvDataLayerAttributesV60 &p_other);
    PackMapEnvDataLayerAttributesV60 &operator=(const PackMapEnvDataLayerAttributesV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV60 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV60> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV60();
    PackMapEnvDataLayerV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV60(const PackMapEnvDataLayerV60 &p_other);
    PackMapEnvDataLayerV60 &operator=(const PackMapEnvDataLayerV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV60 {
    helpers::Array<PackMapEnvDataLayerV60> layers;

public:
    PackMapEnvDataCloudsV60();
    PackMapEnvDataCloudsV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV60(const PackMapEnvDataCloudsV60 &p_other);
    PackMapEnvDataCloudsV60 &operator=(const PackMapEnvDataCloudsV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV31 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV31();
    PackMapEnvDataColoredLightRingsV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV31(const PackMapEnvDataColoredLightRingsV31 &p_other);
    PackMapEnvDataColoredLightRingsV31 &operator=(const PackMapEnvDataColoredLightRingsV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV60 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;
    float2 flatteningRange;

public:
    PackMapEnvDataEffectV60();
    PackMapEnvDataEffectV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV60(const PackMapEnvDataEffectV60 &p_other);
    PackMapEnvDataEffectV60 &operator=(const PackMapEnvDataEffectV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV60 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV60();
    PackMapEnvDataHazeV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV60(const PackMapEnvDataHazeV60 &p_other);
    PackMapEnvDataHazeV60 &operator=(const PackMapEnvDataHazeV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV60 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV60();
    PackMapEnvDataPFieldV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV60(const PackMapEnvDataPFieldV60 &p_other);
    PackMapEnvDataPFieldV60 &operator=(const PackMapEnvDataPFieldV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV31 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV31();
    PackMapEnvDataPFieldCutoutV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV31(const PackMapEnvDataPFieldCutoutV31 &p_other);
    PackMapEnvDataPFieldCutoutV31 &operator=(const PackMapEnvDataPFieldCutoutV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV60 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV60();
    PackMapEnvDataSkyV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV60(const PackMapEnvDataSkyV60 &p_other);
    PackMapEnvDataSkyV60 &operator=(const PackMapEnvDataSkyV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV60 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV60();
    PackMapEnvDataSkyCardAttributesV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV60(const PackMapEnvDataSkyCardAttributesV60 &p_other);
    PackMapEnvDataSkyCardAttributesV60 &operator=(const PackMapEnvDataSkyCardAttributesV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV60 {
    PackMapEnvDataSkyCardAttributesV60 day;
    PackMapEnvDataSkyCardAttributesV60 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV60();
    PackMapEnvDataSkyCardV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV60(const PackMapEnvDataSkyCardV60 &p_other);
    PackMapEnvDataSkyCardV60 &operator=(const PackMapEnvDataSkyCardV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV60 {
    helpers::Array<PackMapEnvDataSkyCardV60> cards;

public:
    PackMapEnvDataSkyCardsV60();
    PackMapEnvDataSkyCardsV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV60(const PackMapEnvDataSkyCardsV60 &p_other);
    PackMapEnvDataSkyCardsV60 &operator=(const PackMapEnvDataSkyCardsV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV31 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV31();
    PackMapEnvDataSpawnModelDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV31(const PackMapEnvDataSpawnModelDataV31 &p_other);
    PackMapEnvDataSpawnModelDataV31 &operator=(const PackMapEnvDataSpawnModelDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV31 {
    helpers::Array<PackMapEnvDataSpawnModelDataV31> spawns;

public:
    PackMapEnvDataSpawnListV31();
    PackMapEnvDataSpawnListV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV31(const PackMapEnvDataSpawnListV31 &p_other);
    PackMapEnvDataSpawnListV31 &operator=(const PackMapEnvDataSpawnListV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV31 {
    helpers::Array<PackMapEnvDataSpawnListV31> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV31();
    PackMapEnvDataSpawnGroupsV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV31(const PackMapEnvDataSpawnGroupsV31 &p_other);
    PackMapEnvDataSpawnGroupsV31 &operator=(const PackMapEnvDataSpawnGroupsV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV60 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV60();
    PackMapEnvDataWaterV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV60(const PackMapEnvDataWaterV60 &p_other);
    PackMapEnvDataWaterV60 &operator=(const PackMapEnvDataWaterV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV60 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV60();
    PackMapEnvDataWindV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV60(const PackMapEnvDataWindV60 &p_other);
    PackMapEnvDataWindV60 &operator=(const PackMapEnvDataWindV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV60 {
    helpers::Array<PackMapEnvDataLightingV60> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV31> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV60> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV31> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV60> effect;
    helpers::Ptr<PackMapEnvDataHazeV60> haze;
    helpers::Ptr<PackMapEnvDataPFieldV60> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV31> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV60> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV60> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV31> spawns;
    helpers::Ptr<PackMapEnvDataWaterV60> water;
    helpers::Ptr<PackMapEnvDataWindV60> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV60();
    PackMapEnvDataLocalV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV60(const PackMapEnvDataLocalV60 &p_other);
    PackMapEnvDataLocalV60 &operator=(const PackMapEnvDataLocalV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV60 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV60();
    PackMapEnvDataSkyModeTexV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV60(const PackMapEnvDataSkyModeTexV60 &p_other);
    PackMapEnvDataSkyModeTexV60 &operator=(const PackMapEnvDataSkyModeTexV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV60 {
    helpers::Array<PackMapEnvDataLightingV60> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV31> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV60> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV31> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV60> effect;
    helpers::Ptr<PackMapEnvDataHazeV60> haze;
    helpers::Ptr<PackMapEnvDataPFieldV60> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV31> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV60> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV60> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV31> spawns;
    helpers::Ptr<PackMapEnvDataWaterV60> water;
    helpers::Ptr<PackMapEnvDataWindV60> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV60> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV60();
    PackMapEnvDataGlobalV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV60(const PackMapEnvDataGlobalV60 &p_other);
    PackMapEnvDataGlobalV60 &operator=(const PackMapEnvDataGlobalV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV60 {
    helpers::Array<PackMapEnvDataLocalV60> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV60> dataGlobal;

public:
    PackMapEnvironmentV60();
    PackMapEnvironmentV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV60(const PackMapEnvironmentV60 &p_other);
    PackMapEnvironmentV60 &operator=(const PackMapEnvironmentV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV60 Gw2Struct;
};

/* Version: 59, ReferencedFunction: 0x4104EF5000000001 */

template <>
struct Gw2Structenv<59>{
struct PackMapEnvDataLightV59 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV59();
    PackMapEnvDataLightV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV59(const PackMapEnvDataLightV59 &p_other);
    PackMapEnvDataLightV59 &operator=(const PackMapEnvDataLightV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV59 {
    helpers::Ptr<PackMapEnvDataLightV59> lights;

public:
    PackMapEnvDataLightingV59();
    PackMapEnvDataLightingV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV59(const PackMapEnvDataLightingV59 &p_other);
    PackMapEnvDataLightingV59 &operator=(const PackMapEnvDataLightingV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV30 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV30();
    PackMapEnvDataLightingCharV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV30(const PackMapEnvDataLightingCharV30 &p_other);
    PackMapEnvDataLightingCharV30 &operator=(const PackMapEnvDataLightingCharV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV30 {
    helpers::Array<PackMapEnvDataLightingCharV30> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV30();
    PackMapEnvDataLightingCharGroupV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV30(const PackMapEnvDataLightingCharGroupV30 &p_other);
    PackMapEnvDataLightingCharGroupV30 &operator=(const PackMapEnvDataLightingCharGroupV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV59 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV59();
    PackMapEnvDataLayerAttributesV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV59(const PackMapEnvDataLayerAttributesV59 &p_other);
    PackMapEnvDataLayerAttributesV59 &operator=(const PackMapEnvDataLayerAttributesV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV59 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV59> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV59();
    PackMapEnvDataLayerV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV59(const PackMapEnvDataLayerV59 &p_other);
    PackMapEnvDataLayerV59 &operator=(const PackMapEnvDataLayerV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV59 {
    helpers::Array<PackMapEnvDataLayerV59> layers;

public:
    PackMapEnvDataCloudsV59();
    PackMapEnvDataCloudsV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV59(const PackMapEnvDataCloudsV59 &p_other);
    PackMapEnvDataCloudsV59 &operator=(const PackMapEnvDataCloudsV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV30 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV30();
    PackMapEnvDataColoredLightRingsV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV30(const PackMapEnvDataColoredLightRingsV30 &p_other);
    PackMapEnvDataColoredLightRingsV30 &operator=(const PackMapEnvDataColoredLightRingsV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV59 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV59();
    PackMapEnvDataEffectV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV59(const PackMapEnvDataEffectV59 &p_other);
    PackMapEnvDataEffectV59 &operator=(const PackMapEnvDataEffectV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV59 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV59();
    PackMapEnvDataHazeV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV59(const PackMapEnvDataHazeV59 &p_other);
    PackMapEnvDataHazeV59 &operator=(const PackMapEnvDataHazeV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV59 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV59();
    PackMapEnvDataPFieldV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV59(const PackMapEnvDataPFieldV59 &p_other);
    PackMapEnvDataPFieldV59 &operator=(const PackMapEnvDataPFieldV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV30 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV30();
    PackMapEnvDataPFieldCutoutV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV30(const PackMapEnvDataPFieldCutoutV30 &p_other);
    PackMapEnvDataPFieldCutoutV30 &operator=(const PackMapEnvDataPFieldCutoutV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV59 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV59();
    PackMapEnvDataSkyV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV59(const PackMapEnvDataSkyV59 &p_other);
    PackMapEnvDataSkyV59 &operator=(const PackMapEnvDataSkyV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV59 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV59();
    PackMapEnvDataSkyCardAttributesV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV59(const PackMapEnvDataSkyCardAttributesV59 &p_other);
    PackMapEnvDataSkyCardAttributesV59 &operator=(const PackMapEnvDataSkyCardAttributesV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV59 {
    PackMapEnvDataSkyCardAttributesV59 day;
    PackMapEnvDataSkyCardAttributesV59 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV59();
    PackMapEnvDataSkyCardV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV59(const PackMapEnvDataSkyCardV59 &p_other);
    PackMapEnvDataSkyCardV59 &operator=(const PackMapEnvDataSkyCardV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV59 {
    helpers::Array<PackMapEnvDataSkyCardV59> cards;

public:
    PackMapEnvDataSkyCardsV59();
    PackMapEnvDataSkyCardsV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV59(const PackMapEnvDataSkyCardsV59 &p_other);
    PackMapEnvDataSkyCardsV59 &operator=(const PackMapEnvDataSkyCardsV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV30 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::FileName modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV30();
    PackMapEnvDataSpawnModelDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV30(const PackMapEnvDataSpawnModelDataV30 &p_other);
    PackMapEnvDataSpawnModelDataV30 &operator=(const PackMapEnvDataSpawnModelDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV30 {
    helpers::Array<PackMapEnvDataSpawnModelDataV30> spawns;

public:
    PackMapEnvDataSpawnListV30();
    PackMapEnvDataSpawnListV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV30(const PackMapEnvDataSpawnListV30 &p_other);
    PackMapEnvDataSpawnListV30 &operator=(const PackMapEnvDataSpawnListV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV30 {
    helpers::Array<PackMapEnvDataSpawnListV30> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV30();
    PackMapEnvDataSpawnGroupsV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV30(const PackMapEnvDataSpawnGroupsV30 &p_other);
    PackMapEnvDataSpawnGroupsV30 &operator=(const PackMapEnvDataSpawnGroupsV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV59 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV59();
    PackMapEnvDataWaterV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV59(const PackMapEnvDataWaterV59 &p_other);
    PackMapEnvDataWaterV59 &operator=(const PackMapEnvDataWaterV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV59 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV59();
    PackMapEnvDataWindV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV59(const PackMapEnvDataWindV59 &p_other);
    PackMapEnvDataWindV59 &operator=(const PackMapEnvDataWindV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV59 {
    helpers::Array<PackMapEnvDataLightingV59> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV30> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV59> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV30> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV59> effect;
    helpers::Ptr<PackMapEnvDataHazeV59> haze;
    helpers::Ptr<PackMapEnvDataPFieldV59> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV30> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV59> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV59> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV30> spawns;
    helpers::Ptr<PackMapEnvDataWaterV59> water;
    helpers::Ptr<PackMapEnvDataWindV59> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV59();
    PackMapEnvDataLocalV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV59(const PackMapEnvDataLocalV59 &p_other);
    PackMapEnvDataLocalV59 &operator=(const PackMapEnvDataLocalV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV59 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV59();
    PackMapEnvDataSkyModeTexV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV59(const PackMapEnvDataSkyModeTexV59 &p_other);
    PackMapEnvDataSkyModeTexV59 &operator=(const PackMapEnvDataSkyModeTexV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV59 {
    helpers::Array<PackMapEnvDataLightingV59> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV30> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV59> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV30> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV59> effect;
    helpers::Ptr<PackMapEnvDataHazeV59> haze;
    helpers::Ptr<PackMapEnvDataPFieldV59> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV30> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV59> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV59> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV30> spawns;
    helpers::Ptr<PackMapEnvDataWaterV59> water;
    helpers::Ptr<PackMapEnvDataWindV59> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV59> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV59();
    PackMapEnvDataGlobalV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV59(const PackMapEnvDataGlobalV59 &p_other);
    PackMapEnvDataGlobalV59 &operator=(const PackMapEnvDataGlobalV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV59 {
    helpers::Array<PackMapEnvDataLocalV59> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV59> dataGlobal;

public:
    PackMapEnvironmentV59();
    PackMapEnvironmentV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV59(const PackMapEnvironmentV59 &p_other);
    PackMapEnvironmentV59 &operator=(const PackMapEnvironmentV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV59 Gw2Struct;
};

/* Version: 58, ReferencedFunction: 0x4104EE8000000001 */

template <>
struct Gw2Structenv<58>{
struct PackMapEnvDataLightV58 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV58();
    PackMapEnvDataLightV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV58(const PackMapEnvDataLightV58 &p_other);
    PackMapEnvDataLightV58 &operator=(const PackMapEnvDataLightV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV58 {
    helpers::Ptr<PackMapEnvDataLightV58> lights;

public:
    PackMapEnvDataLightingV58();
    PackMapEnvDataLightingV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV58(const PackMapEnvDataLightingV58 &p_other);
    PackMapEnvDataLightingV58 &operator=(const PackMapEnvDataLightingV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV29 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV29();
    PackMapEnvDataLightingCharV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV29(const PackMapEnvDataLightingCharV29 &p_other);
    PackMapEnvDataLightingCharV29 &operator=(const PackMapEnvDataLightingCharV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV29 {
    helpers::Array<PackMapEnvDataLightingCharV29> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV29();
    PackMapEnvDataLightingCharGroupV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV29(const PackMapEnvDataLightingCharGroupV29 &p_other);
    PackMapEnvDataLightingCharGroupV29 &operator=(const PackMapEnvDataLightingCharGroupV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV58 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV58();
    PackMapEnvDataLayerAttributesV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV58(const PackMapEnvDataLayerAttributesV58 &p_other);
    PackMapEnvDataLayerAttributesV58 &operator=(const PackMapEnvDataLayerAttributesV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV58 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV58> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV58();
    PackMapEnvDataLayerV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV58(const PackMapEnvDataLayerV58 &p_other);
    PackMapEnvDataLayerV58 &operator=(const PackMapEnvDataLayerV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV58 {
    helpers::Array<PackMapEnvDataLayerV58> layers;

public:
    PackMapEnvDataCloudsV58();
    PackMapEnvDataCloudsV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV58(const PackMapEnvDataCloudsV58 &p_other);
    PackMapEnvDataCloudsV58 &operator=(const PackMapEnvDataCloudsV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV29 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV29();
    PackMapEnvDataColoredLightRingsV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV29(const PackMapEnvDataColoredLightRingsV29 &p_other);
    PackMapEnvDataColoredLightRingsV29 &operator=(const PackMapEnvDataColoredLightRingsV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV58 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV58();
    PackMapEnvDataEffectV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV58(const PackMapEnvDataEffectV58 &p_other);
    PackMapEnvDataEffectV58 &operator=(const PackMapEnvDataEffectV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV58 {
    byte4 nearColor;
    byte4 farColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV58();
    PackMapEnvDataHazeV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV58(const PackMapEnvDataHazeV58 &p_other);
    PackMapEnvDataHazeV58 &operator=(const PackMapEnvDataHazeV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV58 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV58();
    PackMapEnvDataPFieldV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV58(const PackMapEnvDataPFieldV58 &p_other);
    PackMapEnvDataPFieldV58 &operator=(const PackMapEnvDataPFieldV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV29 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV29();
    PackMapEnvDataPFieldCutoutV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV29(const PackMapEnvDataPFieldCutoutV29 &p_other);
    PackMapEnvDataPFieldCutoutV29 &operator=(const PackMapEnvDataPFieldCutoutV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV58 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV58();
    PackMapEnvDataSkyV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV58(const PackMapEnvDataSkyV58 &p_other);
    PackMapEnvDataSkyV58 &operator=(const PackMapEnvDataSkyV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV58 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV58();
    PackMapEnvDataSkyCardAttributesV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV58(const PackMapEnvDataSkyCardAttributesV58 &p_other);
    PackMapEnvDataSkyCardAttributesV58 &operator=(const PackMapEnvDataSkyCardAttributesV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV58 {
    PackMapEnvDataSkyCardAttributesV58 day;
    PackMapEnvDataSkyCardAttributesV58 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV58();
    PackMapEnvDataSkyCardV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV58(const PackMapEnvDataSkyCardV58 &p_other);
    PackMapEnvDataSkyCardV58 &operator=(const PackMapEnvDataSkyCardV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV58 {
    helpers::Array<PackMapEnvDataSkyCardV58> cards;

public:
    PackMapEnvDataSkyCardsV58();
    PackMapEnvDataSkyCardsV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV58(const PackMapEnvDataSkyCardsV58 &p_other);
    PackMapEnvDataSkyCardsV58 &operator=(const PackMapEnvDataSkyCardsV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV29 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::WString modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV29();
    PackMapEnvDataSpawnModelDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV29(const PackMapEnvDataSpawnModelDataV29 &p_other);
    PackMapEnvDataSpawnModelDataV29 &operator=(const PackMapEnvDataSpawnModelDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV29 {
    helpers::Array<PackMapEnvDataSpawnModelDataV29> spawns;

public:
    PackMapEnvDataSpawnListV29();
    PackMapEnvDataSpawnListV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV29(const PackMapEnvDataSpawnListV29 &p_other);
    PackMapEnvDataSpawnListV29 &operator=(const PackMapEnvDataSpawnListV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV29 {
    helpers::Array<PackMapEnvDataSpawnListV29> spawnGroups;
    helpers::Array<qword> targets;

public:
    PackMapEnvDataSpawnGroupsV29();
    PackMapEnvDataSpawnGroupsV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV29(const PackMapEnvDataSpawnGroupsV29 &p_other);
    PackMapEnvDataSpawnGroupsV29 &operator=(const PackMapEnvDataSpawnGroupsV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV58 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV58();
    PackMapEnvDataWaterV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV58(const PackMapEnvDataWaterV58 &p_other);
    PackMapEnvDataWaterV58 &operator=(const PackMapEnvDataWaterV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV58 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV58();
    PackMapEnvDataWindV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV58(const PackMapEnvDataWindV58 &p_other);
    PackMapEnvDataWindV58 &operator=(const PackMapEnvDataWindV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV58 {
    helpers::Array<PackMapEnvDataLightingV58> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV29> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV58> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV29> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV58> effect;
    helpers::Ptr<PackMapEnvDataHazeV58> haze;
    helpers::Ptr<PackMapEnvDataPFieldV58> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV29> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV58> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV58> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV29> spawns;
    helpers::Ptr<PackMapEnvDataWaterV58> water;
    helpers::Ptr<PackMapEnvDataWindV58> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV58();
    PackMapEnvDataLocalV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV58(const PackMapEnvDataLocalV58 &p_other);
    PackMapEnvDataLocalV58 &operator=(const PackMapEnvDataLocalV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV58 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV58();
    PackMapEnvDataSkyModeTexV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV58(const PackMapEnvDataSkyModeTexV58 &p_other);
    PackMapEnvDataSkyModeTexV58 &operator=(const PackMapEnvDataSkyModeTexV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV58 {
    helpers::Array<PackMapEnvDataLightingV58> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV29> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV58> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV29> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV58> effect;
    helpers::Ptr<PackMapEnvDataHazeV58> haze;
    helpers::Ptr<PackMapEnvDataPFieldV58> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV29> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV58> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV58> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV29> spawns;
    helpers::Ptr<PackMapEnvDataWaterV58> water;
    helpers::Ptr<PackMapEnvDataWindV58> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV58> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV58();
    PackMapEnvDataGlobalV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV58(const PackMapEnvDataGlobalV58 &p_other);
    PackMapEnvDataGlobalV58 &operator=(const PackMapEnvDataGlobalV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV58 {
    helpers::Array<PackMapEnvDataLocalV58> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV58> dataGlobal;

public:
    PackMapEnvironmentV58();
    PackMapEnvironmentV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV58(const PackMapEnvironmentV58 &p_other);
    PackMapEnvironmentV58 &operator=(const PackMapEnvironmentV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV58 Gw2Struct;
};

/* Version: 57, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<57>{
struct PackMapEnvDataLightV57 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV57();
    PackMapEnvDataLightV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV57(const PackMapEnvDataLightV57 &p_other);
    PackMapEnvDataLightV57 &operator=(const PackMapEnvDataLightV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV57 {
    helpers::Ptr<PackMapEnvDataLightV57> lights;

public:
    PackMapEnvDataLightingV57();
    PackMapEnvDataLightingV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV57(const PackMapEnvDataLightingV57 &p_other);
    PackMapEnvDataLightingV57 &operator=(const PackMapEnvDataLightingV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV28 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV28();
    PackMapEnvDataLightingCharV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV28(const PackMapEnvDataLightingCharV28 &p_other);
    PackMapEnvDataLightingCharV28 &operator=(const PackMapEnvDataLightingCharV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV28 {
    helpers::Array<PackMapEnvDataLightingCharV28> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV28();
    PackMapEnvDataLightingCharGroupV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV28(const PackMapEnvDataLightingCharGroupV28 &p_other);
    PackMapEnvDataLightingCharGroupV28 &operator=(const PackMapEnvDataLightingCharGroupV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV57 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV57();
    PackMapEnvDataLayerAttributesV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV57(const PackMapEnvDataLayerAttributesV57 &p_other);
    PackMapEnvDataLayerAttributesV57 &operator=(const PackMapEnvDataLayerAttributesV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV57 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV57> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV57();
    PackMapEnvDataLayerV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV57(const PackMapEnvDataLayerV57 &p_other);
    PackMapEnvDataLayerV57 &operator=(const PackMapEnvDataLayerV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV57 {
    helpers::Array<PackMapEnvDataLayerV57> layers;

public:
    PackMapEnvDataCloudsV57();
    PackMapEnvDataCloudsV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV57(const PackMapEnvDataCloudsV57 &p_other);
    PackMapEnvDataCloudsV57 &operator=(const PackMapEnvDataCloudsV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV28 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV28();
    PackMapEnvDataColoredLightRingsV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV28(const PackMapEnvDataColoredLightRingsV28 &p_other);
    PackMapEnvDataColoredLightRingsV28 &operator=(const PackMapEnvDataColoredLightRingsV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV57 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV57();
    PackMapEnvDataEffectV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV57(const PackMapEnvDataEffectV57 &p_other);
    PackMapEnvDataEffectV57 &operator=(const PackMapEnvDataEffectV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV57 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV57();
    PackMapEnvDataHazeV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV57(const PackMapEnvDataHazeV57 &p_other);
    PackMapEnvDataHazeV57 &operator=(const PackMapEnvDataHazeV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV57 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV57();
    PackMapEnvDataPFieldV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV57(const PackMapEnvDataPFieldV57 &p_other);
    PackMapEnvDataPFieldV57 &operator=(const PackMapEnvDataPFieldV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV28 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV28();
    PackMapEnvDataPFieldCutoutV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV28(const PackMapEnvDataPFieldCutoutV28 &p_other);
    PackMapEnvDataPFieldCutoutV28 &operator=(const PackMapEnvDataPFieldCutoutV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV57 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV57();
    PackMapEnvDataSkyV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV57(const PackMapEnvDataSkyV57 &p_other);
    PackMapEnvDataSkyV57 &operator=(const PackMapEnvDataSkyV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV57 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV57();
    PackMapEnvDataSkyCardAttributesV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV57(const PackMapEnvDataSkyCardAttributesV57 &p_other);
    PackMapEnvDataSkyCardAttributesV57 &operator=(const PackMapEnvDataSkyCardAttributesV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV57 {
    PackMapEnvDataSkyCardAttributesV57 day;
    PackMapEnvDataSkyCardAttributesV57 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV57();
    PackMapEnvDataSkyCardV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV57(const PackMapEnvDataSkyCardV57 &p_other);
    PackMapEnvDataSkyCardV57 &operator=(const PackMapEnvDataSkyCardV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV57 {
    helpers::Array<PackMapEnvDataSkyCardV57> cards;

public:
    PackMapEnvDataSkyCardsV57();
    PackMapEnvDataSkyCardsV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV57(const PackMapEnvDataSkyCardsV57 &p_other);
    PackMapEnvDataSkyCardsV57 &operator=(const PackMapEnvDataSkyCardsV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV28 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 heightRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::WString modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV28();
    PackMapEnvDataSpawnModelDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV28(const PackMapEnvDataSpawnModelDataV28 &p_other);
    PackMapEnvDataSpawnModelDataV28 &operator=(const PackMapEnvDataSpawnModelDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV28 {
    helpers::Array<PackMapEnvDataSpawnModelDataV28> spawns;

public:
    PackMapEnvDataSpawnListV28();
    PackMapEnvDataSpawnListV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV28(const PackMapEnvDataSpawnListV28 &p_other);
    PackMapEnvDataSpawnListV28 &operator=(const PackMapEnvDataSpawnListV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV28 {
    helpers::Array<PackMapEnvDataSpawnListV28> spawnGroups;
    qword targetVolume;

public:
    PackMapEnvDataSpawnGroupsV28();
    PackMapEnvDataSpawnGroupsV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV28(const PackMapEnvDataSpawnGroupsV28 &p_other);
    PackMapEnvDataSpawnGroupsV28 &operator=(const PackMapEnvDataSpawnGroupsV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV57 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV57();
    PackMapEnvDataWaterV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV57(const PackMapEnvDataWaterV57 &p_other);
    PackMapEnvDataWaterV57 &operator=(const PackMapEnvDataWaterV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV57 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV57();
    PackMapEnvDataWindV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV57(const PackMapEnvDataWindV57 &p_other);
    PackMapEnvDataWindV57 &operator=(const PackMapEnvDataWindV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV57 {
    helpers::Array<PackMapEnvDataLightingV57> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV28> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV57> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV28> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV57> effect;
    helpers::Ptr<PackMapEnvDataHazeV57> haze;
    helpers::Ptr<PackMapEnvDataPFieldV57> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV28> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV57> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV57> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV28> spawns;
    helpers::Ptr<PackMapEnvDataWaterV57> water;
    helpers::Ptr<PackMapEnvDataWindV57> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV57();
    PackMapEnvDataLocalV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV57(const PackMapEnvDataLocalV57 &p_other);
    PackMapEnvDataLocalV57 &operator=(const PackMapEnvDataLocalV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV57 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV57();
    PackMapEnvDataSkyModeTexV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV57(const PackMapEnvDataSkyModeTexV57 &p_other);
    PackMapEnvDataSkyModeTexV57 &operator=(const PackMapEnvDataSkyModeTexV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV57 {
    helpers::Array<PackMapEnvDataLightingV57> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV28> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV57> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV28> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV57> effect;
    helpers::Ptr<PackMapEnvDataHazeV57> haze;
    helpers::Ptr<PackMapEnvDataPFieldV57> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV28> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV57> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV57> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV28> spawns;
    helpers::Ptr<PackMapEnvDataWaterV57> water;
    helpers::Ptr<PackMapEnvDataWindV57> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV57> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV57();
    PackMapEnvDataGlobalV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV57(const PackMapEnvDataGlobalV57 &p_other);
    PackMapEnvDataGlobalV57 &operator=(const PackMapEnvDataGlobalV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV57 {
    helpers::Array<PackMapEnvDataLocalV57> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV57> dataGlobal;

public:
    PackMapEnvironmentV57();
    PackMapEnvironmentV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV57(const PackMapEnvironmentV57 &p_other);
    PackMapEnvironmentV57 &operator=(const PackMapEnvironmentV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV57 Gw2Struct;
};

/* Version: 56, ReferencedFunction: 0x4104ED2000000001 */

template <>
struct Gw2Structenv<56>{
struct PackMapEnvDataLightV56 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV56();
    PackMapEnvDataLightV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV56(const PackMapEnvDataLightV56 &p_other);
    PackMapEnvDataLightV56 &operator=(const PackMapEnvDataLightV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV56 {
    helpers::Ptr<PackMapEnvDataLightV56> lights;

public:
    PackMapEnvDataLightingV56();
    PackMapEnvDataLightingV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV56(const PackMapEnvDataLightingV56 &p_other);
    PackMapEnvDataLightingV56 &operator=(const PackMapEnvDataLightingV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV27 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV27();
    PackMapEnvDataLightingCharV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV27(const PackMapEnvDataLightingCharV27 &p_other);
    PackMapEnvDataLightingCharV27 &operator=(const PackMapEnvDataLightingCharV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV27 {
    helpers::Array<PackMapEnvDataLightingCharV27> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV27();
    PackMapEnvDataLightingCharGroupV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV27(const PackMapEnvDataLightingCharGroupV27 &p_other);
    PackMapEnvDataLightingCharGroupV27 &operator=(const PackMapEnvDataLightingCharGroupV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV56 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV56();
    PackMapEnvDataLayerAttributesV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV56(const PackMapEnvDataLayerAttributesV56 &p_other);
    PackMapEnvDataLayerAttributesV56 &operator=(const PackMapEnvDataLayerAttributesV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV56 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV56> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV56();
    PackMapEnvDataLayerV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV56(const PackMapEnvDataLayerV56 &p_other);
    PackMapEnvDataLayerV56 &operator=(const PackMapEnvDataLayerV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV56 {
    helpers::Array<PackMapEnvDataLayerV56> layers;

public:
    PackMapEnvDataCloudsV56();
    PackMapEnvDataCloudsV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV56(const PackMapEnvDataCloudsV56 &p_other);
    PackMapEnvDataCloudsV56 &operator=(const PackMapEnvDataCloudsV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV27 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV27();
    PackMapEnvDataColoredLightRingsV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV27(const PackMapEnvDataColoredLightRingsV27 &p_other);
    PackMapEnvDataColoredLightRingsV27 &operator=(const PackMapEnvDataColoredLightRingsV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV56 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV56();
    PackMapEnvDataEffectV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV56(const PackMapEnvDataEffectV56 &p_other);
    PackMapEnvDataEffectV56 &operator=(const PackMapEnvDataEffectV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV56 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV56();
    PackMapEnvDataHazeV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV56(const PackMapEnvDataHazeV56 &p_other);
    PackMapEnvDataHazeV56 &operator=(const PackMapEnvDataHazeV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV56 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV56();
    PackMapEnvDataPFieldV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV56(const PackMapEnvDataPFieldV56 &p_other);
    PackMapEnvDataPFieldV56 &operator=(const PackMapEnvDataPFieldV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV27 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV27();
    PackMapEnvDataPFieldCutoutV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV27(const PackMapEnvDataPFieldCutoutV27 &p_other);
    PackMapEnvDataPFieldCutoutV27 &operator=(const PackMapEnvDataPFieldCutoutV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV56 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV56();
    PackMapEnvDataSkyV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV56(const PackMapEnvDataSkyV56 &p_other);
    PackMapEnvDataSkyV56 &operator=(const PackMapEnvDataSkyV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV56 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV56();
    PackMapEnvDataSkyCardAttributesV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV56(const PackMapEnvDataSkyCardAttributesV56 &p_other);
    PackMapEnvDataSkyCardAttributesV56 &operator=(const PackMapEnvDataSkyCardAttributesV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV56 {
    PackMapEnvDataSkyCardAttributesV56 day;
    PackMapEnvDataSkyCardAttributesV56 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV56();
    PackMapEnvDataSkyCardV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV56(const PackMapEnvDataSkyCardV56 &p_other);
    PackMapEnvDataSkyCardV56 &operator=(const PackMapEnvDataSkyCardV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV56 {
    helpers::Array<PackMapEnvDataSkyCardV56> cards;

public:
    PackMapEnvDataSkyCardsV56();
    PackMapEnvDataSkyCardsV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV56(const PackMapEnvDataSkyCardsV56 &p_other);
    PackMapEnvDataSkyCardsV56 &operator=(const PackMapEnvDataSkyCardsV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV27 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float2 scaleRange;
    float2 rotXRange;
    float2 rotYRange;
    float2 rotZRange;
    float probability;
    float delay;
    dword flags;
    helpers::WString modelFile;
    word maxConcurrent;

public:
    PackMapEnvDataSpawnModelDataV27();
    PackMapEnvDataSpawnModelDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV27(const PackMapEnvDataSpawnModelDataV27 &p_other);
    PackMapEnvDataSpawnModelDataV27 &operator=(const PackMapEnvDataSpawnModelDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV27 {
    helpers::Array<PackMapEnvDataSpawnModelDataV27> spawns;

public:
    PackMapEnvDataSpawnListV27();
    PackMapEnvDataSpawnListV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV27(const PackMapEnvDataSpawnListV27 &p_other);
    PackMapEnvDataSpawnListV27 &operator=(const PackMapEnvDataSpawnListV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV27 {
    helpers::Array<PackMapEnvDataSpawnListV27> spawnGroups;
    qword targetVolume;

public:
    PackMapEnvDataSpawnGroupsV27();
    PackMapEnvDataSpawnGroupsV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV27(const PackMapEnvDataSpawnGroupsV27 &p_other);
    PackMapEnvDataSpawnGroupsV27 &operator=(const PackMapEnvDataSpawnGroupsV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV56 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV56();
    PackMapEnvDataWaterV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV56(const PackMapEnvDataWaterV56 &p_other);
    PackMapEnvDataWaterV56 &operator=(const PackMapEnvDataWaterV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV56 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV56();
    PackMapEnvDataWindV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV56(const PackMapEnvDataWindV56 &p_other);
    PackMapEnvDataWindV56 &operator=(const PackMapEnvDataWindV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV56 {
    helpers::Array<PackMapEnvDataLightingV56> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV27> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV56> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV27> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV56> effect;
    helpers::Ptr<PackMapEnvDataHazeV56> haze;
    helpers::Ptr<PackMapEnvDataPFieldV56> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV27> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV56> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV56> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV27> spawns;
    helpers::Ptr<PackMapEnvDataWaterV56> water;
    helpers::Ptr<PackMapEnvDataWindV56> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV56();
    PackMapEnvDataLocalV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV56(const PackMapEnvDataLocalV56 &p_other);
    PackMapEnvDataLocalV56 &operator=(const PackMapEnvDataLocalV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV56 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV56();
    PackMapEnvDataSkyModeTexV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV56(const PackMapEnvDataSkyModeTexV56 &p_other);
    PackMapEnvDataSkyModeTexV56 &operator=(const PackMapEnvDataSkyModeTexV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV56 {
    helpers::Array<PackMapEnvDataLightingV56> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV27> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV56> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV27> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV56> effect;
    helpers::Ptr<PackMapEnvDataHazeV56> haze;
    helpers::Ptr<PackMapEnvDataPFieldV56> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV27> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV56> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV56> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV27> spawns;
    helpers::Ptr<PackMapEnvDataWaterV56> water;
    helpers::Ptr<PackMapEnvDataWindV56> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV56> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV56();
    PackMapEnvDataGlobalV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV56(const PackMapEnvDataGlobalV56 &p_other);
    PackMapEnvDataGlobalV56 &operator=(const PackMapEnvDataGlobalV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV56 {
    helpers::Array<PackMapEnvDataLocalV56> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV56> dataGlobal;

public:
    PackMapEnvironmentV56();
    PackMapEnvironmentV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV56(const PackMapEnvironmentV56 &p_other);
    PackMapEnvironmentV56 &operator=(const PackMapEnvironmentV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV56 Gw2Struct;
};

/* Version: 55, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<55>{
struct PackMapEnvDataLightV55 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV55();
    PackMapEnvDataLightV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV55(const PackMapEnvDataLightV55 &p_other);
    PackMapEnvDataLightV55 &operator=(const PackMapEnvDataLightV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV55 {
    helpers::Ptr<PackMapEnvDataLightV55> lights;

public:
    PackMapEnvDataLightingV55();
    PackMapEnvDataLightingV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV55(const PackMapEnvDataLightingV55 &p_other);
    PackMapEnvDataLightingV55 &operator=(const PackMapEnvDataLightingV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV26 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV26();
    PackMapEnvDataLightingCharV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV26(const PackMapEnvDataLightingCharV26 &p_other);
    PackMapEnvDataLightingCharV26 &operator=(const PackMapEnvDataLightingCharV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV26 {
    helpers::Array<PackMapEnvDataLightingCharV26> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV26();
    PackMapEnvDataLightingCharGroupV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV26(const PackMapEnvDataLightingCharGroupV26 &p_other);
    PackMapEnvDataLightingCharGroupV26 &operator=(const PackMapEnvDataLightingCharGroupV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV55 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV55();
    PackMapEnvDataLayerAttributesV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV55(const PackMapEnvDataLayerAttributesV55 &p_other);
    PackMapEnvDataLayerAttributesV55 &operator=(const PackMapEnvDataLayerAttributesV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV55 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV55> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV55();
    PackMapEnvDataLayerV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV55(const PackMapEnvDataLayerV55 &p_other);
    PackMapEnvDataLayerV55 &operator=(const PackMapEnvDataLayerV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV55 {
    helpers::Array<PackMapEnvDataLayerV55> layers;

public:
    PackMapEnvDataCloudsV55();
    PackMapEnvDataCloudsV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV55(const PackMapEnvDataCloudsV55 &p_other);
    PackMapEnvDataCloudsV55 &operator=(const PackMapEnvDataCloudsV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV26 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV26();
    PackMapEnvDataColoredLightRingsV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV26(const PackMapEnvDataColoredLightRingsV26 &p_other);
    PackMapEnvDataColoredLightRingsV26 &operator=(const PackMapEnvDataColoredLightRingsV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV55 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV55();
    PackMapEnvDataEffectV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV55(const PackMapEnvDataEffectV55 &p_other);
    PackMapEnvDataEffectV55 &operator=(const PackMapEnvDataEffectV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV55 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV55();
    PackMapEnvDataHazeV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV55(const PackMapEnvDataHazeV55 &p_other);
    PackMapEnvDataHazeV55 &operator=(const PackMapEnvDataHazeV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV55 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV55();
    PackMapEnvDataPFieldV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV55(const PackMapEnvDataPFieldV55 &p_other);
    PackMapEnvDataPFieldV55 &operator=(const PackMapEnvDataPFieldV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV26 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV26();
    PackMapEnvDataPFieldCutoutV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV26(const PackMapEnvDataPFieldCutoutV26 &p_other);
    PackMapEnvDataPFieldCutoutV26 &operator=(const PackMapEnvDataPFieldCutoutV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV55 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV55();
    PackMapEnvDataSkyV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV55(const PackMapEnvDataSkyV55 &p_other);
    PackMapEnvDataSkyV55 &operator=(const PackMapEnvDataSkyV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV55 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV55();
    PackMapEnvDataSkyCardAttributesV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV55(const PackMapEnvDataSkyCardAttributesV55 &p_other);
    PackMapEnvDataSkyCardAttributesV55 &operator=(const PackMapEnvDataSkyCardAttributesV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV55 {
    PackMapEnvDataSkyCardAttributesV55 day;
    PackMapEnvDataSkyCardAttributesV55 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV55();
    PackMapEnvDataSkyCardV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV55(const PackMapEnvDataSkyCardV55 &p_other);
    PackMapEnvDataSkyCardV55 &operator=(const PackMapEnvDataSkyCardV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV55 {
    helpers::Array<PackMapEnvDataSkyCardV55> cards;

public:
    PackMapEnvDataSkyCardsV55();
    PackMapEnvDataSkyCardsV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV55(const PackMapEnvDataSkyCardsV55 &p_other);
    PackMapEnvDataSkyCardsV55 &operator=(const PackMapEnvDataSkyCardsV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnModelDataV26 {
    dword2 spawnRange;
    dword2 lifeSpan;
    float probability;
    float delay;
    word maxConcurrent;
    dword flags;
    helpers::WString modelFile;

public:
    PackMapEnvDataSpawnModelDataV26();
    PackMapEnvDataSpawnModelDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnModelDataV26(const PackMapEnvDataSpawnModelDataV26 &p_other);
    PackMapEnvDataSpawnModelDataV26 &operator=(const PackMapEnvDataSpawnModelDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnListV26 {
    helpers::Array<PackMapEnvDataSpawnModelDataV26> spawns;

public:
    PackMapEnvDataSpawnListV26();
    PackMapEnvDataSpawnListV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnListV26(const PackMapEnvDataSpawnListV26 &p_other);
    PackMapEnvDataSpawnListV26 &operator=(const PackMapEnvDataSpawnListV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSpawnGroupsV26 {
    helpers::Array<PackMapEnvDataSpawnListV26> spawnGroups;
    qword targetVolume;

public:
    PackMapEnvDataSpawnGroupsV26();
    PackMapEnvDataSpawnGroupsV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSpawnGroupsV26(const PackMapEnvDataSpawnGroupsV26 &p_other);
    PackMapEnvDataSpawnGroupsV26 &operator=(const PackMapEnvDataSpawnGroupsV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV55 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV55();
    PackMapEnvDataWaterV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV55(const PackMapEnvDataWaterV55 &p_other);
    PackMapEnvDataWaterV55 &operator=(const PackMapEnvDataWaterV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV55 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV55();
    PackMapEnvDataWindV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV55(const PackMapEnvDataWindV55 &p_other);
    PackMapEnvDataWindV55 &operator=(const PackMapEnvDataWindV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV55 {
    helpers::Array<PackMapEnvDataLightingV55> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV26> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV55> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV26> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV55> effect;
    helpers::Ptr<PackMapEnvDataHazeV55> haze;
    helpers::Ptr<PackMapEnvDataPFieldV55> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV26> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV55> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV55> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV26> spawns;
    helpers::Ptr<PackMapEnvDataWaterV55> water;
    helpers::Ptr<PackMapEnvDataWindV55> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV55();
    PackMapEnvDataLocalV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV55(const PackMapEnvDataLocalV55 &p_other);
    PackMapEnvDataLocalV55 &operator=(const PackMapEnvDataLocalV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV55 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV55();
    PackMapEnvDataSkyModeTexV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV55(const PackMapEnvDataSkyModeTexV55 &p_other);
    PackMapEnvDataSkyModeTexV55 &operator=(const PackMapEnvDataSkyModeTexV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV55 {
    helpers::Array<PackMapEnvDataLightingV55> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV26> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV55> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV26> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV55> effect;
    helpers::Ptr<PackMapEnvDataHazeV55> haze;
    helpers::Ptr<PackMapEnvDataPFieldV55> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV26> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV55> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV55> skyCards;
    helpers::Ptr<PackMapEnvDataSpawnGroupsV26> spawns;
    helpers::Ptr<PackMapEnvDataWaterV55> water;
    helpers::Ptr<PackMapEnvDataWindV55> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV55> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV55();
    PackMapEnvDataGlobalV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV55(const PackMapEnvDataGlobalV55 &p_other);
    PackMapEnvDataGlobalV55 &operator=(const PackMapEnvDataGlobalV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV55 {
    helpers::Array<PackMapEnvDataLocalV55> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV55> dataGlobal;

public:
    PackMapEnvironmentV55();
    PackMapEnvironmentV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV55(const PackMapEnvironmentV55 &p_other);
    PackMapEnvironmentV55 &operator=(const PackMapEnvironmentV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV55 Gw2Struct;
};

/* Version: 54, ReferencedFunction: 0x4104EC5000000001 */

template <>
struct Gw2Structenv<54>{
struct PackMapEnvDataLightV54 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV54();
    PackMapEnvDataLightV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV54(const PackMapEnvDataLightV54 &p_other);
    PackMapEnvDataLightV54 &operator=(const PackMapEnvDataLightV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV54 {
    helpers::Ptr<PackMapEnvDataLightV54> lights;

public:
    PackMapEnvDataLightingV54();
    PackMapEnvDataLightingV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV54(const PackMapEnvDataLightingV54 &p_other);
    PackMapEnvDataLightingV54 &operator=(const PackMapEnvDataLightingV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV25 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV25();
    PackMapEnvDataLightingCharV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV25(const PackMapEnvDataLightingCharV25 &p_other);
    PackMapEnvDataLightingCharV25 &operator=(const PackMapEnvDataLightingCharV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV25 {
    helpers::Array<PackMapEnvDataLightingCharV25> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV25();
    PackMapEnvDataLightingCharGroupV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV25(const PackMapEnvDataLightingCharGroupV25 &p_other);
    PackMapEnvDataLightingCharGroupV25 &operator=(const PackMapEnvDataLightingCharGroupV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV54 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV54();
    PackMapEnvDataLayerAttributesV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV54(const PackMapEnvDataLayerAttributesV54 &p_other);
    PackMapEnvDataLayerAttributesV54 &operator=(const PackMapEnvDataLayerAttributesV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV54 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV54> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV54();
    PackMapEnvDataLayerV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV54(const PackMapEnvDataLayerV54 &p_other);
    PackMapEnvDataLayerV54 &operator=(const PackMapEnvDataLayerV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV54 {
    helpers::Array<PackMapEnvDataLayerV54> layers;

public:
    PackMapEnvDataCloudsV54();
    PackMapEnvDataCloudsV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV54(const PackMapEnvDataCloudsV54 &p_other);
    PackMapEnvDataCloudsV54 &operator=(const PackMapEnvDataCloudsV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV25 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV25();
    PackMapEnvDataColoredLightRingsV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV25(const PackMapEnvDataColoredLightRingsV25 &p_other);
    PackMapEnvDataColoredLightRingsV25 &operator=(const PackMapEnvDataColoredLightRingsV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV54 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV54();
    PackMapEnvDataEffectV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV54(const PackMapEnvDataEffectV54 &p_other);
    PackMapEnvDataEffectV54 &operator=(const PackMapEnvDataEffectV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV54 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV54();
    PackMapEnvDataHazeV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV54(const PackMapEnvDataHazeV54 &p_other);
    PackMapEnvDataHazeV54 &operator=(const PackMapEnvDataHazeV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV54 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV54();
    PackMapEnvDataPFieldV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV54(const PackMapEnvDataPFieldV54 &p_other);
    PackMapEnvDataPFieldV54 &operator=(const PackMapEnvDataPFieldV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV25 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV25();
    PackMapEnvDataPFieldCutoutV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV25(const PackMapEnvDataPFieldCutoutV25 &p_other);
    PackMapEnvDataPFieldCutoutV25 &operator=(const PackMapEnvDataPFieldCutoutV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV54 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV54();
    PackMapEnvDataSkyV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV54(const PackMapEnvDataSkyV54 &p_other);
    PackMapEnvDataSkyV54 &operator=(const PackMapEnvDataSkyV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV54 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV54();
    PackMapEnvDataSkyCardAttributesV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV54(const PackMapEnvDataSkyCardAttributesV54 &p_other);
    PackMapEnvDataSkyCardAttributesV54 &operator=(const PackMapEnvDataSkyCardAttributesV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV54 {
    PackMapEnvDataSkyCardAttributesV54 day;
    PackMapEnvDataSkyCardAttributesV54 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV54();
    PackMapEnvDataSkyCardV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV54(const PackMapEnvDataSkyCardV54 &p_other);
    PackMapEnvDataSkyCardV54 &operator=(const PackMapEnvDataSkyCardV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV54 {
    helpers::Array<PackMapEnvDataSkyCardV54> cards;

public:
    PackMapEnvDataSkyCardsV54();
    PackMapEnvDataSkyCardsV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV54(const PackMapEnvDataSkyCardsV54 &p_other);
    PackMapEnvDataSkyCardsV54 &operator=(const PackMapEnvDataSkyCardsV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV54 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV54();
    PackMapEnvDataWaterV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV54(const PackMapEnvDataWaterV54 &p_other);
    PackMapEnvDataWaterV54 &operator=(const PackMapEnvDataWaterV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV54 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV54();
    PackMapEnvDataWindV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV54(const PackMapEnvDataWindV54 &p_other);
    PackMapEnvDataWindV54 &operator=(const PackMapEnvDataWindV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV54 {
    helpers::Array<PackMapEnvDataLightingV54> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV25> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV54> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV25> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV54> effect;
    helpers::Ptr<PackMapEnvDataHazeV54> haze;
    helpers::Ptr<PackMapEnvDataPFieldV54> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV25> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV54> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV54> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV54> water;
    helpers::Ptr<PackMapEnvDataWindV54> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV54();
    PackMapEnvDataLocalV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV54(const PackMapEnvDataLocalV54 &p_other);
    PackMapEnvDataLocalV54 &operator=(const PackMapEnvDataLocalV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV54 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV54();
    PackMapEnvDataSkyModeTexV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV54(const PackMapEnvDataSkyModeTexV54 &p_other);
    PackMapEnvDataSkyModeTexV54 &operator=(const PackMapEnvDataSkyModeTexV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV54 {
    helpers::Array<PackMapEnvDataLightingV54> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV25> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV54> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV25> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV54> effect;
    helpers::Ptr<PackMapEnvDataHazeV54> haze;
    helpers::Ptr<PackMapEnvDataPFieldV54> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV25> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV54> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV54> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV54> water;
    helpers::Ptr<PackMapEnvDataWindV54> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV54> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV54();
    PackMapEnvDataGlobalV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV54(const PackMapEnvDataGlobalV54 &p_other);
    PackMapEnvDataGlobalV54 &operator=(const PackMapEnvDataGlobalV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV54 {
    helpers::Array<PackMapEnvDataLocalV54> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV54> dataGlobal;

public:
    PackMapEnvironmentV54();
    PackMapEnvironmentV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV54(const PackMapEnvironmentV54 &p_other);
    PackMapEnvironmentV54 &operator=(const PackMapEnvironmentV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV54 Gw2Struct;
};

/* Version: 53, ReferencedFunction: 0x4104EB8000000001 */

template <>
struct Gw2Structenv<53>{
struct PackMapEnvDataLightV53 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV53();
    PackMapEnvDataLightV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV53(const PackMapEnvDataLightV53 &p_other);
    PackMapEnvDataLightV53 &operator=(const PackMapEnvDataLightV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV53 {
    helpers::Ptr<PackMapEnvDataLightV53> lights;

public:
    PackMapEnvDataLightingV53();
    PackMapEnvDataLightingV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV53(const PackMapEnvDataLightingV53 &p_other);
    PackMapEnvDataLightingV53 &operator=(const PackMapEnvDataLightingV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV24 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV24();
    PackMapEnvDataLightingCharV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV24(const PackMapEnvDataLightingCharV24 &p_other);
    PackMapEnvDataLightingCharV24 &operator=(const PackMapEnvDataLightingCharV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV24 {
    helpers::Array<PackMapEnvDataLightingCharV24> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV24();
    PackMapEnvDataLightingCharGroupV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV24(const PackMapEnvDataLightingCharGroupV24 &p_other);
    PackMapEnvDataLightingCharGroupV24 &operator=(const PackMapEnvDataLightingCharGroupV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV53 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV53();
    PackMapEnvDataLayerAttributesV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV53(const PackMapEnvDataLayerAttributesV53 &p_other);
    PackMapEnvDataLayerAttributesV53 &operator=(const PackMapEnvDataLayerAttributesV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV53 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV53> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV53();
    PackMapEnvDataLayerV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV53(const PackMapEnvDataLayerV53 &p_other);
    PackMapEnvDataLayerV53 &operator=(const PackMapEnvDataLayerV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV53 {
    helpers::Array<PackMapEnvDataLayerV53> layers;

public:
    PackMapEnvDataCloudsV53();
    PackMapEnvDataCloudsV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV53(const PackMapEnvDataCloudsV53 &p_other);
    PackMapEnvDataCloudsV53 &operator=(const PackMapEnvDataCloudsV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV24 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV24();
    PackMapEnvDataColoredLightRingsV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV24(const PackMapEnvDataColoredLightRingsV24 &p_other);
    PackMapEnvDataColoredLightRingsV24 &operator=(const PackMapEnvDataColoredLightRingsV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV53 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV53();
    PackMapEnvDataEffectV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV53(const PackMapEnvDataEffectV53 &p_other);
    PackMapEnvDataEffectV53 &operator=(const PackMapEnvDataEffectV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV53 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV53();
    PackMapEnvDataHazeV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV53(const PackMapEnvDataHazeV53 &p_other);
    PackMapEnvDataHazeV53 &operator=(const PackMapEnvDataHazeV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV53 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    float2 deviationSpeed;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV53();
    PackMapEnvDataPFieldV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV53(const PackMapEnvDataPFieldV53 &p_other);
    PackMapEnvDataPFieldV53 &operator=(const PackMapEnvDataPFieldV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV24 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV24();
    PackMapEnvDataPFieldCutoutV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV24(const PackMapEnvDataPFieldCutoutV24 &p_other);
    PackMapEnvDataPFieldCutoutV24 &operator=(const PackMapEnvDataPFieldCutoutV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV53 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV53();
    PackMapEnvDataSkyV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV53(const PackMapEnvDataSkyV53 &p_other);
    PackMapEnvDataSkyV53 &operator=(const PackMapEnvDataSkyV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV53 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV53();
    PackMapEnvDataSkyCardAttributesV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV53(const PackMapEnvDataSkyCardAttributesV53 &p_other);
    PackMapEnvDataSkyCardAttributesV53 &operator=(const PackMapEnvDataSkyCardAttributesV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV53 {
    PackMapEnvDataSkyCardAttributesV53 day;
    PackMapEnvDataSkyCardAttributesV53 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV53();
    PackMapEnvDataSkyCardV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV53(const PackMapEnvDataSkyCardV53 &p_other);
    PackMapEnvDataSkyCardV53 &operator=(const PackMapEnvDataSkyCardV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV53 {
    helpers::Array<PackMapEnvDataSkyCardV53> cards;

public:
    PackMapEnvDataSkyCardsV53();
    PackMapEnvDataSkyCardsV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV53(const PackMapEnvDataSkyCardsV53 &p_other);
    PackMapEnvDataSkyCardsV53 &operator=(const PackMapEnvDataSkyCardsV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV53 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV53();
    PackMapEnvDataWaterV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV53(const PackMapEnvDataWaterV53 &p_other);
    PackMapEnvDataWaterV53 &operator=(const PackMapEnvDataWaterV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV53 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV53();
    PackMapEnvDataWindV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV53(const PackMapEnvDataWindV53 &p_other);
    PackMapEnvDataWindV53 &operator=(const PackMapEnvDataWindV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV53 {
    helpers::Array<PackMapEnvDataLightingV53> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV24> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV53> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV24> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV53> effect;
    helpers::Ptr<PackMapEnvDataHazeV53> haze;
    helpers::Ptr<PackMapEnvDataPFieldV53> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV24> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV53> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV53> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV53> water;
    helpers::Ptr<PackMapEnvDataWindV53> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV53();
    PackMapEnvDataLocalV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV53(const PackMapEnvDataLocalV53 &p_other);
    PackMapEnvDataLocalV53 &operator=(const PackMapEnvDataLocalV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV53 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV53();
    PackMapEnvDataSkyModeTexV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV53(const PackMapEnvDataSkyModeTexV53 &p_other);
    PackMapEnvDataSkyModeTexV53 &operator=(const PackMapEnvDataSkyModeTexV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV53 {
    helpers::Array<PackMapEnvDataLightingV53> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV24> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV53> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV24> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV53> effect;
    helpers::Ptr<PackMapEnvDataHazeV53> haze;
    helpers::Ptr<PackMapEnvDataPFieldV53> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV24> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV53> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV53> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV53> water;
    helpers::Ptr<PackMapEnvDataWindV53> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV53> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV53();
    PackMapEnvDataGlobalV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV53(const PackMapEnvDataGlobalV53 &p_other);
    PackMapEnvDataGlobalV53 &operator=(const PackMapEnvDataGlobalV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV53 {
    helpers::Array<PackMapEnvDataLocalV53> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV53> dataGlobal;

public:
    PackMapEnvironmentV53();
    PackMapEnvironmentV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV53(const PackMapEnvironmentV53 &p_other);
    PackMapEnvironmentV53 &operator=(const PackMapEnvironmentV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV53 Gw2Struct;
};

/* Version: 52, ReferencedFunction: 0x4104EA8000000001 */

template <>
struct Gw2Structenv<52>{
struct PackMapEnvDataLightV52 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV52();
    PackMapEnvDataLightV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV52(const PackMapEnvDataLightV52 &p_other);
    PackMapEnvDataLightV52 &operator=(const PackMapEnvDataLightV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV52 {
    helpers::Ptr<PackMapEnvDataLightV52> lights;

public:
    PackMapEnvDataLightingV52();
    PackMapEnvDataLightingV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV52(const PackMapEnvDataLightingV52 &p_other);
    PackMapEnvDataLightingV52 &operator=(const PackMapEnvDataLightingV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV23 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV23();
    PackMapEnvDataLightingCharV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV23(const PackMapEnvDataLightingCharV23 &p_other);
    PackMapEnvDataLightingCharV23 &operator=(const PackMapEnvDataLightingCharV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV23 {
    helpers::Array<PackMapEnvDataLightingCharV23> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV23();
    PackMapEnvDataLightingCharGroupV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV23(const PackMapEnvDataLightingCharGroupV23 &p_other);
    PackMapEnvDataLightingCharGroupV23 &operator=(const PackMapEnvDataLightingCharGroupV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV52 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV52();
    PackMapEnvDataLayerAttributesV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV52(const PackMapEnvDataLayerAttributesV52 &p_other);
    PackMapEnvDataLayerAttributesV52 &operator=(const PackMapEnvDataLayerAttributesV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV52 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV52> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV52();
    PackMapEnvDataLayerV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV52(const PackMapEnvDataLayerV52 &p_other);
    PackMapEnvDataLayerV52 &operator=(const PackMapEnvDataLayerV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV52 {
    helpers::Array<PackMapEnvDataLayerV52> layers;

public:
    PackMapEnvDataCloudsV52();
    PackMapEnvDataCloudsV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV52(const PackMapEnvDataCloudsV52 &p_other);
    PackMapEnvDataCloudsV52 &operator=(const PackMapEnvDataCloudsV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV23 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV23();
    PackMapEnvDataColoredLightRingsV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV23(const PackMapEnvDataColoredLightRingsV23 &p_other);
    PackMapEnvDataColoredLightRingsV23 &operator=(const PackMapEnvDataColoredLightRingsV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV52 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV52();
    PackMapEnvDataEffectV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV52(const PackMapEnvDataEffectV52 &p_other);
    PackMapEnvDataEffectV52 &operator=(const PackMapEnvDataEffectV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV52 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV52();
    PackMapEnvDataHazeV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV52(const PackMapEnvDataHazeV52 &p_other);
    PackMapEnvDataHazeV52 &operator=(const PackMapEnvDataHazeV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV52 {
    float altitude;
    float2 angle;
    word clusterCount;
    float2 clustering;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    word flags;
    float2 lifetime;
    float2 opacity;
    word particleCount;
    float2 period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    dword seed;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV52();
    PackMapEnvDataPFieldV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV52(const PackMapEnvDataPFieldV52 &p_other);
    PackMapEnvDataPFieldV52 &operator=(const PackMapEnvDataPFieldV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV23 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV23();
    PackMapEnvDataPFieldCutoutV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV23(const PackMapEnvDataPFieldCutoutV23 &p_other);
    PackMapEnvDataPFieldCutoutV23 &operator=(const PackMapEnvDataPFieldCutoutV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV52 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV52();
    PackMapEnvDataSkyV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV52(const PackMapEnvDataSkyV52 &p_other);
    PackMapEnvDataSkyV52 &operator=(const PackMapEnvDataSkyV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV52 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV52();
    PackMapEnvDataSkyCardAttributesV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV52(const PackMapEnvDataSkyCardAttributesV52 &p_other);
    PackMapEnvDataSkyCardAttributesV52 &operator=(const PackMapEnvDataSkyCardAttributesV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV52 {
    PackMapEnvDataSkyCardAttributesV52 day;
    PackMapEnvDataSkyCardAttributesV52 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV52();
    PackMapEnvDataSkyCardV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV52(const PackMapEnvDataSkyCardV52 &p_other);
    PackMapEnvDataSkyCardV52 &operator=(const PackMapEnvDataSkyCardV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV52 {
    helpers::Array<PackMapEnvDataSkyCardV52> cards;

public:
    PackMapEnvDataSkyCardsV52();
    PackMapEnvDataSkyCardsV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV52(const PackMapEnvDataSkyCardsV52 &p_other);
    PackMapEnvDataSkyCardsV52 &operator=(const PackMapEnvDataSkyCardsV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV52 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV52();
    PackMapEnvDataWaterV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV52(const PackMapEnvDataWaterV52 &p_other);
    PackMapEnvDataWaterV52 &operator=(const PackMapEnvDataWaterV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV52 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV52();
    PackMapEnvDataWindV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV52(const PackMapEnvDataWindV52 &p_other);
    PackMapEnvDataWindV52 &operator=(const PackMapEnvDataWindV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV52 {
    helpers::Array<PackMapEnvDataLightingV52> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV23> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV52> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV23> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV52> effect;
    helpers::Ptr<PackMapEnvDataHazeV52> haze;
    helpers::Ptr<PackMapEnvDataPFieldV52> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV23> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV52> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV52> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV52> water;
    helpers::Ptr<PackMapEnvDataWindV52> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV52();
    PackMapEnvDataLocalV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV52(const PackMapEnvDataLocalV52 &p_other);
    PackMapEnvDataLocalV52 &operator=(const PackMapEnvDataLocalV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV52 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV52();
    PackMapEnvDataSkyModeTexV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV52(const PackMapEnvDataSkyModeTexV52 &p_other);
    PackMapEnvDataSkyModeTexV52 &operator=(const PackMapEnvDataSkyModeTexV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV52 {
    helpers::Array<PackMapEnvDataLightingV52> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV23> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV52> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV23> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV52> effect;
    helpers::Ptr<PackMapEnvDataHazeV52> haze;
    helpers::Ptr<PackMapEnvDataPFieldV52> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV23> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV52> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV52> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV52> water;
    helpers::Ptr<PackMapEnvDataWindV52> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV52> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV52();
    PackMapEnvDataGlobalV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV52(const PackMapEnvDataGlobalV52 &p_other);
    PackMapEnvDataGlobalV52 &operator=(const PackMapEnvDataGlobalV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV52 {
    helpers::Array<PackMapEnvDataLocalV52> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV52> dataGlobal;

public:
    PackMapEnvironmentV52();
    PackMapEnvironmentV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV52(const PackMapEnvironmentV52 &p_other);
    PackMapEnvironmentV52 &operator=(const PackMapEnvironmentV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV52 Gw2Struct;
};

/* Version: 51, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<51>{
struct PackMapEnvDataLightV51 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV51();
    PackMapEnvDataLightV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV51(const PackMapEnvDataLightV51 &p_other);
    PackMapEnvDataLightV51 &operator=(const PackMapEnvDataLightV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV51 {
    helpers::Ptr<PackMapEnvDataLightV51> lights;

public:
    PackMapEnvDataLightingV51();
    PackMapEnvDataLightingV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV51(const PackMapEnvDataLightingV51 &p_other);
    PackMapEnvDataLightingV51 &operator=(const PackMapEnvDataLightingV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV22 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV22();
    PackMapEnvDataLightingCharV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV22(const PackMapEnvDataLightingCharV22 &p_other);
    PackMapEnvDataLightingCharV22 &operator=(const PackMapEnvDataLightingCharV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV22 {
    helpers::Array<PackMapEnvDataLightingCharV22> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV22();
    PackMapEnvDataLightingCharGroupV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV22(const PackMapEnvDataLightingCharGroupV22 &p_other);
    PackMapEnvDataLightingCharGroupV22 &operator=(const PackMapEnvDataLightingCharGroupV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV51 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV51();
    PackMapEnvDataLayerAttributesV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV51(const PackMapEnvDataLayerAttributesV51 &p_other);
    PackMapEnvDataLayerAttributesV51 &operator=(const PackMapEnvDataLayerAttributesV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV51 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV51> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV51();
    PackMapEnvDataLayerV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV51(const PackMapEnvDataLayerV51 &p_other);
    PackMapEnvDataLayerV51 &operator=(const PackMapEnvDataLayerV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV51 {
    helpers::Array<PackMapEnvDataLayerV51> layers;

public:
    PackMapEnvDataCloudsV51();
    PackMapEnvDataCloudsV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV51(const PackMapEnvDataCloudsV51 &p_other);
    PackMapEnvDataCloudsV51 &operator=(const PackMapEnvDataCloudsV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV22 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV22();
    PackMapEnvDataColoredLightRingsV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV22(const PackMapEnvDataColoredLightRingsV22 &p_other);
    PackMapEnvDataColoredLightRingsV22 &operator=(const PackMapEnvDataColoredLightRingsV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV51 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV51();
    PackMapEnvDataEffectV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV51(const PackMapEnvDataEffectV51 &p_other);
    PackMapEnvDataEffectV51 &operator=(const PackMapEnvDataEffectV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV51 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV51();
    PackMapEnvDataHazeV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV51(const PackMapEnvDataHazeV51 &p_other);
    PackMapEnvDataHazeV51 &operator=(const PackMapEnvDataHazeV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV51 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float lifetime;
    float2 opacity;
    word particleCount;
    float period;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV51();
    PackMapEnvDataPFieldV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV51(const PackMapEnvDataPFieldV51 &p_other);
    PackMapEnvDataPFieldV51 &operator=(const PackMapEnvDataPFieldV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV22 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV22();
    PackMapEnvDataPFieldCutoutV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV22(const PackMapEnvDataPFieldCutoutV22 &p_other);
    PackMapEnvDataPFieldCutoutV22 &operator=(const PackMapEnvDataPFieldCutoutV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV51 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV51();
    PackMapEnvDataSkyV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV51(const PackMapEnvDataSkyV51 &p_other);
    PackMapEnvDataSkyV51 &operator=(const PackMapEnvDataSkyV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV51 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV51();
    PackMapEnvDataSkyCardAttributesV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV51(const PackMapEnvDataSkyCardAttributesV51 &p_other);
    PackMapEnvDataSkyCardAttributesV51 &operator=(const PackMapEnvDataSkyCardAttributesV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV51 {
    PackMapEnvDataSkyCardAttributesV51 day;
    PackMapEnvDataSkyCardAttributesV51 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV51();
    PackMapEnvDataSkyCardV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV51(const PackMapEnvDataSkyCardV51 &p_other);
    PackMapEnvDataSkyCardV51 &operator=(const PackMapEnvDataSkyCardV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV51 {
    helpers::Array<PackMapEnvDataSkyCardV51> cards;

public:
    PackMapEnvDataSkyCardsV51();
    PackMapEnvDataSkyCardsV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV51(const PackMapEnvDataSkyCardsV51 &p_other);
    PackMapEnvDataSkyCardsV51 &operator=(const PackMapEnvDataSkyCardsV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV51 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV51();
    PackMapEnvDataWaterV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV51(const PackMapEnvDataWaterV51 &p_other);
    PackMapEnvDataWaterV51 &operator=(const PackMapEnvDataWaterV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV51 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV51();
    PackMapEnvDataWindV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV51(const PackMapEnvDataWindV51 &p_other);
    PackMapEnvDataWindV51 &operator=(const PackMapEnvDataWindV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV51 {
    helpers::Array<PackMapEnvDataLightingV51> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV22> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV51> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV22> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV51> effect;
    helpers::Ptr<PackMapEnvDataHazeV51> haze;
    helpers::Ptr<PackMapEnvDataPFieldV51> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV22> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV51> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV51> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV51> water;
    helpers::Ptr<PackMapEnvDataWindV51> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV51();
    PackMapEnvDataLocalV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV51(const PackMapEnvDataLocalV51 &p_other);
    PackMapEnvDataLocalV51 &operator=(const PackMapEnvDataLocalV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV51 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV51();
    PackMapEnvDataSkyModeTexV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV51(const PackMapEnvDataSkyModeTexV51 &p_other);
    PackMapEnvDataSkyModeTexV51 &operator=(const PackMapEnvDataSkyModeTexV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV51 {
    helpers::Array<PackMapEnvDataLightingV51> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV22> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV51> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV22> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV51> effect;
    helpers::Ptr<PackMapEnvDataHazeV51> haze;
    helpers::Ptr<PackMapEnvDataPFieldV51> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV22> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV51> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV51> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV51> water;
    helpers::Ptr<PackMapEnvDataWindV51> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV51> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV51();
    PackMapEnvDataGlobalV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV51(const PackMapEnvDataGlobalV51 &p_other);
    PackMapEnvDataGlobalV51 &operator=(const PackMapEnvDataGlobalV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV51 {
    helpers::Array<PackMapEnvDataLocalV51> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV51> dataGlobal;

public:
    PackMapEnvironmentV51();
    PackMapEnvironmentV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV51(const PackMapEnvironmentV51 &p_other);
    PackMapEnvironmentV51 &operator=(const PackMapEnvironmentV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV51 Gw2Struct;
};

/* Version: 50, ReferencedFunction: 0x4104E90000000001 */

template <>
struct Gw2Structenv<50>{
struct PackMapEnvDataLightV50 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV50();
    PackMapEnvDataLightV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV50(const PackMapEnvDataLightV50 &p_other);
    PackMapEnvDataLightV50 &operator=(const PackMapEnvDataLightV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV50 {
    helpers::Ptr<PackMapEnvDataLightV50> lights;

public:
    PackMapEnvDataLightingV50();
    PackMapEnvDataLightingV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV50(const PackMapEnvDataLightingV50 &p_other);
    PackMapEnvDataLightingV50 &operator=(const PackMapEnvDataLightingV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV21 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV21();
    PackMapEnvDataLightingCharV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV21(const PackMapEnvDataLightingCharV21 &p_other);
    PackMapEnvDataLightingCharV21 &operator=(const PackMapEnvDataLightingCharV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV21 {
    helpers::Array<PackMapEnvDataLightingCharV21> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV21();
    PackMapEnvDataLightingCharGroupV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV21(const PackMapEnvDataLightingCharGroupV21 &p_other);
    PackMapEnvDataLightingCharGroupV21 &operator=(const PackMapEnvDataLightingCharGroupV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV50 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV50();
    PackMapEnvDataLayerAttributesV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV50(const PackMapEnvDataLayerAttributesV50 &p_other);
    PackMapEnvDataLayerAttributesV50 &operator=(const PackMapEnvDataLayerAttributesV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV50 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV50> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV50();
    PackMapEnvDataLayerV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV50(const PackMapEnvDataLayerV50 &p_other);
    PackMapEnvDataLayerV50 &operator=(const PackMapEnvDataLayerV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV50 {
    helpers::Array<PackMapEnvDataLayerV50> layers;

public:
    PackMapEnvDataCloudsV50();
    PackMapEnvDataCloudsV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV50(const PackMapEnvDataCloudsV50 &p_other);
    PackMapEnvDataCloudsV50 &operator=(const PackMapEnvDataCloudsV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV21 {
    float2 range;
    float distances[6];
    byte4 lightColors[6];
    byte4 shadowColors[6];

public:
    PackMapEnvDataColoredLightRingsV21();
    PackMapEnvDataColoredLightRingsV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV21(const PackMapEnvDataColoredLightRingsV21 &p_other);
    PackMapEnvDataColoredLightRingsV21 &operator=(const PackMapEnvDataColoredLightRingsV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV50 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV50();
    PackMapEnvDataEffectV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV50(const PackMapEnvDataEffectV50 &p_other);
    PackMapEnvDataEffectV50 &operator=(const PackMapEnvDataEffectV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV50 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV50();
    PackMapEnvDataHazeV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV50(const PackMapEnvDataHazeV50 &p_other);
    PackMapEnvDataHazeV50 &operator=(const PackMapEnvDataHazeV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV50 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV50();
    PackMapEnvDataPFieldV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV50(const PackMapEnvDataPFieldV50 &p_other);
    PackMapEnvDataPFieldV50 &operator=(const PackMapEnvDataPFieldV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV21 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV21();
    PackMapEnvDataPFieldCutoutV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV21(const PackMapEnvDataPFieldCutoutV21 &p_other);
    PackMapEnvDataPFieldCutoutV21 &operator=(const PackMapEnvDataPFieldCutoutV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV50 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV50();
    PackMapEnvDataSkyV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV50(const PackMapEnvDataSkyV50 &p_other);
    PackMapEnvDataSkyV50 &operator=(const PackMapEnvDataSkyV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV50 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV50();
    PackMapEnvDataSkyCardAttributesV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV50(const PackMapEnvDataSkyCardAttributesV50 &p_other);
    PackMapEnvDataSkyCardAttributesV50 &operator=(const PackMapEnvDataSkyCardAttributesV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV50 {
    PackMapEnvDataSkyCardAttributesV50 day;
    PackMapEnvDataSkyCardAttributesV50 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV50();
    PackMapEnvDataSkyCardV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV50(const PackMapEnvDataSkyCardV50 &p_other);
    PackMapEnvDataSkyCardV50 &operator=(const PackMapEnvDataSkyCardV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV50 {
    helpers::Array<PackMapEnvDataSkyCardV50> cards;

public:
    PackMapEnvDataSkyCardsV50();
    PackMapEnvDataSkyCardsV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV50(const PackMapEnvDataSkyCardsV50 &p_other);
    PackMapEnvDataSkyCardsV50 &operator=(const PackMapEnvDataSkyCardsV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV50 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV50();
    PackMapEnvDataWaterV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV50(const PackMapEnvDataWaterV50 &p_other);
    PackMapEnvDataWaterV50 &operator=(const PackMapEnvDataWaterV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV50 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV50();
    PackMapEnvDataWindV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV50(const PackMapEnvDataWindV50 &p_other);
    PackMapEnvDataWindV50 &operator=(const PackMapEnvDataWindV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV50 {
    helpers::Array<PackMapEnvDataLightingV50> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV21> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV50> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV21> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV50> effect;
    helpers::Ptr<PackMapEnvDataHazeV50> haze;
    helpers::Ptr<PackMapEnvDataPFieldV50> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV21> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV50> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV50> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV50> water;
    helpers::Ptr<PackMapEnvDataWindV50> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV50();
    PackMapEnvDataLocalV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV50(const PackMapEnvDataLocalV50 &p_other);
    PackMapEnvDataLocalV50 &operator=(const PackMapEnvDataLocalV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV50 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV50();
    PackMapEnvDataSkyModeTexV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV50(const PackMapEnvDataSkyModeTexV50 &p_other);
    PackMapEnvDataSkyModeTexV50 &operator=(const PackMapEnvDataSkyModeTexV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV50 {
    helpers::Array<PackMapEnvDataLightingV50> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV21> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV50> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV21> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV50> effect;
    helpers::Ptr<PackMapEnvDataHazeV50> haze;
    helpers::Ptr<PackMapEnvDataPFieldV50> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV21> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV50> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV50> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV50> water;
    helpers::Ptr<PackMapEnvDataWindV50> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV50> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV50();
    PackMapEnvDataGlobalV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV50(const PackMapEnvDataGlobalV50 &p_other);
    PackMapEnvDataGlobalV50 &operator=(const PackMapEnvDataGlobalV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV50 {
    helpers::Array<PackMapEnvDataLocalV50> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV50> dataGlobal;

public:
    PackMapEnvironmentV50();
    PackMapEnvironmentV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV50(const PackMapEnvironmentV50 &p_other);
    PackMapEnvironmentV50 &operator=(const PackMapEnvironmentV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV50 Gw2Struct;
};

/* Version: 49, ReferencedFunction: 0x4104E77000000001 */

template <>
struct Gw2Structenv<49>{
struct PackMapEnvDataLightV49 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV49();
    PackMapEnvDataLightV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV49(const PackMapEnvDataLightV49 &p_other);
    PackMapEnvDataLightV49 &operator=(const PackMapEnvDataLightV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV49 {
    helpers::Ptr<PackMapEnvDataLightV49> lights;

public:
    PackMapEnvDataLightingV49();
    PackMapEnvDataLightingV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV49(const PackMapEnvDataLightingV49 &p_other);
    PackMapEnvDataLightingV49 &operator=(const PackMapEnvDataLightingV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV20 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV20();
    PackMapEnvDataLightingCharV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV20(const PackMapEnvDataLightingCharV20 &p_other);
    PackMapEnvDataLightingCharV20 &operator=(const PackMapEnvDataLightingCharV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharGroupV20 {
    helpers::Array<PackMapEnvDataLightingCharV20> lightingChar;

public:
    PackMapEnvDataLightingCharGroupV20();
    PackMapEnvDataLightingCharGroupV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharGroupV20(const PackMapEnvDataLightingCharGroupV20 &p_other);
    PackMapEnvDataLightingCharGroupV20 &operator=(const PackMapEnvDataLightingCharGroupV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV49 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV49();
    PackMapEnvDataLayerAttributesV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV49(const PackMapEnvDataLayerAttributesV49 &p_other);
    PackMapEnvDataLayerAttributesV49 &operator=(const PackMapEnvDataLayerAttributesV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV49 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV49> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV49();
    PackMapEnvDataLayerV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV49(const PackMapEnvDataLayerV49 &p_other);
    PackMapEnvDataLayerV49 &operator=(const PackMapEnvDataLayerV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV49 {
    helpers::Array<PackMapEnvDataLayerV49> layers;

public:
    PackMapEnvDataCloudsV49();
    PackMapEnvDataCloudsV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV49(const PackMapEnvDataCloudsV49 &p_other);
    PackMapEnvDataCloudsV49 &operator=(const PackMapEnvDataCloudsV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV20 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV20();
    PackMapEnvDataColoredLightRingsV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV20(const PackMapEnvDataColoredLightRingsV20 &p_other);
    PackMapEnvDataColoredLightRingsV20 &operator=(const PackMapEnvDataColoredLightRingsV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV49 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV49();
    PackMapEnvDataEffectV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV49(const PackMapEnvDataEffectV49 &p_other);
    PackMapEnvDataEffectV49 &operator=(const PackMapEnvDataEffectV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV49 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV49();
    PackMapEnvDataHazeV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV49(const PackMapEnvDataHazeV49 &p_other);
    PackMapEnvDataHazeV49 &operator=(const PackMapEnvDataHazeV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV49 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV49();
    PackMapEnvDataPFieldV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV49(const PackMapEnvDataPFieldV49 &p_other);
    PackMapEnvDataPFieldV49 &operator=(const PackMapEnvDataPFieldV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV20 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV20();
    PackMapEnvDataPFieldCutoutV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV20(const PackMapEnvDataPFieldCutoutV20 &p_other);
    PackMapEnvDataPFieldCutoutV20 &operator=(const PackMapEnvDataPFieldCutoutV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV49 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV49();
    PackMapEnvDataSkyV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV49(const PackMapEnvDataSkyV49 &p_other);
    PackMapEnvDataSkyV49 &operator=(const PackMapEnvDataSkyV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV49 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV49();
    PackMapEnvDataSkyCardAttributesV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV49(const PackMapEnvDataSkyCardAttributesV49 &p_other);
    PackMapEnvDataSkyCardAttributesV49 &operator=(const PackMapEnvDataSkyCardAttributesV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV49 {
    PackMapEnvDataSkyCardAttributesV49 day;
    PackMapEnvDataSkyCardAttributesV49 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV49();
    PackMapEnvDataSkyCardV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV49(const PackMapEnvDataSkyCardV49 &p_other);
    PackMapEnvDataSkyCardV49 &operator=(const PackMapEnvDataSkyCardV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV49 {
    helpers::Array<PackMapEnvDataSkyCardV49> cards;

public:
    PackMapEnvDataSkyCardsV49();
    PackMapEnvDataSkyCardsV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV49(const PackMapEnvDataSkyCardsV49 &p_other);
    PackMapEnvDataSkyCardsV49 &operator=(const PackMapEnvDataSkyCardsV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV49 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV49();
    PackMapEnvDataWaterV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV49(const PackMapEnvDataWaterV49 &p_other);
    PackMapEnvDataWaterV49 &operator=(const PackMapEnvDataWaterV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV49 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV49();
    PackMapEnvDataWindV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV49(const PackMapEnvDataWindV49 &p_other);
    PackMapEnvDataWindV49 &operator=(const PackMapEnvDataWindV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV49 {
    helpers::Array<PackMapEnvDataLightingV49> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV20> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV49> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV20> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV49> effect;
    helpers::Ptr<PackMapEnvDataHazeV49> haze;
    helpers::Ptr<PackMapEnvDataPFieldV49> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV20> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV49> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV49> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV49> water;
    helpers::Ptr<PackMapEnvDataWindV49> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV49();
    PackMapEnvDataLocalV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV49(const PackMapEnvDataLocalV49 &p_other);
    PackMapEnvDataLocalV49 &operator=(const PackMapEnvDataLocalV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV49 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV49();
    PackMapEnvDataSkyModeTexV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV49(const PackMapEnvDataSkyModeTexV49 &p_other);
    PackMapEnvDataSkyModeTexV49 &operator=(const PackMapEnvDataSkyModeTexV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV49 {
    helpers::Array<PackMapEnvDataLightingV49> lighting;
    helpers::Array<PackMapEnvDataLightingCharGroupV20> lightingCharGroups;
    helpers::Ptr<PackMapEnvDataCloudsV49> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV20> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV49> effect;
    helpers::Ptr<PackMapEnvDataHazeV49> haze;
    helpers::Ptr<PackMapEnvDataPFieldV49> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV20> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV49> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV49> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV49> water;
    helpers::Ptr<PackMapEnvDataWindV49> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV49> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV49();
    PackMapEnvDataGlobalV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV49(const PackMapEnvDataGlobalV49 &p_other);
    PackMapEnvDataGlobalV49 &operator=(const PackMapEnvDataGlobalV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV49 {
    helpers::Array<PackMapEnvDataLocalV49> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV49> dataGlobal;

public:
    PackMapEnvironmentV49();
    PackMapEnvironmentV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV49(const PackMapEnvironmentV49 &p_other);
    PackMapEnvironmentV49 &operator=(const PackMapEnvironmentV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV49 Gw2Struct;
};

/* Version: 48, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<48>{
struct PackMapEnvDataLightV48 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV48();
    PackMapEnvDataLightV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV48(const PackMapEnvDataLightV48 &p_other);
    PackMapEnvDataLightV48 &operator=(const PackMapEnvDataLightV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV48 {
    helpers::Ptr<PackMapEnvDataLightV48> lights;

public:
    PackMapEnvDataLightingV48();
    PackMapEnvDataLightingV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV48(const PackMapEnvDataLightingV48 &p_other);
    PackMapEnvDataLightingV48 &operator=(const PackMapEnvDataLightingV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV19 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV19();
    PackMapEnvDataLightingCharV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV19(const PackMapEnvDataLightingCharV19 &p_other);
    PackMapEnvDataLightingCharV19 &operator=(const PackMapEnvDataLightingCharV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV48 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV48();
    PackMapEnvDataLayerAttributesV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV48(const PackMapEnvDataLayerAttributesV48 &p_other);
    PackMapEnvDataLayerAttributesV48 &operator=(const PackMapEnvDataLayerAttributesV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV48 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV48> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV48();
    PackMapEnvDataLayerV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV48(const PackMapEnvDataLayerV48 &p_other);
    PackMapEnvDataLayerV48 &operator=(const PackMapEnvDataLayerV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV48 {
    helpers::Array<PackMapEnvDataLayerV48> layers;

public:
    PackMapEnvDataCloudsV48();
    PackMapEnvDataCloudsV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV48(const PackMapEnvDataCloudsV48 &p_other);
    PackMapEnvDataCloudsV48 &operator=(const PackMapEnvDataCloudsV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV19 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV19();
    PackMapEnvDataColoredLightRingsV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV19(const PackMapEnvDataColoredLightRingsV19 &p_other);
    PackMapEnvDataColoredLightRingsV19 &operator=(const PackMapEnvDataColoredLightRingsV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV48 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV48();
    PackMapEnvDataEffectV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV48(const PackMapEnvDataEffectV48 &p_other);
    PackMapEnvDataEffectV48 &operator=(const PackMapEnvDataEffectV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV48 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV48();
    PackMapEnvDataHazeV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV48(const PackMapEnvDataHazeV48 &p_other);
    PackMapEnvDataHazeV48 &operator=(const PackMapEnvDataHazeV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV48 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV48();
    PackMapEnvDataPFieldV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV48(const PackMapEnvDataPFieldV48 &p_other);
    PackMapEnvDataPFieldV48 &operator=(const PackMapEnvDataPFieldV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV19 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV19();
    PackMapEnvDataPFieldCutoutV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV19(const PackMapEnvDataPFieldCutoutV19 &p_other);
    PackMapEnvDataPFieldCutoutV19 &operator=(const PackMapEnvDataPFieldCutoutV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV48 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV48();
    PackMapEnvDataSkyV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV48(const PackMapEnvDataSkyV48 &p_other);
    PackMapEnvDataSkyV48 &operator=(const PackMapEnvDataSkyV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV48 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV48();
    PackMapEnvDataSkyCardAttributesV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV48(const PackMapEnvDataSkyCardAttributesV48 &p_other);
    PackMapEnvDataSkyCardAttributesV48 &operator=(const PackMapEnvDataSkyCardAttributesV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV48 {
    PackMapEnvDataSkyCardAttributesV48 day;
    PackMapEnvDataSkyCardAttributesV48 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV48();
    PackMapEnvDataSkyCardV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV48(const PackMapEnvDataSkyCardV48 &p_other);
    PackMapEnvDataSkyCardV48 &operator=(const PackMapEnvDataSkyCardV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV48 {
    helpers::Array<PackMapEnvDataSkyCardV48> cards;

public:
    PackMapEnvDataSkyCardsV48();
    PackMapEnvDataSkyCardsV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV48(const PackMapEnvDataSkyCardsV48 &p_other);
    PackMapEnvDataSkyCardsV48 &operator=(const PackMapEnvDataSkyCardsV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV48 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV48();
    PackMapEnvDataWaterV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV48(const PackMapEnvDataWaterV48 &p_other);
    PackMapEnvDataWaterV48 &operator=(const PackMapEnvDataWaterV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV48 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV48();
    PackMapEnvDataWindV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV48(const PackMapEnvDataWindV48 &p_other);
    PackMapEnvDataWindV48 &operator=(const PackMapEnvDataWindV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV48 {
    helpers::Array<PackMapEnvDataLightingV48> lighting;
    helpers::Array<PackMapEnvDataLightingCharV19> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV48> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV19> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV48> effect;
    helpers::Ptr<PackMapEnvDataHazeV48> haze;
    helpers::Ptr<PackMapEnvDataPFieldV48> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV19> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV48> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV48> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV48> water;
    helpers::Ptr<PackMapEnvDataWindV48> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV48();
    PackMapEnvDataLocalV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV48(const PackMapEnvDataLocalV48 &p_other);
    PackMapEnvDataLocalV48 &operator=(const PackMapEnvDataLocalV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV48 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV48();
    PackMapEnvDataSkyModeTexV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV48(const PackMapEnvDataSkyModeTexV48 &p_other);
    PackMapEnvDataSkyModeTexV48 &operator=(const PackMapEnvDataSkyModeTexV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV48 {
    helpers::Array<PackMapEnvDataLightingV48> lighting;
    helpers::Array<PackMapEnvDataLightingCharV19> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV48> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV19> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV48> effect;
    helpers::Ptr<PackMapEnvDataHazeV48> haze;
    helpers::Ptr<PackMapEnvDataPFieldV48> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV19> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV48> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV48> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV48> water;
    helpers::Ptr<PackMapEnvDataWindV48> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    qword bindTarget;
    helpers::Array<PackMapEnvDataSkyModeTexV48> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV48();
    PackMapEnvDataGlobalV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV48(const PackMapEnvDataGlobalV48 &p_other);
    PackMapEnvDataGlobalV48 &operator=(const PackMapEnvDataGlobalV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV48 {
    helpers::Array<PackMapEnvDataLocalV48> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV48> dataGlobal;

public:
    PackMapEnvironmentV48();
    PackMapEnvironmentV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV48(const PackMapEnvironmentV48 &p_other);
    PackMapEnvironmentV48 &operator=(const PackMapEnvironmentV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV48 Gw2Struct;
};

/* Version: 47, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<47>{
struct PackMapEnvDataLightV47 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV47();
    PackMapEnvDataLightV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV47(const PackMapEnvDataLightV47 &p_other);
    PackMapEnvDataLightV47 &operator=(const PackMapEnvDataLightV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV47 {
    helpers::Ptr<PackMapEnvDataLightV47> lights;

public:
    PackMapEnvDataLightingV47();
    PackMapEnvDataLightingV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV47(const PackMapEnvDataLightingV47 &p_other);
    PackMapEnvDataLightingV47 &operator=(const PackMapEnvDataLightingV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV18 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV18();
    PackMapEnvDataLightingCharV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV18(const PackMapEnvDataLightingCharV18 &p_other);
    PackMapEnvDataLightingCharV18 &operator=(const PackMapEnvDataLightingCharV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV47 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV47();
    PackMapEnvDataLayerAttributesV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV47(const PackMapEnvDataLayerAttributesV47 &p_other);
    PackMapEnvDataLayerAttributesV47 &operator=(const PackMapEnvDataLayerAttributesV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV47 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV47> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV47();
    PackMapEnvDataLayerV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV47(const PackMapEnvDataLayerV47 &p_other);
    PackMapEnvDataLayerV47 &operator=(const PackMapEnvDataLayerV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV47 {
    helpers::Array<PackMapEnvDataLayerV47> layers;

public:
    PackMapEnvDataCloudsV47();
    PackMapEnvDataCloudsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV47(const PackMapEnvDataCloudsV47 &p_other);
    PackMapEnvDataCloudsV47 &operator=(const PackMapEnvDataCloudsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV18 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV18();
    PackMapEnvDataColoredLightRingsV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV18(const PackMapEnvDataColoredLightRingsV18 &p_other);
    PackMapEnvDataColoredLightRingsV18 &operator=(const PackMapEnvDataColoredLightRingsV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV47 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV47();
    PackMapEnvDataEffectV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV47(const PackMapEnvDataEffectV47 &p_other);
    PackMapEnvDataEffectV47 &operator=(const PackMapEnvDataEffectV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV47 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV47();
    PackMapEnvDataHazeV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV47(const PackMapEnvDataHazeV47 &p_other);
    PackMapEnvDataHazeV47 &operator=(const PackMapEnvDataHazeV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV47 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV47();
    PackMapEnvDataPFieldV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV47(const PackMapEnvDataPFieldV47 &p_other);
    PackMapEnvDataPFieldV47 &operator=(const PackMapEnvDataPFieldV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV18 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV18();
    PackMapEnvDataPFieldCutoutV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV18(const PackMapEnvDataPFieldCutoutV18 &p_other);
    PackMapEnvDataPFieldCutoutV18 &operator=(const PackMapEnvDataPFieldCutoutV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV47 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV47();
    PackMapEnvDataSkyV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV47(const PackMapEnvDataSkyV47 &p_other);
    PackMapEnvDataSkyV47 &operator=(const PackMapEnvDataSkyV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV47 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV47();
    PackMapEnvDataSkyCardAttributesV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV47(const PackMapEnvDataSkyCardAttributesV47 &p_other);
    PackMapEnvDataSkyCardAttributesV47 &operator=(const PackMapEnvDataSkyCardAttributesV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV47 {
    PackMapEnvDataSkyCardAttributesV47 day;
    PackMapEnvDataSkyCardAttributesV47 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV47();
    PackMapEnvDataSkyCardV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV47(const PackMapEnvDataSkyCardV47 &p_other);
    PackMapEnvDataSkyCardV47 &operator=(const PackMapEnvDataSkyCardV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV47 {
    helpers::Array<PackMapEnvDataSkyCardV47> cards;

public:
    PackMapEnvDataSkyCardsV47();
    PackMapEnvDataSkyCardsV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV47(const PackMapEnvDataSkyCardsV47 &p_other);
    PackMapEnvDataSkyCardsV47 &operator=(const PackMapEnvDataSkyCardsV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV47 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV47();
    PackMapEnvDataWaterV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV47(const PackMapEnvDataWaterV47 &p_other);
    PackMapEnvDataWaterV47 &operator=(const PackMapEnvDataWaterV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV47 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV47();
    PackMapEnvDataWindV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV47(const PackMapEnvDataWindV47 &p_other);
    PackMapEnvDataWindV47 &operator=(const PackMapEnvDataWindV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV47 {
    helpers::Array<PackMapEnvDataLightingV47> lighting;
    helpers::Array<PackMapEnvDataLightingCharV18> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV47> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV18> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV47> effect;
    helpers::Ptr<PackMapEnvDataHazeV47> haze;
    helpers::Ptr<PackMapEnvDataPFieldV47> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV18> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV47> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV47> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV47> water;
    helpers::Ptr<PackMapEnvDataWindV47> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV47();
    PackMapEnvDataLocalV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV47(const PackMapEnvDataLocalV47 &p_other);
    PackMapEnvDataLocalV47 &operator=(const PackMapEnvDataLocalV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV47 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV47();
    PackMapEnvDataSkyModeTexV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV47(const PackMapEnvDataSkyModeTexV47 &p_other);
    PackMapEnvDataSkyModeTexV47 &operator=(const PackMapEnvDataSkyModeTexV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV47 {
    helpers::Array<PackMapEnvDataLightingV47> lighting;
    helpers::Array<PackMapEnvDataLightingCharV18> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV47> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV18> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV47> effect;
    helpers::Ptr<PackMapEnvDataHazeV47> haze;
    helpers::Ptr<PackMapEnvDataPFieldV47> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV18> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV47> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV47> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV47> water;
    helpers::Ptr<PackMapEnvDataWindV47> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV47> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV47();
    PackMapEnvDataGlobalV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV47(const PackMapEnvDataGlobalV47 &p_other);
    PackMapEnvDataGlobalV47 &operator=(const PackMapEnvDataGlobalV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV47 {
    helpers::Array<PackMapEnvDataLocalV47> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV47> dataGlobal;

public:
    PackMapEnvironmentV47();
    PackMapEnvironmentV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV47(const PackMapEnvironmentV47 &p_other);
    PackMapEnvironmentV47 &operator=(const PackMapEnvironmentV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV47 Gw2Struct;
};

/* Version: 46, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<46>{
struct PackMapEnvDataLightV46 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV46();
    PackMapEnvDataLightV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV46(const PackMapEnvDataLightV46 &p_other);
    PackMapEnvDataLightV46 &operator=(const PackMapEnvDataLightV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV46 {
    helpers::Ptr<PackMapEnvDataLightV46> lights;

public:
    PackMapEnvDataLightingV46();
    PackMapEnvDataLightingV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV46(const PackMapEnvDataLightingV46 &p_other);
    PackMapEnvDataLightingV46 &operator=(const PackMapEnvDataLightingV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV17 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV17();
    PackMapEnvDataLightingCharV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV17(const PackMapEnvDataLightingCharV17 &p_other);
    PackMapEnvDataLightingCharV17 &operator=(const PackMapEnvDataLightingCharV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV46 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV46();
    PackMapEnvDataLayerAttributesV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV46(const PackMapEnvDataLayerAttributesV46 &p_other);
    PackMapEnvDataLayerAttributesV46 &operator=(const PackMapEnvDataLayerAttributesV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV46 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV46> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV46();
    PackMapEnvDataLayerV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV46(const PackMapEnvDataLayerV46 &p_other);
    PackMapEnvDataLayerV46 &operator=(const PackMapEnvDataLayerV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV46 {
    helpers::Array<PackMapEnvDataLayerV46> layers;

public:
    PackMapEnvDataCloudsV46();
    PackMapEnvDataCloudsV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV46(const PackMapEnvDataCloudsV46 &p_other);
    PackMapEnvDataCloudsV46 &operator=(const PackMapEnvDataCloudsV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV17 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV17();
    PackMapEnvDataColoredLightRingsV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV17(const PackMapEnvDataColoredLightRingsV17 &p_other);
    PackMapEnvDataColoredLightRingsV17 &operator=(const PackMapEnvDataColoredLightRingsV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV46 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV46();
    PackMapEnvDataEffectV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV46(const PackMapEnvDataEffectV46 &p_other);
    PackMapEnvDataEffectV46 &operator=(const PackMapEnvDataEffectV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV46 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV46();
    PackMapEnvDataHazeV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV46(const PackMapEnvDataHazeV46 &p_other);
    PackMapEnvDataHazeV46 &operator=(const PackMapEnvDataHazeV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV46 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV46();
    PackMapEnvDataPFieldV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV46(const PackMapEnvDataPFieldV46 &p_other);
    PackMapEnvDataPFieldV46 &operator=(const PackMapEnvDataPFieldV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV17 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV17();
    PackMapEnvDataPFieldCutoutV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV17(const PackMapEnvDataPFieldCutoutV17 &p_other);
    PackMapEnvDataPFieldCutoutV17 &operator=(const PackMapEnvDataPFieldCutoutV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV46 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV46();
    PackMapEnvDataSkyV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV46(const PackMapEnvDataSkyV46 &p_other);
    PackMapEnvDataSkyV46 &operator=(const PackMapEnvDataSkyV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV46 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV46();
    PackMapEnvDataSkyCardAttributesV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV46(const PackMapEnvDataSkyCardAttributesV46 &p_other);
    PackMapEnvDataSkyCardAttributesV46 &operator=(const PackMapEnvDataSkyCardAttributesV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV46 {
    PackMapEnvDataSkyCardAttributesV46 day;
    PackMapEnvDataSkyCardAttributesV46 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV46();
    PackMapEnvDataSkyCardV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV46(const PackMapEnvDataSkyCardV46 &p_other);
    PackMapEnvDataSkyCardV46 &operator=(const PackMapEnvDataSkyCardV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV46 {
    helpers::Array<PackMapEnvDataSkyCardV46> cards;

public:
    PackMapEnvDataSkyCardsV46();
    PackMapEnvDataSkyCardsV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV46(const PackMapEnvDataSkyCardsV46 &p_other);
    PackMapEnvDataSkyCardsV46 &operator=(const PackMapEnvDataSkyCardsV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV46 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV46();
    PackMapEnvDataWaterV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV46(const PackMapEnvDataWaterV46 &p_other);
    PackMapEnvDataWaterV46 &operator=(const PackMapEnvDataWaterV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV46 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV46();
    PackMapEnvDataWindV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV46(const PackMapEnvDataWindV46 &p_other);
    PackMapEnvDataWindV46 &operator=(const PackMapEnvDataWindV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV46 {
    helpers::Array<PackMapEnvDataLightingV46> lighting;
    helpers::Array<PackMapEnvDataLightingCharV17> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV46> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV17> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV46> effect;
    helpers::Ptr<PackMapEnvDataHazeV46> haze;
    helpers::Ptr<PackMapEnvDataPFieldV46> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV17> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV46> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV46> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV46> water;
    helpers::Ptr<PackMapEnvDataWindV46> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV46();
    PackMapEnvDataLocalV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV46(const PackMapEnvDataLocalV46 &p_other);
    PackMapEnvDataLocalV46 &operator=(const PackMapEnvDataLocalV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV46 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV46();
    PackMapEnvDataSkyModeTexV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV46(const PackMapEnvDataSkyModeTexV46 &p_other);
    PackMapEnvDataSkyModeTexV46 &operator=(const PackMapEnvDataSkyModeTexV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV46 {
    helpers::Array<PackMapEnvDataLightingV46> lighting;
    helpers::Array<PackMapEnvDataLightingCharV17> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV46> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV17> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV46> effect;
    helpers::Ptr<PackMapEnvDataHazeV46> haze;
    helpers::Ptr<PackMapEnvDataPFieldV46> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV17> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV46> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV46> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV46> water;
    helpers::Ptr<PackMapEnvDataWindV46> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV46> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV46();
    PackMapEnvDataGlobalV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV46(const PackMapEnvDataGlobalV46 &p_other);
    PackMapEnvDataGlobalV46 &operator=(const PackMapEnvDataGlobalV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV46 {
    helpers::Array<PackMapEnvDataLocalV46> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV46> dataGlobal;

public:
    PackMapEnvironmentV46();
    PackMapEnvironmentV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV46(const PackMapEnvironmentV46 &p_other);
    PackMapEnvironmentV46 &operator=(const PackMapEnvironmentV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV46 Gw2Struct;
};

/* Version: 45, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<45>{
struct PackMapEnvDataLightV45 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV45();
    PackMapEnvDataLightV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV45(const PackMapEnvDataLightV45 &p_other);
    PackMapEnvDataLightV45 &operator=(const PackMapEnvDataLightV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV45 {
    helpers::Ptr<PackMapEnvDataLightV45> lights;

public:
    PackMapEnvDataLightingV45();
    PackMapEnvDataLightingV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV45(const PackMapEnvDataLightingV45 &p_other);
    PackMapEnvDataLightingV45 &operator=(const PackMapEnvDataLightingV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV16 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV16();
    PackMapEnvDataLightingCharV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV16(const PackMapEnvDataLightingCharV16 &p_other);
    PackMapEnvDataLightingCharV16 &operator=(const PackMapEnvDataLightingCharV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV45 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV45();
    PackMapEnvDataLayerAttributesV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV45(const PackMapEnvDataLayerAttributesV45 &p_other);
    PackMapEnvDataLayerAttributesV45 &operator=(const PackMapEnvDataLayerAttributesV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV45 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV45> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV45();
    PackMapEnvDataLayerV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV45(const PackMapEnvDataLayerV45 &p_other);
    PackMapEnvDataLayerV45 &operator=(const PackMapEnvDataLayerV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV45 {
    helpers::Array<PackMapEnvDataLayerV45> layers;

public:
    PackMapEnvDataCloudsV45();
    PackMapEnvDataCloudsV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV45(const PackMapEnvDataCloudsV45 &p_other);
    PackMapEnvDataCloudsV45 &operator=(const PackMapEnvDataCloudsV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV16 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV16();
    PackMapEnvDataColoredLightRingsV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV16(const PackMapEnvDataColoredLightRingsV16 &p_other);
    PackMapEnvDataColoredLightRingsV16 &operator=(const PackMapEnvDataColoredLightRingsV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV45 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV45();
    PackMapEnvDataEffectV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV45(const PackMapEnvDataEffectV45 &p_other);
    PackMapEnvDataEffectV45 &operator=(const PackMapEnvDataEffectV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV45 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV45();
    PackMapEnvDataHazeV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV45(const PackMapEnvDataHazeV45 &p_other);
    PackMapEnvDataHazeV45 &operator=(const PackMapEnvDataHazeV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV45 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV45();
    PackMapEnvDataPFieldV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV45(const PackMapEnvDataPFieldV45 &p_other);
    PackMapEnvDataPFieldV45 &operator=(const PackMapEnvDataPFieldV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV16 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV16();
    PackMapEnvDataPFieldCutoutV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV16(const PackMapEnvDataPFieldCutoutV16 &p_other);
    PackMapEnvDataPFieldCutoutV16 &operator=(const PackMapEnvDataPFieldCutoutV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV45 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV45();
    PackMapEnvDataSkyV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV45(const PackMapEnvDataSkyV45 &p_other);
    PackMapEnvDataSkyV45 &operator=(const PackMapEnvDataSkyV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV45 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV45();
    PackMapEnvDataSkyCardAttributesV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV45(const PackMapEnvDataSkyCardAttributesV45 &p_other);
    PackMapEnvDataSkyCardAttributesV45 &operator=(const PackMapEnvDataSkyCardAttributesV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV45 {
    PackMapEnvDataSkyCardAttributesV45 day;
    PackMapEnvDataSkyCardAttributesV45 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV45();
    PackMapEnvDataSkyCardV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV45(const PackMapEnvDataSkyCardV45 &p_other);
    PackMapEnvDataSkyCardV45 &operator=(const PackMapEnvDataSkyCardV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV45 {
    helpers::Array<PackMapEnvDataSkyCardV45> cards;

public:
    PackMapEnvDataSkyCardsV45();
    PackMapEnvDataSkyCardsV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV45(const PackMapEnvDataSkyCardsV45 &p_other);
    PackMapEnvDataSkyCardsV45 &operator=(const PackMapEnvDataSkyCardsV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV45 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV45();
    PackMapEnvDataWaterV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV45(const PackMapEnvDataWaterV45 &p_other);
    PackMapEnvDataWaterV45 &operator=(const PackMapEnvDataWaterV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV45 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV45();
    PackMapEnvDataWindV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV45(const PackMapEnvDataWindV45 &p_other);
    PackMapEnvDataWindV45 &operator=(const PackMapEnvDataWindV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV45 {
    helpers::Array<PackMapEnvDataLightingV45> lighting;
    helpers::Array<PackMapEnvDataLightingCharV16> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV45> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV16> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV45> effect;
    helpers::Ptr<PackMapEnvDataHazeV45> haze;
    helpers::Ptr<PackMapEnvDataPFieldV45> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV16> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV45> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV45> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV45> water;
    helpers::Ptr<PackMapEnvDataWindV45> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV45();
    PackMapEnvDataLocalV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV45(const PackMapEnvDataLocalV45 &p_other);
    PackMapEnvDataLocalV45 &operator=(const PackMapEnvDataLocalV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV45 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV45();
    PackMapEnvDataSkyModeTexV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV45(const PackMapEnvDataSkyModeTexV45 &p_other);
    PackMapEnvDataSkyModeTexV45 &operator=(const PackMapEnvDataSkyModeTexV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV45 {
    helpers::Array<PackMapEnvDataLightingV45> lighting;
    helpers::Array<PackMapEnvDataLightingCharV16> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV45> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV16> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV45> effect;
    helpers::Ptr<PackMapEnvDataHazeV45> haze;
    helpers::Ptr<PackMapEnvDataPFieldV45> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV16> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV45> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV45> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV45> water;
    helpers::Ptr<PackMapEnvDataWindV45> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV45> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV45();
    PackMapEnvDataGlobalV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV45(const PackMapEnvDataGlobalV45 &p_other);
    PackMapEnvDataGlobalV45 &operator=(const PackMapEnvDataGlobalV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV45 {
    helpers::Array<PackMapEnvDataLocalV45> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV45> dataGlobal;

public:
    PackMapEnvironmentV45();
    PackMapEnvironmentV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV45(const PackMapEnvironmentV45 &p_other);
    PackMapEnvironmentV45 &operator=(const PackMapEnvironmentV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV45 Gw2Struct;
};

/* Version: 44, ReferencedFunction: 0x4104E41000000001 */

template <>
struct Gw2Structenv<44>{
struct PackMapEnvDataLightV44 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV44();
    PackMapEnvDataLightV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV44(const PackMapEnvDataLightV44 &p_other);
    PackMapEnvDataLightV44 &operator=(const PackMapEnvDataLightV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV44 {
    helpers::Ptr<PackMapEnvDataLightV44> lights;

public:
    PackMapEnvDataLightingV44();
    PackMapEnvDataLightingV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV44(const PackMapEnvDataLightingV44 &p_other);
    PackMapEnvDataLightingV44 &operator=(const PackMapEnvDataLightingV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV15 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV15();
    PackMapEnvDataLightingCharV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV15(const PackMapEnvDataLightingCharV15 &p_other);
    PackMapEnvDataLightingCharV15 &operator=(const PackMapEnvDataLightingCharV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV44 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV44();
    PackMapEnvDataLayerAttributesV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV44(const PackMapEnvDataLayerAttributesV44 &p_other);
    PackMapEnvDataLayerAttributesV44 &operator=(const PackMapEnvDataLayerAttributesV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV44 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV44> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV44();
    PackMapEnvDataLayerV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV44(const PackMapEnvDataLayerV44 &p_other);
    PackMapEnvDataLayerV44 &operator=(const PackMapEnvDataLayerV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV44 {
    helpers::Array<PackMapEnvDataLayerV44> layers;

public:
    PackMapEnvDataCloudsV44();
    PackMapEnvDataCloudsV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV44(const PackMapEnvDataCloudsV44 &p_other);
    PackMapEnvDataCloudsV44 &operator=(const PackMapEnvDataCloudsV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataColoredLightRingsV15 {
    float2 range;
    byte4 colors[6];
    float distances[6];

public:
    PackMapEnvDataColoredLightRingsV15();
    PackMapEnvDataColoredLightRingsV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataColoredLightRingsV15(const PackMapEnvDataColoredLightRingsV15 &p_other);
    PackMapEnvDataColoredLightRingsV15 &operator=(const PackMapEnvDataColoredLightRingsV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV44 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV44();
    PackMapEnvDataEffectV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV44(const PackMapEnvDataEffectV44 &p_other);
    PackMapEnvDataEffectV44 &operator=(const PackMapEnvDataEffectV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV44 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV44();
    PackMapEnvDataHazeV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV44(const PackMapEnvDataHazeV44 &p_other);
    PackMapEnvDataHazeV44 &operator=(const PackMapEnvDataHazeV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV44 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV44();
    PackMapEnvDataPFieldV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV44(const PackMapEnvDataPFieldV44 &p_other);
    PackMapEnvDataPFieldV44 &operator=(const PackMapEnvDataPFieldV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV15 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV15();
    PackMapEnvDataPFieldCutoutV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV15(const PackMapEnvDataPFieldCutoutV15 &p_other);
    PackMapEnvDataPFieldCutoutV15 &operator=(const PackMapEnvDataPFieldCutoutV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV44 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV44();
    PackMapEnvDataSkyV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV44(const PackMapEnvDataSkyV44 &p_other);
    PackMapEnvDataSkyV44 &operator=(const PackMapEnvDataSkyV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV44 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV44();
    PackMapEnvDataSkyCardAttributesV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV44(const PackMapEnvDataSkyCardAttributesV44 &p_other);
    PackMapEnvDataSkyCardAttributesV44 &operator=(const PackMapEnvDataSkyCardAttributesV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV44 {
    PackMapEnvDataSkyCardAttributesV44 day;
    PackMapEnvDataSkyCardAttributesV44 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV44();
    PackMapEnvDataSkyCardV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV44(const PackMapEnvDataSkyCardV44 &p_other);
    PackMapEnvDataSkyCardV44 &operator=(const PackMapEnvDataSkyCardV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV44 {
    helpers::Array<PackMapEnvDataSkyCardV44> cards;

public:
    PackMapEnvDataSkyCardsV44();
    PackMapEnvDataSkyCardsV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV44(const PackMapEnvDataSkyCardsV44 &p_other);
    PackMapEnvDataSkyCardsV44 &operator=(const PackMapEnvDataSkyCardsV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV44 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV44();
    PackMapEnvDataWaterV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV44(const PackMapEnvDataWaterV44 &p_other);
    PackMapEnvDataWaterV44 &operator=(const PackMapEnvDataWaterV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV44 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV44();
    PackMapEnvDataWindV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV44(const PackMapEnvDataWindV44 &p_other);
    PackMapEnvDataWindV44 &operator=(const PackMapEnvDataWindV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV44 {
    helpers::Array<PackMapEnvDataLightingV44> lighting;
    helpers::Array<PackMapEnvDataLightingCharV15> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV44> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV15> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV44> effect;
    helpers::Ptr<PackMapEnvDataHazeV44> haze;
    helpers::Ptr<PackMapEnvDataPFieldV44> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV15> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV44> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV44> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV44> water;
    helpers::Ptr<PackMapEnvDataWindV44> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV44();
    PackMapEnvDataLocalV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV44(const PackMapEnvDataLocalV44 &p_other);
    PackMapEnvDataLocalV44 &operator=(const PackMapEnvDataLocalV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV44 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV44();
    PackMapEnvDataSkyModeTexV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV44(const PackMapEnvDataSkyModeTexV44 &p_other);
    PackMapEnvDataSkyModeTexV44 &operator=(const PackMapEnvDataSkyModeTexV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV44 {
    helpers::Array<PackMapEnvDataLightingV44> lighting;
    helpers::Array<PackMapEnvDataLightingCharV15> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV44> clouds;
    helpers::Ptr<PackMapEnvDataColoredLightRingsV15> coloredLightRings;
    helpers::Ptr<PackMapEnvDataEffectV44> effect;
    helpers::Ptr<PackMapEnvDataHazeV44> haze;
    helpers::Ptr<PackMapEnvDataPFieldV44> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV15> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV44> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV44> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV44> water;
    helpers::Ptr<PackMapEnvDataWindV44> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV44> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV44();
    PackMapEnvDataGlobalV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV44(const PackMapEnvDataGlobalV44 &p_other);
    PackMapEnvDataGlobalV44 &operator=(const PackMapEnvDataGlobalV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV44 {
    helpers::Array<PackMapEnvDataLocalV44> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV44> dataGlobal;

public:
    PackMapEnvironmentV44();
    PackMapEnvironmentV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV44(const PackMapEnvironmentV44 &p_other);
    PackMapEnvironmentV44 &operator=(const PackMapEnvironmentV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV44 Gw2Struct;
};

/* Version: 43, ReferencedFunction: 0x4104E26000000001 */

template <>
struct Gw2Structenv<43>{
struct PackMapEnvDataLightV43 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV43();
    PackMapEnvDataLightV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV43(const PackMapEnvDataLightV43 &p_other);
    PackMapEnvDataLightV43 &operator=(const PackMapEnvDataLightV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV43 {
    helpers::Ptr<PackMapEnvDataLightV43> lights;

public:
    PackMapEnvDataLightingV43();
    PackMapEnvDataLightingV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV43(const PackMapEnvDataLightingV43 &p_other);
    PackMapEnvDataLightingV43 &operator=(const PackMapEnvDataLightingV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV14 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV14();
    PackMapEnvDataLightingCharV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV14(const PackMapEnvDataLightingCharV14 &p_other);
    PackMapEnvDataLightingCharV14 &operator=(const PackMapEnvDataLightingCharV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV43 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;
    float fadeWidth;
    float fadeEnd;

public:
    PackMapEnvDataLayerAttributesV43();
    PackMapEnvDataLayerAttributesV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV43(const PackMapEnvDataLayerAttributesV43 &p_other);
    PackMapEnvDataLayerAttributesV43 &operator=(const PackMapEnvDataLayerAttributesV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV43 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV43> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV43();
    PackMapEnvDataLayerV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV43(const PackMapEnvDataLayerV43 &p_other);
    PackMapEnvDataLayerV43 &operator=(const PackMapEnvDataLayerV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV43 {
    helpers::Array<PackMapEnvDataLayerV43> layers;

public:
    PackMapEnvDataCloudsV43();
    PackMapEnvDataCloudsV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV43(const PackMapEnvDataCloudsV43 &p_other);
    PackMapEnvDataCloudsV43 &operator=(const PackMapEnvDataCloudsV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV43 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV43();
    PackMapEnvDataEffectV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV43(const PackMapEnvDataEffectV43 &p_other);
    PackMapEnvDataEffectV43 &operator=(const PackMapEnvDataEffectV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV43 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV43();
    PackMapEnvDataHazeV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV43(const PackMapEnvDataHazeV43 &p_other);
    PackMapEnvDataHazeV43 &operator=(const PackMapEnvDataHazeV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV43 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV43();
    PackMapEnvDataPFieldV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV43(const PackMapEnvDataPFieldV43 &p_other);
    PackMapEnvDataPFieldV43 &operator=(const PackMapEnvDataPFieldV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV14 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV14();
    PackMapEnvDataPFieldCutoutV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV14(const PackMapEnvDataPFieldCutoutV14 &p_other);
    PackMapEnvDataPFieldCutoutV14 &operator=(const PackMapEnvDataPFieldCutoutV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV43 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV43();
    PackMapEnvDataSkyV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV43(const PackMapEnvDataSkyV43 &p_other);
    PackMapEnvDataSkyV43 &operator=(const PackMapEnvDataSkyV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV43 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;
    float brightness;

public:
    PackMapEnvDataSkyCardAttributesV43();
    PackMapEnvDataSkyCardAttributesV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV43(const PackMapEnvDataSkyCardAttributesV43 &p_other);
    PackMapEnvDataSkyCardAttributesV43 &operator=(const PackMapEnvDataSkyCardAttributesV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV43 {
    PackMapEnvDataSkyCardAttributesV43 day;
    PackMapEnvDataSkyCardAttributesV43 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV43();
    PackMapEnvDataSkyCardV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV43(const PackMapEnvDataSkyCardV43 &p_other);
    PackMapEnvDataSkyCardV43 &operator=(const PackMapEnvDataSkyCardV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV43 {
    helpers::Array<PackMapEnvDataSkyCardV43> cards;

public:
    PackMapEnvDataSkyCardsV43();
    PackMapEnvDataSkyCardsV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV43(const PackMapEnvDataSkyCardsV43 &p_other);
    PackMapEnvDataSkyCardsV43 &operator=(const PackMapEnvDataSkyCardsV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV43 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapEnvDataWaterV43();
    PackMapEnvDataWaterV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV43(const PackMapEnvDataWaterV43 &p_other);
    PackMapEnvDataWaterV43 &operator=(const PackMapEnvDataWaterV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV43 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV43();
    PackMapEnvDataWindV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV43(const PackMapEnvDataWindV43 &p_other);
    PackMapEnvDataWindV43 &operator=(const PackMapEnvDataWindV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV43 {
    helpers::Array<PackMapEnvDataLightingV43> lighting;
    helpers::Array<PackMapEnvDataLightingCharV14> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV43> clouds;
    helpers::Ptr<PackMapEnvDataEffectV43> effect;
    helpers::Ptr<PackMapEnvDataHazeV43> haze;
    helpers::Ptr<PackMapEnvDataPFieldV43> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV14> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV43> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV43> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV43> water;
    helpers::Ptr<PackMapEnvDataWindV43> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV43();
    PackMapEnvDataLocalV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV43(const PackMapEnvDataLocalV43 &p_other);
    PackMapEnvDataLocalV43 &operator=(const PackMapEnvDataLocalV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV43 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV43();
    PackMapEnvDataSkyModeTexV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV43(const PackMapEnvDataSkyModeTexV43 &p_other);
    PackMapEnvDataSkyModeTexV43 &operator=(const PackMapEnvDataSkyModeTexV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV43 {
    helpers::Array<PackMapEnvDataLightingV43> lighting;
    helpers::Array<PackMapEnvDataLightingCharV14> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV43> clouds;
    helpers::Ptr<PackMapEnvDataEffectV43> effect;
    helpers::Ptr<PackMapEnvDataHazeV43> haze;
    helpers::Ptr<PackMapEnvDataPFieldV43> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV14> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV43> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV43> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV43> water;
    helpers::Ptr<PackMapEnvDataWindV43> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV43> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV43();
    PackMapEnvDataGlobalV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV43(const PackMapEnvDataGlobalV43 &p_other);
    PackMapEnvDataGlobalV43 &operator=(const PackMapEnvDataGlobalV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV43 {
    helpers::Array<PackMapEnvDataLocalV43> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV43> dataGlobal;

public:
    PackMapEnvironmentV43();
    PackMapEnvironmentV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV43(const PackMapEnvironmentV43 &p_other);
    PackMapEnvironmentV43 &operator=(const PackMapEnvironmentV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV43 Gw2Struct;
};

/* Version: 42, ReferencedFunction: 0x4104E19000000001 */

template <>
struct Gw2Structenv<42>{
struct PackMapEnvDataLightV42 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV42();
    PackMapEnvDataLightV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV42(const PackMapEnvDataLightV42 &p_other);
    PackMapEnvDataLightV42 &operator=(const PackMapEnvDataLightV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV42 {
    helpers::Ptr<PackMapEnvDataLightV42> lights;

public:
    PackMapEnvDataLightingV42();
    PackMapEnvDataLightingV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV42(const PackMapEnvDataLightingV42 &p_other);
    PackMapEnvDataLightingV42 &operator=(const PackMapEnvDataLightingV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV13 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV13();
    PackMapEnvDataLightingCharV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV13(const PackMapEnvDataLightingCharV13 &p_other);
    PackMapEnvDataLightingCharV13 &operator=(const PackMapEnvDataLightingCharV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV42 {
    float brightness;
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV42();
    PackMapEnvDataLayerAttributesV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV42(const PackMapEnvDataLayerAttributesV42 &p_other);
    PackMapEnvDataLayerAttributesV42 &operator=(const PackMapEnvDataLayerAttributesV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV42 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV42> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV42();
    PackMapEnvDataLayerV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV42(const PackMapEnvDataLayerV42 &p_other);
    PackMapEnvDataLayerV42 &operator=(const PackMapEnvDataLayerV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV42 {
    helpers::Array<PackMapEnvDataLayerV42> layers;

public:
    PackMapEnvDataCloudsV42();
    PackMapEnvDataCloudsV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV42(const PackMapEnvDataCloudsV42 &p_other);
    PackMapEnvDataCloudsV42 &operator=(const PackMapEnvDataCloudsV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV42 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV42();
    PackMapEnvDataEffectV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV42(const PackMapEnvDataEffectV42 &p_other);
    PackMapEnvDataEffectV42 &operator=(const PackMapEnvDataEffectV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV42 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV42();
    PackMapEnvDataHazeV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV42(const PackMapEnvDataHazeV42 &p_other);
    PackMapEnvDataHazeV42 &operator=(const PackMapEnvDataHazeV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV42 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV42();
    PackMapEnvDataPFieldV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV42(const PackMapEnvDataPFieldV42 &p_other);
    PackMapEnvDataPFieldV42 &operator=(const PackMapEnvDataPFieldV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV13 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV13();
    PackMapEnvDataPFieldCutoutV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV13(const PackMapEnvDataPFieldCutoutV13 &p_other);
    PackMapEnvDataPFieldCutoutV13 &operator=(const PackMapEnvDataPFieldCutoutV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV42 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV42();
    PackMapEnvDataSkyV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV42(const PackMapEnvDataSkyV42 &p_other);
    PackMapEnvDataSkyV42 &operator=(const PackMapEnvDataSkyV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV42 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV42();
    PackMapEnvDataSkyCardAttributesV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV42(const PackMapEnvDataSkyCardAttributesV42 &p_other);
    PackMapEnvDataSkyCardAttributesV42 &operator=(const PackMapEnvDataSkyCardAttributesV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV42 {
    PackMapEnvDataSkyCardAttributesV42 day;
    PackMapEnvDataSkyCardAttributesV42 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV42();
    PackMapEnvDataSkyCardV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV42(const PackMapEnvDataSkyCardV42 &p_other);
    PackMapEnvDataSkyCardV42 &operator=(const PackMapEnvDataSkyCardV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV42 {
    helpers::Array<PackMapEnvDataSkyCardV42> cards;

public:
    PackMapEnvDataSkyCardsV42();
    PackMapEnvDataSkyCardsV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV42(const PackMapEnvDataSkyCardsV42 &p_other);
    PackMapEnvDataSkyCardsV42 &operator=(const PackMapEnvDataSkyCardsV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV42 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;

public:
    PackMapEnvDataWaterV42();
    PackMapEnvDataWaterV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV42(const PackMapEnvDataWaterV42 &p_other);
    PackMapEnvDataWaterV42 &operator=(const PackMapEnvDataWaterV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV42 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV42();
    PackMapEnvDataWindV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV42(const PackMapEnvDataWindV42 &p_other);
    PackMapEnvDataWindV42 &operator=(const PackMapEnvDataWindV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV42 {
    helpers::Array<PackMapEnvDataLightingV42> lighting;
    helpers::Array<PackMapEnvDataLightingCharV13> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV42> clouds;
    helpers::Ptr<PackMapEnvDataEffectV42> effect;
    helpers::Ptr<PackMapEnvDataHazeV42> haze;
    helpers::Ptr<PackMapEnvDataPFieldV42> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV13> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV42> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV42> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV42> water;
    helpers::Ptr<PackMapEnvDataWindV42> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV42();
    PackMapEnvDataLocalV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV42(const PackMapEnvDataLocalV42 &p_other);
    PackMapEnvDataLocalV42 &operator=(const PackMapEnvDataLocalV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV42 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV42();
    PackMapEnvDataSkyModeTexV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV42(const PackMapEnvDataSkyModeTexV42 &p_other);
    PackMapEnvDataSkyModeTexV42 &operator=(const PackMapEnvDataSkyModeTexV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV42 {
    helpers::Array<PackMapEnvDataLightingV42> lighting;
    helpers::Array<PackMapEnvDataLightingCharV13> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV42> clouds;
    helpers::Ptr<PackMapEnvDataEffectV42> effect;
    helpers::Ptr<PackMapEnvDataHazeV42> haze;
    helpers::Ptr<PackMapEnvDataPFieldV42> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV13> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV42> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV42> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV42> water;
    helpers::Ptr<PackMapEnvDataWindV42> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV42> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV42();
    PackMapEnvDataGlobalV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV42(const PackMapEnvDataGlobalV42 &p_other);
    PackMapEnvDataGlobalV42 &operator=(const PackMapEnvDataGlobalV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV42 {
    helpers::Array<PackMapEnvDataLocalV42> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV42> dataGlobal;

public:
    PackMapEnvironmentV42();
    PackMapEnvironmentV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV42(const PackMapEnvironmentV42 &p_other);
    PackMapEnvironmentV42 &operator=(const PackMapEnvironmentV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV42 Gw2Struct;
};

/* Version: 41, ReferencedFunction: 0x4104E02000000001 */

template <>
struct Gw2Structenv<41>{
struct PackMapEnvDataLightV41 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV41();
    PackMapEnvDataLightV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV41(const PackMapEnvDataLightV41 &p_other);
    PackMapEnvDataLightV41 &operator=(const PackMapEnvDataLightV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV41 {
    helpers::Ptr<PackMapEnvDataLightV41> lights;

public:
    PackMapEnvDataLightingV41();
    PackMapEnvDataLightingV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV41(const PackMapEnvDataLightingV41 &p_other);
    PackMapEnvDataLightingV41 &operator=(const PackMapEnvDataLightingV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV12 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV12();
    PackMapEnvDataLightingCharV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV12(const PackMapEnvDataLightingCharV12 &p_other);
    PackMapEnvDataLightingCharV12 &operator=(const PackMapEnvDataLightingCharV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV41 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV41();
    PackMapEnvDataLayerAttributesV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV41(const PackMapEnvDataLayerAttributesV41 &p_other);
    PackMapEnvDataLayerAttributesV41 &operator=(const PackMapEnvDataLayerAttributesV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV41 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV41> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV41();
    PackMapEnvDataLayerV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV41(const PackMapEnvDataLayerV41 &p_other);
    PackMapEnvDataLayerV41 &operator=(const PackMapEnvDataLayerV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV41 {
    helpers::Array<PackMapEnvDataLayerV41> layers;

public:
    PackMapEnvDataCloudsV41();
    PackMapEnvDataCloudsV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV41(const PackMapEnvDataCloudsV41 &p_other);
    PackMapEnvDataCloudsV41 &operator=(const PackMapEnvDataCloudsV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV41 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV41();
    PackMapEnvDataEffectV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV41(const PackMapEnvDataEffectV41 &p_other);
    PackMapEnvDataEffectV41 &operator=(const PackMapEnvDataEffectV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV41 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV41();
    PackMapEnvDataHazeV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV41(const PackMapEnvDataHazeV41 &p_other);
    PackMapEnvDataHazeV41 &operator=(const PackMapEnvDataHazeV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV41 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV41();
    PackMapEnvDataPFieldV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV41(const PackMapEnvDataPFieldV41 &p_other);
    PackMapEnvDataPFieldV41 &operator=(const PackMapEnvDataPFieldV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV12 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV12();
    PackMapEnvDataPFieldCutoutV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV12(const PackMapEnvDataPFieldCutoutV12 &p_other);
    PackMapEnvDataPFieldCutoutV12 &operator=(const PackMapEnvDataPFieldCutoutV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV41 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV41();
    PackMapEnvDataSkyV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV41(const PackMapEnvDataSkyV41 &p_other);
    PackMapEnvDataSkyV41 &operator=(const PackMapEnvDataSkyV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV41 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV41();
    PackMapEnvDataSkyCardAttributesV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV41(const PackMapEnvDataSkyCardAttributesV41 &p_other);
    PackMapEnvDataSkyCardAttributesV41 &operator=(const PackMapEnvDataSkyCardAttributesV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV41 {
    PackMapEnvDataSkyCardAttributesV41 day;
    PackMapEnvDataSkyCardAttributesV41 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV41();
    PackMapEnvDataSkyCardV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV41(const PackMapEnvDataSkyCardV41 &p_other);
    PackMapEnvDataSkyCardV41 &operator=(const PackMapEnvDataSkyCardV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV41 {
    helpers::Array<PackMapEnvDataSkyCardV41> cards;

public:
    PackMapEnvDataSkyCardsV41();
    PackMapEnvDataSkyCardsV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV41(const PackMapEnvDataSkyCardsV41 &p_other);
    PackMapEnvDataSkyCardsV41 &operator=(const PackMapEnvDataSkyCardsV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV41 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    float depthAttenuation;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;

public:
    PackMapEnvDataWaterV41();
    PackMapEnvDataWaterV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV41(const PackMapEnvDataWaterV41 &p_other);
    PackMapEnvDataWaterV41 &operator=(const PackMapEnvDataWaterV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV41 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV41();
    PackMapEnvDataWindV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV41(const PackMapEnvDataWindV41 &p_other);
    PackMapEnvDataWindV41 &operator=(const PackMapEnvDataWindV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV41 {
    helpers::Array<PackMapEnvDataLightingV41> lighting;
    helpers::Array<PackMapEnvDataLightingCharV12> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV41> clouds;
    helpers::Ptr<PackMapEnvDataEffectV41> effect;
    helpers::Ptr<PackMapEnvDataHazeV41> haze;
    helpers::Ptr<PackMapEnvDataPFieldV41> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV12> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV41> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV41> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV41> water;
    helpers::Ptr<PackMapEnvDataWindV41> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV41();
    PackMapEnvDataLocalV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV41(const PackMapEnvDataLocalV41 &p_other);
    PackMapEnvDataLocalV41 &operator=(const PackMapEnvDataLocalV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV41 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV41();
    PackMapEnvDataSkyModeTexV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV41(const PackMapEnvDataSkyModeTexV41 &p_other);
    PackMapEnvDataSkyModeTexV41 &operator=(const PackMapEnvDataSkyModeTexV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV41 {
    helpers::Array<PackMapEnvDataLightingV41> lighting;
    helpers::Array<PackMapEnvDataLightingCharV12> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV41> clouds;
    helpers::Ptr<PackMapEnvDataEffectV41> effect;
    helpers::Ptr<PackMapEnvDataHazeV41> haze;
    helpers::Ptr<PackMapEnvDataPFieldV41> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV12> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV41> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV41> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV41> water;
    helpers::Ptr<PackMapEnvDataWindV41> wind;
    helpers::WString name;
    helpers::Array<byte> nightMods;
    helpers::Array<PackMapEnvDataSkyModeTexV41> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV41();
    PackMapEnvDataGlobalV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV41(const PackMapEnvDataGlobalV41 &p_other);
    PackMapEnvDataGlobalV41 &operator=(const PackMapEnvDataGlobalV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV41 {
    helpers::Array<PackMapEnvDataLocalV41> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV41> dataGlobal;

public:
    PackMapEnvironmentV41();
    PackMapEnvironmentV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV41(const PackMapEnvironmentV41 &p_other);
    PackMapEnvironmentV41 &operator=(const PackMapEnvironmentV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV41 Gw2Struct;
};

/* Version: 40, ReferencedFunction: 0x4104DFE000000001 */

template <>
struct Gw2Structenv<40>{
struct PackMapEnvDataLightV40 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV40();
    PackMapEnvDataLightV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV40(const PackMapEnvDataLightV40 &p_other);
    PackMapEnvDataLightV40 &operator=(const PackMapEnvDataLightV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV40 {
    helpers::Ptr<PackMapEnvDataLightV40> lights;

public:
    PackMapEnvDataLightingV40();
    PackMapEnvDataLightingV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV40(const PackMapEnvDataLightingV40 &p_other);
    PackMapEnvDataLightingV40 &operator=(const PackMapEnvDataLightingV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV11 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV11();
    PackMapEnvDataLightingCharV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV11(const PackMapEnvDataLightingCharV11 &p_other);
    PackMapEnvDataLightingCharV11 &operator=(const PackMapEnvDataLightingCharV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV40 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV40();
    PackMapEnvDataLayerAttributesV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV40(const PackMapEnvDataLayerAttributesV40 &p_other);
    PackMapEnvDataLayerAttributesV40 &operator=(const PackMapEnvDataLayerAttributesV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV40 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV40> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV40();
    PackMapEnvDataLayerV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV40(const PackMapEnvDataLayerV40 &p_other);
    PackMapEnvDataLayerV40 &operator=(const PackMapEnvDataLayerV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV40 {
    helpers::Array<PackMapEnvDataLayerV40> layers;

public:
    PackMapEnvDataCloudsV40();
    PackMapEnvDataCloudsV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV40(const PackMapEnvDataCloudsV40 &p_other);
    PackMapEnvDataCloudsV40 &operator=(const PackMapEnvDataCloudsV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV40 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV40();
    PackMapEnvDataEffectV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV40(const PackMapEnvDataEffectV40 &p_other);
    PackMapEnvDataEffectV40 &operator=(const PackMapEnvDataEffectV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV40 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV40();
    PackMapEnvDataHazeV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV40(const PackMapEnvDataHazeV40 &p_other);
    PackMapEnvDataHazeV40 &operator=(const PackMapEnvDataHazeV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV40 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV40();
    PackMapEnvDataPFieldV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV40(const PackMapEnvDataPFieldV40 &p_other);
    PackMapEnvDataPFieldV40 &operator=(const PackMapEnvDataPFieldV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV11 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV11();
    PackMapEnvDataPFieldCutoutV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV11(const PackMapEnvDataPFieldCutoutV11 &p_other);
    PackMapEnvDataPFieldCutoutV11 &operator=(const PackMapEnvDataPFieldCutoutV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV40 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV40();
    PackMapEnvDataSkyV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV40(const PackMapEnvDataSkyV40 &p_other);
    PackMapEnvDataSkyV40 &operator=(const PackMapEnvDataSkyV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV40 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV40();
    PackMapEnvDataSkyCardAttributesV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV40(const PackMapEnvDataSkyCardAttributesV40 &p_other);
    PackMapEnvDataSkyCardAttributesV40 &operator=(const PackMapEnvDataSkyCardAttributesV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV40 {
    PackMapEnvDataSkyCardAttributesV40 day;
    PackMapEnvDataSkyCardAttributesV40 night;
    dword flags;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV40();
    PackMapEnvDataSkyCardV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV40(const PackMapEnvDataSkyCardV40 &p_other);
    PackMapEnvDataSkyCardV40 &operator=(const PackMapEnvDataSkyCardV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV40 {
    helpers::Array<PackMapEnvDataSkyCardV40> cards;

public:
    PackMapEnvDataSkyCardsV40();
    PackMapEnvDataSkyCardsV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV40(const PackMapEnvDataSkyCardsV40 &p_other);
    PackMapEnvDataSkyCardsV40 &operator=(const PackMapEnvDataSkyCardsV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV40 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;
    float depthAttenuation;

public:
    PackMapEnvDataWaterV40();
    PackMapEnvDataWaterV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV40(const PackMapEnvDataWaterV40 &p_other);
    PackMapEnvDataWaterV40 &operator=(const PackMapEnvDataWaterV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV40 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV40();
    PackMapEnvDataWindV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV40(const PackMapEnvDataWindV40 &p_other);
    PackMapEnvDataWindV40 &operator=(const PackMapEnvDataWindV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV40 {
    helpers::Array<PackMapEnvDataLightingV40> lighting;
    helpers::Array<PackMapEnvDataLightingCharV11> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV40> clouds;
    helpers::Ptr<PackMapEnvDataEffectV40> effect;
    helpers::Ptr<PackMapEnvDataHazeV40> haze;
    helpers::Ptr<PackMapEnvDataPFieldV40> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV11> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV40> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV40> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV40> water;
    helpers::Ptr<PackMapEnvDataWindV40> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV40();
    PackMapEnvDataLocalV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV40(const PackMapEnvDataLocalV40 &p_other);
    PackMapEnvDataLocalV40 &operator=(const PackMapEnvDataLocalV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV40 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV40();
    PackMapEnvDataSkyModeTexV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV40(const PackMapEnvDataSkyModeTexV40 &p_other);
    PackMapEnvDataSkyModeTexV40 &operator=(const PackMapEnvDataSkyModeTexV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV40 {
    helpers::Array<PackMapEnvDataLightingV40> lighting;
    helpers::Array<PackMapEnvDataLightingCharV11> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV40> clouds;
    helpers::Ptr<PackMapEnvDataEffectV40> effect;
    helpers::Ptr<PackMapEnvDataHazeV40> haze;
    helpers::Ptr<PackMapEnvDataPFieldV40> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV11> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV40> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV40> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV40> water;
    helpers::Ptr<PackMapEnvDataWindV40> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV40> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV40();
    PackMapEnvDataGlobalV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV40(const PackMapEnvDataGlobalV40 &p_other);
    PackMapEnvDataGlobalV40 &operator=(const PackMapEnvDataGlobalV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV40 {
    helpers::Array<PackMapEnvDataLocalV40> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV40> dataGlobal;

public:
    PackMapEnvironmentV40();
    PackMapEnvironmentV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV40(const PackMapEnvironmentV40 &p_other);
    PackMapEnvironmentV40 &operator=(const PackMapEnvironmentV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV40 Gw2Struct;
};

/* Version: 39, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<39>{
struct PackMapEnvDataLightV39 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV39();
    PackMapEnvDataLightV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV39(const PackMapEnvDataLightV39 &p_other);
    PackMapEnvDataLightV39 &operator=(const PackMapEnvDataLightV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV39 {
    helpers::Ptr<PackMapEnvDataLightV39> lights;

public:
    PackMapEnvDataLightingV39();
    PackMapEnvDataLightingV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV39(const PackMapEnvDataLightingV39 &p_other);
    PackMapEnvDataLightingV39 &operator=(const PackMapEnvDataLightingV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingCharV10 {
    float sunScale;
    float saturation;
    float sunFill;
    float ambScale;
    float ambFill;
    byte flags;

public:
    PackMapEnvDataLightingCharV10();
    PackMapEnvDataLightingCharV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingCharV10(const PackMapEnvDataLightingCharV10 &p_other);
    PackMapEnvDataLightingCharV10 &operator=(const PackMapEnvDataLightingCharV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV39 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV39();
    PackMapEnvDataLayerAttributesV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV39(const PackMapEnvDataLayerAttributesV39 &p_other);
    PackMapEnvDataLayerAttributesV39 &operator=(const PackMapEnvDataLayerAttributesV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV39 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV39> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV39();
    PackMapEnvDataLayerV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV39(const PackMapEnvDataLayerV39 &p_other);
    PackMapEnvDataLayerV39 &operator=(const PackMapEnvDataLayerV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV39 {
    helpers::Array<PackMapEnvDataLayerV39> layers;

public:
    PackMapEnvDataCloudsV39();
    PackMapEnvDataCloudsV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV39(const PackMapEnvDataCloudsV39 &p_other);
    PackMapEnvDataCloudsV39 &operator=(const PackMapEnvDataCloudsV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV39 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV39();
    PackMapEnvDataEffectV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV39(const PackMapEnvDataEffectV39 &p_other);
    PackMapEnvDataEffectV39 &operator=(const PackMapEnvDataEffectV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV39 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV39();
    PackMapEnvDataHazeV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV39(const PackMapEnvDataHazeV39 &p_other);
    PackMapEnvDataHazeV39 &operator=(const PackMapEnvDataHazeV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV39 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV39();
    PackMapEnvDataPFieldV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV39(const PackMapEnvDataPFieldV39 &p_other);
    PackMapEnvDataPFieldV39 &operator=(const PackMapEnvDataPFieldV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV10 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV10();
    PackMapEnvDataPFieldCutoutV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV10(const PackMapEnvDataPFieldCutoutV10 &p_other);
    PackMapEnvDataPFieldCutoutV10 &operator=(const PackMapEnvDataPFieldCutoutV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV39 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV39();
    PackMapEnvDataSkyV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV39(const PackMapEnvDataSkyV39 &p_other);
    PackMapEnvDataSkyV39 &operator=(const PackMapEnvDataSkyV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV39 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV39();
    PackMapEnvDataSkyCardAttributesV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV39(const PackMapEnvDataSkyCardAttributesV39 &p_other);
    PackMapEnvDataSkyCardAttributesV39 &operator=(const PackMapEnvDataSkyCardAttributesV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV39 {
    PackMapEnvDataSkyCardAttributesV39 day;
    PackMapEnvDataSkyCardAttributesV39 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV39();
    PackMapEnvDataSkyCardV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV39(const PackMapEnvDataSkyCardV39 &p_other);
    PackMapEnvDataSkyCardV39 &operator=(const PackMapEnvDataSkyCardV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV39 {
    helpers::Array<PackMapEnvDataSkyCardV39> cards;

public:
    PackMapEnvDataSkyCardsV39();
    PackMapEnvDataSkyCardsV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV39(const PackMapEnvDataSkyCardsV39 &p_other);
    PackMapEnvDataSkyCardsV39 &operator=(const PackMapEnvDataSkyCardsV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV39 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;
    float depthAttenuation;

public:
    PackMapEnvDataWaterV39();
    PackMapEnvDataWaterV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV39(const PackMapEnvDataWaterV39 &p_other);
    PackMapEnvDataWaterV39 &operator=(const PackMapEnvDataWaterV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV39 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV39();
    PackMapEnvDataWindV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV39(const PackMapEnvDataWindV39 &p_other);
    PackMapEnvDataWindV39 &operator=(const PackMapEnvDataWindV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV39 {
    helpers::Array<PackMapEnvDataLightingV39> lighting;
    helpers::Array<PackMapEnvDataLightingCharV10> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV39> clouds;
    helpers::Ptr<PackMapEnvDataEffectV39> effect;
    helpers::Ptr<PackMapEnvDataHazeV39> haze;
    helpers::Ptr<PackMapEnvDataPFieldV39> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV10> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV39> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV39> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV39> water;
    helpers::Ptr<PackMapEnvDataWindV39> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;
    qword guid;

public:
    PackMapEnvDataLocalV39();
    PackMapEnvDataLocalV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV39(const PackMapEnvDataLocalV39 &p_other);
    PackMapEnvDataLocalV39 &operator=(const PackMapEnvDataLocalV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV39 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV39();
    PackMapEnvDataSkyModeTexV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV39(const PackMapEnvDataSkyModeTexV39 &p_other);
    PackMapEnvDataSkyModeTexV39 &operator=(const PackMapEnvDataSkyModeTexV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV39 {
    helpers::Array<PackMapEnvDataLightingV39> lighting;
    helpers::Array<PackMapEnvDataLightingCharV10> lightingChar;
    helpers::Ptr<PackMapEnvDataCloudsV39> clouds;
    helpers::Ptr<PackMapEnvDataEffectV39> effect;
    helpers::Ptr<PackMapEnvDataHazeV39> haze;
    helpers::Ptr<PackMapEnvDataPFieldV39> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV10> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV39> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV39> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV39> water;
    helpers::Ptr<PackMapEnvDataWindV39> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV39> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV39();
    PackMapEnvDataGlobalV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV39(const PackMapEnvDataGlobalV39 &p_other);
    PackMapEnvDataGlobalV39 &operator=(const PackMapEnvDataGlobalV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV39 {
    helpers::Array<PackMapEnvDataLocalV39> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV39> dataGlobal;

public:
    PackMapEnvironmentV39();
    PackMapEnvironmentV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV39(const PackMapEnvironmentV39 &p_other);
    PackMapEnvironmentV39 &operator=(const PackMapEnvironmentV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV39 Gw2Struct;
};

/* Version: 38, ReferencedFunction: 0x4104DF4000000001 */

template <>
struct Gw2Structenv<38>{
struct PackMapEnvDataLightV38 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV38();
    PackMapEnvDataLightV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV38(const PackMapEnvDataLightV38 &p_other);
    PackMapEnvDataLightV38 &operator=(const PackMapEnvDataLightV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV38 {
    helpers::Ptr<PackMapEnvDataLightV38> lights;

public:
    PackMapEnvDataLightingV38();
    PackMapEnvDataLightingV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV38(const PackMapEnvDataLightingV38 &p_other);
    PackMapEnvDataLightingV38 &operator=(const PackMapEnvDataLightingV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV38 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV38();
    PackMapEnvDataLayerAttributesV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV38(const PackMapEnvDataLayerAttributesV38 &p_other);
    PackMapEnvDataLayerAttributesV38 &operator=(const PackMapEnvDataLayerAttributesV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV38 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV38> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV38();
    PackMapEnvDataLayerV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV38(const PackMapEnvDataLayerV38 &p_other);
    PackMapEnvDataLayerV38 &operator=(const PackMapEnvDataLayerV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV38 {
    helpers::Array<PackMapEnvDataLayerV38> layers;

public:
    PackMapEnvDataCloudsV38();
    PackMapEnvDataCloudsV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV38(const PackMapEnvDataCloudsV38 &p_other);
    PackMapEnvDataCloudsV38 &operator=(const PackMapEnvDataCloudsV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV38 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;
    float focalDepth;
    float focalRange;

public:
    PackMapEnvDataEffectV38();
    PackMapEnvDataEffectV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV38(const PackMapEnvDataEffectV38 &p_other);
    PackMapEnvDataEffectV38 &operator=(const PackMapEnvDataEffectV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV38 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV38();
    PackMapEnvDataHazeV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV38(const PackMapEnvDataHazeV38 &p_other);
    PackMapEnvDataHazeV38 &operator=(const PackMapEnvDataHazeV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV38 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV38();
    PackMapEnvDataPFieldV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV38(const PackMapEnvDataPFieldV38 &p_other);
    PackMapEnvDataPFieldV38 &operator=(const PackMapEnvDataPFieldV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV9 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV9();
    PackMapEnvDataPFieldCutoutV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV9(const PackMapEnvDataPFieldCutoutV9 &p_other);
    PackMapEnvDataPFieldCutoutV9 &operator=(const PackMapEnvDataPFieldCutoutV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV38 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV38();
    PackMapEnvDataSkyV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV38(const PackMapEnvDataSkyV38 &p_other);
    PackMapEnvDataSkyV38 &operator=(const PackMapEnvDataSkyV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV38 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV38();
    PackMapEnvDataSkyCardAttributesV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV38(const PackMapEnvDataSkyCardAttributesV38 &p_other);
    PackMapEnvDataSkyCardAttributesV38 &operator=(const PackMapEnvDataSkyCardAttributesV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV38 {
    PackMapEnvDataSkyCardAttributesV38 day;
    PackMapEnvDataSkyCardAttributesV38 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV38();
    PackMapEnvDataSkyCardV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV38(const PackMapEnvDataSkyCardV38 &p_other);
    PackMapEnvDataSkyCardV38 &operator=(const PackMapEnvDataSkyCardV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV38 {
    helpers::Array<PackMapEnvDataSkyCardV38> cards;

public:
    PackMapEnvDataSkyCardsV38();
    PackMapEnvDataSkyCardsV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV38(const PackMapEnvDataSkyCardsV38 &p_other);
    PackMapEnvDataSkyCardsV38 &operator=(const PackMapEnvDataSkyCardsV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV38 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;
    float depthAttenuation;

public:
    PackMapEnvDataWaterV38();
    PackMapEnvDataWaterV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV38(const PackMapEnvDataWaterV38 &p_other);
    PackMapEnvDataWaterV38 &operator=(const PackMapEnvDataWaterV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV38 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV38();
    PackMapEnvDataWindV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV38(const PackMapEnvDataWindV38 &p_other);
    PackMapEnvDataWindV38 &operator=(const PackMapEnvDataWindV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV38 {
    helpers::Array<PackMapEnvDataLightingV38> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV38> clouds;
    helpers::Ptr<PackMapEnvDataEffectV38> effect;
    helpers::Ptr<PackMapEnvDataHazeV38> haze;
    helpers::Ptr<PackMapEnvDataPFieldV38> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV9> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV38> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV38> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV38> water;
    helpers::Ptr<PackMapEnvDataWindV38> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV38();
    PackMapEnvDataLocalV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV38(const PackMapEnvDataLocalV38 &p_other);
    PackMapEnvDataLocalV38 &operator=(const PackMapEnvDataLocalV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV38 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV38();
    PackMapEnvDataSkyModeTexV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV38(const PackMapEnvDataSkyModeTexV38 &p_other);
    PackMapEnvDataSkyModeTexV38 &operator=(const PackMapEnvDataSkyModeTexV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV38 {
    helpers::Array<PackMapEnvDataLightingV38> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV38> clouds;
    helpers::Ptr<PackMapEnvDataEffectV38> effect;
    helpers::Ptr<PackMapEnvDataHazeV38> haze;
    helpers::Ptr<PackMapEnvDataPFieldV38> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV9> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV38> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV38> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV38> water;
    helpers::Ptr<PackMapEnvDataWindV38> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV38> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV38();
    PackMapEnvDataGlobalV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV38(const PackMapEnvDataGlobalV38 &p_other);
    PackMapEnvDataGlobalV38 &operator=(const PackMapEnvDataGlobalV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV38 {
    helpers::Array<PackMapEnvDataLocalV38> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV38> dataGlobal;

public:
    PackMapEnvironmentV38();
    PackMapEnvironmentV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV38(const PackMapEnvironmentV38 &p_other);
    PackMapEnvironmentV38 &operator=(const PackMapEnvironmentV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV38 Gw2Struct;
};

/* Version: 37, ReferencedFunction: 0x4104DEA000000001 */

template <>
struct Gw2Structenv<37>{
struct PackMapEnvDataLightV37 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV37();
    PackMapEnvDataLightV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV37(const PackMapEnvDataLightV37 &p_other);
    PackMapEnvDataLightV37 &operator=(const PackMapEnvDataLightV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV37 {
    helpers::Ptr<PackMapEnvDataLightV37> lights;

public:
    PackMapEnvDataLightingV37();
    PackMapEnvDataLightingV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV37(const PackMapEnvDataLightingV37 &p_other);
    PackMapEnvDataLightingV37 &operator=(const PackMapEnvDataLightingV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV37 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV37();
    PackMapEnvDataLayerAttributesV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV37(const PackMapEnvDataLayerAttributesV37 &p_other);
    PackMapEnvDataLayerAttributesV37 &operator=(const PackMapEnvDataLayerAttributesV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV37 {
    float altitude;
    float cutOut;
    float depth;
    float extent;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV37> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV37();
    PackMapEnvDataLayerV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV37(const PackMapEnvDataLayerV37 &p_other);
    PackMapEnvDataLayerV37 &operator=(const PackMapEnvDataLayerV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV37 {
    helpers::Array<PackMapEnvDataLayerV37> layers;

public:
    PackMapEnvDataCloudsV37();
    PackMapEnvDataCloudsV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV37(const PackMapEnvDataCloudsV37 &p_other);
    PackMapEnvDataCloudsV37 &operator=(const PackMapEnvDataCloudsV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV37 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV37();
    PackMapEnvDataEffectV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV37(const PackMapEnvDataEffectV37 &p_other);
    PackMapEnvDataEffectV37 &operator=(const PackMapEnvDataEffectV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV37 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV37();
    PackMapEnvDataHazeV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV37(const PackMapEnvDataHazeV37 &p_other);
    PackMapEnvDataHazeV37 &operator=(const PackMapEnvDataHazeV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV37 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV37();
    PackMapEnvDataPFieldV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV37(const PackMapEnvDataPFieldV37 &p_other);
    PackMapEnvDataPFieldV37 &operator=(const PackMapEnvDataPFieldV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV8 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV8();
    PackMapEnvDataPFieldCutoutV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV8(const PackMapEnvDataPFieldCutoutV8 &p_other);
    PackMapEnvDataPFieldCutoutV8 &operator=(const PackMapEnvDataPFieldCutoutV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV37 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV37();
    PackMapEnvDataSkyV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV37(const PackMapEnvDataSkyV37 &p_other);
    PackMapEnvDataSkyV37 &operator=(const PackMapEnvDataSkyV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV37 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV37();
    PackMapEnvDataSkyCardAttributesV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV37(const PackMapEnvDataSkyCardAttributesV37 &p_other);
    PackMapEnvDataSkyCardAttributesV37 &operator=(const PackMapEnvDataSkyCardAttributesV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV37 {
    PackMapEnvDataSkyCardAttributesV37 day;
    PackMapEnvDataSkyCardAttributesV37 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV37();
    PackMapEnvDataSkyCardV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV37(const PackMapEnvDataSkyCardV37 &p_other);
    PackMapEnvDataSkyCardV37 &operator=(const PackMapEnvDataSkyCardV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV37 {
    helpers::Array<PackMapEnvDataSkyCardV37> cards;

public:
    PackMapEnvDataSkyCardsV37();
    PackMapEnvDataSkyCardsV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV37(const PackMapEnvDataSkyCardsV37 &p_other);
    PackMapEnvDataSkyCardsV37 &operator=(const PackMapEnvDataSkyCardsV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV37 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;
    float depthAttenuation;

public:
    PackMapEnvDataWaterV37();
    PackMapEnvDataWaterV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV37(const PackMapEnvDataWaterV37 &p_other);
    PackMapEnvDataWaterV37 &operator=(const PackMapEnvDataWaterV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV37 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV37();
    PackMapEnvDataWindV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV37(const PackMapEnvDataWindV37 &p_other);
    PackMapEnvDataWindV37 &operator=(const PackMapEnvDataWindV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV37 {
    helpers::Array<PackMapEnvDataLightingV37> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV37> clouds;
    helpers::Ptr<PackMapEnvDataEffectV37> effect;
    helpers::Ptr<PackMapEnvDataHazeV37> haze;
    helpers::Ptr<PackMapEnvDataPFieldV37> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV8> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV37> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV37> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV37> water;
    helpers::Ptr<PackMapEnvDataWindV37> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV37();
    PackMapEnvDataLocalV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV37(const PackMapEnvDataLocalV37 &p_other);
    PackMapEnvDataLocalV37 &operator=(const PackMapEnvDataLocalV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV37 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV37();
    PackMapEnvDataSkyModeTexV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV37(const PackMapEnvDataSkyModeTexV37 &p_other);
    PackMapEnvDataSkyModeTexV37 &operator=(const PackMapEnvDataSkyModeTexV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV37 {
    helpers::Array<PackMapEnvDataLightingV37> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV37> clouds;
    helpers::Ptr<PackMapEnvDataEffectV37> effect;
    helpers::Ptr<PackMapEnvDataHazeV37> haze;
    helpers::Ptr<PackMapEnvDataPFieldV37> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV8> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV37> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV37> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV37> water;
    helpers::Ptr<PackMapEnvDataWindV37> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV37> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV37();
    PackMapEnvDataGlobalV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV37(const PackMapEnvDataGlobalV37 &p_other);
    PackMapEnvDataGlobalV37 &operator=(const PackMapEnvDataGlobalV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV37 {
    helpers::Array<PackMapEnvDataLocalV37> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV37> dataGlobal;

public:
    PackMapEnvironmentV37();
    PackMapEnvironmentV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV37(const PackMapEnvironmentV37 &p_other);
    PackMapEnvironmentV37 &operator=(const PackMapEnvironmentV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV37 Gw2Struct;
};

/* Version: 36, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<36>{
struct PackMapEnvDataLightV36 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV36();
    PackMapEnvDataLightV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV36(const PackMapEnvDataLightV36 &p_other);
    PackMapEnvDataLightV36 &operator=(const PackMapEnvDataLightV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV36 {
    helpers::Ptr<PackMapEnvDataLightV36> lights;

public:
    PackMapEnvDataLightingV36();
    PackMapEnvDataLightingV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV36(const PackMapEnvDataLightingV36 &p_other);
    PackMapEnvDataLightingV36 &operator=(const PackMapEnvDataLightingV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV36 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV36();
    PackMapEnvDataLayerAttributesV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV36(const PackMapEnvDataLayerAttributesV36 &p_other);
    PackMapEnvDataLayerAttributesV36 &operator=(const PackMapEnvDataLayerAttributesV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV36 {
    float altitude;
    float cutOut;
    float depth;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV36> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV36();
    PackMapEnvDataLayerV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV36(const PackMapEnvDataLayerV36 &p_other);
    PackMapEnvDataLayerV36 &operator=(const PackMapEnvDataLayerV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV36 {
    helpers::Array<PackMapEnvDataLayerV36> layers;

public:
    PackMapEnvDataCloudsV36();
    PackMapEnvDataCloudsV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV36(const PackMapEnvDataCloudsV36 &p_other);
    PackMapEnvDataCloudsV36 &operator=(const PackMapEnvDataCloudsV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV36 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV36();
    PackMapEnvDataEffectV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV36(const PackMapEnvDataEffectV36 &p_other);
    PackMapEnvDataEffectV36 &operator=(const PackMapEnvDataEffectV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV36 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV36();
    PackMapEnvDataHazeV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV36(const PackMapEnvDataHazeV36 &p_other);
    PackMapEnvDataHazeV36 &operator=(const PackMapEnvDataHazeV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV36 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV36();
    PackMapEnvDataPFieldV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV36(const PackMapEnvDataPFieldV36 &p_other);
    PackMapEnvDataPFieldV36 &operator=(const PackMapEnvDataPFieldV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV7 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV7();
    PackMapEnvDataPFieldCutoutV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV7(const PackMapEnvDataPFieldCutoutV7 &p_other);
    PackMapEnvDataPFieldCutoutV7 &operator=(const PackMapEnvDataPFieldCutoutV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV36 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV36();
    PackMapEnvDataSkyV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV36(const PackMapEnvDataSkyV36 &p_other);
    PackMapEnvDataSkyV36 &operator=(const PackMapEnvDataSkyV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV36 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV36();
    PackMapEnvDataSkyCardAttributesV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV36(const PackMapEnvDataSkyCardAttributesV36 &p_other);
    PackMapEnvDataSkyCardAttributesV36 &operator=(const PackMapEnvDataSkyCardAttributesV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV36 {
    PackMapEnvDataSkyCardAttributesV36 day;
    PackMapEnvDataSkyCardAttributesV36 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV36();
    PackMapEnvDataSkyCardV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV36(const PackMapEnvDataSkyCardV36 &p_other);
    PackMapEnvDataSkyCardV36 &operator=(const PackMapEnvDataSkyCardV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV36 {
    helpers::Array<PackMapEnvDataSkyCardV36> cards;

public:
    PackMapEnvDataSkyCardsV36();
    PackMapEnvDataSkyCardsV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV36(const PackMapEnvDataSkyCardsV36 &p_other);
    PackMapEnvDataSkyCardsV36 &operator=(const PackMapEnvDataSkyCardsV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV36 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;
    float depthAttenuation;

public:
    PackMapEnvDataWaterV36();
    PackMapEnvDataWaterV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV36(const PackMapEnvDataWaterV36 &p_other);
    PackMapEnvDataWaterV36 &operator=(const PackMapEnvDataWaterV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV36 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV36();
    PackMapEnvDataWindV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV36(const PackMapEnvDataWindV36 &p_other);
    PackMapEnvDataWindV36 &operator=(const PackMapEnvDataWindV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV36 {
    helpers::Array<PackMapEnvDataLightingV36> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV36> clouds;
    helpers::Ptr<PackMapEnvDataEffectV36> effect;
    helpers::Ptr<PackMapEnvDataHazeV36> haze;
    helpers::Ptr<PackMapEnvDataPFieldV36> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV7> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV36> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV36> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV36> water;
    helpers::Ptr<PackMapEnvDataWindV36> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV36();
    PackMapEnvDataLocalV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV36(const PackMapEnvDataLocalV36 &p_other);
    PackMapEnvDataLocalV36 &operator=(const PackMapEnvDataLocalV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV36 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV36();
    PackMapEnvDataSkyModeTexV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV36(const PackMapEnvDataSkyModeTexV36 &p_other);
    PackMapEnvDataSkyModeTexV36 &operator=(const PackMapEnvDataSkyModeTexV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV36 {
    helpers::Array<PackMapEnvDataLightingV36> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV36> clouds;
    helpers::Ptr<PackMapEnvDataEffectV36> effect;
    helpers::Ptr<PackMapEnvDataHazeV36> haze;
    helpers::Ptr<PackMapEnvDataPFieldV36> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV7> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV36> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV36> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV36> water;
    helpers::Ptr<PackMapEnvDataWindV36> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV36> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV36();
    PackMapEnvDataGlobalV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV36(const PackMapEnvDataGlobalV36 &p_other);
    PackMapEnvDataGlobalV36 &operator=(const PackMapEnvDataGlobalV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV36 {
    helpers::Array<PackMapEnvDataLocalV36> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV36> dataGlobal;

public:
    PackMapEnvironmentV36();
    PackMapEnvironmentV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV36(const PackMapEnvironmentV36 &p_other);
    PackMapEnvironmentV36 &operator=(const PackMapEnvironmentV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV36 Gw2Struct;
};

/* Version: 35, ReferencedFunction: 0x4104DE4000000001 */

template <>
struct Gw2Structenv<35>{
struct PackMapEnvDataLightV35 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV35();
    PackMapEnvDataLightV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV35(const PackMapEnvDataLightV35 &p_other);
    PackMapEnvDataLightV35 &operator=(const PackMapEnvDataLightV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV35 {
    helpers::Ptr<PackMapEnvDataLightV35> lights;

public:
    PackMapEnvDataLightingV35();
    PackMapEnvDataLightingV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV35(const PackMapEnvDataLightingV35 &p_other);
    PackMapEnvDataLightingV35 &operator=(const PackMapEnvDataLightingV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV35 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV35();
    PackMapEnvDataLayerAttributesV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV35(const PackMapEnvDataLayerAttributesV35 &p_other);
    PackMapEnvDataLayerAttributesV35 &operator=(const PackMapEnvDataLayerAttributesV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV35 {
    float altitude;
    float cutOut;
    float depth;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV35> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV35();
    PackMapEnvDataLayerV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV35(const PackMapEnvDataLayerV35 &p_other);
    PackMapEnvDataLayerV35 &operator=(const PackMapEnvDataLayerV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV35 {
    helpers::Array<PackMapEnvDataLayerV35> layers;

public:
    PackMapEnvDataCloudsV35();
    PackMapEnvDataCloudsV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV35(const PackMapEnvDataCloudsV35 &p_other);
    PackMapEnvDataCloudsV35 &operator=(const PackMapEnvDataCloudsV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV35 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV35();
    PackMapEnvDataEffectV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV35(const PackMapEnvDataEffectV35 &p_other);
    PackMapEnvDataEffectV35 &operator=(const PackMapEnvDataEffectV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV35 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV35();
    PackMapEnvDataHazeV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV35(const PackMapEnvDataHazeV35 &p_other);
    PackMapEnvDataHazeV35 &operator=(const PackMapEnvDataHazeV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV35 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV35();
    PackMapEnvDataPFieldV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV35(const PackMapEnvDataPFieldV35 &p_other);
    PackMapEnvDataPFieldV35 &operator=(const PackMapEnvDataPFieldV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldCutoutV6 {
    helpers::WString name;
    float4 x;
    float4 y;
    float4 z;

public:
    PackMapEnvDataPFieldCutoutV6();
    PackMapEnvDataPFieldCutoutV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldCutoutV6(const PackMapEnvDataPFieldCutoutV6 &p_other);
    PackMapEnvDataPFieldCutoutV6 &operator=(const PackMapEnvDataPFieldCutoutV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV35 {
    byte flags;
    float dayBrightness;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightBrightness;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV35();
    PackMapEnvDataSkyV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV35(const PackMapEnvDataSkyV35 &p_other);
    PackMapEnvDataSkyV35 &operator=(const PackMapEnvDataSkyV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV35 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV35();
    PackMapEnvDataSkyCardAttributesV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV35(const PackMapEnvDataSkyCardAttributesV35 &p_other);
    PackMapEnvDataSkyCardAttributesV35 &operator=(const PackMapEnvDataSkyCardAttributesV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV35 {
    PackMapEnvDataSkyCardAttributesV35 day;
    PackMapEnvDataSkyCardAttributesV35 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV35();
    PackMapEnvDataSkyCardV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV35(const PackMapEnvDataSkyCardV35 &p_other);
    PackMapEnvDataSkyCardV35 &operator=(const PackMapEnvDataSkyCardV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV35 {
    helpers::Array<PackMapEnvDataSkyCardV35> cards;

public:
    PackMapEnvDataSkyCardsV35();
    PackMapEnvDataSkyCardsV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV35(const PackMapEnvDataSkyCardsV35 &p_other);
    PackMapEnvDataSkyCardsV35 &operator=(const PackMapEnvDataSkyCardsV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV35 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV35();
    PackMapEnvDataWaterV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV35(const PackMapEnvDataWaterV35 &p_other);
    PackMapEnvDataWaterV35 &operator=(const PackMapEnvDataWaterV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV35 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV35();
    PackMapEnvDataWindV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV35(const PackMapEnvDataWindV35 &p_other);
    PackMapEnvDataWindV35 &operator=(const PackMapEnvDataWindV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV35 {
    helpers::Array<PackMapEnvDataLightingV35> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV35> clouds;
    helpers::Ptr<PackMapEnvDataEffectV35> effect;
    helpers::Ptr<PackMapEnvDataHazeV35> haze;
    helpers::Ptr<PackMapEnvDataPFieldV35> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV6> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV35> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV35> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV35> water;
    helpers::Ptr<PackMapEnvDataWindV35> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV35();
    PackMapEnvDataLocalV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV35(const PackMapEnvDataLocalV35 &p_other);
    PackMapEnvDataLocalV35 &operator=(const PackMapEnvDataLocalV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV35 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV35();
    PackMapEnvDataSkyModeTexV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV35(const PackMapEnvDataSkyModeTexV35 &p_other);
    PackMapEnvDataSkyModeTexV35 &operator=(const PackMapEnvDataSkyModeTexV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV35 {
    helpers::Array<PackMapEnvDataLightingV35> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV35> clouds;
    helpers::Ptr<PackMapEnvDataEffectV35> effect;
    helpers::Ptr<PackMapEnvDataHazeV35> haze;
    helpers::Ptr<PackMapEnvDataPFieldV35> particleFields;
    helpers::Array<PackMapEnvDataPFieldCutoutV6> particleFieldCutouts;
    helpers::Ptr<PackMapEnvDataSkyV35> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV35> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV35> water;
    helpers::Ptr<PackMapEnvDataWindV35> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV35> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV35();
    PackMapEnvDataGlobalV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV35(const PackMapEnvDataGlobalV35 &p_other);
    PackMapEnvDataGlobalV35 &operator=(const PackMapEnvDataGlobalV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV35 {
    helpers::Array<PackMapEnvDataLocalV35> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV35> dataGlobal;

public:
    PackMapEnvironmentV35();
    PackMapEnvironmentV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV35(const PackMapEnvironmentV35 &p_other);
    PackMapEnvironmentV35 &operator=(const PackMapEnvironmentV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV35 Gw2Struct;
};

/* Version: 34, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<34>{
struct PackMapEnvDataLightV34 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV34();
    PackMapEnvDataLightV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV34(const PackMapEnvDataLightV34 &p_other);
    PackMapEnvDataLightV34 &operator=(const PackMapEnvDataLightV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV34 {
    helpers::Ptr<PackMapEnvDataLightV34> lights;

public:
    PackMapEnvDataLightingV34();
    PackMapEnvDataLightingV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV34(const PackMapEnvDataLightingV34 &p_other);
    PackMapEnvDataLightingV34 &operator=(const PackMapEnvDataLightingV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV34 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV34();
    PackMapEnvDataLayerAttributesV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV34(const PackMapEnvDataLayerAttributesV34 &p_other);
    PackMapEnvDataLayerAttributesV34 &operator=(const PackMapEnvDataLayerAttributesV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV34 {
    float altitude;
    float cutOut;
    float depth;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV34> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV34();
    PackMapEnvDataLayerV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV34(const PackMapEnvDataLayerV34 &p_other);
    PackMapEnvDataLayerV34 &operator=(const PackMapEnvDataLayerV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV34 {
    helpers::Array<PackMapEnvDataLayerV34> layers;

public:
    PackMapEnvDataCloudsV34();
    PackMapEnvDataCloudsV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV34(const PackMapEnvDataCloudsV34 &p_other);
    PackMapEnvDataCloudsV34 &operator=(const PackMapEnvDataCloudsV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV34 {
    byte4 glow;
    byte4 tintColor;
    byte4 tintTargetColor;
    float saturation;
    float tintAmount;
    float tintFocus;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV34();
    PackMapEnvDataEffectV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV34(const PackMapEnvDataEffectV34 &p_other);
    PackMapEnvDataEffectV34 &operator=(const PackMapEnvDataEffectV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV34 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV34();
    PackMapEnvDataHazeV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV34(const PackMapEnvDataHazeV34 &p_other);
    PackMapEnvDataHazeV34 &operator=(const PackMapEnvDataHazeV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV34 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV34();
    PackMapEnvDataPFieldV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV34(const PackMapEnvDataPFieldV34 &p_other);
    PackMapEnvDataPFieldV34 &operator=(const PackMapEnvDataPFieldV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV34 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV34();
    PackMapEnvDataSkyV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV34(const PackMapEnvDataSkyV34 &p_other);
    PackMapEnvDataSkyV34 &operator=(const PackMapEnvDataSkyV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV34 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV34();
    PackMapEnvDataSkyCardAttributesV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV34(const PackMapEnvDataSkyCardAttributesV34 &p_other);
    PackMapEnvDataSkyCardAttributesV34 &operator=(const PackMapEnvDataSkyCardAttributesV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV34 {
    PackMapEnvDataSkyCardAttributesV34 day;
    PackMapEnvDataSkyCardAttributesV34 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV34();
    PackMapEnvDataSkyCardV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV34(const PackMapEnvDataSkyCardV34 &p_other);
    PackMapEnvDataSkyCardV34 &operator=(const PackMapEnvDataSkyCardV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV34 {
    helpers::Array<PackMapEnvDataSkyCardV34> cards;

public:
    PackMapEnvDataSkyCardsV34();
    PackMapEnvDataSkyCardsV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV34(const PackMapEnvDataSkyCardsV34 &p_other);
    PackMapEnvDataSkyCardsV34 &operator=(const PackMapEnvDataSkyCardsV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV34 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV34();
    PackMapEnvDataWaterV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV34(const PackMapEnvDataWaterV34 &p_other);
    PackMapEnvDataWaterV34 &operator=(const PackMapEnvDataWaterV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV34 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV34();
    PackMapEnvDataWindV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV34(const PackMapEnvDataWindV34 &p_other);
    PackMapEnvDataWindV34 &operator=(const PackMapEnvDataWindV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV34 {
    helpers::Array<PackMapEnvDataLightingV34> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV34> clouds;
    helpers::Ptr<PackMapEnvDataEffectV34> effect;
    helpers::Ptr<PackMapEnvDataHazeV34> haze;
    helpers::Ptr<PackMapEnvDataPFieldV34> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV34> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV34> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV34> water;
    helpers::Ptr<PackMapEnvDataWindV34> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV34();
    PackMapEnvDataLocalV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV34(const PackMapEnvDataLocalV34 &p_other);
    PackMapEnvDataLocalV34 &operator=(const PackMapEnvDataLocalV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV34 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV34();
    PackMapEnvDataSkyModeTexV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV34(const PackMapEnvDataSkyModeTexV34 &p_other);
    PackMapEnvDataSkyModeTexV34 &operator=(const PackMapEnvDataSkyModeTexV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV34 {
    helpers::Array<PackMapEnvDataLightingV34> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV34> clouds;
    helpers::Ptr<PackMapEnvDataEffectV34> effect;
    helpers::Ptr<PackMapEnvDataHazeV34> haze;
    helpers::Ptr<PackMapEnvDataPFieldV34> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV34> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV34> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV34> water;
    helpers::Ptr<PackMapEnvDataWindV34> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV34> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV34();
    PackMapEnvDataGlobalV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV34(const PackMapEnvDataGlobalV34 &p_other);
    PackMapEnvDataGlobalV34 &operator=(const PackMapEnvDataGlobalV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV34 {
    helpers::Array<PackMapEnvDataLocalV34> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV34> dataGlobal;

public:
    PackMapEnvironmentV34();
    PackMapEnvironmentV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV34(const PackMapEnvironmentV34 &p_other);
    PackMapEnvironmentV34 &operator=(const PackMapEnvironmentV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV34 Gw2Struct;
};

/* Version: 33, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<33>{
struct PackMapEnvDataLightV33 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV33();
    PackMapEnvDataLightV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV33(const PackMapEnvDataLightV33 &p_other);
    PackMapEnvDataLightV33 &operator=(const PackMapEnvDataLightV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV33 {
    helpers::Ptr<PackMapEnvDataLightV33> lights;

public:
    PackMapEnvDataLightingV33();
    PackMapEnvDataLightingV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV33(const PackMapEnvDataLightingV33 &p_other);
    PackMapEnvDataLightingV33 &operator=(const PackMapEnvDataLightingV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV33 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV33();
    PackMapEnvDataLayerAttributesV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV33(const PackMapEnvDataLayerAttributesV33 &p_other);
    PackMapEnvDataLayerAttributesV33 &operator=(const PackMapEnvDataLayerAttributesV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV33 {
    float altitude;
    float cutOut;
    float depth;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV33> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV33();
    PackMapEnvDataLayerV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV33(const PackMapEnvDataLayerV33 &p_other);
    PackMapEnvDataLayerV33 &operator=(const PackMapEnvDataLayerV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV33 {
    helpers::Array<PackMapEnvDataLayerV33> layers;

public:
    PackMapEnvDataCloudsV33();
    PackMapEnvDataCloudsV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV33(const PackMapEnvDataCloudsV33 &p_other);
    PackMapEnvDataCloudsV33 &operator=(const PackMapEnvDataCloudsV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV33 {
    byte4 glow;
    byte4 tintColor;
    float saturation;
    float tintAmount;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV33();
    PackMapEnvDataEffectV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV33(const PackMapEnvDataEffectV33 &p_other);
    PackMapEnvDataEffectV33 &operator=(const PackMapEnvDataEffectV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV33 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV33();
    PackMapEnvDataHazeV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV33(const PackMapEnvDataHazeV33 &p_other);
    PackMapEnvDataHazeV33 &operator=(const PackMapEnvDataHazeV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV33 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV33();
    PackMapEnvDataPFieldV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV33(const PackMapEnvDataPFieldV33 &p_other);
    PackMapEnvDataPFieldV33 &operator=(const PackMapEnvDataPFieldV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV33 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV33();
    PackMapEnvDataSkyV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV33(const PackMapEnvDataSkyV33 &p_other);
    PackMapEnvDataSkyV33 &operator=(const PackMapEnvDataSkyV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV33 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV33();
    PackMapEnvDataSkyCardAttributesV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV33(const PackMapEnvDataSkyCardAttributesV33 &p_other);
    PackMapEnvDataSkyCardAttributesV33 &operator=(const PackMapEnvDataSkyCardAttributesV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV33 {
    PackMapEnvDataSkyCardAttributesV33 day;
    PackMapEnvDataSkyCardAttributesV33 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV33();
    PackMapEnvDataSkyCardV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV33(const PackMapEnvDataSkyCardV33 &p_other);
    PackMapEnvDataSkyCardV33 &operator=(const PackMapEnvDataSkyCardV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV33 {
    helpers::Array<PackMapEnvDataSkyCardV33> cards;

public:
    PackMapEnvDataSkyCardsV33();
    PackMapEnvDataSkyCardsV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV33(const PackMapEnvDataSkyCardsV33 &p_other);
    PackMapEnvDataSkyCardsV33 &operator=(const PackMapEnvDataSkyCardsV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV33 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV33();
    PackMapEnvDataWaterV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV33(const PackMapEnvDataWaterV33 &p_other);
    PackMapEnvDataWaterV33 &operator=(const PackMapEnvDataWaterV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV33 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV33();
    PackMapEnvDataWindV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV33(const PackMapEnvDataWindV33 &p_other);
    PackMapEnvDataWindV33 &operator=(const PackMapEnvDataWindV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV33 {
    helpers::Array<PackMapEnvDataLightingV33> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV33> clouds;
    helpers::Ptr<PackMapEnvDataEffectV33> effect;
    helpers::Ptr<PackMapEnvDataHazeV33> haze;
    helpers::Ptr<PackMapEnvDataPFieldV33> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV33> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV33> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV33> water;
    helpers::Ptr<PackMapEnvDataWindV33> wind;
    helpers::WString name;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV33();
    PackMapEnvDataLocalV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV33(const PackMapEnvDataLocalV33 &p_other);
    PackMapEnvDataLocalV33 &operator=(const PackMapEnvDataLocalV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV33 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV33();
    PackMapEnvDataSkyModeTexV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV33(const PackMapEnvDataSkyModeTexV33 &p_other);
    PackMapEnvDataSkyModeTexV33 &operator=(const PackMapEnvDataSkyModeTexV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV33 {
    helpers::Array<PackMapEnvDataLightingV33> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV33> clouds;
    helpers::Ptr<PackMapEnvDataEffectV33> effect;
    helpers::Ptr<PackMapEnvDataHazeV33> haze;
    helpers::Ptr<PackMapEnvDataPFieldV33> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV33> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV33> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV33> water;
    helpers::Ptr<PackMapEnvDataWindV33> wind;
    helpers::WString name;
    helpers::Array<PackMapEnvDataSkyModeTexV33> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV33();
    PackMapEnvDataGlobalV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV33(const PackMapEnvDataGlobalV33 &p_other);
    PackMapEnvDataGlobalV33 &operator=(const PackMapEnvDataGlobalV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV33 {
    helpers::Array<PackMapEnvDataLocalV33> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV33> dataGlobal;

public:
    PackMapEnvironmentV33();
    PackMapEnvironmentV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV33(const PackMapEnvironmentV33 &p_other);
    PackMapEnvironmentV33 &operator=(const PackMapEnvironmentV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV33 Gw2Struct;
};

/* Version: 32, ReferencedFunction: 0x4104DC8000000001 */

template <>
struct Gw2Structenv<32>{
struct PackMapEnvDataLightV32 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV32();
    PackMapEnvDataLightV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV32(const PackMapEnvDataLightV32 &p_other);
    PackMapEnvDataLightV32 &operator=(const PackMapEnvDataLightV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV32 {
    helpers::Ptr<PackMapEnvDataLightV32> lights;

public:
    PackMapEnvDataLightingV32();
    PackMapEnvDataLightingV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV32(const PackMapEnvDataLightingV32 &p_other);
    PackMapEnvDataLightingV32 &operator=(const PackMapEnvDataLightingV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV32 {
    float density;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV32();
    PackMapEnvDataLayerAttributesV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV32(const PackMapEnvDataLayerAttributesV32 &p_other);
    PackMapEnvDataLayerAttributesV32 &operator=(const PackMapEnvDataLayerAttributesV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV32 {
    float altitude;
    float cutOut;
    float depth;
    float scale;
    helpers::FileName texture;
    helpers::Array<PackMapEnvDataLayerAttributesV32> attributes;
    helpers::WString name;

public:
    PackMapEnvDataLayerV32();
    PackMapEnvDataLayerV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV32(const PackMapEnvDataLayerV32 &p_other);
    PackMapEnvDataLayerV32 &operator=(const PackMapEnvDataLayerV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV32 {
    helpers::Array<PackMapEnvDataLayerV32> layers;

public:
    PackMapEnvDataCloudsV32();
    PackMapEnvDataCloudsV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV32(const PackMapEnvDataCloudsV32 &p_other);
    PackMapEnvDataCloudsV32 &operator=(const PackMapEnvDataCloudsV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV32 {
    byte4 glow;
    byte4 tintColor;
    float saturation;
    float tintAmount;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV32();
    PackMapEnvDataEffectV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV32(const PackMapEnvDataEffectV32 &p_other);
    PackMapEnvDataEffectV32 &operator=(const PackMapEnvDataEffectV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV32 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV32();
    PackMapEnvDataHazeV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV32(const PackMapEnvDataHazeV32 &p_other);
    PackMapEnvDataHazeV32 &operator=(const PackMapEnvDataHazeV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV32 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV32();
    PackMapEnvDataPFieldV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV32(const PackMapEnvDataPFieldV32 &p_other);
    PackMapEnvDataPFieldV32 &operator=(const PackMapEnvDataPFieldV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV32 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV32();
    PackMapEnvDataSkyV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV32(const PackMapEnvDataSkyV32 &p_other);
    PackMapEnvDataSkyV32 &operator=(const PackMapEnvDataSkyV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV32 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV32();
    PackMapEnvDataSkyCardAttributesV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV32(const PackMapEnvDataSkyCardAttributesV32 &p_other);
    PackMapEnvDataSkyCardAttributesV32 &operator=(const PackMapEnvDataSkyCardAttributesV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV32 {
    PackMapEnvDataSkyCardAttributesV32 day;
    PackMapEnvDataSkyCardAttributesV32 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV32();
    PackMapEnvDataSkyCardV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV32(const PackMapEnvDataSkyCardV32 &p_other);
    PackMapEnvDataSkyCardV32 &operator=(const PackMapEnvDataSkyCardV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV32 {
    helpers::Array<PackMapEnvDataSkyCardV32> cards;

public:
    PackMapEnvDataSkyCardsV32();
    PackMapEnvDataSkyCardsV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV32(const PackMapEnvDataSkyCardsV32 &p_other);
    PackMapEnvDataSkyCardsV32 &operator=(const PackMapEnvDataSkyCardsV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV32 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV32();
    PackMapEnvDataWaterV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV32(const PackMapEnvDataWaterV32 &p_other);
    PackMapEnvDataWaterV32 &operator=(const PackMapEnvDataWaterV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV32 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV32();
    PackMapEnvDataWindV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV32(const PackMapEnvDataWindV32 &p_other);
    PackMapEnvDataWindV32 &operator=(const PackMapEnvDataWindV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV32 {
    helpers::Array<PackMapEnvDataLightingV32> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV32> clouds;
    helpers::Ptr<PackMapEnvDataEffectV32> effect;
    helpers::Ptr<PackMapEnvDataHazeV32> haze;
    helpers::Ptr<PackMapEnvDataPFieldV32> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV32> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV32> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV32> water;
    helpers::Ptr<PackMapEnvDataWindV32> wind;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV32();
    PackMapEnvDataLocalV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV32(const PackMapEnvDataLocalV32 &p_other);
    PackMapEnvDataLocalV32 &operator=(const PackMapEnvDataLocalV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV32 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV32();
    PackMapEnvDataSkyModeTexV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV32(const PackMapEnvDataSkyModeTexV32 &p_other);
    PackMapEnvDataSkyModeTexV32 &operator=(const PackMapEnvDataSkyModeTexV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV32 {
    helpers::Array<PackMapEnvDataLightingV32> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV32> clouds;
    helpers::Ptr<PackMapEnvDataEffectV32> effect;
    helpers::Ptr<PackMapEnvDataHazeV32> haze;
    helpers::Ptr<PackMapEnvDataPFieldV32> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV32> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV32> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV32> water;
    helpers::Ptr<PackMapEnvDataWindV32> wind;
    helpers::Array<PackMapEnvDataSkyModeTexV32> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV32();
    PackMapEnvDataGlobalV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV32(const PackMapEnvDataGlobalV32 &p_other);
    PackMapEnvDataGlobalV32 &operator=(const PackMapEnvDataGlobalV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV32 {
    helpers::Array<PackMapEnvDataLocalV32> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV32> dataGlobal;

public:
    PackMapEnvironmentV32();
    PackMapEnvironmentV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV32(const PackMapEnvironmentV32 &p_other);
    PackMapEnvironmentV32 &operator=(const PackMapEnvironmentV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV32 Gw2Struct;
};

/* Version: 31, ReferencedFunction: 0x4104DC0000000001 */

template <>
struct Gw2Structenv<31>{
struct PackMapEnvDataLightV31 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV31();
    PackMapEnvDataLightV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV31(const PackMapEnvDataLightV31 &p_other);
    PackMapEnvDataLightV31 &operator=(const PackMapEnvDataLightV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV31 {
    helpers::Ptr<PackMapEnvDataLightV31> lights;

public:
    PackMapEnvDataLightingV31();
    PackMapEnvDataLightingV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV31(const PackMapEnvDataLightingV31 &p_other);
    PackMapEnvDataLightingV31 &operator=(const PackMapEnvDataLightingV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV31 {
    float density;
    float depth;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV31();
    PackMapEnvDataLayerAttributesV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV31(const PackMapEnvDataLayerAttributesV31 &p_other);
    PackMapEnvDataLayerAttributesV31 &operator=(const PackMapEnvDataLayerAttributesV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV31 {
    float altitude;
    float cutOut;
    float scale;
    helpers::FileName texture;
    PackMapEnvDataLayerAttributesV31 day;
    PackMapEnvDataLayerAttributesV31 night;
    helpers::WString name;

public:
    PackMapEnvDataLayerV31();
    PackMapEnvDataLayerV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV31(const PackMapEnvDataLayerV31 &p_other);
    PackMapEnvDataLayerV31 &operator=(const PackMapEnvDataLayerV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV31 {
    helpers::Array<PackMapEnvDataLayerV31> layers;

public:
    PackMapEnvDataCloudsV31();
    PackMapEnvDataCloudsV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV31(const PackMapEnvDataCloudsV31 &p_other);
    PackMapEnvDataCloudsV31 &operator=(const PackMapEnvDataCloudsV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV31 {
    byte4 glow;
    byte4 tintColor;
    float saturation;
    float tintAmount;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV31();
    PackMapEnvDataEffectV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV31(const PackMapEnvDataEffectV31 &p_other);
    PackMapEnvDataEffectV31 &operator=(const PackMapEnvDataEffectV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV31 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV31();
    PackMapEnvDataHazeV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV31(const PackMapEnvDataHazeV31 &p_other);
    PackMapEnvDataHazeV31 &operator=(const PackMapEnvDataHazeV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV31 {
    float altitude;
    float2 angle;
    float depth;
    float deviation;
    word extent;
    float fade;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV31();
    PackMapEnvDataPFieldV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV31(const PackMapEnvDataPFieldV31 &p_other);
    PackMapEnvDataPFieldV31 &operator=(const PackMapEnvDataPFieldV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV31 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV31();
    PackMapEnvDataSkyV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV31(const PackMapEnvDataSkyV31 &p_other);
    PackMapEnvDataSkyV31 &operator=(const PackMapEnvDataSkyV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV31 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV31();
    PackMapEnvDataSkyCardAttributesV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV31(const PackMapEnvDataSkyCardAttributesV31 &p_other);
    PackMapEnvDataSkyCardAttributesV31 &operator=(const PackMapEnvDataSkyCardAttributesV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV31 {
    PackMapEnvDataSkyCardAttributesV31 day;
    PackMapEnvDataSkyCardAttributesV31 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV31();
    PackMapEnvDataSkyCardV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV31(const PackMapEnvDataSkyCardV31 &p_other);
    PackMapEnvDataSkyCardV31 &operator=(const PackMapEnvDataSkyCardV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV31 {
    helpers::Array<PackMapEnvDataSkyCardV31> cards;

public:
    PackMapEnvDataSkyCardsV31();
    PackMapEnvDataSkyCardsV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV31(const PackMapEnvDataSkyCardsV31 &p_other);
    PackMapEnvDataSkyCardsV31 &operator=(const PackMapEnvDataSkyCardsV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV31 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    float patternEdge;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV31();
    PackMapEnvDataWaterV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV31(const PackMapEnvDataWaterV31 &p_other);
    PackMapEnvDataWaterV31 &operator=(const PackMapEnvDataWaterV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV31 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV31();
    PackMapEnvDataWindV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV31(const PackMapEnvDataWindV31 &p_other);
    PackMapEnvDataWindV31 &operator=(const PackMapEnvDataWindV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV31 {
    helpers::Array<PackMapEnvDataLightingV31> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV31> clouds;
    helpers::Ptr<PackMapEnvDataEffectV31> effect;
    helpers::Ptr<PackMapEnvDataHazeV31> haze;
    helpers::Ptr<PackMapEnvDataPFieldV31> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV31> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV31> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV31> water;
    helpers::Ptr<PackMapEnvDataWindV31> wind;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV31();
    PackMapEnvDataLocalV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV31(const PackMapEnvDataLocalV31 &p_other);
    PackMapEnvDataLocalV31 &operator=(const PackMapEnvDataLocalV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV31 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV31();
    PackMapEnvDataSkyModeTexV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV31(const PackMapEnvDataSkyModeTexV31 &p_other);
    PackMapEnvDataSkyModeTexV31 &operator=(const PackMapEnvDataSkyModeTexV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV31 {
    helpers::Array<PackMapEnvDataLightingV31> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV31> clouds;
    helpers::Ptr<PackMapEnvDataEffectV31> effect;
    helpers::Ptr<PackMapEnvDataHazeV31> haze;
    helpers::Ptr<PackMapEnvDataPFieldV31> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV31> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV31> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV31> water;
    helpers::Ptr<PackMapEnvDataWindV31> wind;
    helpers::Array<PackMapEnvDataSkyModeTexV31> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV31();
    PackMapEnvDataGlobalV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV31(const PackMapEnvDataGlobalV31 &p_other);
    PackMapEnvDataGlobalV31 &operator=(const PackMapEnvDataGlobalV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV31 {
    helpers::Array<PackMapEnvDataLocalV31> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV31> dataGlobal;

public:
    PackMapEnvironmentV31();
    PackMapEnvironmentV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV31(const PackMapEnvironmentV31 &p_other);
    PackMapEnvironmentV31 &operator=(const PackMapEnvironmentV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV31 Gw2Struct;
};

/* Version: 30, ReferencedFunction: 0x4104DB7000000001 */

template <>
struct Gw2Structenv<30>{
struct PackMapEnvDataLightV30 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV30();
    PackMapEnvDataLightV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV30(const PackMapEnvDataLightV30 &p_other);
    PackMapEnvDataLightV30 &operator=(const PackMapEnvDataLightV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV30 {
    helpers::Ptr<PackMapEnvDataLightV30> lights;

public:
    PackMapEnvDataLightingV30();
    PackMapEnvDataLightingV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV30(const PackMapEnvDataLightingV30 &p_other);
    PackMapEnvDataLightingV30 &operator=(const PackMapEnvDataLightingV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV30 {
    float density;
    float depth;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV30();
    PackMapEnvDataLayerAttributesV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV30(const PackMapEnvDataLayerAttributesV30 &p_other);
    PackMapEnvDataLayerAttributesV30 &operator=(const PackMapEnvDataLayerAttributesV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV30 {
    float altitude;
    float cutOut;
    float scale;
    helpers::FileName texture;
    PackMapEnvDataLayerAttributesV30 day;
    PackMapEnvDataLayerAttributesV30 night;
    helpers::WString name;

public:
    PackMapEnvDataLayerV30();
    PackMapEnvDataLayerV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV30(const PackMapEnvDataLayerV30 &p_other);
    PackMapEnvDataLayerV30 &operator=(const PackMapEnvDataLayerV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV30 {
    helpers::Array<PackMapEnvDataLayerV30> layers;

public:
    PackMapEnvDataCloudsV30();
    PackMapEnvDataCloudsV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV30(const PackMapEnvDataCloudsV30 &p_other);
    PackMapEnvDataCloudsV30 &operator=(const PackMapEnvDataCloudsV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV30 {
    byte4 glow;
    byte4 tintColor;
    float saturation;
    float tintAmount;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV30();
    PackMapEnvDataEffectV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV30(const PackMapEnvDataEffectV30 &p_other);
    PackMapEnvDataEffectV30 &operator=(const PackMapEnvDataEffectV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV30 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV30();
    PackMapEnvDataHazeV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV30(const PackMapEnvDataHazeV30 &p_other);
    PackMapEnvDataHazeV30 &operator=(const PackMapEnvDataHazeV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV30 {
    float2 angle;
    float deviation;
    word extent;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV30();
    PackMapEnvDataPFieldV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV30(const PackMapEnvDataPFieldV30 &p_other);
    PackMapEnvDataPFieldV30 &operator=(const PackMapEnvDataPFieldV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV30 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV30();
    PackMapEnvDataSkyV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV30(const PackMapEnvDataSkyV30 &p_other);
    PackMapEnvDataSkyV30 &operator=(const PackMapEnvDataSkyV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV30 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV30();
    PackMapEnvDataSkyCardAttributesV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV30(const PackMapEnvDataSkyCardAttributesV30 &p_other);
    PackMapEnvDataSkyCardAttributesV30 &operator=(const PackMapEnvDataSkyCardAttributesV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV30 {
    PackMapEnvDataSkyCardAttributesV30 day;
    PackMapEnvDataSkyCardAttributesV30 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV30();
    PackMapEnvDataSkyCardV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV30(const PackMapEnvDataSkyCardV30 &p_other);
    PackMapEnvDataSkyCardV30 &operator=(const PackMapEnvDataSkyCardV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV30 {
    helpers::Array<PackMapEnvDataSkyCardV30> cards;

public:
    PackMapEnvDataSkyCardsV30();
    PackMapEnvDataSkyCardsV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV30(const PackMapEnvDataSkyCardsV30 &p_other);
    PackMapEnvDataSkyCardsV30 &operator=(const PackMapEnvDataSkyCardsV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV30 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV30();
    PackMapEnvDataWaterV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV30(const PackMapEnvDataWaterV30 &p_other);
    PackMapEnvDataWaterV30 &operator=(const PackMapEnvDataWaterV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV30 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV30();
    PackMapEnvDataWindV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV30(const PackMapEnvDataWindV30 &p_other);
    PackMapEnvDataWindV30 &operator=(const PackMapEnvDataWindV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV30 {
    helpers::Array<PackMapEnvDataLightingV30> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV30> clouds;
    helpers::Ptr<PackMapEnvDataEffectV30> effect;
    helpers::Ptr<PackMapEnvDataHazeV30> haze;
    helpers::Ptr<PackMapEnvDataPFieldV30> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV30> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV30> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV30> water;
    helpers::Ptr<PackMapEnvDataWindV30> wind;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV30();
    PackMapEnvDataLocalV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV30(const PackMapEnvDataLocalV30 &p_other);
    PackMapEnvDataLocalV30 &operator=(const PackMapEnvDataLocalV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV30 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV30();
    PackMapEnvDataSkyModeTexV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV30(const PackMapEnvDataSkyModeTexV30 &p_other);
    PackMapEnvDataSkyModeTexV30 &operator=(const PackMapEnvDataSkyModeTexV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV30 {
    helpers::Array<PackMapEnvDataLightingV30> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV30> clouds;
    helpers::Ptr<PackMapEnvDataEffectV30> effect;
    helpers::Ptr<PackMapEnvDataHazeV30> haze;
    helpers::Ptr<PackMapEnvDataPFieldV30> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV30> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV30> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV30> water;
    helpers::Ptr<PackMapEnvDataWindV30> wind;
    helpers::Array<PackMapEnvDataSkyModeTexV30> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV30();
    PackMapEnvDataGlobalV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV30(const PackMapEnvDataGlobalV30 &p_other);
    PackMapEnvDataGlobalV30 &operator=(const PackMapEnvDataGlobalV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV30 {
    helpers::Array<PackMapEnvDataLocalV30> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV30> dataGlobal;

public:
    PackMapEnvironmentV30();
    PackMapEnvironmentV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV30(const PackMapEnvironmentV30 &p_other);
    PackMapEnvironmentV30 &operator=(const PackMapEnvironmentV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV30 Gw2Struct;
};

/* Version: 29, ReferencedFunction: 0x1 */

template <>
struct Gw2Structenv<29>{
struct PackMapEnvDataLightV29 {
    byte3 color;
    float intensity;
    float3 direction;

public:
    PackMapEnvDataLightV29();
    PackMapEnvDataLightV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightV29(const PackMapEnvDataLightV29 &p_other);
    PackMapEnvDataLightV29 &operator=(const PackMapEnvDataLightV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLightingV29 {
    helpers::Ptr<PackMapEnvDataLightV29> lights;

public:
    PackMapEnvDataLightingV29();
    PackMapEnvDataLightingV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLightingV29(const PackMapEnvDataLightingV29 &p_other);
    PackMapEnvDataLightingV29 &operator=(const PackMapEnvDataLightingV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerAttributesV29 {
    float density;
    float depth;
    float haze;
    float lightIntensity;
    float2 velocity;

public:
    PackMapEnvDataLayerAttributesV29();
    PackMapEnvDataLayerAttributesV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerAttributesV29(const PackMapEnvDataLayerAttributesV29 &p_other);
    PackMapEnvDataLayerAttributesV29 &operator=(const PackMapEnvDataLayerAttributesV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLayerV29 {
    float altitude;
    float scale;
    helpers::FileName texture;
    PackMapEnvDataLayerAttributesV29 day;
    PackMapEnvDataLayerAttributesV29 night;
    helpers::WString name;

public:
    PackMapEnvDataLayerV29();
    PackMapEnvDataLayerV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLayerV29(const PackMapEnvDataLayerV29 &p_other);
    PackMapEnvDataLayerV29 &operator=(const PackMapEnvDataLayerV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataCloudsV29 {
    helpers::Array<PackMapEnvDataLayerV29> layers;

public:
    PackMapEnvDataCloudsV29();
    PackMapEnvDataCloudsV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataCloudsV29(const PackMapEnvDataCloudsV29 &p_other);
    PackMapEnvDataCloudsV29 &operator=(const PackMapEnvDataCloudsV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataEffectV29 {
    byte4 glow;
    byte4 tintColor;
    float saturation;
    float tintAmount;
    byte4 glowLevel;
    float glowAmplify;

public:
    PackMapEnvDataEffectV29();
    PackMapEnvDataEffectV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataEffectV29(const PackMapEnvDataEffectV29 &p_other);
    PackMapEnvDataEffectV29 &operator=(const PackMapEnvDataEffectV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataHazeV29 {
    byte4 distColor;
    float2 distRange;
    byte4 heightColor;
    float2 heightRange;
    float depthCue;

public:
    PackMapEnvDataHazeV29();
    PackMapEnvDataHazeV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataHazeV29(const PackMapEnvDataHazeV29 &p_other);
    PackMapEnvDataHazeV29 &operator=(const PackMapEnvDataHazeV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataPFieldV29 {
    float2 angle;
    float deviation;
    word extent;
    float3 fieldDirection;
    byte flags;
    float2 opacity;
    word particleCount;
    float2 rotation;
    float2 scaleX;
    float2 scaleY;
    float2 speed;
    dword2 texColRow;
    word texFPS;
    helpers::FileName texPath;
    byte type;
    helpers::WString name;

public:
    PackMapEnvDataPFieldV29();
    PackMapEnvDataPFieldV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataPFieldV29(const PackMapEnvDataPFieldV29 &p_other);
    PackMapEnvDataPFieldV29 &operator=(const PackMapEnvDataPFieldV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyV29 {
    byte flags;
    float dayHazeBottom;
    float dayHazeDensity;
    float dayHazeFalloff;
    float dayLightIntensity;
    float dayStarDensity;
    float nightHazeBottom;
    float nightHazeDensity;
    float nightHazeFalloff;
    float nightLightIntensity;
    float nightStarDensity;

public:
    PackMapEnvDataSkyV29();
    PackMapEnvDataSkyV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyV29(const PackMapEnvDataSkyV29 &p_other);
    PackMapEnvDataSkyV29 &operator=(const PackMapEnvDataSkyV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardAttributesV29 {
    float azimuth;
    float density;
    float hazeDensity;
    float latitude;
    float lightIntensity;
    float minHaze;
    float2 scale;
    float speed;
    helpers::FileName texture;
    float4 textureUV;

public:
    PackMapEnvDataSkyCardAttributesV29();
    PackMapEnvDataSkyCardAttributesV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardAttributesV29(const PackMapEnvDataSkyCardAttributesV29 &p_other);
    PackMapEnvDataSkyCardAttributesV29 &operator=(const PackMapEnvDataSkyCardAttributesV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardV29 {
    PackMapEnvDataSkyCardAttributesV29 day;
    PackMapEnvDataSkyCardAttributesV29 night;
    helpers::WString name;

public:
    PackMapEnvDataSkyCardV29();
    PackMapEnvDataSkyCardV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardV29(const PackMapEnvDataSkyCardV29 &p_other);
    PackMapEnvDataSkyCardV29 &operator=(const PackMapEnvDataSkyCardV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyCardsV29 {
    helpers::Array<PackMapEnvDataSkyCardV29> cards;

public:
    PackMapEnvDataSkyCardsV29();
    PackMapEnvDataSkyCardsV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyCardsV29(const PackMapEnvDataSkyCardsV29 &p_other);
    PackMapEnvDataSkyCardsV29 &operator=(const PackMapEnvDataSkyCardsV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWaterV29 {
    dword waterFlags;
    float animAmplitude;
    float animChoppiness;
    float2 animWind;
    float bumpAmount;
    float bumpAngle0;
    float bumpAngle1;
    float bumpScale0;
    float bumpScale1;
    float bumpSpeed0;
    float bumpSpeed1;
    float bumpTile0;
    float bumpTile1;
    float patternAngle;
    float patternTile;
    float patternSpeed;
    byte4 surfaceShallowColor;
    byte4 surfaceDeepColor;
    byte4 patternColor;
    float surfaceFresnel;
    float distortAmount;
    helpers::FileName bumpTexture;
    helpers::FileName patternTexture;

public:
    PackMapEnvDataWaterV29();
    PackMapEnvDataWaterV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWaterV29(const PackMapEnvDataWaterV29 &p_other);
    PackMapEnvDataWaterV29 &operator=(const PackMapEnvDataWaterV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataWindV29 {
    byte azimuth;
    byte elevation;
    byte noise;
    byte speed;
    byte gust;
    byte gustFreq;

public:
    PackMapEnvDataWindV29();
    PackMapEnvDataWindV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataWindV29(const PackMapEnvDataWindV29 &p_other);
    PackMapEnvDataWindV29 &operator=(const PackMapEnvDataWindV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataLocalV29 {
    helpers::Array<PackMapEnvDataLightingV29> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV29> clouds;
    helpers::Ptr<PackMapEnvDataEffectV29> effect;
    helpers::Ptr<PackMapEnvDataHazeV29> haze;
    helpers::Ptr<PackMapEnvDataPFieldV29> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV29> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV29> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV29> water;
    helpers::Ptr<PackMapEnvDataWindV29> wind;
    float3 center;
    float2 zRange;
    float fadeHorizInner;
    float fadeHorizOuter;
    float fadeVertical;
    byte type;
    helpers::Array<float2> vertexArray;

public:
    PackMapEnvDataLocalV29();
    PackMapEnvDataLocalV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataLocalV29(const PackMapEnvDataLocalV29 &p_other);
    PackMapEnvDataLocalV29 &operator=(const PackMapEnvDataLocalV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataSkyModeTexV29 {
    helpers::FileName texPathNE;
    helpers::FileName texPathSW;
    helpers::FileName texPathT;

public:
    PackMapEnvDataSkyModeTexV29();
    PackMapEnvDataSkyModeTexV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataSkyModeTexV29(const PackMapEnvDataSkyModeTexV29 &p_other);
    PackMapEnvDataSkyModeTexV29 &operator=(const PackMapEnvDataSkyModeTexV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvDataGlobalV29 {
    helpers::Array<PackMapEnvDataLightingV29> lighting;
    helpers::Ptr<PackMapEnvDataCloudsV29> clouds;
    helpers::Ptr<PackMapEnvDataEffectV29> effect;
    helpers::Ptr<PackMapEnvDataHazeV29> haze;
    helpers::Ptr<PackMapEnvDataPFieldV29> particleFields;
    helpers::Ptr<PackMapEnvDataSkyV29> sky;
    helpers::Ptr<PackMapEnvDataSkyCardsV29> skyCards;
    helpers::Ptr<PackMapEnvDataWaterV29> water;
    helpers::Ptr<PackMapEnvDataWindV29> wind;
    helpers::Array<PackMapEnvDataSkyModeTexV29> skyModeTex;
    helpers::FileName starFile;

public:
    PackMapEnvDataGlobalV29();
    PackMapEnvDataGlobalV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvDataGlobalV29(const PackMapEnvDataGlobalV29 &p_other);
    PackMapEnvDataGlobalV29 &operator=(const PackMapEnvDataGlobalV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEnvironmentV29 {
    helpers::Array<PackMapEnvDataLocalV29> dataLocalArray;
    helpers::Ptr<PackMapEnvDataGlobalV29> dataGlobal;

public:
    PackMapEnvironmentV29();
    PackMapEnvironmentV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEnvironmentV29(const PackMapEnvironmentV29 &p_other);
    PackMapEnvironmentV29 &operator=(const PackMapEnvironmentV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapEnvironmentV29 Gw2Struct;
};


/* ===============================================
 * Chunk: laye, versions: 2, strucTab: 0x1420F1F78
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structlaye;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlaye<1>{
struct PackMapLayerProp {
    qword guid;
    helpers::Array<dword> layerIds;

public:
    PackMapLayerProp();
    PackMapLayerProp(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayerProp(const PackMapLayerProp &p_other);
    PackMapLayerProp &operator=(const PackMapLayerProp &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLayerLight {
    qword guid;
    helpers::Array<dword> layerIds;

public:
    PackMapLayerLight();
    PackMapLayerLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayerLight(const PackMapLayerLight &p_other);
    PackMapLayerLight &operator=(const PackMapLayerLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLayer {
    dword layerId;
    helpers::Array<dword4> metaData;

public:
    PackMapLayer();
    PackMapLayer(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayer(const PackMapLayer &p_other);
    PackMapLayer &operator=(const PackMapLayer &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLayers {
    helpers::Array<PackMapLayerProp> props;
    helpers::Array<PackMapLayerLight> lights;
    helpers::Array<PackMapLayer> layers;

public:
    PackMapLayers();
    PackMapLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayers(const PackMapLayers &p_other);
    PackMapLayers &operator=(const PackMapLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLayers Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlaye<0>{
struct PackMapLayerProp {
    qword guid;
    helpers::Array<dword> layerIds;

public:
    PackMapLayerProp();
    PackMapLayerProp(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayerProp(const PackMapLayerProp &p_other);
    PackMapLayerProp &operator=(const PackMapLayerProp &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLayer {
    dword layerId;
    helpers::Array<dword4> metaData;

public:
    PackMapLayer();
    PackMapLayer(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayer(const PackMapLayer &p_other);
    PackMapLayer &operator=(const PackMapLayer &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLayers {
    helpers::Array<PackMapLayerProp> props;
    helpers::Array<PackMapLayer> layers;

public:
    PackMapLayers();
    PackMapLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLayers(const PackMapLayers &p_other);
    PackMapLayers &operator=(const PackMapLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLayers Gw2Struct;
};


/* ===============================================
 * Chunk: lght, versions: 20, strucTab: 0x1420F2150
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structlght;

/* Version: 19, ReferencedFunction: 0x41053C2000000001 */

template <>
struct Gw2Structlght<19>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalData {
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;

public:
    PackMapPortalData();
    PackMapPortalData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalData(const PackMapPortalData &p_other);
    PackMapPortalData &operator=(const PackMapPortalData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalLight {
    qword guid;
    helpers::Array<float3> points;
    helpers::Array<PackMapPortalData> portalData;
    word broadId;

public:
    PackMapPortalLight();
    PackMapPortalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalLight(const PackMapPortalLight &p_other);
    PackMapPortalLight &operator=(const PackMapPortalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotShadow {
    helpers::FileName shadowFilename;

public:
    PackMapSpotShadow();
    PackMapSpotShadow(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotShadow(const PackMapSpotShadow &p_other);
    PackMapSpotShadow &operator=(const PackMapSpotShadow &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLod {
    float distance;
    dword flags;
    dword lightFlags;
    byte3 color;
    float intensity;
    float nearDist;
    float farDist;
    float innerAngle;
    float outerAngle;

public:
    PackMapSpotLod();
    PackMapSpotLod(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLod(const PackMapSpotLod &p_other);
    PackMapSpotLod &operator=(const PackMapSpotLod &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float3 upDirection;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;
    helpers::Ptr<PackMapSpotShadow> shadowData;
    PackMapSpotLod lodData[2];

public:
    PackMapSpotLight();
    PackMapSpotLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLight(const PackMapSpotLight &p_other);
    PackMapSpotLight &operator=(const PackMapSpotLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapSpotLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapPortalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;
    dword maxLightVsConstants;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<18>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalData {
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;

public:
    PackMapPortalData();
    PackMapPortalData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalData(const PackMapPortalData &p_other);
    PackMapPortalData &operator=(const PackMapPortalData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalLight {
    qword guid;
    helpers::Array<float3> points;
    helpers::Array<PackMapPortalData> portalData;
    word broadId;

public:
    PackMapPortalLight();
    PackMapPortalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalLight(const PackMapPortalLight &p_other);
    PackMapPortalLight &operator=(const PackMapPortalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotShadow {
    helpers::FileName shadowFilename;

public:
    PackMapSpotShadow();
    PackMapSpotShadow(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotShadow(const PackMapSpotShadow &p_other);
    PackMapSpotShadow &operator=(const PackMapSpotShadow &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLod {
    float distance;
    dword flags;
    dword lightFlags;
    byte3 color;
    float intensity;
    float nearDist;
    float farDist;
    float innerAngle;
    float outerAngle;

public:
    PackMapSpotLod();
    PackMapSpotLod(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLod(const PackMapSpotLod &p_other);
    PackMapSpotLod &operator=(const PackMapSpotLod &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float3 upDirection;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;
    helpers::Ptr<PackMapSpotShadow> shadowData;
    PackMapSpotLod lodData[2];

public:
    PackMapSpotLight();
    PackMapSpotLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLight(const PackMapSpotLight &p_other);
    PackMapSpotLight &operator=(const PackMapSpotLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapSpotLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapPortalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<17>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalData {
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;

public:
    PackMapPortalData();
    PackMapPortalData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalData(const PackMapPortalData &p_other);
    PackMapPortalData &operator=(const PackMapPortalData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalLight {
    qword guid;
    helpers::Array<float3> points;
    helpers::Array<PackMapPortalData> portalData;
    word broadId;

public:
    PackMapPortalLight();
    PackMapPortalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalLight(const PackMapPortalLight &p_other);
    PackMapPortalLight &operator=(const PackMapPortalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotShadow {
    helpers::FileName shadowFilename;

public:
    PackMapSpotShadow();
    PackMapSpotShadow(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotShadow(const PackMapSpotShadow &p_other);
    PackMapSpotShadow &operator=(const PackMapSpotShadow &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float3 upDirection;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;
    helpers::Ptr<PackMapSpotShadow> shadowData;

public:
    PackMapSpotLight();
    PackMapSpotLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLight(const PackMapSpotLight &p_other);
    PackMapSpotLight &operator=(const PackMapSpotLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapSpotLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapPortalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<16>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalData {
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;

public:
    PackMapPortalData();
    PackMapPortalData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalData(const PackMapPortalData &p_other);
    PackMapPortalData &operator=(const PackMapPortalData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalLight {
    qword guid;
    helpers::Array<float3> points;
    helpers::Array<PackMapPortalData> portalData;
    word broadId;

public:
    PackMapPortalLight();
    PackMapPortalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalLight(const PackMapPortalLight &p_other);
    PackMapPortalLight &operator=(const PackMapPortalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotShadow {
    helpers::FileName shadowFilename;

public:
    PackMapSpotShadow();
    PackMapSpotShadow(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotShadow(const PackMapSpotShadow &p_other);
    PackMapSpotShadow &operator=(const PackMapSpotShadow &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;
    helpers::Ptr<PackMapSpotShadow> shadowData;

public:
    PackMapSpotLight();
    PackMapSpotLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLight(const PackMapSpotLight &p_other);
    PackMapSpotLight &operator=(const PackMapSpotLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapSpotLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapPortalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x41053B5000000001 */

template <>
struct Gw2Structlght<15>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalData {
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;

public:
    PackMapPortalData();
    PackMapPortalData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalData(const PackMapPortalData &p_other);
    PackMapPortalData &operator=(const PackMapPortalData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPortalLight {
    qword guid;
    helpers::Array<float3> points;
    helpers::Array<PackMapPortalData> portalData;
    word broadId;

public:
    PackMapPortalLight();
    PackMapPortalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPortalLight(const PackMapPortalLight &p_other);
    PackMapPortalLight &operator=(const PackMapPortalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightsV15 {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapPortalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLightsV15();
    PackMapLightsV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightsV15(const PackMapLightsV15 &p_other);
    PackMapLightsV15 &operator=(const PackMapLightsV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLightsV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<14>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapProtalLight {
    qword guid;
    float fadeCamera;
    float fadeLight;
    float lighten;
    float darken;
    helpers::Array<float3> points;
    word broadId;

public:
    PackMapProtalLight();
    PackMapProtalLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapProtalLight(const PackMapProtalLight &p_other);
    PackMapProtalLight &operator=(const PackMapProtalLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapSpotLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapSpotLightgroups();
    PackMapSpotLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapSpotLightgroups(const PackMapSpotLightgroups &p_other);
    PackMapSpotLightgroups &operator=(const PackMapSpotLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightsV14 {
    helpers::Array<PackMapPointLightgroups> pointLights;
    helpers::Array<PackMapProtalLight> portalLights;
    helpers::Array<PackMapSpotLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLightsV14();
    PackMapLightsV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightsV14(const PackMapLightsV14 &p_other);
    PackMapLightsV14 &operator=(const PackMapLightsV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLightsV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x410539B000000001 */

template <>
struct Gw2Structlght<13>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<float3> floodPoints;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x4105375000000001 */

template <>
struct Gw2Structlght<12>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    float3 floodPoint;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x4105375000000001 */

template <>
struct Gw2Structlght<11>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;
    word broadId;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    float3 floodPoint;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;
    word broadId;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x4105441000000001 */

template <>
struct Gw2Structlght<10>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword2 dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    float3 floodPoint;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x4105435000000001 */

template <>
struct Gw2Structlght<9>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 position;
    float3 extents;
    float3 rotation;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    float3 floodPoint;
    dword flags;
    helpers::Array<PackMapVolumeImage> images;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x410542D000000001 */

template <>
struct Gw2Structlght<8>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 minExt;
    float3 maxExt;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    float3 floodPoint;
    helpers::Array<PackMapVolumeImage> images;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<7>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 minExt;
    float3 maxExt;
    float2 intensities;
    float4 pack;
    helpers::WString name;
    helpers::Array<PackMapVolumeImage> images;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<6>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeImage {
    helpers::FileName filename;
    dword dims;
    dword format;
    helpers::Array<byte> image;

public:
    PackMapVolumeImage();
    PackMapVolumeImage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeImage(const PackMapVolumeImage &p_other);
    PackMapVolumeImage &operator=(const PackMapVolumeImage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapVolumeLight {
    qword guid;
    float3 minExt;
    float3 maxExt;
    float2 intensities;
    float4 pack;
    helpers::Array<PackMapVolumeImage> images;

public:
    PackMapVolumeLight();
    PackMapVolumeLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapVolumeLight(const PackMapVolumeLight &p_other);
    PackMapVolumeLight &operator=(const PackMapVolumeLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;
    helpers::Array<PackMapVolumeLight> volumeLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x4105410000000001 */

template <>
struct Gw2Structlght<5>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;
    float3 direction;
    float innerAngle;
    float outerAngle;
    helpers::FileName textureName;

public:
    PackMapPointLight();
    PackMapPointLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLight(const PackMapPointLight &p_other);
    PackMapPointLight &operator=(const PackMapPointLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPointLightgroups {
    qword guid;
    helpers::Array<PackMapPointLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapPointLightgroups();
    PackMapPointLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPointLightgroups(const PackMapPointLightgroups &p_other);
    PackMapPointLightgroups &operator=(const PackMapPointLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> pointLights;
    helpers::Array<PackMapPointLightgroups> spotLights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x41053EE000000001 */

template <>
struct Gw2Structlght<4>{
struct PackMapLight {
    float3 position;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    float offset;
    float amplitude;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    qword guid;
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> lights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x41053D8000000001 */

template <>
struct Gw2Structlght<3>{
struct PackMapLight {
    dword type;
    float3 position;
    float elevation;
    float azimuth;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapCurve {
    float gust;
    float gustFreq;
    float noise;
    float phase;
    dword curveType;

public:
    PackMapCurve();
    PackMapCurve(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapCurve(const PackMapCurve &p_other);
    PackMapCurve &operator=(const PackMapCurve &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    helpers::Array<PackMapLight> lights;
    helpers::Array<PackMapCurve> curves;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> lights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x41053C3000000001 */

template <>
struct Gw2Structlght<2>{
struct PackMapLight {
    dword type;
    float3 position;
    float elevation;
    float azimuth;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;
    dword flags;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLightgroups {
    helpers::Array<PackMapLight> lights;

public:
    PackMapLightgroups();
    PackMapLightgroups(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLightgroups(const PackMapLightgroups &p_other);
    PackMapLightgroups &operator=(const PackMapLightgroups &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLightgroups> groups;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structlght<1>{
struct PackMapLight {
    dword type;
    float3 position;
    float elevation;
    float azimuth;
    byte3 color;
    float intensity;
    float nearDistance;
    float farDistance;

public:
    PackMapLight();
    PackMapLight(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLight(const PackMapLight &p_other);
    PackMapLight &operator=(const PackMapLight &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapLights {
    helpers::Array<PackMapLight> lights;

public:
    PackMapLights();
    PackMapLights(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapLights(const PackMapLights &p_other);
    PackMapLights &operator=(const PackMapLights &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapLights Gw2Struct;
};


/* ===============================================
 * Chunk: msn, versions: 3, strucTab: 0x1420F2410
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmsn;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmsn<2>{
struct PackMapInterestPoint {
    float3 position;
    float3 forward;
    helpers::WString description;

public:
    PackMapInterestPoint();
    PackMapInterestPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapInterestPoint(const PackMapInterestPoint &p_other);
    PackMapInterestPoint &operator=(const PackMapInterestPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapMission {
    helpers::Array<PackMapInterestPoint> interestPoint;

public:
    MapMission();
    MapMission(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapMission(const MapMission &p_other);
    MapMission &operator=(const MapMission &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapMission Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmsn<1>{
struct PackMapInterestPoint {
    float3 position;
    float3 forward;

public:
    PackMapInterestPoint();
    PackMapInterestPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapInterestPoint(const PackMapInterestPoint &p_other);
    PackMapInterestPoint &operator=(const PackMapInterestPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapMission {
    helpers::Array<PackMapInterestPoint> interestPoint;

public:
    MapMission();
    MapMission(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapMission(const MapMission &p_other);
    MapMission &operator=(const MapMission &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapMission Gw2Struct;
};


/* ===============================================
 * Chunk: nm15, versions: 4, strucTab: 0x1420F0390
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structnm15;

/* Version: 3, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structnm15<3>{
struct PackMapNavMeshChunkV3 {
    dword chunkIndex;
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV3();
    PackMapNavMeshChunkV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV3(const PackMapNavMeshChunkV3 &p_other);
    PackMapNavMeshChunkV3 &operator=(const PackMapNavMeshChunkV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshMoverV3 {
    dword chunkIndex;
    qword mapPropId;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> mediatorData;

public:
    PackMapNavMeshMoverV3();
    PackMapNavMeshMoverV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshMoverV3(const PackMapNavMeshMoverV3 &p_other);
    PackMapNavMeshMoverV3 &operator=(const PackMapNavMeshMoverV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshV3 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkV3> chunkArray;
    helpers::Array<PackMapNavMeshMoverV3> dynamicArray;

public:
    PackMapNavMeshV3();
    PackMapNavMeshV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshV3(const PackMapNavMeshV3 &p_other);
    PackMapNavMeshV3 &operator=(const PackMapNavMeshV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnm15<2>{
struct PackMapNavMeshChunkV2 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV2();
    PackMapNavMeshChunkV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV2(const PackMapNavMeshChunkV2 &p_other);
    PackMapNavMeshChunkV2 &operator=(const PackMapNavMeshChunkV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshMoverV2 {
    qword mapPropId;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> mediatorData;

public:
    PackMapNavMeshMoverV2();
    PackMapNavMeshMoverV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshMoverV2(const PackMapNavMeshMoverV2 &p_other);
    PackMapNavMeshMoverV2 &operator=(const PackMapNavMeshMoverV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshV2 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkV2> chunkArray;
    helpers::Array<PackMapNavMeshMoverV2> dynamicArray;

public:
    PackMapNavMeshV2();
    PackMapNavMeshV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshV2(const PackMapNavMeshV2 &p_other);
    PackMapNavMeshV2 &operator=(const PackMapNavMeshV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x410549B000000001 */

template <>
struct Gw2Structnm15<1>{
struct PackMapNavMeshChunkV1 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV1();
    PackMapNavMeshChunkV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV1(const PackMapNavMeshChunkV1 &p_other);
    PackMapNavMeshChunkV1 &operator=(const PackMapNavMeshChunkV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshV1 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkV1> chunkArray;

public:
    PackMapNavMeshV1();
    PackMapNavMeshV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshV1(const PackMapNavMeshV1 &p_other);
    PackMapNavMeshV1 &operator=(const PackMapNavMeshV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnm15<0>{
struct PackMapNavMeshChunkV0 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    PackMapNavMeshChunkV0();
    PackMapNavMeshChunkV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkV0(const PackMapNavMeshChunkV0 &p_other);
    PackMapNavMeshChunkV0 &operator=(const PackMapNavMeshChunkV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshV0 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkV0> chunkArray;

public:
    PackMapNavMeshV0();
    PackMapNavMeshV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshV0(const PackMapNavMeshV0 &p_other);
    PackMapNavMeshV0 &operator=(const PackMapNavMeshV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshV0 Gw2Struct;
};


/* ===============================================
 * Chunk: nmex, versions: 4, strucTab: 0x1420F03F0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structnmex;

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnmex<3>{
struct PackMapNavMeshChunkExternalV3 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::FileName filename;

public:
    PackMapNavMeshChunkExternalV3();
    PackMapNavMeshChunkExternalV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkExternalV3(const PackMapNavMeshChunkExternalV3 &p_other);
    PackMapNavMeshChunkExternalV3 &operator=(const PackMapNavMeshChunkExternalV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshMoverV3 {
    dword chunkIndex;
    qword mapPropId;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> mediatorData;

public:
    PackMapNavMeshMoverV3();
    PackMapNavMeshMoverV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshMoverV3(const PackMapNavMeshMoverV3 &p_other);
    PackMapNavMeshMoverV3 &operator=(const PackMapNavMeshMoverV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshExternalV3 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkExternalV3> chunkArray;
    helpers::Array<PackMapNavMeshMoverV3> dynamicArray;

public:
    PackMapNavMeshExternalV3();
    PackMapNavMeshExternalV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshExternalV3(const PackMapNavMeshExternalV3 &p_other);
    PackMapNavMeshExternalV3 &operator=(const PackMapNavMeshExternalV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshExternalV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnmex<2>{
struct PackMapNavMeshChunkExternalV2 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::FileName filename;

public:
    PackMapNavMeshChunkExternalV2();
    PackMapNavMeshChunkExternalV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkExternalV2(const PackMapNavMeshChunkExternalV2 &p_other);
    PackMapNavMeshChunkExternalV2 &operator=(const PackMapNavMeshChunkExternalV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshMoverV2 {
    qword mapPropId;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> mediatorData;

public:
    PackMapNavMeshMoverV2();
    PackMapNavMeshMoverV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshMoverV2(const PackMapNavMeshMoverV2 &p_other);
    PackMapNavMeshMoverV2 &operator=(const PackMapNavMeshMoverV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshExternalV2 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkExternalV2> chunkArray;
    helpers::Array<PackMapNavMeshMoverV2> dynamicArray;

public:
    PackMapNavMeshExternalV2();
    PackMapNavMeshExternalV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshExternalV2(const PackMapNavMeshExternalV2 &p_other);
    PackMapNavMeshExternalV2 &operator=(const PackMapNavMeshExternalV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshExternalV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnmex<1>{
struct PackMapNavMeshChunkExternalV1 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::FileName filename;

public:
    PackMapNavMeshChunkExternalV1();
    PackMapNavMeshChunkExternalV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkExternalV1(const PackMapNavMeshChunkExternalV1 &p_other);
    PackMapNavMeshChunkExternalV1 &operator=(const PackMapNavMeshChunkExternalV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshExternalV1 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkExternalV1> chunkArray;

public:
    PackMapNavMeshExternalV1();
    PackMapNavMeshExternalV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshExternalV1(const PackMapNavMeshExternalV1 &p_other);
    PackMapNavMeshExternalV1 &operator=(const PackMapNavMeshExternalV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshExternalV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structnmex<0>{
struct PackMapNavMeshChunkExternalV0 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::FileName filename;

public:
    PackMapNavMeshChunkExternalV0();
    PackMapNavMeshChunkExternalV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshChunkExternalV0(const PackMapNavMeshChunkExternalV0 &p_other);
    PackMapNavMeshChunkExternalV0 &operator=(const PackMapNavMeshChunkExternalV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapNavMeshExternalV0 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapNavMeshChunkExternalV0> chunkArray;

public:
    PackMapNavMeshExternalV0();
    PackMapNavMeshExternalV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapNavMeshExternalV0(const PackMapNavMeshExternalV0 &p_other);
    PackMapNavMeshExternalV0 &operator=(const PackMapNavMeshExternalV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapNavMeshExternalV0 Gw2Struct;
};


/* ===============================================
 * Chunk: obs, versions: 3, strucTab: 0x1420F2580
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structobs;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structobs<2>{
struct PackMapEditCollision {
    dword token;
    dword flags;
    helpers::Array<float3> bottmVertices;
    helpers::Array<float3> topVertices;
    helpers::WString name;
    qword surface;

public:
    PackMapEditCollision();
    PackMapEditCollision(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditCollision(const PackMapEditCollision &p_other);
    PackMapEditCollision &operator=(const PackMapEditCollision &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapObstacles {
    helpers::Array<PackMapEditCollision> obstacles;

public:
    MapObstacles();
    MapObstacles(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapObstacles(const MapObstacles &p_other);
    MapObstacles &operator=(const MapObstacles &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapObstacles Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structobs<1>{
struct PackMapEditCollision {
    dword token;
    dword flags;
    helpers::Array<float3> bottmVertices;
    helpers::Array<float3> topVertices;
    helpers::WString name;

public:
    PackMapEditCollision();
    PackMapEditCollision(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditCollision(const PackMapEditCollision &p_other);
    PackMapEditCollision &operator=(const PackMapEditCollision &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapObstacles {
    helpers::Array<PackMapEditCollision> obstacles;

public:
    MapObstacles();
    MapObstacles(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapObstacles(const MapObstacles &p_other);
    MapObstacles &operator=(const MapObstacles &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapObstacles Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structobs<0>{
struct PackMapEditCollision {
    dword token;
    dword flags;
    helpers::Array<float3> bottmVertices;
    helpers::Array<float3> topVertices;

public:
    PackMapEditCollision();
    PackMapEditCollision(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditCollision(const PackMapEditCollision &p_other);
    PackMapEditCollision &operator=(const PackMapEditCollision &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapObstacles {
    helpers::Array<PackMapEditCollision> obstacles;

public:
    MapObstacles();
    MapObstacles(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapObstacles(const MapObstacles &p_other);
    MapObstacles &operator=(const MapObstacles &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapObstacles Gw2Struct;
};


/* ===============================================
 * Chunk: occ, versions: 1, strucTab: 0x1420F25C8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structocc;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structocc<0>{
struct MapOcclusion {
    dword token;
    dword flags;
    helpers::Array<float3> vertices;
    helpers::WString name;

public:
    MapOcclusion();
    MapOcclusion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapOcclusion(const MapOcclusion &p_other);
    MapOcclusion &operator=(const MapOcclusion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapOcclusions {
    helpers::Array<MapOcclusion> Occlusions;

public:
    MapOcclusions();
    MapOcclusions(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapOcclusions(const MapOcclusions &p_other);
    MapOcclusions &operator=(const MapOcclusions &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapOcclusions Gw2Struct;
};


/* ===============================================
 * Chunk: octm, versions: 1, strucTab: 0x1420F25E0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structoctm;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structoctm<0>{
struct MapOcclusionTome {
    dword enableTomeQueries;
    helpers::Array<byte> tome;
    helpers::Array<byte> propIDMap;
    helpers::Array<byte> reserved;

public:
    MapOcclusionTome();
    MapOcclusionTome(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapOcclusionTome(const MapOcclusionTome &p_other);
    MapOcclusionTome &operator=(const MapOcclusionTome &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapOcclusionTome Gw2Struct;
};


/* ===============================================
 * Chunk: parm, versions: 1, strucTab: 0x1420F25F8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structparm;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structparm<0>{
struct MapParam {
    float4 rect;
    dword flags;
    byte16 guid;

public:
    MapParam();
    MapParam(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapParam(const MapParam &p_other);
    MapParam &operator=(const MapParam &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapParam Gw2Struct;
};


/* ===============================================
 * Chunk: phys, versions: 11, strucTab: 0x1420F27B0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structphys;

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2Structphys<10>{
struct PackMapPhysicsMeshV10 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV10();
    PackMapPhysicsMeshV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV10(const PackMapPhysicsMeshV10 &p_other);
    PackMapPhysicsMeshV10 &operator=(const PackMapPhysicsMeshV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV10 {
    helpers::Ptr<PackMapPhysicsMeshV10> mesh;
    helpers::Array<byte> sceneFilePtr;

public:
    PackMapPhysicsObjectV10();
    PackMapPhysicsObjectV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV10(const PackMapPhysicsObjectV10 &p_other);
    PackMapPhysicsObjectV10 &operator=(const PackMapPhysicsObjectV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV10 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV10();
    PackMapPhysicsObjectRefV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV10(const PackMapPhysicsObjectRefV10 &p_other);
    PackMapPhysicsObjectRefV10 &operator=(const PackMapPhysicsObjectRefV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV10 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV10> objRefArray;
    helpers::Array<word> surface;

public:
    PackMapPhysicsGeometryV10();
    PackMapPhysicsGeometryV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV10(const PackMapPhysicsGeometryV10 &p_other);
    PackMapPhysicsGeometryV10 &operator=(const PackMapPhysicsGeometryV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV10 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV10();
    PackMapPhysicsModelPropV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV10(const PackMapPhysicsModelPropV10 &p_other);
    PackMapPhysicsModelPropV10 &operator=(const PackMapPhysicsModelPropV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV8 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV8();
    PackMapPhysicsModelZoneV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV8(const PackMapPhysicsModelZoneV8 &p_other);
    PackMapPhysicsModelZoneV8 &operator=(const PackMapPhysicsModelZoneV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV10 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV10();
    PackMapPhysicsModelObstacleV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV10(const PackMapPhysicsModelObstacleV10 &p_other);
    PackMapPhysicsModelObstacleV10 &operator=(const PackMapPhysicsModelObstacleV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsBlockV10 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV10> objectArray;
    helpers::Array<PackMapPhysicsGeometryV10> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV10> propModelArray;
    helpers::Array<PackMapPhysicsModelPropV10> debrisModelArray;
    helpers::Array<PackMapPhysicsModelZoneV8> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV10> obsModelArray;

public:
    PackMapPhysicsBlockV10();
    PackMapPhysicsBlockV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsBlockV10(const PackMapPhysicsBlockV10 &p_other);
    PackMapPhysicsBlockV10 &operator=(const PackMapPhysicsBlockV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV10 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsBlockV10> blockArray;

public:
    PackMapPhysicsV10();
    PackMapPhysicsV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV10(const PackMapPhysicsV10 &p_other);
    PackMapPhysicsV10 &operator=(const PackMapPhysicsV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x4104D4A000000001 */

template <>
struct Gw2Structphys<9>{
struct PackMapPhysicsMeshV9 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV9();
    PackMapPhysicsMeshV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV9(const PackMapPhysicsMeshV9 &p_other);
    PackMapPhysicsMeshV9 &operator=(const PackMapPhysicsMeshV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV9 {
    helpers::Ptr<PackMapPhysicsMeshV9> mesh;
    helpers::Array<byte> sceneFilePtr;

public:
    PackMapPhysicsObjectV9();
    PackMapPhysicsObjectV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV9(const PackMapPhysicsObjectV9 &p_other);
    PackMapPhysicsObjectV9 &operator=(const PackMapPhysicsObjectV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV9 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV9();
    PackMapPhysicsObjectRefV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV9(const PackMapPhysicsObjectRefV9 &p_other);
    PackMapPhysicsObjectRefV9 &operator=(const PackMapPhysicsObjectRefV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV9 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV9> objRefArray;

public:
    PackMapPhysicsGeometryV9();
    PackMapPhysicsGeometryV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV9(const PackMapPhysicsGeometryV9 &p_other);
    PackMapPhysicsGeometryV9 &operator=(const PackMapPhysicsGeometryV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV9 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV9();
    PackMapPhysicsModelPropV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV9(const PackMapPhysicsModelPropV9 &p_other);
    PackMapPhysicsModelPropV9 &operator=(const PackMapPhysicsModelPropV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV7 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV7();
    PackMapPhysicsModelZoneV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV7(const PackMapPhysicsModelZoneV7 &p_other);
    PackMapPhysicsModelZoneV7 &operator=(const PackMapPhysicsModelZoneV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV9 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV9();
    PackMapPhysicsModelObstacleV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV9(const PackMapPhysicsModelObstacleV9 &p_other);
    PackMapPhysicsModelObstacleV9 &operator=(const PackMapPhysicsModelObstacleV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsBlockV9 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV9> objectArray;
    helpers::Array<PackMapPhysicsGeometryV9> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV9> propModelArray;
    helpers::Array<PackMapPhysicsModelPropV9> debrisModelArray;
    helpers::Array<PackMapPhysicsModelZoneV7> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV9> obsModelArray;

public:
    PackMapPhysicsBlockV9();
    PackMapPhysicsBlockV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsBlockV9(const PackMapPhysicsBlockV9 &p_other);
    PackMapPhysicsBlockV9 &operator=(const PackMapPhysicsBlockV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV9 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsBlockV9> blockArray;

public:
    PackMapPhysicsV9();
    PackMapPhysicsV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV9(const PackMapPhysicsV9 &p_other);
    PackMapPhysicsV9 &operator=(const PackMapPhysicsV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structphys<8>{
struct PackMapPhysicsMeshV8 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV8();
    PackMapPhysicsMeshV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV8(const PackMapPhysicsMeshV8 &p_other);
    PackMapPhysicsMeshV8 &operator=(const PackMapPhysicsMeshV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathNodeV6 {
    float3 position;
    float4 rotation;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV6();
    ScenePathNodeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV6(const ScenePathNodeV6 &p_other);
    ScenePathNodeV6 &operator=(const ScenePathNodeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV6 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV6> points;
    byte closed;

public:
    ScenePathV6();
    ScenePathV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV6(const ScenePathV6 &p_other);
    ScenePathV6 &operator=(const ScenePathV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV6 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV6();
    SceneEdgeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV6(const SceneEdgeV6 &p_other);
    SceneEdgeV6 &operator=(const SceneEdgeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV6 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV6> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<byte> surfaces;

public:
    SceneGameMeshV6();
    SceneGameMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV6(const SceneGameMeshV6 &p_other);
    SceneGameMeshV6 &operator=(const SceneGameMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    SceneGameSurfaceV6();
    SceneGameSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameSurfaceV6(const SceneGameSurfaceV6 &p_other);
    SceneGameSurfaceV6 &operator=(const SceneGameSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV6 {
    helpers::Array<ScenePathV6> paths;
    helpers::Array<SceneGameMeshV6> meshes;
    helpers::Array<SceneGameSurfaceV6> surfaces;

public:
    SceneFileGameV6();
    SceneFileGameV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV6(const SceneFileGameV6 &p_other);
    SceneFileGameV6 &operator=(const SceneFileGameV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV8 {
    helpers::Ptr<PackMapPhysicsMeshV8> mesh;
    helpers::Ptr<SceneFilePhysicsV7> physics;
    helpers::Ptr<SceneFileGameV6> game;

public:
    PackMapPhysicsObjectV8();
    PackMapPhysicsObjectV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV8(const PackMapPhysicsObjectV8 &p_other);
    PackMapPhysicsObjectV8 &operator=(const PackMapPhysicsObjectV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV8 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV8();
    PackMapPhysicsObjectRefV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV8(const PackMapPhysicsObjectRefV8 &p_other);
    PackMapPhysicsObjectRefV8 &operator=(const PackMapPhysicsObjectRefV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV8 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV8> objRefArray;

public:
    PackMapPhysicsGeometryV8();
    PackMapPhysicsGeometryV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV8(const PackMapPhysicsGeometryV8 &p_other);
    PackMapPhysicsGeometryV8 &operator=(const PackMapPhysicsGeometryV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV8 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV8();
    PackMapPhysicsModelPropV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV8(const PackMapPhysicsModelPropV8 &p_other);
    PackMapPhysicsModelPropV8 &operator=(const PackMapPhysicsModelPropV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV6 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV6();
    PackMapPhysicsModelZoneV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV6(const PackMapPhysicsModelZoneV6 &p_other);
    PackMapPhysicsModelZoneV6 &operator=(const PackMapPhysicsModelZoneV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV8 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV8();
    PackMapPhysicsModelObstacleV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV8(const PackMapPhysicsModelObstacleV8 &p_other);
    PackMapPhysicsModelObstacleV8 &operator=(const PackMapPhysicsModelObstacleV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsBlockV8 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV8> objectArray;
    helpers::Array<PackMapPhysicsGeometryV8> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV8> propModelArray;
    helpers::Array<PackMapPhysicsModelPropV8> debrisModelArray;
    helpers::Array<PackMapPhysicsModelZoneV6> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV8> obsModelArray;

public:
    PackMapPhysicsBlockV8();
    PackMapPhysicsBlockV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsBlockV8(const PackMapPhysicsBlockV8 &p_other);
    PackMapPhysicsBlockV8 &operator=(const PackMapPhysicsBlockV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV8 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsBlockV8> blockArray;

public:
    PackMapPhysicsV8();
    PackMapPhysicsV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV8(const PackMapPhysicsV8 &p_other);
    PackMapPhysicsV8 &operator=(const PackMapPhysicsV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structphys<7>{
struct PackMapPhysicsMeshV7 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV7();
    PackMapPhysicsMeshV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV7(const PackMapPhysicsMeshV7 &p_other);
    PackMapPhysicsMeshV7 &operator=(const PackMapPhysicsMeshV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathNodeV6 {
    float3 position;
    float4 rotation;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV6();
    ScenePathNodeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV6(const ScenePathNodeV6 &p_other);
    ScenePathNodeV6 &operator=(const ScenePathNodeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV6 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV6> points;
    byte closed;

public:
    ScenePathV6();
    ScenePathV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV6(const ScenePathV6 &p_other);
    ScenePathV6 &operator=(const ScenePathV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV6 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV6();
    SceneEdgeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV6(const SceneEdgeV6 &p_other);
    SceneEdgeV6 &operator=(const SceneEdgeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV6 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV6> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<byte> surfaces;

public:
    SceneGameMeshV6();
    SceneGameMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV6(const SceneGameMeshV6 &p_other);
    SceneGameMeshV6 &operator=(const SceneGameMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    SceneGameSurfaceV6();
    SceneGameSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameSurfaceV6(const SceneGameSurfaceV6 &p_other);
    SceneGameSurfaceV6 &operator=(const SceneGameSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV6 {
    helpers::Array<ScenePathV6> paths;
    helpers::Array<SceneGameMeshV6> meshes;
    helpers::Array<SceneGameSurfaceV6> surfaces;

public:
    SceneFileGameV6();
    SceneFileGameV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV6(const SceneFileGameV6 &p_other);
    SceneFileGameV6 &operator=(const SceneFileGameV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV7 {
    helpers::Ptr<PackMapPhysicsMeshV7> mesh;
    helpers::Ptr<SceneFilePhysicsV7> physics;
    helpers::Ptr<SceneFileGameV6> game;

public:
    PackMapPhysicsObjectV7();
    PackMapPhysicsObjectV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV7(const PackMapPhysicsObjectV7 &p_other);
    PackMapPhysicsObjectV7 &operator=(const PackMapPhysicsObjectV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV7 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV7();
    PackMapPhysicsObjectRefV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV7(const PackMapPhysicsObjectRefV7 &p_other);
    PackMapPhysicsObjectRefV7 &operator=(const PackMapPhysicsObjectRefV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV7 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV7> objRefArray;

public:
    PackMapPhysicsGeometryV7();
    PackMapPhysicsGeometryV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV7(const PackMapPhysicsGeometryV7 &p_other);
    PackMapPhysicsGeometryV7 &operator=(const PackMapPhysicsGeometryV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV7 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV7();
    PackMapPhysicsModelPropV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV7(const PackMapPhysicsModelPropV7 &p_other);
    PackMapPhysicsModelPropV7 &operator=(const PackMapPhysicsModelPropV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV5 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV5();
    PackMapPhysicsModelZoneV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV5(const PackMapPhysicsModelZoneV5 &p_other);
    PackMapPhysicsModelZoneV5 &operator=(const PackMapPhysicsModelZoneV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV7 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV7();
    PackMapPhysicsModelObstacleV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV7(const PackMapPhysicsModelObstacleV7 &p_other);
    PackMapPhysicsModelObstacleV7 &operator=(const PackMapPhysicsModelObstacleV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsBlockV7 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV7> objectArray;
    helpers::Array<PackMapPhysicsGeometryV7> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV7> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV5> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV7> obsModelArray;

public:
    PackMapPhysicsBlockV7();
    PackMapPhysicsBlockV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsBlockV7(const PackMapPhysicsBlockV7 &p_other);
    PackMapPhysicsBlockV7 &operator=(const PackMapPhysicsBlockV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV7 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsBlockV7> blockArray;

public:
    PackMapPhysicsV7();
    PackMapPhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV7(const PackMapPhysicsV7 &p_other);
    PackMapPhysicsV7 &operator=(const PackMapPhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x4104D49000000001 */

template <>
struct Gw2Structphys<6>{
struct PackMapPhysicsMeshV6 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV6();
    PackMapPhysicsMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV6(const PackMapPhysicsMeshV6 &p_other);
    PackMapPhysicsMeshV6 &operator=(const PackMapPhysicsMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathNodeV6 {
    float3 position;
    float4 rotation;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV6();
    ScenePathNodeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV6(const ScenePathNodeV6 &p_other);
    ScenePathNodeV6 &operator=(const ScenePathNodeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV6 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV6> points;
    byte closed;

public:
    ScenePathV6();
    ScenePathV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV6(const ScenePathV6 &p_other);
    ScenePathV6 &operator=(const ScenePathV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV6 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV6();
    SceneEdgeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV6(const SceneEdgeV6 &p_other);
    SceneEdgeV6 &operator=(const SceneEdgeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV6 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV6> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<byte> surfaces;

public:
    SceneGameMeshV6();
    SceneGameMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV6(const SceneGameMeshV6 &p_other);
    SceneGameMeshV6 &operator=(const SceneGameMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    SceneGameSurfaceV6();
    SceneGameSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameSurfaceV6(const SceneGameSurfaceV6 &p_other);
    SceneGameSurfaceV6 &operator=(const SceneGameSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV6 {
    helpers::Array<ScenePathV6> paths;
    helpers::Array<SceneGameMeshV6> meshes;
    helpers::Array<SceneGameSurfaceV6> surfaces;

public:
    SceneFileGameV6();
    SceneFileGameV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV6(const SceneFileGameV6 &p_other);
    SceneFileGameV6 &operator=(const SceneFileGameV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV6 {
    helpers::Ptr<PackMapPhysicsMeshV6> mesh;
    helpers::Ptr<SceneFilePhysicsV7> physics;
    helpers::Ptr<SceneFileGameV6> game;

public:
    PackMapPhysicsObjectV6();
    PackMapPhysicsObjectV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV6(const PackMapPhysicsObjectV6 &p_other);
    PackMapPhysicsObjectV6 &operator=(const PackMapPhysicsObjectV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV6 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV6();
    PackMapPhysicsObjectRefV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV6(const PackMapPhysicsObjectRefV6 &p_other);
    PackMapPhysicsObjectRefV6 &operator=(const PackMapPhysicsObjectRefV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV6 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV6> objRefArray;

public:
    PackMapPhysicsGeometryV6();
    PackMapPhysicsGeometryV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV6(const PackMapPhysicsGeometryV6 &p_other);
    PackMapPhysicsGeometryV6 &operator=(const PackMapPhysicsGeometryV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV6 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV6();
    PackMapPhysicsModelPropV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV6(const PackMapPhysicsModelPropV6 &p_other);
    PackMapPhysicsModelPropV6 &operator=(const PackMapPhysicsModelPropV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV4 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV4();
    PackMapPhysicsModelZoneV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV4(const PackMapPhysicsModelZoneV4 &p_other);
    PackMapPhysicsModelZoneV4 &operator=(const PackMapPhysicsModelZoneV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV6 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV6();
    PackMapPhysicsModelObstacleV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV6(const PackMapPhysicsModelObstacleV6 &p_other);
    PackMapPhysicsModelObstacleV6 &operator=(const PackMapPhysicsModelObstacleV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV6 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV6> objectArray;
    helpers::Array<PackMapPhysicsGeometryV6> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV6> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV4> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV6> obsModelArray;

public:
    PackMapPhysicsV6();
    PackMapPhysicsV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV6(const PackMapPhysicsV6 &p_other);
    PackMapPhysicsV6 &operator=(const PackMapPhysicsV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x4104D49000000001 */

template <>
struct Gw2Structphys<5>{
struct PackMapPhysicsMeshV5 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV5();
    PackMapPhysicsMeshV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV5(const PackMapPhysicsMeshV5 &p_other);
    PackMapPhysicsMeshV5 &operator=(const PackMapPhysicsMeshV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathNodeV5 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV5();
    ScenePathNodeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV5(const ScenePathNodeV5 &p_other);
    ScenePathNodeV5 &operator=(const ScenePathNodeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV5 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV5> points;
    byte closed;

public:
    ScenePathV5();
    ScenePathV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV5(const ScenePathV5 &p_other);
    ScenePathV5 &operator=(const ScenePathV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV5 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV5();
    SceneEdgeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV5(const SceneEdgeV5 &p_other);
    SceneEdgeV5 &operator=(const SceneEdgeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV5 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV5> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<dword> surfaceFlags;

public:
    SceneGameMeshV5();
    SceneGameMeshV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV5(const SceneGameMeshV5 &p_other);
    SceneGameMeshV5 &operator=(const SceneGameMeshV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV5 {
    helpers::Array<ScenePathV5> paths;
    helpers::Array<SceneGameMeshV5> meshes;

public:
    SceneFileGameV5();
    SceneFileGameV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV5(const SceneFileGameV5 &p_other);
    SceneFileGameV5 &operator=(const SceneFileGameV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV5 {
    helpers::Ptr<PackMapPhysicsMeshV5> mesh;
    helpers::Ptr<SceneFilePhysicsV7> physics;
    helpers::Ptr<SceneFileGameV5> game;

public:
    PackMapPhysicsObjectV5();
    PackMapPhysicsObjectV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV5(const PackMapPhysicsObjectV5 &p_other);
    PackMapPhysicsObjectV5 &operator=(const PackMapPhysicsObjectV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV5 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV5();
    PackMapPhysicsObjectRefV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV5(const PackMapPhysicsObjectRefV5 &p_other);
    PackMapPhysicsObjectRefV5 &operator=(const PackMapPhysicsObjectRefV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV5 {
    helpers::WString filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV5> objRefArray;

public:
    PackMapPhysicsGeometryV5();
    PackMapPhysicsGeometryV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV5(const PackMapPhysicsGeometryV5 &p_other);
    PackMapPhysicsGeometryV5 &operator=(const PackMapPhysicsGeometryV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV5 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV5();
    PackMapPhysicsModelPropV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV5(const PackMapPhysicsModelPropV5 &p_other);
    PackMapPhysicsModelPropV5 &operator=(const PackMapPhysicsModelPropV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV3 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV3();
    PackMapPhysicsModelZoneV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV3(const PackMapPhysicsModelZoneV3 &p_other);
    PackMapPhysicsModelZoneV3 &operator=(const PackMapPhysicsModelZoneV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV5 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV5();
    PackMapPhysicsModelObstacleV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV5(const PackMapPhysicsModelObstacleV5 &p_other);
    PackMapPhysicsModelObstacleV5 &operator=(const PackMapPhysicsModelObstacleV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV5 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV5> objectArray;
    helpers::Array<PackMapPhysicsGeometryV5> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV5> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV3> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV5> obsModelArray;

public:
    PackMapPhysicsV5();
    PackMapPhysicsV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV5(const PackMapPhysicsV5 &p_other);
    PackMapPhysicsV5 &operator=(const PackMapPhysicsV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x4104D49000000001 */

template <>
struct Gw2Structphys<4>{
struct PackMapPhysicsMeshV4 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV4();
    PackMapPhysicsMeshV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV4(const PackMapPhysicsMeshV4 &p_other);
    PackMapPhysicsMeshV4 &operator=(const PackMapPhysicsMeshV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathNodeV5 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV5();
    ScenePathNodeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV5(const ScenePathNodeV5 &p_other);
    ScenePathNodeV5 &operator=(const ScenePathNodeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV5 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV5> points;
    byte closed;

public:
    ScenePathV5();
    ScenePathV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV5(const ScenePathV5 &p_other);
    ScenePathV5 &operator=(const ScenePathV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV5 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV5();
    SceneEdgeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV5(const SceneEdgeV5 &p_other);
    SceneEdgeV5 &operator=(const SceneEdgeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV5 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV5> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<dword> surfaceFlags;

public:
    SceneGameMeshV5();
    SceneGameMeshV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV5(const SceneGameMeshV5 &p_other);
    SceneGameMeshV5 &operator=(const SceneGameMeshV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV5 {
    helpers::Array<ScenePathV5> paths;
    helpers::Array<SceneGameMeshV5> meshes;

public:
    SceneFileGameV5();
    SceneFileGameV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV5(const SceneFileGameV5 &p_other);
    SceneFileGameV5 &operator=(const SceneFileGameV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectV4 {
    helpers::Ptr<PackMapPhysicsMeshV4> mesh;
    helpers::Ptr<SceneFilePhysicsV7> physics;
    helpers::Ptr<SceneFileGameV5> game;

public:
    PackMapPhysicsObjectV4();
    PackMapPhysicsObjectV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectV4(const PackMapPhysicsObjectV4 &p_other);
    PackMapPhysicsObjectV4 &operator=(const PackMapPhysicsObjectV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsObjectRefV4 {
    qword sequence;
    dword objectIndex;

public:
    PackMapPhysicsObjectRefV4();
    PackMapPhysicsObjectRefV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsObjectRefV4(const PackMapPhysicsObjectRefV4 &p_other);
    PackMapPhysicsObjectRefV4 &operator=(const PackMapPhysicsObjectRefV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV4 {
    helpers::FileName filePath;
    byte quantizedExtents;
    helpers::Array<PackMapPhysicsObjectRefV4> objRefArray;

public:
    PackMapPhysicsGeometryV4();
    PackMapPhysicsGeometryV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV4(const PackMapPhysicsGeometryV4 &p_other);
    PackMapPhysicsGeometryV4 &operator=(const PackMapPhysicsGeometryV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV4 {
    qword token;
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV4();
    PackMapPhysicsModelPropV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV4(const PackMapPhysicsModelPropV4 &p_other);
    PackMapPhysicsModelPropV4 &operator=(const PackMapPhysicsModelPropV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV2 {
    float scale;
    float3 translate;
    float4 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV2();
    PackMapPhysicsModelZoneV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV2(const PackMapPhysicsModelZoneV2 &p_other);
    PackMapPhysicsModelZoneV2 &operator=(const PackMapPhysicsModelZoneV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelObstacleV4 {
    float3 translate;
    dword geometryIndex;

public:
    PackMapPhysicsModelObstacleV4();
    PackMapPhysicsModelObstacleV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelObstacleV4(const PackMapPhysicsModelObstacleV4 &p_other);
    PackMapPhysicsModelObstacleV4 &operator=(const PackMapPhysicsModelObstacleV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV4 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsObjectV4> objectArray;
    helpers::Array<PackMapPhysicsGeometryV4> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV4> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV2> zoneModelArray;
    helpers::Array<PackMapPhysicsModelObstacleV4> obsModelArray;

public:
    PackMapPhysicsV4();
    PackMapPhysicsV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV4(const PackMapPhysicsV4 &p_other);
    PackMapPhysicsV4 &operator=(const PackMapPhysicsV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structphys<3>{
struct PackMapPhysicsMeshV3 {
    helpers::Array<word> indexArray;
    helpers::Array<float3> vertexArray;
    helpers::Array<byte> moppCodeData;

public:
    PackMapPhysicsMeshV3();
    PackMapPhysicsMeshV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsMeshV3(const PackMapPhysicsMeshV3 &p_other);
    PackMapPhysicsMeshV3 &operator=(const PackMapPhysicsMeshV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsShapeDataV3 {
    float scale;
    helpers::Array<byte> gameDataPtr;

public:
    PackMapPhysicsShapeDataV3();
    PackMapPhysicsShapeDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsShapeDataV3(const PackMapPhysicsShapeDataV3 &p_other);
    PackMapPhysicsShapeDataV3 &operator=(const PackMapPhysicsShapeDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV3 {
    helpers::Array<dword> shapeDataIndexArray;

public:
    PackMapPhysicsGeometryV3();
    PackMapPhysicsGeometryV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV3(const PackMapPhysicsGeometryV3 &p_other);
    PackMapPhysicsGeometryV3 &operator=(const PackMapPhysicsGeometryV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV3 {
    dword2 token;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV3();
    PackMapPhysicsModelPropV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV3(const PackMapPhysicsModelPropV3 &p_other);
    PackMapPhysicsModelPropV3 &operator=(const PackMapPhysicsModelPropV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV1 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV1();
    PackMapPhysicsModelZoneV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV1(const PackMapPhysicsModelZoneV1 &p_other);
    PackMapPhysicsModelZoneV1 &operator=(const PackMapPhysicsModelZoneV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV3 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsMeshV3> meshArray;
    helpers::Array<PackMapPhysicsShapeDataV3> shapeArray;
    helpers::Array<PackMapPhysicsGeometryV3> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV3> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV1> zoneModelArray;

public:
    PackMapPhysicsV3();
    PackMapPhysicsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV3(const PackMapPhysicsV3 &p_other);
    PackMapPhysicsV3 &operator=(const PackMapPhysicsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x4104D48000000001 */

template <>
struct Gw2Structphys<2>{
struct PackMapPhysicsShapeDataV2 {
    float scale;
    helpers::Array<byte> gameDataPtr;

public:
    PackMapPhysicsShapeDataV2();
    PackMapPhysicsShapeDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsShapeDataV2(const PackMapPhysicsShapeDataV2 &p_other);
    PackMapPhysicsShapeDataV2 &operator=(const PackMapPhysicsShapeDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV2 {
    helpers::Array<dword> shapeDataIndexArray;

public:
    PackMapPhysicsGeometryV2();
    PackMapPhysicsGeometryV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV2(const PackMapPhysicsGeometryV2 &p_other);
    PackMapPhysicsGeometryV2 &operator=(const PackMapPhysicsGeometryV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV2 {
    dword2 token;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV2();
    PackMapPhysicsModelPropV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV2(const PackMapPhysicsModelPropV2 &p_other);
    PackMapPhysicsModelPropV2 &operator=(const PackMapPhysicsModelPropV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelZoneV0 {
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelZoneV0();
    PackMapPhysicsModelZoneV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelZoneV0(const PackMapPhysicsModelZoneV0 &p_other);
    PackMapPhysicsModelZoneV0 &operator=(const PackMapPhysicsModelZoneV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV2 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsShapeDataV2> shapeArray;
    helpers::Array<PackMapPhysicsGeometryV2> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV2> propModelArray;
    helpers::Array<PackMapPhysicsModelZoneV0> zoneModelArray;

public:
    PackMapPhysicsV2();
    PackMapPhysicsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV2(const PackMapPhysicsV2 &p_other);
    PackMapPhysicsV2 &operator=(const PackMapPhysicsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x4104D47000000001 */

template <>
struct Gw2Structphys<1>{
struct PackMapPhysicsShapeDataV1 {
    float scale;
    helpers::Array<byte> gameDataPtr;

public:
    PackMapPhysicsShapeDataV1();
    PackMapPhysicsShapeDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsShapeDataV1(const PackMapPhysicsShapeDataV1 &p_other);
    PackMapPhysicsShapeDataV1 &operator=(const PackMapPhysicsShapeDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsGeometryV1 {
    helpers::Array<dword> shapeDataIndexArray;

public:
    PackMapPhysicsGeometryV1();
    PackMapPhysicsGeometryV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsGeometryV1(const PackMapPhysicsGeometryV1 &p_other);
    PackMapPhysicsGeometryV1 &operator=(const PackMapPhysicsGeometryV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsModelPropV1 {
    dword2 token;
    float scale;
    float3 translate;
    float3 rotate;
    dword geometryIndex;

public:
    PackMapPhysicsModelPropV1();
    PackMapPhysicsModelPropV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsModelPropV1(const PackMapPhysicsModelPropV1 &p_other);
    PackMapPhysicsModelPropV1 &operator=(const PackMapPhysicsModelPropV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsV1 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<PackMapPhysicsShapeDataV1> shapeArray;
    helpers::Array<PackMapPhysicsGeometryV1> geometryArray;
    helpers::Array<PackMapPhysicsModelPropV1> propModelArray;

public:
    PackMapPhysicsV1();
    PackMapPhysicsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsV1(const PackMapPhysicsV1 &p_other);
    PackMapPhysicsV1 &operator=(const PackMapPhysicsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsV1 Gw2Struct;
};


/* ===============================================
 * Chunk: pnvm, versions: 3, strucTab: 0x1420F28C0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structpnvm;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structpnvm<2>{
struct PackMapPhysicsNavMeshChunkV2 {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> mediatorMoppData;
    helpers::Array<byte> coarseGraphData;

public:
    PackMapPhysicsNavMeshChunkV2();
    PackMapPhysicsNavMeshChunkV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshChunkV2(const PackMapPhysicsNavMeshChunkV2 &p_other);
    PackMapPhysicsNavMeshChunkV2 &operator=(const PackMapPhysicsNavMeshChunkV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsNavMeshV2 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    float erosionRadius;
    helpers::Array<PackMapPhysicsNavMeshChunkV2> chunkArray;

public:
    PackMapPhysicsNavMeshV2();
    PackMapPhysicsNavMeshV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshV2(const PackMapPhysicsNavMeshV2 &p_other);
    PackMapPhysicsNavMeshV2 &operator=(const PackMapPhysicsNavMeshV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsNavMeshV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x4105008000000001 */

template <>
struct Gw2Structpnvm<1>{
struct PackMapPhysicsNavMeshChunkV1 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> mediatorMoppData;
    helpers::Array<byte> coarseGraphData;

public:
    PackMapPhysicsNavMeshChunkV1();
    PackMapPhysicsNavMeshChunkV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshChunkV1(const PackMapPhysicsNavMeshChunkV1 &p_other);
    PackMapPhysicsNavMeshChunkV1 &operator=(const PackMapPhysicsNavMeshChunkV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsNavMeshV1 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapPhysicsNavMeshChunkV1> chunkArray;

public:
    PackMapPhysicsNavMeshV1();
    PackMapPhysicsNavMeshV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshV1(const PackMapPhysicsNavMeshV1 &p_other);
    PackMapPhysicsNavMeshV1 &operator=(const PackMapPhysicsNavMeshV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsNavMeshV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structpnvm<0>{
struct PackMapPhysicsNavMeshChunkV0 {
    float3 boundsMin;
    float3 boundsMax;
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> mediatorMoppData;

public:
    PackMapPhysicsNavMeshChunkV0();
    PackMapPhysicsNavMeshChunkV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshChunkV0(const PackMapPhysicsNavMeshChunkV0 &p_other);
    PackMapPhysicsNavMeshChunkV0 &operator=(const PackMapPhysicsNavMeshChunkV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPhysicsNavMeshV0 {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<PackMapPhysicsNavMeshChunkV0> chunkArray;

public:
    PackMapPhysicsNavMeshV0();
    PackMapPhysicsNavMeshV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPhysicsNavMeshV0(const PackMapPhysicsNavMeshV0 &p_other);
    PackMapPhysicsNavMeshV0 &operator=(const PackMapPhysicsNavMeshV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPhysicsNavMeshV0 Gw2Struct;
};


/* ===============================================
 * Chunk: prp2, versions: 22, strucTab: 0x1420F2910
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structprp2;

/* Version: 21, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<21>{
struct PackMapPropConstantV18 {
    dword token;
    float4 constant;
    dword submodel;

public:
    PackMapPropConstantV18();
    PackMapPropConstantV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropConstantV18(const PackMapPropConstantV18 &p_other);
    PackMapPropConstantV18 &operator=(const PackMapPropConstantV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjV21 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV18> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    dword reserved;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;

public:
    PackMapPropObjV21();
    PackMapPropObjV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV21(const PackMapPropObjV21 &p_other);
    PackMapPropObjV21 &operator=(const PackMapPropObjV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV21 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV18> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    dword reserved;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV21();
    PackMapPropObjAnimSeqV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV21(const PackMapPropObjAnimSeqV21 &p_other);
    PackMapPropObjAnimSeqV21 &operator=(const PackMapPropObjAnimSeqV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV21 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV21();
    PackMapPropTransformV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV21(const PackMapPropTransformV21 &p_other);
    PackMapPropTransformV21 &operator=(const PackMapPropTransformV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV21 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV18> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    dword reserved;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    helpers::Array<PackMapPropTransformV21> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV21();
    PackMapPropObjInstanceV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV21(const PackMapPropObjInstanceV21 &p_other);
    PackMapPropObjInstanceV21 &operator=(const PackMapPropObjInstanceV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV21 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV21();
    PackMapPropObjToolV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV21(const PackMapPropObjToolV21 &p_other);
    PackMapPropObjToolV21 &operator=(const PackMapPropObjToolV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV21 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV18> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    dword reserved;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV21();
    PackMapPropObjMetaV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV21(const PackMapPropObjMetaV21 &p_other);
    PackMapPropObjMetaV21 &operator=(const PackMapPropObjMetaV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV21 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV21();
    PackMapPropObjVolumeV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV21(const PackMapPropObjVolumeV21 &p_other);
    PackMapPropObjVolumeV21 &operator=(const PackMapPropObjVolumeV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV21 {
    helpers::Array<PackMapPropObjV21> propArray;
    helpers::Array<PackMapPropObjAnimSeqV21> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV21> propInstanceArray;
    helpers::Array<PackMapPropObjToolV21> propToolArray;
    helpers::Array<PackMapPropObjMetaV21> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV21> propVolumeArray;
    helpers::WString reserved;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV21();
    PackMapPropV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV21(const PackMapPropV21 &p_other);
    PackMapPropV21 &operator=(const PackMapPropV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV21 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<20>{
struct PackMapPropConstantV17 {
    dword token;
    float4 constant;
    dword submodel;

public:
    PackMapPropConstantV17();
    PackMapPropConstantV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropConstantV17(const PackMapPropConstantV17 &p_other);
    PackMapPropConstantV17 &operator=(const PackMapPropConstantV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjV20 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV17> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;

public:
    PackMapPropObjV20();
    PackMapPropObjV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV20(const PackMapPropObjV20 &p_other);
    PackMapPropObjV20 &operator=(const PackMapPropObjV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV20 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV17> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV20();
    PackMapPropObjAnimSeqV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV20(const PackMapPropObjAnimSeqV20 &p_other);
    PackMapPropObjAnimSeqV20 &operator=(const PackMapPropObjAnimSeqV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV20 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV20();
    PackMapPropTransformV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV20(const PackMapPropTransformV20 &p_other);
    PackMapPropTransformV20 &operator=(const PackMapPropTransformV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV20 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV17> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    helpers::Array<PackMapPropTransformV20> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV20();
    PackMapPropObjInstanceV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV20(const PackMapPropObjInstanceV20 &p_other);
    PackMapPropObjInstanceV20 &operator=(const PackMapPropObjInstanceV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV20 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV20();
    PackMapPropObjToolV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV20(const PackMapPropObjToolV20 &p_other);
    PackMapPropObjToolV20 &operator=(const PackMapPropObjToolV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV20 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<PackMapPropConstantV17> constants;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV20();
    PackMapPropObjMetaV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV20(const PackMapPropObjMetaV20 &p_other);
    PackMapPropObjMetaV20 &operator=(const PackMapPropObjMetaV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV20 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV20();
    PackMapPropObjVolumeV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV20(const PackMapPropObjVolumeV20 &p_other);
    PackMapPropObjVolumeV20 &operator=(const PackMapPropObjVolumeV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV20 {
    helpers::Array<PackMapPropObjV20> propArray;
    helpers::Array<PackMapPropObjAnimSeqV20> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV20> propInstanceArray;
    helpers::Array<PackMapPropObjToolV20> propToolArray;
    helpers::Array<PackMapPropObjMetaV20> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV20> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV20();
    PackMapPropV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV20(const PackMapPropV20 &p_other);
    PackMapPropV20 &operator=(const PackMapPropV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV20 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<19>{
struct PackMapPropObjV19 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<dword> constTokens;
    helpers::Array<float4> constValues;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;

public:
    PackMapPropObjV19();
    PackMapPropObjV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV19(const PackMapPropObjV19 &p_other);
    PackMapPropObjV19 &operator=(const PackMapPropObjV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV19 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<dword> constTokens;
    helpers::Array<float4> constValues;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV19();
    PackMapPropObjAnimSeqV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV19(const PackMapPropObjAnimSeqV19 &p_other);
    PackMapPropObjAnimSeqV19 &operator=(const PackMapPropObjAnimSeqV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV19 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV19();
    PackMapPropTransformV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV19(const PackMapPropTransformV19 &p_other);
    PackMapPropTransformV19 &operator=(const PackMapPropTransformV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV19 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<dword> constTokens;
    helpers::Array<float4> constValues;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    helpers::Array<PackMapPropTransformV19> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV19();
    PackMapPropObjInstanceV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV19(const PackMapPropObjInstanceV19 &p_other);
    PackMapPropObjInstanceV19 &operator=(const PackMapPropObjInstanceV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV19 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV19();
    PackMapPropObjToolV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV19(const PackMapPropObjToolV19 &p_other);
    PackMapPropObjToolV19 &operator=(const PackMapPropObjToolV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV19 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    helpers::Array<dword> constTokens;
    helpers::Array<float4> constValues;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV19();
    PackMapPropObjMetaV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV19(const PackMapPropObjMetaV19 &p_other);
    PackMapPropObjMetaV19 &operator=(const PackMapPropObjMetaV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV19 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV19();
    PackMapPropObjVolumeV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV19(const PackMapPropObjVolumeV19 &p_other);
    PackMapPropObjVolumeV19 &operator=(const PackMapPropObjVolumeV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV19 {
    helpers::Array<PackMapPropObjV19> propArray;
    helpers::Array<PackMapPropObjAnimSeqV19> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV19> propInstanceArray;
    helpers::Array<PackMapPropObjToolV19> propToolArray;
    helpers::Array<PackMapPropObjMetaV19> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV19> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV19();
    PackMapPropV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV19(const PackMapPropV19 &p_other);
    PackMapPropV19 &operator=(const PackMapPropV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV19 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<18>{
struct PackMapPropObjV18 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;

public:
    PackMapPropObjV18();
    PackMapPropObjV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV18(const PackMapPropObjV18 &p_other);
    PackMapPropObjV18 &operator=(const PackMapPropObjV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV18 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV18();
    PackMapPropObjAnimSeqV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV18(const PackMapPropObjAnimSeqV18 &p_other);
    PackMapPropObjAnimSeqV18 &operator=(const PackMapPropObjAnimSeqV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV18 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV18();
    PackMapPropTransformV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV18(const PackMapPropTransformV18 &p_other);
    PackMapPropTransformV18 &operator=(const PackMapPropTransformV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV18 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    helpers::Array<PackMapPropTransformV18> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV18();
    PackMapPropObjInstanceV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV18(const PackMapPropObjInstanceV18 &p_other);
    PackMapPropObjInstanceV18 &operator=(const PackMapPropObjInstanceV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV18 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV18();
    PackMapPropObjToolV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV18(const PackMapPropObjToolV18 &p_other);
    PackMapPropObjToolV18 &operator=(const PackMapPropObjToolV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV18 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    byte sortLayer;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV18();
    PackMapPropObjMetaV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV18(const PackMapPropObjMetaV18 &p_other);
    PackMapPropObjMetaV18 &operator=(const PackMapPropObjMetaV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV18 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV18();
    PackMapPropObjVolumeV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV18(const PackMapPropObjVolumeV18 &p_other);
    PackMapPropObjVolumeV18 &operator=(const PackMapPropObjVolumeV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV18 {
    helpers::Array<PackMapPropObjV18> propArray;
    helpers::Array<PackMapPropObjAnimSeqV18> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV18> propInstanceArray;
    helpers::Array<PackMapPropObjToolV18> propToolArray;
    helpers::Array<PackMapPropObjMetaV18> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV18> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV18();
    PackMapPropV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV18(const PackMapPropV18 &p_other);
    PackMapPropV18 &operator=(const PackMapPropV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x410523D000000001 */

template <>
struct Gw2Structprp2<17>{
struct PackMapPropObjV17 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;

public:
    PackMapPropObjV17();
    PackMapPropObjV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV17(const PackMapPropObjV17 &p_other);
    PackMapPropObjV17 &operator=(const PackMapPropObjV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV17 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV17();
    PackMapPropObjAnimSeqV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV17(const PackMapPropObjAnimSeqV17 &p_other);
    PackMapPropObjAnimSeqV17 &operator=(const PackMapPropObjAnimSeqV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV17 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV17();
    PackMapPropTransformV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV17(const PackMapPropTransformV17 &p_other);
    PackMapPropTransformV17 &operator=(const PackMapPropTransformV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV17 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    helpers::Array<PackMapPropTransformV17> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV17();
    PackMapPropObjInstanceV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV17(const PackMapPropObjInstanceV17 &p_other);
    PackMapPropObjInstanceV17 &operator=(const PackMapPropObjInstanceV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV17 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV17();
    PackMapPropObjToolV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV17(const PackMapPropObjToolV17 &p_other);
    PackMapPropObjToolV17 &operator=(const PackMapPropObjToolV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV17 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV17();
    PackMapPropObjMetaV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV17(const PackMapPropObjMetaV17 &p_other);
    PackMapPropObjMetaV17 &operator=(const PackMapPropObjMetaV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV17 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV17();
    PackMapPropObjVolumeV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV17(const PackMapPropObjVolumeV17 &p_other);
    PackMapPropObjVolumeV17 &operator=(const PackMapPropObjVolumeV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV17 {
    helpers::Array<PackMapPropObjV17> propArray;
    helpers::Array<PackMapPropObjAnimSeqV17> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV17> propInstanceArray;
    helpers::Array<PackMapPropObjToolV17> propToolArray;
    helpers::Array<PackMapPropObjMetaV17> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV17> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV17();
    PackMapPropV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV17(const PackMapPropV17 &p_other);
    PackMapPropV17 &operator=(const PackMapPropV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<16>{
struct PackMapPropObjV16 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;

public:
    PackMapPropObjV16();
    PackMapPropObjV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV16(const PackMapPropObjV16 &p_other);
    PackMapPropObjV16 &operator=(const PackMapPropObjV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV16 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV16();
    PackMapPropObjAnimSeqV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV16(const PackMapPropObjAnimSeqV16 &p_other);
    PackMapPropObjAnimSeqV16 &operator=(const PackMapPropObjAnimSeqV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV16 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV16();
    PackMapPropTransformV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV16(const PackMapPropTransformV16 &p_other);
    PackMapPropTransformV16 &operator=(const PackMapPropTransformV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV16 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    helpers::Array<PackMapPropTransformV16> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV16();
    PackMapPropObjInstanceV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV16(const PackMapPropObjInstanceV16 &p_other);
    PackMapPropObjInstanceV16 &operator=(const PackMapPropObjInstanceV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV16 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV16();
    PackMapPropObjToolV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV16(const PackMapPropObjToolV16 &p_other);
    PackMapPropObjToolV16 &operator=(const PackMapPropObjToolV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV16 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    qword permutation;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV16();
    PackMapPropObjMetaV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV16(const PackMapPropObjMetaV16 &p_other);
    PackMapPropObjMetaV16 &operator=(const PackMapPropObjMetaV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV16 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV16();
    PackMapPropObjVolumeV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV16(const PackMapPropObjVolumeV16 &p_other);
    PackMapPropObjVolumeV16 &operator=(const PackMapPropObjVolumeV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV16 {
    helpers::Array<PackMapPropObjV16> propArray;
    helpers::Array<PackMapPropObjAnimSeqV16> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV16> propInstanceArray;
    helpers::Array<PackMapPropObjToolV16> propToolArray;
    helpers::Array<PackMapPropObjMetaV16> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV16> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV16();
    PackMapPropV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV16(const PackMapPropV16 &p_other);
    PackMapPropV16 &operator=(const PackMapPropV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<15>{
struct PackMapPropObjV15 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;

public:
    PackMapPropObjV15();
    PackMapPropObjV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV15(const PackMapPropObjV15 &p_other);
    PackMapPropObjV15 &operator=(const PackMapPropObjV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV15 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV15();
    PackMapPropObjAnimSeqV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV15(const PackMapPropObjAnimSeqV15 &p_other);
    PackMapPropObjAnimSeqV15 &operator=(const PackMapPropObjAnimSeqV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropTransformV15 {
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropTransformV15();
    PackMapPropTransformV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropTransformV15(const PackMapPropTransformV15 &p_other);
    PackMapPropTransformV15 &operator=(const PackMapPropTransformV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjInstanceV15 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    helpers::Array<PackMapPropTransformV15> transforms;
    helpers::Array<qword> origGuidArray;

public:
    PackMapPropObjInstanceV15();
    PackMapPropObjInstanceV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjInstanceV15(const PackMapPropObjInstanceV15 &p_other);
    PackMapPropObjInstanceV15 &operator=(const PackMapPropObjInstanceV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV15 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV15();
    PackMapPropObjToolV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV15(const PackMapPropObjToolV15 &p_other);
    PackMapPropObjToolV15 &operator=(const PackMapPropObjToolV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV15 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float4 bounds;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV15();
    PackMapPropObjMetaV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV15(const PackMapPropObjMetaV15 &p_other);
    PackMapPropObjMetaV15 &operator=(const PackMapPropObjMetaV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV15 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV15();
    PackMapPropObjVolumeV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV15(const PackMapPropObjVolumeV15 &p_other);
    PackMapPropObjVolumeV15 &operator=(const PackMapPropObjVolumeV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV15 {
    helpers::Array<PackMapPropObjV15> propArray;
    helpers::Array<PackMapPropObjAnimSeqV15> propAnimArray;
    helpers::Array<PackMapPropObjInstanceV15> propInstanceArray;
    helpers::Array<PackMapPropObjToolV15> propToolArray;
    helpers::Array<PackMapPropObjMetaV15> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV15> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV15();
    PackMapPropV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV15(const PackMapPropV15 &p_other);
    PackMapPropV15 &operator=(const PackMapPropV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x4105236000000001 */

template <>
struct Gw2Structprp2<14>{
struct PackMapPropObjV14 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;

public:
    PackMapPropObjV14();
    PackMapPropObjV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV14(const PackMapPropObjV14 &p_other);
    PackMapPropObjV14 &operator=(const PackMapPropObjV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV14 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV14();
    PackMapPropObjAnimSeqV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV14(const PackMapPropObjAnimSeqV14 &p_other);
    PackMapPropObjAnimSeqV14 &operator=(const PackMapPropObjAnimSeqV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV14 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV14();
    PackMapPropObjToolV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV14(const PackMapPropObjToolV14 &p_other);
    PackMapPropObjToolV14 &operator=(const PackMapPropObjToolV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV14 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    word bucketId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV14();
    PackMapPropObjMetaV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV14(const PackMapPropObjMetaV14 &p_other);
    PackMapPropObjMetaV14 &operator=(const PackMapPropObjMetaV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV14 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV14();
    PackMapPropObjVolumeV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV14(const PackMapPropObjVolumeV14 &p_other);
    PackMapPropObjVolumeV14 &operator=(const PackMapPropObjVolumeV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV14 {
    helpers::Array<PackMapPropObjV14> propArray;
    helpers::Array<PackMapPropObjAnimSeqV14> propAnimArray;
    helpers::Array<PackMapPropObjToolV14> propToolArray;
    helpers::Array<PackMapPropObjMetaV14> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV14> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV14();
    PackMapPropV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV14(const PackMapPropV14 &p_other);
    PackMapPropV14 &operator=(const PackMapPropV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<13>{
struct PackMapPropObjV13 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;

public:
    PackMapPropObjV13();
    PackMapPropObjV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV13(const PackMapPropObjV13 &p_other);
    PackMapPropObjV13 &operator=(const PackMapPropObjV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV13 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV13();
    PackMapPropObjAnimSeqV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV13(const PackMapPropObjAnimSeqV13 &p_other);
    PackMapPropObjAnimSeqV13 &operator=(const PackMapPropObjAnimSeqV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV13 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;

public:
    PackMapPropObjToolV13();
    PackMapPropObjToolV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV13(const PackMapPropObjToolV13 &p_other);
    PackMapPropObjToolV13 &operator=(const PackMapPropObjToolV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV13 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV13();
    PackMapPropObjMetaV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV13(const PackMapPropObjMetaV13 &p_other);
    PackMapPropObjMetaV13 &operator=(const PackMapPropObjMetaV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV13 {
    qword guid;
    dword layerMask;
    byte glomType;
    helpers::Array<qword> children;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV13();
    PackMapPropObjVolumeV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV13(const PackMapPropObjVolumeV13 &p_other);
    PackMapPropObjVolumeV13 &operator=(const PackMapPropObjVolumeV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV13 {
    helpers::Array<PackMapPropObjV13> propArray;
    helpers::Array<PackMapPropObjAnimSeqV13> propAnimArray;
    helpers::Array<PackMapPropObjToolV13> propToolArray;
    helpers::Array<PackMapPropObjMetaV13> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV13> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV13();
    PackMapPropV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV13(const PackMapPropV13 &p_other);
    PackMapPropV13 &operator=(const PackMapPropV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x41050AE000000001 */

template <>
struct Gw2Structprp2<12>{
struct PackMapPropObjV12 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;

public:
    PackMapPropObjV12();
    PackMapPropObjV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV12(const PackMapPropObjV12 &p_other);
    PackMapPropObjV12 &operator=(const PackMapPropObjV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV12 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV12();
    PackMapPropObjAnimSeqV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV12(const PackMapPropObjAnimSeqV12 &p_other);
    PackMapPropObjAnimSeqV12 &operator=(const PackMapPropObjAnimSeqV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV12 {
    qword guid;
    dword layerMask;
    byte glomType;

public:
    PackMapPropObjToolV12();
    PackMapPropObjToolV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV12(const PackMapPropObjToolV12 &p_other);
    PackMapPropObjToolV12 &operator=(const PackMapPropObjToolV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjMetaV12 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;
    dword layerMask;
    byte glomType;
    qword parent;
    float3 glomOrigin;

public:
    PackMapPropObjMetaV12();
    PackMapPropObjMetaV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjMetaV12(const PackMapPropObjMetaV12 &p_other);
    PackMapPropObjMetaV12 &operator=(const PackMapPropObjMetaV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjVolumeV12 {
    qword guid;
    dword layerMask;
    byte glomType;
    float3 glomClipScale;
    float3 position;
    float3 rotation;
    float scale;

public:
    PackMapPropObjVolumeV12();
    PackMapPropObjVolumeV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjVolumeV12(const PackMapPropObjVolumeV12 &p_other);
    PackMapPropObjVolumeV12 &operator=(const PackMapPropObjVolumeV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV12 {
    helpers::Array<PackMapPropObjV12> propArray;
    helpers::Array<PackMapPropObjAnimSeqV12> propAnimArray;
    helpers::Array<PackMapPropObjToolV12> propToolArray;
    helpers::Array<PackMapPropObjMetaV12> propMetaArray;
    helpers::Array<PackMapPropObjVolumeV12> propVolumeArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV12();
    PackMapPropV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV12(const PackMapPropV12 &p_other);
    PackMapPropV12 &operator=(const PackMapPropV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x410508F000000001 */

template <>
struct Gw2Structprp2<11>{
struct PackMapPropObjV11 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;

public:
    PackMapPropObjV11();
    PackMapPropObjV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV11(const PackMapPropObjV11 &p_other);
    PackMapPropObjV11 &operator=(const PackMapPropObjV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV11 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    word broadId;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV11();
    PackMapPropObjAnimSeqV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV11(const PackMapPropObjAnimSeqV11 &p_other);
    PackMapPropObjAnimSeqV11 &operator=(const PackMapPropObjAnimSeqV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV11 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV11();
    PackMapPropObjToolV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV11(const PackMapPropObjToolV11 &p_other);
    PackMapPropObjToolV11 &operator=(const PackMapPropObjToolV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV11 {
    helpers::Array<PackMapPropObjV11> propArray;
    helpers::Array<PackMapPropObjAnimSeqV11> propAnimArray;
    helpers::Array<PackMapPropObjToolV11> propToolArray;
    PackBroadphaseType broadPhase;
    dword nextBroadId;

public:
    PackMapPropV11();
    PackMapPropV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV11(const PackMapPropV11 &p_other);
    PackMapPropV11 &operator=(const PackMapPropV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x410528D000000001 */

template <>
struct Gw2Structprp2<10>{
struct PackMapPropObjV10 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV10();
    PackMapPropObjV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV10(const PackMapPropObjV10 &p_other);
    PackMapPropObjV10 &operator=(const PackMapPropObjV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV10 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV10();
    PackMapPropObjAnimSeqV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV10(const PackMapPropObjAnimSeqV10 &p_other);
    PackMapPropObjAnimSeqV10 &operator=(const PackMapPropObjAnimSeqV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV10 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV10();
    PackMapPropObjToolV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV10(const PackMapPropObjToolV10 &p_other);
    PackMapPropObjToolV10 &operator=(const PackMapPropObjToolV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV10 {
    helpers::Array<PackMapPropObjV10> propArray;
    helpers::Array<PackMapPropObjAnimSeqV10> propAnimArray;
    helpers::Array<PackMapPropObjToolV10> propToolArray;

public:
    PackMapPropV10();
    PackMapPropV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV10(const PackMapPropV10 &p_other);
    PackMapPropV10 &operator=(const PackMapPropV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x4105278000000001 */

template <>
struct Gw2Structprp2<9>{
struct PackMapPropObjV9 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV9();
    PackMapPropObjV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV9(const PackMapPropObjV9 &p_other);
    PackMapPropObjV9 &operator=(const PackMapPropObjV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV9 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV9();
    PackMapPropObjAnimSeqV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV9(const PackMapPropObjAnimSeqV9 &p_other);
    PackMapPropObjAnimSeqV9 &operator=(const PackMapPropObjAnimSeqV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV9 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV9();
    PackMapPropObjToolV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV9(const PackMapPropObjToolV9 &p_other);
    PackMapPropObjToolV9 &operator=(const PackMapPropObjToolV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV9 {
    helpers::Array<PackMapPropObjV9> propArray;
    helpers::Array<PackMapPropObjAnimSeqV9> propAnimArray;
    helpers::Array<PackMapPropObjToolV9> propToolArray;

public:
    PackMapPropV9();
    PackMapPropV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV9(const PackMapPropV9 &p_other);
    PackMapPropV9 &operator=(const PackMapPropV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<8>{
struct PackMapPropObjV8 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV8();
    PackMapPropObjV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV8(const PackMapPropObjV8 &p_other);
    PackMapPropObjV8 &operator=(const PackMapPropObjV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV8 {
    helpers::FileName filename;
    helpers::Array<helpers::FileName> blitTextures;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV8();
    PackMapPropObjAnimSeqV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV8(const PackMapPropObjAnimSeqV8 &p_other);
    PackMapPropObjAnimSeqV8 &operator=(const PackMapPropObjAnimSeqV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV8 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV8();
    PackMapPropObjToolV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV8(const PackMapPropObjToolV8 &p_other);
    PackMapPropObjToolV8 &operator=(const PackMapPropObjToolV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV8 {
    helpers::Array<PackMapPropObjV8> propArray;
    helpers::Array<PackMapPropObjAnimSeqV8> propAnimArray;
    helpers::Array<PackMapPropObjToolV8> propToolArray;

public:
    PackMapPropV8();
    PackMapPropV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV8(const PackMapPropV8 &p_other);
    PackMapPropV8 &operator=(const PackMapPropV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x4105271000000001 */

template <>
struct Gw2Structprp2<7>{
struct PackMapPropObjV7 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV7();
    PackMapPropObjV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV7(const PackMapPropObjV7 &p_other);
    PackMapPropObjV7 &operator=(const PackMapPropObjV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV7 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    byte4 color;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV7();
    PackMapPropObjAnimSeqV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV7(const PackMapPropObjAnimSeqV7 &p_other);
    PackMapPropObjAnimSeqV7 &operator=(const PackMapPropObjAnimSeqV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV7 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV7();
    PackMapPropObjToolV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV7(const PackMapPropObjToolV7 &p_other);
    PackMapPropObjToolV7 &operator=(const PackMapPropObjToolV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV7 {
    helpers::Array<PackMapPropObjV7> propArray;
    helpers::Array<PackMapPropObjAnimSeqV7> propAnimArray;
    helpers::Array<PackMapPropObjToolV7> propToolArray;

public:
    PackMapPropV7();
    PackMapPropV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV7(const PackMapPropV7 &p_other);
    PackMapPropV7 &operator=(const PackMapPropV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x4105256000000001 */

template <>
struct Gw2Structprp2<6>{
struct PackMapPropObjV6 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV6();
    PackMapPropObjV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV6(const PackMapPropObjV6 &p_other);
    PackMapPropObjV6 &operator=(const PackMapPropObjV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV6 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    float lod1;
    float lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV6();
    PackMapPropObjAnimSeqV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV6(const PackMapPropObjAnimSeqV6 &p_other);
    PackMapPropObjAnimSeqV6 &operator=(const PackMapPropObjAnimSeqV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV6 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV6();
    PackMapPropObjToolV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV6(const PackMapPropObjToolV6 &p_other);
    PackMapPropObjToolV6 &operator=(const PackMapPropObjToolV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV6 {
    helpers::Array<PackMapPropObjV6> propArray;
    helpers::Array<PackMapPropObjAnimSeqV6> propAnimArray;
    helpers::Array<PackMapPropObjToolV6> propToolArray;

public:
    PackMapPropV6();
    PackMapPropV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV6(const PackMapPropV6 &p_other);
    PackMapPropV6 &operator=(const PackMapPropV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<5>{
struct PackMapPropObjV5 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV5();
    PackMapPropObjV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV5(const PackMapPropObjV5 &p_other);
    PackMapPropObjV5 &operator=(const PackMapPropObjV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV5 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV5();
    PackMapPropObjAnimSeqV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV5(const PackMapPropObjAnimSeqV5 &p_other);
    PackMapPropObjAnimSeqV5 &operator=(const PackMapPropObjAnimSeqV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV5 {
    qword guid;
    dword layerMask;
    float3 glomOrigin;
    float3 glomClipScale;
    qword glomTargetId;
    byte glomType;

public:
    PackMapPropObjToolV5();
    PackMapPropObjToolV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV5(const PackMapPropObjToolV5 &p_other);
    PackMapPropObjToolV5 &operator=(const PackMapPropObjToolV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV5 {
    helpers::Array<PackMapPropObjV5> propArray;
    helpers::Array<PackMapPropObjAnimSeqV5> propAnimArray;
    helpers::Array<PackMapPropObjToolV5> propToolArray;

public:
    PackMapPropV5();
    PackMapPropV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV5(const PackMapPropV5 &p_other);
    PackMapPropV5 &operator=(const PackMapPropV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<4>{
struct PackMapPropObjV4 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;
    byte byte;

public:
    PackMapPropObjV4();
    PackMapPropObjV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV4(const PackMapPropObjV4 &p_other);
    PackMapPropObjV4 &operator=(const PackMapPropObjV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV4 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;
    byte byte;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV4();
    PackMapPropObjAnimSeqV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV4(const PackMapPropObjAnimSeqV4 &p_other);
    PackMapPropObjAnimSeqV4 &operator=(const PackMapPropObjAnimSeqV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV4 {
    qword guid;
    dword layerMask;

public:
    PackMapPropObjToolV4();
    PackMapPropObjToolV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV4(const PackMapPropObjToolV4 &p_other);
    PackMapPropObjToolV4 &operator=(const PackMapPropObjToolV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV4 {
    helpers::Array<PackMapPropObjV4> propArray;
    helpers::Array<PackMapPropObjAnimSeqV4> propAnimArray;
    helpers::Array<PackMapPropObjToolV4> propToolArray;

public:
    PackMapPropV4();
    PackMapPropV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV4(const PackMapPropV4 &p_other);
    PackMapPropV4 &operator=(const PackMapPropV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structprp2<3>{
struct PackMapPropObjV3 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;

public:
    PackMapPropObjV3();
    PackMapPropObjV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjV3(const PackMapPropObjV3 &p_other);
    PackMapPropObjV3 &operator=(const PackMapPropObjV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjAnimSeqV3 {
    helpers::FileName filename;
    qword guid;
    float3 position;
    float3 rotation;
    float scale;
    word lod1;
    word lod2;
    dword flags;
    qword animSequence;

public:
    PackMapPropObjAnimSeqV3();
    PackMapPropObjAnimSeqV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjAnimSeqV3(const PackMapPropObjAnimSeqV3 &p_other);
    PackMapPropObjAnimSeqV3 &operator=(const PackMapPropObjAnimSeqV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropObjToolV3 {
    qword guid;
    dword layerMask;

public:
    PackMapPropObjToolV3();
    PackMapPropObjToolV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropObjToolV3(const PackMapPropObjToolV3 &p_other);
    PackMapPropObjToolV3 &operator=(const PackMapPropObjToolV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapPropV3 {
    helpers::Array<PackMapPropObjV3> propArray;
    helpers::Array<PackMapPropObjAnimSeqV3> propAnimArray;
    helpers::Array<PackMapPropObjToolV3> propToolArray;

public:
    PackMapPropV3();
    PackMapPropV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapPropV3(const PackMapPropV3 &p_other);
    PackMapPropV3 &operator=(const PackMapPropV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapPropV3 Gw2Struct;
};


/* ===============================================
 * Chunk: reso, versions: 2, strucTab: 0x1420F3360
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structreso;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structreso<1>{
struct PackMapResourceMapNodeItemV1 {
    helpers::FileName filename;
    dword type;
    qword permutation;

public:
    PackMapResourceMapNodeItemV1();
    PackMapResourceMapNodeItemV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapNodeItemV1(const PackMapResourceMapNodeItemV1 &p_other);
    PackMapResourceMapNodeItemV1 &operator=(const PackMapResourceMapNodeItemV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapResourceMapNodeV1 {
    float3 position;
    dword flags;
    helpers::Array<PackMapResourceMapNodeItemV1> itemArray;

public:
    PackMapResourceMapNodeV1();
    PackMapResourceMapNodeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapNodeV1(const PackMapResourceMapNodeV1 &p_other);
    PackMapResourceMapNodeV1 &operator=(const PackMapResourceMapNodeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapResourceMapV1 {
    helpers::Array<PackMapResourceMapNodeV1> nodeArray;

public:
    PackMapResourceMapV1();
    PackMapResourceMapV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapV1(const PackMapResourceMapV1 &p_other);
    PackMapResourceMapV1 &operator=(const PackMapResourceMapV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapResourceMapV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structreso<0>{
struct PackMapResourceMapNodeItemV0 {
    helpers::FileName filename;
    dword type;

public:
    PackMapResourceMapNodeItemV0();
    PackMapResourceMapNodeItemV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapNodeItemV0(const PackMapResourceMapNodeItemV0 &p_other);
    PackMapResourceMapNodeItemV0 &operator=(const PackMapResourceMapNodeItemV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapResourceMapNodeV0 {
    float3 position;
    dword flags;
    helpers::Array<PackMapResourceMapNodeItemV0> itemArray;

public:
    PackMapResourceMapNodeV0();
    PackMapResourceMapNodeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapNodeV0(const PackMapResourceMapNodeV0 &p_other);
    PackMapResourceMapNodeV0 &operator=(const PackMapResourceMapNodeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapResourceMapV0 {
    helpers::Array<PackMapResourceMapNodeV0> nodeArray;

public:
    PackMapResourceMapV0();
    PackMapResourceMapV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapResourceMapV0(const PackMapResourceMapV0 &p_other);
    PackMapResourceMapV0 &operator=(const PackMapResourceMapV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapResourceMapV0 Gw2Struct;
};


/* ===============================================
 * Chunk: rive, versions: 6, strucTab: 0x1420F3410
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structrive;

/* Version: 5, ReferencedFunction: 0x41052D1000000001 */

template <>
struct Gw2Structrive<5>{
struct PackMapRiverProperty {
    dword type;
    qword val;
    helpers::FileName strVal;

public:
    PackMapRiverProperty();
    PackMapRiverProperty(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRiverProperty(const PackMapRiverProperty &p_other);
    PackMapRiverProperty &operator=(const PackMapRiverProperty &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    helpers::Array<PackMapRiverProperty> properties;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    helpers::WString name;
    helpers::Array<PackMapRiverProperty> properties;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    helpers::Array<MapRiver> rivers;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2Structrive<4>{
struct MapRiverTextureMap {
    float scale;
    float speedX;
    float speedY;
    float tiling;
    dword flags;
    byte uvIndex;

public:
    MapRiverTextureMap();
    MapRiverTextureMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverTextureMap(const MapRiverTextureMap &p_other);
    MapRiverTextureMap &operator=(const MapRiverTextureMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverMaterial {
    helpers::FileName materialFile;
    helpers::Array<helpers::FileName> textureFiles;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<MapRiverTextureMap> textureMaps;
    dword flags;

public:
    MapRiverMaterial();
    MapRiverMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverMaterial(const MapRiverMaterial &p_other);
    MapRiverMaterial &operator=(const MapRiverMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    float width;
    float curveLength;
    float curvePercent;
    dword xTessellation;
    dword2 yTessellation;
    dword broadId;
    dword fvf;
    dword flags;
    helpers::Array<MapRiverMaterial> materials;
    helpers::WString reserved;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    helpers::WString name;
    float xTiling;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;
    dword flags;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    dword flags;
    dword nextBroadId;
    helpers::Array<MapRiver> rivers;
    PackBroadphaseType broadPhase;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structrive<3>{
struct MapRiverTextureMap {
    float scale;
    float speedX;
    float speedY;
    float tiling;
    byte uvIndex;

public:
    MapRiverTextureMap();
    MapRiverTextureMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverTextureMap(const MapRiverTextureMap &p_other);
    MapRiverTextureMap &operator=(const MapRiverTextureMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverMaterial {
    helpers::FileName materialFile;
    helpers::Array<helpers::FileName> textureFiles;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<MapRiverTextureMap> textureMaps;

public:
    MapRiverMaterial();
    MapRiverMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverMaterial(const MapRiverMaterial &p_other);
    MapRiverMaterial &operator=(const MapRiverMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    float width;
    float curveLength;
    float curvePercent;
    dword xTessellation;
    dword2 yTessellation;
    dword broadId;
    dword fvf;
    dword flags;
    helpers::Array<MapRiverMaterial> materials;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    helpers::WString name;
    float xTiling;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;
    dword flags;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    dword flags;
    dword nextBroadId;
    helpers::Array<MapRiver> rivers;
    PackBroadphaseType broadPhase;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structrive<2>{
struct MapRiverTextureMap {
    float scale;
    float speedX;
    float speedY;
    float tiling;
    byte uvIndex;

public:
    MapRiverTextureMap();
    MapRiverTextureMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverTextureMap(const MapRiverTextureMap &p_other);
    MapRiverTextureMap &operator=(const MapRiverTextureMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverMaterial {
    helpers::FileName materialFile;
    helpers::Array<helpers::FileName> textureFiles;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<MapRiverTextureMap> textureMaps;

public:
    MapRiverMaterial();
    MapRiverMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverMaterial(const MapRiverMaterial &p_other);
    MapRiverMaterial &operator=(const MapRiverMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    float width;
    float curveLength;
    float curvePercent;
    dword xTessellation;
    dword2 yTessellation;
    dword broadId;
    dword fvf;
    helpers::Array<MapRiverMaterial> materials;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    helpers::WString name;
    float xTiling;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    dword flags;
    dword nextBroadId;
    helpers::Array<MapRiver> rivers;
    PackBroadphaseType broadPhase;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structrive<1>{
struct MapRiverTextureMap {
    float scale;
    float speedX;
    float speedY;
    float tiling;
    byte uvIndex;

public:
    MapRiverTextureMap();
    MapRiverTextureMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverTextureMap(const MapRiverTextureMap &p_other);
    MapRiverTextureMap &operator=(const MapRiverTextureMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverMaterial {
    helpers::FileName materialFile;
    helpers::Array<helpers::FileName> textureFiles;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<MapRiverTextureMap> textureMaps;

public:
    MapRiverMaterial();
    MapRiverMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverMaterial(const MapRiverMaterial &p_other);
    MapRiverMaterial &operator=(const MapRiverMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    float width;
    float curveLength;
    float curvePercent;
    dword xTessellation;
    dword2 yTessellation;
    dword broadId;
    helpers::Array<MapRiverMaterial> materials;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    helpers::WString name;
    float xTiling;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    dword flags;
    dword nextBroadId;
    helpers::Array<MapRiver> rivers;
    PackBroadphaseType broadPhase;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structrive<0>{
struct MapRiverTextureMap {
    float scale;
    float speed;
    float tiling;
    byte uvIndex;

public:
    MapRiverTextureMap();
    MapRiverTextureMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverTextureMap(const MapRiverTextureMap &p_other);
    MapRiverTextureMap &operator=(const MapRiverTextureMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverMaterial {
    helpers::FileName materialFile;
    helpers::Array<helpers::FileName> textureFiles;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<MapRiverTextureMap> textureMaps;

public:
    MapRiverMaterial();
    MapRiverMaterial(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverMaterial(const MapRiverMaterial &p_other);
    MapRiverMaterial &operator=(const MapRiverMaterial &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiverReach {
    float width;
    float curveLength;
    float curvePercent;
    dword xTessellation;
    dword2 yTessellation;
    dword broadId;
    helpers::Array<MapRiverMaterial> materials;

public:
    MapRiverReach();
    MapRiverReach(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiverReach(const MapRiverReach &p_other);
    MapRiverReach &operator=(const MapRiverReach &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapRiver {
    qword guid;
    float xTiling;
    helpers::Array<float3> points;
    helpers::Array<MapRiverReach> reaches;

public:
    MapRiver();
    MapRiver(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapRiver(const MapRiver &p_other);
    MapRiver &operator=(const MapRiver &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapRivers {
    dword flags;
    dword nextBroadId;
    helpers::Array<MapRiver> rivers;
    PackBroadphaseType broadPhase;

public:
    PackMapRivers();
    PackMapRivers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapRivers(const PackMapRivers &p_other);
    PackMapRivers &operator=(const PackMapRivers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapRivers Gw2Struct;
};


/* ===============================================
 * Chunk: tlfs, versions: 1, strucTab: 0x1420F2790
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtlfs;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtlfs<0>{
struct PackMapToolFsFileV0 {
    helpers::FileName filename;
    qword time;
    helpers::Array<byte> dataPtr;

public:
    PackMapToolFsFileV0();
    PackMapToolFsFileV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapToolFsFileV0(const PackMapToolFsFileV0 &p_other);
    PackMapToolFsFileV0 &operator=(const PackMapToolFsFileV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapToolFsV0 {
    helpers::Array<PackMapToolFsFileV0> filePtr;

public:
    PackMapToolFsV0();
    PackMapToolFsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapToolFsV0(const PackMapToolFsV0 &p_other);
    PackMapToolFsV0 &operator=(const PackMapToolFsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapToolFsV0 Gw2Struct;
};


/* ===============================================
 * Chunk: shad, versions: 2, strucTab: 0x1420F3540
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structshad;

/* Version: 1, ReferencedFunction: 0x41052E7000000001 */

template <>
struct Gw2Structshad<1>{
struct PackMapShadowTileV1 {
    dword compressionMode;
    helpers::Array<byte> bytes;

public:
    PackMapShadowTileV1();
    PackMapShadowTileV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapShadowTileV1(const PackMapShadowTileV1 &p_other);
    PackMapShadowTileV1 &operator=(const PackMapShadowTileV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapShadowV1 {
    dword2 shadowDims;
    dword2 tileDims;
    helpers::Array<PackMapShadowTileV1> tiles;
    float worldToShadow[16];
    float2 s;
    float2 t;
    float2 u;
    float3 shadowEye;
    float3 shadowDir;
    float3 shadowUp;

public:
    PackMapShadowV1();
    PackMapShadowV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapShadowV1(const PackMapShadowV1 &p_other);
    PackMapShadowV1 &operator=(const PackMapShadowV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapShadowV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structshad<0>{
struct PackMapShadowTileV0 {
    dword compressionMode;
    helpers::Array<byte> bytes;

public:
    PackMapShadowTileV0();
    PackMapShadowTileV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapShadowTileV0(const PackMapShadowTileV0 &p_other);
    PackMapShadowTileV0 &operator=(const PackMapShadowTileV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapShadowV0 {
    dword2 shadowDims;
    dword2 tileDims;
    helpers::Array<PackMapShadowTileV0> tiles;
    float worldToShadow[16];
    float2 s;
    float2 t;
    float2 u;

public:
    PackMapShadowV0();
    PackMapShadowV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapShadowV0(const PackMapShadowV0 &p_other);
    PackMapShadowV0 &operator=(const PackMapShadowV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapShadowV0 Gw2Struct;
};


/* ===============================================
 * Chunk: shex, versions: 2, strucTab: 0x1420F3570
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structshex;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structshex<1>{
struct PackMapShadowExtV1 {
    helpers::FileName filename;
    dword2 shadowDims;

public:
    PackMapShadowExtV1();
    PackMapShadowExtV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapShadowExtV1(const PackMapShadowExtV1 &p_other);
    PackMapShadowExtV1 &operator=(const PackMapShadowExtV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapShadowExtV1 Gw2Struct;
};


/* ===============================================
 * Chunk: shor, versions: 4, strucTab: 0x1420F35A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structshor;

/* Version: 3, ReferencedFunction: 0x41052E8000000001 */

template <>
struct Gw2Structshor<3>{
struct MapShoreChain {
    float offset;
    float opacity;
    float animationSpeed;
    float2 edgeSize;
    dword flags;
    helpers::Array<float2> points;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    float restTime;
    float2 fadeRanges[4];
    float simplifyDistMin;
    float simplifyDistMax;
    float simplifyDot;

public:
    MapShoreChain();
    MapShoreChain(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapShoreChain(const MapShoreChain &p_other);
    MapShoreChain &operator=(const MapShoreChain &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapShore {
    helpers::Array<MapShoreChain> chains;

public:
    MapShore();
    MapShore(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapShore(const MapShore &p_other);
    MapShore &operator=(const MapShore &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapShore Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structshor<2>{
struct MapShoreChain {
    float offset;
    float opacity;
    float animationSpeed;
    float2 edgeSize;
    dword flags;
    helpers::Array<float2> points;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    float restTime;
    float2 fadeRanges[4];

public:
    MapShoreChain();
    MapShoreChain(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapShoreChain(const MapShoreChain &p_other);
    MapShoreChain &operator=(const MapShoreChain &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapShore {
    helpers::Array<MapShoreChain> chains;

public:
    MapShore();
    MapShore(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapShore(const MapShore &p_other);
    MapShore &operator=(const MapShore &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapShore Gw2Struct;
};


/* ===============================================
 * Chunk: snd, versions: 1, strucTab: 0x1420EFB20
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structsnd;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structsnd<0>{
struct MapLegacy {
    helpers::Array<byte> data;
    helpers::Array<helpers::FileName> files;

public:
    MapLegacy();
    MapLegacy(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapLegacy(const MapLegacy &p_other);
    MapLegacy &operator=(const MapLegacy &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapLegacy Gw2Struct;
};


/* ===============================================
 * Chunk: surf, versions: 3, strucTab: 0x1420F3960
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structsurf;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structsurf<2>{
struct MapSurfaceAttribute {
    qword Id;
    qword Sound;
    dword flags;

public:
    MapSurfaceAttribute();
    MapSurfaceAttribute(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceAttribute(const MapSurfaceAttribute &p_other);
    MapSurfaceAttribute &operator=(const MapSurfaceAttribute &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaceAttributeTool {
    helpers::WString name;
    helpers::WString category;
    byte4 color;

public:
    MapSurfaceAttributeTool();
    MapSurfaceAttributeTool(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceAttributeTool(const MapSurfaceAttributeTool &p_other);
    MapSurfaceAttributeTool &operator=(const MapSurfaceAttributeTool &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaceOverride {
    qword surfaceId;
    helpers::Array<dword> bitArray;

public:
    MapSurfaceOverride();
    MapSurfaceOverride(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceOverride(const MapSurfaceOverride &p_other);
    MapSurfaceOverride &operator=(const MapSurfaceOverride &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaceTerrainOverride {
    dword2 chunkCoord;
    helpers::Array<MapSurfaceOverride> overrideArray;

public:
    MapSurfaceTerrainOverride();
    MapSurfaceTerrainOverride(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceTerrainOverride(const MapSurfaceTerrainOverride &p_other);
    MapSurfaceTerrainOverride &operator=(const MapSurfaceTerrainOverride &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfacePropOverride {
    qword propId;
    helpers::Array<MapSurfaceOverride> overrideArray;

public:
    MapSurfacePropOverride();
    MapSurfacePropOverride(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfacePropOverride(const MapSurfacePropOverride &p_other);
    MapSurfacePropOverride &operator=(const MapSurfacePropOverride &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaces {
    helpers::Array<MapSurfaceAttribute> attributeData;
    helpers::Array<MapSurfaceAttributeTool> toolData;
    helpers::Array<MapSurfaceTerrainOverride> terrainArray;
    helpers::Array<MapSurfacePropOverride> propArray;

public:
    MapSurfaces();
    MapSurfaces(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaces(const MapSurfaces &p_other);
    MapSurfaces &operator=(const MapSurfaces &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapSurfaces Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structsurf<1>{
struct MapSurfaceAttribute {
    qword Id;
    qword Sound;
    dword flags;

public:
    MapSurfaceAttribute();
    MapSurfaceAttribute(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceAttribute(const MapSurfaceAttribute &p_other);
    MapSurfaceAttribute &operator=(const MapSurfaceAttribute &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaceAttributeTool {
    helpers::WString name;
    helpers::WString category;
    byte4 color;

public:
    MapSurfaceAttributeTool();
    MapSurfaceAttributeTool(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceAttributeTool(const MapSurfaceAttributeTool &p_other);
    MapSurfaceAttributeTool &operator=(const MapSurfaceAttributeTool &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaces {
    helpers::Array<MapSurfaceAttribute> attributeData;
    helpers::Array<MapSurfaceAttributeTool> toolData;

public:
    MapSurfaces();
    MapSurfaces(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaces(const MapSurfaces &p_other);
    MapSurfaces &operator=(const MapSurfaces &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapSurfaces Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structsurf<0>{
struct MapSurfaceMeta {
    word index;
    byte descriptor;
    byte data;

public:
    MapSurfaceMeta();
    MapSurfaceMeta(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceMeta(const MapSurfaceMeta &p_other);
    MapSurfaceMeta &operator=(const MapSurfaceMeta &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaceChunk {
    dword coord[3];
    helpers::Array<MapSurfaceMeta> metadata;
    helpers::Array<byte> typeData;

public:
    MapSurfaceChunk();
    MapSurfaceChunk(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaceChunk(const MapSurfaceChunk &p_other);
    MapSurfaceChunk &operator=(const MapSurfaceChunk &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapSurfaces {
    helpers::Array<MapSurfaceChunk> chunkData;
    helpers::Array<qword> typeData;

public:
    MapSurfaces();
    MapSurfaces(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapSurfaces(const MapSurfaces &p_other);
    MapSurfaces &operator=(const MapSurfaces &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapSurfaces Gw2Struct;
};


/* ===============================================
 * Chunk: zon2, versions: 23, strucTab: 0x1420F40A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structzon2;

/* Version: 22, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<22>{
struct PackMapZoneModelV23 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];
    qword permutation;

public:
    PackMapZoneModelV23();
    PackMapZoneModelV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV23(const PackMapZoneModelV23 &p_other);
    PackMapZoneModelV23 &operator=(const PackMapZoneModelV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV23 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[4];
    float instanceScaleJitter;
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV23> modelArray;
    helpers::Ptr<PackMapZoneModelV23> subModel;
    helpers::WString reserved;

public:
    PackMapZoneLayerDefV23();
    PackMapZoneLayerDefV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV23(const PackMapZoneLayerDefV23 &p_other);
    PackMapZoneLayerDefV23 &operator=(const PackMapZoneLayerDefV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV11 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;
    helpers::WString string;

public:
    PackMapZonePageV11();
    PackMapZonePageV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV11(const PackMapZonePageV11 &p_other);
    PackMapZonePageV11 &operator=(const PackMapZonePageV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV11 {
    helpers::Array<PackMapZonePageV11> pageArray;
    dword flags;

public:
    PackMapZonePageTableV11();
    PackMapZonePageTableV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV11(const PackMapZonePageTableV11 &p_other);
    PackMapZonePageTableV11 &operator=(const PackMapZonePageTableV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV23 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV23> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV11> pageTable;
    helpers::WString reserved;

public:
    PackMapZoneDefV23();
    PackMapZoneDefV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV23(const PackMapZoneDefV23 &p_other);
    PackMapZoneDefV23 &operator=(const PackMapZoneDefV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV23 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV23();
    PackMapZoneEncodingDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV23(const PackMapZoneEncodingDataV23 &p_other);
    PackMapZoneEncodingDataV23 &operator=(const PackMapZoneEncodingDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV23 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV23();
    PackMapZoneCollideDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV23(const PackMapZoneCollideDataV23 &p_other);
    PackMapZoneCollideDataV23 &operator=(const PackMapZoneCollideDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV23 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV23> encodeData;
    helpers::Array<PackMapZoneCollideDataV23> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;
    helpers::WString reserved;

public:
    PackMapZoneV23();
    PackMapZoneV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV23(const PackMapZoneV23 &p_other);
    PackMapZoneV23 &operator=(const PackMapZoneV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV23 {
    helpers::Array<PackMapZoneDefV23> zoneDefArray;
    helpers::Array<PackMapZoneV23> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;
    helpers::WString string;

public:
    PackMapZonesV23();
    PackMapZonesV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV23(const PackMapZonesV23 &p_other);
    PackMapZonesV23 &operator=(const PackMapZonesV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV23 Gw2Struct;
};

/* Version: 21, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<21>{
struct PackMapZoneModelV22 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];

public:
    PackMapZoneModelV22();
    PackMapZoneModelV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV22(const PackMapZoneModelV22 &p_other);
    PackMapZoneModelV22 &operator=(const PackMapZoneModelV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV22 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[4];
    float instanceScaleJitter;
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV22> modelArray;
    helpers::Ptr<PackMapZoneModelV22> subModel;
    helpers::WString reserved;

public:
    PackMapZoneLayerDefV22();
    PackMapZoneLayerDefV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV22(const PackMapZoneLayerDefV22 &p_other);
    PackMapZoneLayerDefV22 &operator=(const PackMapZoneLayerDefV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV10 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;
    helpers::WString string;

public:
    PackMapZonePageV10();
    PackMapZonePageV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV10(const PackMapZonePageV10 &p_other);
    PackMapZonePageV10 &operator=(const PackMapZonePageV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV10 {
    helpers::Array<PackMapZonePageV10> pageArray;
    dword flags;

public:
    PackMapZonePageTableV10();
    PackMapZonePageTableV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV10(const PackMapZonePageTableV10 &p_other);
    PackMapZonePageTableV10 &operator=(const PackMapZonePageTableV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV22 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV22> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV10> pageTable;
    helpers::WString reserved;

public:
    PackMapZoneDefV22();
    PackMapZoneDefV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV22(const PackMapZoneDefV22 &p_other);
    PackMapZoneDefV22 &operator=(const PackMapZoneDefV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV22 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV22();
    PackMapZoneEncodingDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV22(const PackMapZoneEncodingDataV22 &p_other);
    PackMapZoneEncodingDataV22 &operator=(const PackMapZoneEncodingDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV22 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV22();
    PackMapZoneCollideDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV22(const PackMapZoneCollideDataV22 &p_other);
    PackMapZoneCollideDataV22 &operator=(const PackMapZoneCollideDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV22 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV22> encodeData;
    helpers::Array<PackMapZoneCollideDataV22> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;
    helpers::WString reserved;

public:
    PackMapZoneV22();
    PackMapZoneV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV22(const PackMapZoneV22 &p_other);
    PackMapZoneV22 &operator=(const PackMapZoneV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV22 {
    helpers::Array<PackMapZoneDefV22> zoneDefArray;
    helpers::Array<PackMapZoneV22> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;
    helpers::WString string;

public:
    PackMapZonesV22();
    PackMapZonesV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV22(const PackMapZonesV22 &p_other);
    PackMapZonesV22 &operator=(const PackMapZonesV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV22 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x4105487000000001 */

template <>
struct Gw2Structzon2<20>{
struct PackMapZoneModelV21 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];

public:
    PackMapZoneModelV21();
    PackMapZoneModelV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV21(const PackMapZoneModelV21 &p_other);
    PackMapZoneModelV21 &operator=(const PackMapZoneModelV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV21 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[4];
    float instanceScaleJitter;
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV21> modelArray;
    helpers::Ptr<PackMapZoneModelV21> subModel;

public:
    PackMapZoneLayerDefV21();
    PackMapZoneLayerDefV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV21(const PackMapZoneLayerDefV21 &p_other);
    PackMapZoneLayerDefV21 &operator=(const PackMapZoneLayerDefV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV9 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV9();
    PackMapZonePageV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV9(const PackMapZonePageV9 &p_other);
    PackMapZonePageV9 &operator=(const PackMapZonePageV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV9 {
    helpers::Array<PackMapZonePageV9> pageArray;
    dword flags;

public:
    PackMapZonePageTableV9();
    PackMapZonePageTableV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV9(const PackMapZonePageTableV9 &p_other);
    PackMapZonePageTableV9 &operator=(const PackMapZonePageTableV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV21 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV21> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV9> pageTable;

public:
    PackMapZoneDefV21();
    PackMapZoneDefV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV21(const PackMapZoneDefV21 &p_other);
    PackMapZoneDefV21 &operator=(const PackMapZoneDefV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV21 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV21();
    PackMapZoneEncodingDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV21(const PackMapZoneEncodingDataV21 &p_other);
    PackMapZoneEncodingDataV21 &operator=(const PackMapZoneEncodingDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV21 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV21();
    PackMapZoneCollideDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV21(const PackMapZoneCollideDataV21 &p_other);
    PackMapZoneCollideDataV21 &operator=(const PackMapZoneCollideDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV21 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV21> encodeData;
    helpers::Array<PackMapZoneCollideDataV21> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV21();
    PackMapZoneV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV21(const PackMapZoneV21 &p_other);
    PackMapZoneV21 &operator=(const PackMapZoneV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV21 {
    helpers::Array<PackMapZoneDefV21> zoneDefArray;
    helpers::Array<PackMapZoneV21> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV21();
    PackMapZonesV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV21(const PackMapZonesV21 &p_other);
    PackMapZonesV21 &operator=(const PackMapZonesV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV21 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structzon2<19>{
struct PackMapZoneModelV20 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];

public:
    PackMapZoneModelV20();
    PackMapZoneModelV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV20(const PackMapZoneModelV20 &p_other);
    PackMapZoneModelV20 &operator=(const PackMapZoneModelV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV20 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[3];
    float instanceScaleJitter;
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV20> modelArray;
    helpers::Ptr<PackMapZoneModelV20> subModel;

public:
    PackMapZoneLayerDefV20();
    PackMapZoneLayerDefV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV20(const PackMapZoneLayerDefV20 &p_other);
    PackMapZoneLayerDefV20 &operator=(const PackMapZoneLayerDefV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV8 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV8();
    PackMapZonePageV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV8(const PackMapZonePageV8 &p_other);
    PackMapZonePageV8 &operator=(const PackMapZonePageV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV8 {
    helpers::Array<PackMapZonePageV8> pageArray;
    dword flags;

public:
    PackMapZonePageTableV8();
    PackMapZonePageTableV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV8(const PackMapZonePageTableV8 &p_other);
    PackMapZonePageTableV8 &operator=(const PackMapZonePageTableV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV20 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV20> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV8> pageTable;

public:
    PackMapZoneDefV20();
    PackMapZoneDefV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV20(const PackMapZoneDefV20 &p_other);
    PackMapZoneDefV20 &operator=(const PackMapZoneDefV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV20 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV20();
    PackMapZoneEncodingDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV20(const PackMapZoneEncodingDataV20 &p_other);
    PackMapZoneEncodingDataV20 &operator=(const PackMapZoneEncodingDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV20 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV20();
    PackMapZoneCollideDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV20(const PackMapZoneCollideDataV20 &p_other);
    PackMapZoneCollideDataV20 &operator=(const PackMapZoneCollideDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV20 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV20> encodeData;
    helpers::Array<PackMapZoneCollideDataV20> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV20();
    PackMapZoneV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV20(const PackMapZoneV20 &p_other);
    PackMapZoneV20 &operator=(const PackMapZoneV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV20 {
    helpers::Array<PackMapZoneDefV20> zoneDefArray;
    helpers::Array<PackMapZoneV20> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV20();
    PackMapZonesV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV20(const PackMapZonesV20 &p_other);
    PackMapZonesV20 &operator=(const PackMapZonesV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV20 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x410547F000000001 */

template <>
struct Gw2Structzon2<18>{
struct PackMapZoneModelV19 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];

public:
    PackMapZoneModelV19();
    PackMapZoneModelV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV19(const PackMapZoneModelV19 &p_other);
    PackMapZoneModelV19 &operator=(const PackMapZoneModelV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV19 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[4];
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV19> modelArray;
    helpers::Ptr<PackMapZoneModelV19> subModel;

public:
    PackMapZoneLayerDefV19();
    PackMapZoneLayerDefV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV19(const PackMapZoneLayerDefV19 &p_other);
    PackMapZoneLayerDefV19 &operator=(const PackMapZoneLayerDefV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV7 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV7();
    PackMapZonePageV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV7(const PackMapZonePageV7 &p_other);
    PackMapZonePageV7 &operator=(const PackMapZonePageV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV7 {
    helpers::Array<PackMapZonePageV7> pageArray;
    dword flags;

public:
    PackMapZonePageTableV7();
    PackMapZonePageTableV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV7(const PackMapZonePageTableV7 &p_other);
    PackMapZonePageTableV7 &operator=(const PackMapZonePageTableV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV19 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV19> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV7> pageTable;

public:
    PackMapZoneDefV19();
    PackMapZoneDefV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV19(const PackMapZoneDefV19 &p_other);
    PackMapZoneDefV19 &operator=(const PackMapZoneDefV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV19 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV19();
    PackMapZoneEncodingDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV19(const PackMapZoneEncodingDataV19 &p_other);
    PackMapZoneEncodingDataV19 &operator=(const PackMapZoneEncodingDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV19 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV19();
    PackMapZoneCollideDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV19(const PackMapZoneCollideDataV19 &p_other);
    PackMapZoneCollideDataV19 &operator=(const PackMapZoneCollideDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV19 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV19> encodeData;
    helpers::Array<PackMapZoneCollideDataV19> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV19();
    PackMapZoneV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV19(const PackMapZoneV19 &p_other);
    PackMapZoneV19 &operator=(const PackMapZoneV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV19 {
    helpers::Array<PackMapZoneDefV19> zoneDefArray;
    helpers::Array<PackMapZoneV19> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV19();
    PackMapZonesV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV19(const PackMapZonesV19 &p_other);
    PackMapZonesV19 &operator=(const PackMapZonesV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV19 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x4105473000000001 */

template <>
struct Gw2Structzon2<17>{
struct PackMapZoneModelV18 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;
    byte zOffsets[2];

public:
    PackMapZoneModelV18();
    PackMapZoneModelV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV18(const PackMapZoneModelV18 &p_other);
    PackMapZoneModelV18 &operator=(const PackMapZoneModelV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV18 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    float2 hslRanges[3];
    byte noise;
    dword layerFlags;
    helpers::FileName materialname;
    helpers::Array<PackMapZoneModelV18> modelArray;
    helpers::Ptr<PackMapZoneModelV18> subModel;

public:
    PackMapZoneLayerDefV18();
    PackMapZoneLayerDefV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV18(const PackMapZoneLayerDefV18 &p_other);
    PackMapZoneLayerDefV18 &operator=(const PackMapZoneLayerDefV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV6 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV6();
    PackMapZonePageV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV6(const PackMapZonePageV6 &p_other);
    PackMapZonePageV6 &operator=(const PackMapZonePageV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV6 {
    helpers::Array<PackMapZonePageV6> pageArray;
    dword flags;

public:
    PackMapZonePageTableV6();
    PackMapZonePageTableV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV6(const PackMapZonePageTableV6 &p_other);
    PackMapZonePageTableV6 &operator=(const PackMapZonePageTableV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV18 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV18> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV6> pageTable;

public:
    PackMapZoneDefV18();
    PackMapZoneDefV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV18(const PackMapZoneDefV18 &p_other);
    PackMapZoneDefV18 &operator=(const PackMapZoneDefV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV18 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV18();
    PackMapZoneEncodingDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV18(const PackMapZoneEncodingDataV18 &p_other);
    PackMapZoneEncodingDataV18 &operator=(const PackMapZoneEncodingDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV18 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV18();
    PackMapZoneCollideDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV18(const PackMapZoneCollideDataV18 &p_other);
    PackMapZoneCollideDataV18 &operator=(const PackMapZoneCollideDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV18 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV18> encodeData;
    helpers::Array<PackMapZoneCollideDataV18> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV18();
    PackMapZoneV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV18(const PackMapZoneV18 &p_other);
    PackMapZoneV18 &operator=(const PackMapZoneV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV18 {
    helpers::Array<PackMapZoneDefV18> zoneDefArray;
    helpers::Array<PackMapZoneV18> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV18();
    PackMapZonesV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV18(const PackMapZonesV18 &p_other);
    PackMapZonesV18 &operator=(const PackMapZonesV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV18 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x4105452000000001 */

template <>
struct Gw2Structzon2<16>{
struct PackMapZoneModelV17 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;

public:
    PackMapZoneModelV17();
    PackMapZoneModelV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV17(const PackMapZoneModelV17 &p_other);
    PackMapZoneModelV17 &operator=(const PackMapZoneModelV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV17 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV17> modelArray;
    helpers::Ptr<PackMapZoneModelV17> subModel;

public:
    PackMapZoneLayerDefV17();
    PackMapZoneLayerDefV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV17(const PackMapZoneLayerDefV17 &p_other);
    PackMapZoneLayerDefV17 &operator=(const PackMapZoneLayerDefV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV5 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV5();
    PackMapZonePageV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV5(const PackMapZonePageV5 &p_other);
    PackMapZonePageV5 &operator=(const PackMapZonePageV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV5 {
    helpers::Array<PackMapZonePageV5> pageArray;
    dword flags;

public:
    PackMapZonePageTableV5();
    PackMapZonePageTableV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV5(const PackMapZonePageTableV5 &p_other);
    PackMapZonePageTableV5 &operator=(const PackMapZonePageTableV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV17 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV17> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV5> pageTable;

public:
    PackMapZoneDefV17();
    PackMapZoneDefV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV17(const PackMapZoneDefV17 &p_other);
    PackMapZoneDefV17 &operator=(const PackMapZoneDefV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV17 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV17();
    PackMapZoneEncodingDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV17(const PackMapZoneEncodingDataV17 &p_other);
    PackMapZoneEncodingDataV17 &operator=(const PackMapZoneEncodingDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV17 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV17();
    PackMapZoneCollideDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV17(const PackMapZoneCollideDataV17 &p_other);
    PackMapZoneCollideDataV17 &operator=(const PackMapZoneCollideDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV17 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV17> encodeData;
    helpers::Array<PackMapZoneCollideDataV17> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV17();
    PackMapZoneV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV17(const PackMapZoneV17 &p_other);
    PackMapZoneV17 &operator=(const PackMapZoneV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV17 {
    helpers::Array<PackMapZoneDefV17> zoneDefArray;
    helpers::Array<PackMapZoneV17> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV17();
    PackMapZonesV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV17(const PackMapZonesV17 &p_other);
    PackMapZonesV17 &operator=(const PackMapZonesV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV17 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x4105452000000001 */

template <>
struct Gw2Structzon2<15>{
struct PackMapZoneModelV16 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;

public:
    PackMapZoneModelV16();
    PackMapZoneModelV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV16(const PackMapZoneModelV16 &p_other);
    PackMapZoneModelV16 &operator=(const PackMapZoneModelV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV16 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV16> modelArray;
    helpers::Ptr<PackMapZoneModelV16> subModel;

public:
    PackMapZoneLayerDefV16();
    PackMapZoneLayerDefV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV16(const PackMapZoneLayerDefV16 &p_other);
    PackMapZoneLayerDefV16 &operator=(const PackMapZoneLayerDefV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV4 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV4();
    PackMapZonePageV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV4(const PackMapZonePageV4 &p_other);
    PackMapZonePageV4 &operator=(const PackMapZonePageV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV4 {
    helpers::Array<PackMapZonePageV4> pageArray;
    dword flags;

public:
    PackMapZonePageTableV4();
    PackMapZonePageTableV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV4(const PackMapZonePageTableV4 &p_other);
    PackMapZonePageTableV4 &operator=(const PackMapZonePageTableV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV16 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV16> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV4> pageTable;

public:
    PackMapZoneDefV16();
    PackMapZoneDefV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV16(const PackMapZoneDefV16 &p_other);
    PackMapZoneDefV16 &operator=(const PackMapZoneDefV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV16 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV16();
    PackMapZoneEncodingDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV16(const PackMapZoneEncodingDataV16 &p_other);
    PackMapZoneEncodingDataV16 &operator=(const PackMapZoneEncodingDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV16 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV16();
    PackMapZoneCollideDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV16(const PackMapZoneCollideDataV16 &p_other);
    PackMapZoneCollideDataV16 &operator=(const PackMapZoneCollideDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV16 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV16> encodeData;
    helpers::Array<PackMapZoneCollideDataV16> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;
    word broadId;

public:
    PackMapZoneV16();
    PackMapZoneV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV16(const PackMapZoneV16 &p_other);
    PackMapZoneV16 &operator=(const PackMapZoneV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackBroadphaseType {
    helpers::Array<byte> broadphaseData;

public:
    PackBroadphaseType();
    PackBroadphaseType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackBroadphaseType(const PackBroadphaseType &p_other);
    PackBroadphaseType &operator=(const PackBroadphaseType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV16 {
    helpers::Array<PackMapZoneDefV16> zoneDefArray;
    helpers::Array<PackMapZoneV16> zoneArray;
    PackBroadphaseType broadPhase;
    word maxBroadId;

public:
    PackMapZonesV16();
    PackMapZonesV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV16(const PackMapZonesV16 &p_other);
    PackMapZonesV16 &operator=(const PackMapZonesV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV16 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<14>{
struct PackMapZoneModelV15 {
    helpers::FileName filename;
    float probability;
    dword flags;
    float3 hslOffset;

public:
    PackMapZoneModelV15();
    PackMapZoneModelV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV15(const PackMapZoneModelV15 &p_other);
    PackMapZoneModelV15 &operator=(const PackMapZoneModelV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV15 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV15> modelArray;
    helpers::Ptr<PackMapZoneModelV15> subModel;

public:
    PackMapZoneLayerDefV15();
    PackMapZoneLayerDefV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV15(const PackMapZoneLayerDefV15 &p_other);
    PackMapZoneLayerDefV15 &operator=(const PackMapZoneLayerDefV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV3 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV3();
    PackMapZonePageV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV3(const PackMapZonePageV3 &p_other);
    PackMapZonePageV3 &operator=(const PackMapZonePageV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV3 {
    helpers::Array<PackMapZonePageV3> pageArray;
    dword flags;

public:
    PackMapZonePageTableV3();
    PackMapZonePageTableV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV3(const PackMapZonePageTableV3 &p_other);
    PackMapZonePageTableV3 &operator=(const PackMapZonePageTableV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV15 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV15> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV3> pageTable;

public:
    PackMapZoneDefV15();
    PackMapZoneDefV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV15(const PackMapZoneDefV15 &p_other);
    PackMapZoneDefV15 &operator=(const PackMapZoneDefV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV15 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV15();
    PackMapZoneEncodingDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV15(const PackMapZoneEncodingDataV15 &p_other);
    PackMapZoneEncodingDataV15 &operator=(const PackMapZoneEncodingDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV15 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV15();
    PackMapZoneCollideDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV15(const PackMapZoneCollideDataV15 &p_other);
    PackMapZoneCollideDataV15 &operator=(const PackMapZoneCollideDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV15 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV15> encodeData;
    helpers::Array<PackMapZoneCollideDataV15> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;

public:
    PackMapZoneV15();
    PackMapZoneV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV15(const PackMapZoneV15 &p_other);
    PackMapZoneV15 &operator=(const PackMapZoneV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV15 {
    helpers::Array<PackMapZoneDefV15> zoneDefArray;
    helpers::Array<PackMapZoneV15> zoneArray;

public:
    PackMapZonesV15();
    PackMapZonesV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV15(const PackMapZonesV15 &p_other);
    PackMapZonesV15 &operator=(const PackMapZonesV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV15 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<13>{
struct PackMapZoneModelV14 {
    helpers::FileName filename;
    float probability;
    dword flags;

public:
    PackMapZoneModelV14();
    PackMapZoneModelV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV14(const PackMapZoneModelV14 &p_other);
    PackMapZoneModelV14 &operator=(const PackMapZoneModelV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV14 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV14> modelArray;
    helpers::Ptr<PackMapZoneModelV14> subModel;

public:
    PackMapZoneLayerDefV14();
    PackMapZoneLayerDefV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV14(const PackMapZoneLayerDefV14 &p_other);
    PackMapZoneLayerDefV14 &operator=(const PackMapZoneLayerDefV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageV2 {
    helpers::Array<byte> flags;
    dword2 chunkCoord;
    byte seed;
    helpers::Array<dword> paintFlags;

public:
    PackMapZonePageV2();
    PackMapZonePageV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageV2(const PackMapZonePageV2 &p_other);
    PackMapZonePageV2 &operator=(const PackMapZonePageV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonePageTableV2 {
    helpers::Array<PackMapZonePageV2> pageArray;
    dword flags;

public:
    PackMapZonePageTableV2();
    PackMapZonePageTableV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonePageTableV2(const PackMapZonePageTableV2 &p_other);
    PackMapZonePageTableV2 &operator=(const PackMapZonePageTableV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV14 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV14> layerDefArray;
    qword timeStamp;
    helpers::Ptr<PackMapZonePageTableV2> pageTable;

public:
    PackMapZoneDefV14();
    PackMapZoneDefV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV14(const PackMapZoneDefV14 &p_other);
    PackMapZoneDefV14 &operator=(const PackMapZoneDefV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV14 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV14();
    PackMapZoneEncodingDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV14(const PackMapZoneEncodingDataV14 &p_other);
    PackMapZoneEncodingDataV14 &operator=(const PackMapZoneEncodingDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV14 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV14();
    PackMapZoneCollideDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV14(const PackMapZoneCollideDataV14 &p_other);
    PackMapZoneCollideDataV14 &operator=(const PackMapZoneCollideDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV14 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV14> encodeData;
    helpers::Array<PackMapZoneCollideDataV14> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;

public:
    PackMapZoneV14();
    PackMapZoneV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV14(const PackMapZoneV14 &p_other);
    PackMapZoneV14 &operator=(const PackMapZoneV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV14 {
    helpers::Array<PackMapZoneDefV14> zoneDefArray;
    helpers::Array<PackMapZoneV14> zoneArray;

public:
    PackMapZonesV14();
    PackMapZonesV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV14(const PackMapZonesV14 &p_other);
    PackMapZonesV14 &operator=(const PackMapZonesV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV14 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<12>{
struct PackMapZoneModelV13 {
    helpers::FileName filename;
    float probability;
    dword flags;

public:
    PackMapZoneModelV13();
    PackMapZoneModelV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV13(const PackMapZoneModelV13 &p_other);
    PackMapZoneModelV13 &operator=(const PackMapZoneModelV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV13 {
    byte type;
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV13> modelArray;
    helpers::Ptr<PackMapZoneModelV13> subModel;

public:
    PackMapZoneLayerDefV13();
    PackMapZoneLayerDefV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV13(const PackMapZoneLayerDefV13 &p_other);
    PackMapZoneLayerDefV13 &operator=(const PackMapZoneLayerDefV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV13 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV13> layerDefArray;
    qword timeStamp;

public:
    PackMapZoneDefV13();
    PackMapZoneDefV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV13(const PackMapZoneDefV13 &p_other);
    PackMapZoneDefV13 &operator=(const PackMapZoneDefV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV13 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV13();
    PackMapZoneEncodingDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV13(const PackMapZoneEncodingDataV13 &p_other);
    PackMapZoneEncodingDataV13 &operator=(const PackMapZoneEncodingDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV13 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV13();
    PackMapZoneCollideDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV13(const PackMapZoneCollideDataV13 &p_other);
    PackMapZoneCollideDataV13 &operator=(const PackMapZoneCollideDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV13 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV13> encodeData;
    helpers::Array<PackMapZoneCollideDataV13> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;

public:
    PackMapZoneV13();
    PackMapZoneV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV13(const PackMapZoneV13 &p_other);
    PackMapZoneV13 &operator=(const PackMapZoneV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV13 {
    helpers::Array<PackMapZoneDefV13> zoneDefArray;
    helpers::Array<PackMapZoneV13> zoneArray;

public:
    PackMapZonesV13();
    PackMapZonesV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV13(const PackMapZonesV13 &p_other);
    PackMapZonesV13 &operator=(const PackMapZonesV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV13 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x1 */

template <>
struct Gw2Structzon2<11>{
struct PackMapZoneModelV12 {
    helpers::FileName filename;
    float probability;
    dword flags;

public:
    PackMapZoneModelV12();
    PackMapZoneModelV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneModelV12(const PackMapZoneModelV12 &p_other);
    PackMapZoneModelV12 &operator=(const PackMapZoneModelV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneLayerDefV12 {
    byte height;
    byte width;
    byte radiusGround;
    byte sortGroup;
    byte tiling;
    float2 scaleRange;
    float probability;
    float2 fadeRange;
    float2 rotRange[3];
    byte noise;
    dword layerFlags;
    helpers::Array<PackMapZoneModelV12> modelArray;
    helpers::Ptr<PackMapZoneModelV12> subModel;

public:
    PackMapZoneLayerDefV12();
    PackMapZoneLayerDefV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneLayerDefV12(const PackMapZoneLayerDefV12 &p_other);
    PackMapZoneLayerDefV12 &operator=(const PackMapZoneLayerDefV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneDefV12 {
    helpers::FileName defFilename;
    dword token;
    helpers::Array<PackMapZoneLayerDefV12> layerDefArray;
    qword timeStamp;

public:
    PackMapZoneDefV12();
    PackMapZoneDefV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneDefV12(const PackMapZoneDefV12 &p_other);
    PackMapZoneDefV12 &operator=(const PackMapZoneDefV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneEncodingDataV12 {
    word index;
    byte offset;

public:
    PackMapZoneEncodingDataV12();
    PackMapZoneEncodingDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneEncodingDataV12(const PackMapZoneEncodingDataV12 &p_other);
    PackMapZoneEncodingDataV12 &operator=(const PackMapZoneEncodingDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneCollideDataV12 {
    float normalX;
    float normalY;
    float zPos;

public:
    PackMapZoneCollideDataV12();
    PackMapZoneCollideDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneCollideDataV12(const PackMapZoneCollideDataV12 &p_other);
    PackMapZoneCollideDataV12 &operator=(const PackMapZoneCollideDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZoneV12 {
    dword zoneFlags;
    dword4 vertRect;
    float waterHeight;
    byte seed;
    dword defToken;
    float2 range;
    float zPos;
    helpers::Array<byte> flags;
    helpers::Array<PackMapZoneEncodingDataV12> encodeData;
    helpers::Array<PackMapZoneCollideDataV12> collideData;
    helpers::Array<word> offsetData;
    helpers::Array<float2> vertices;

public:
    PackMapZoneV12();
    PackMapZoneV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZoneV12(const PackMapZoneV12 &p_other);
    PackMapZoneV12 &operator=(const PackMapZoneV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapZonesV12 {
    helpers::Array<PackMapZoneDefV12> zoneDefArray;
    helpers::Array<PackMapZoneV12> zoneArray;

public:
    PackMapZonesV12();
    PackMapZonesV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapZonesV12(const PackMapZonesV12 &p_other);
    PackMapZonesV12 &operator=(const PackMapZonesV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapZonesV12 Gw2Struct;
};


/* ===============================================
 * Chunk: trn, versions: 16, strucTab: 0x1420F3C70
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtrn;

/* Version: 15, ReferencedFunction: 0x410536B000000001 */

template <>
struct Gw2Structtrn<15>{
struct PackMapTerrainChunkV14 {
    dword chunkFlags;
    helpers::Array<word> surfaceIndexArray;
    helpers::Array<qword> surfaceTokenArray;

public:
    PackMapTerrainChunkV14();
    PackMapTerrainChunkV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV14(const PackMapTerrainChunkV14 &p_other);
    PackMapTerrainChunkV14 &operator=(const PackMapTerrainChunkV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV14 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV14();
    PackMapTerrainConstV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV14(const PackMapTerrainConstV14 &p_other);
    PackMapTerrainConstV14 &operator=(const PackMapTerrainConstV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV14 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV14();
    PackMapTerrainTexV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV14(const PackMapTerrainTexV14 &p_other);
    PackMapTerrainTexV14 &operator=(const PackMapTerrainTexV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV14 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV14();
    PackMapTerrainMaterialV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV14(const PackMapTerrainMaterialV14 &p_other);
    PackMapTerrainMaterialV14 &operator=(const PackMapTerrainMaterialV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV14 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV14();
    PackMapTerrainChunkUVDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV14(const PackMapTerrainChunkUVDataV14 &p_other);
    PackMapTerrainChunkUVDataV14 &operator=(const PackMapTerrainChunkUVDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV14 {
    byte tiling[3];
    PackMapTerrainMaterialV14 hiResMaterial;
    PackMapTerrainMaterialV14 loResMaterial;
    PackMapTerrainMaterialV14 faderMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV14> uvData;

public:
    PackMapTerrrainChunkMaterialV14();
    PackMapTerrrainChunkMaterialV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV14(const PackMapTerrrainChunkMaterialV14 &p_other);
    PackMapTerrrainChunkMaterialV14 &operator=(const PackMapTerrrainChunkMaterialV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV14 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV14> constArray;
    helpers::Array<PackMapTerrainTexV14> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV14> materials;
    float2 midFade;
    float2 farFade;

public:
    PackMapTerrainMaterialsV14();
    PackMapTerrainMaterialsV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV14(const PackMapTerrainMaterialsV14 &p_other);
    PackMapTerrainMaterialsV14 &operator=(const PackMapTerrainMaterialsV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV15 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV14> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV14> materials;
    dword verticesPerChunkSide;

public:
    PackMapTerrainV15();
    PackMapTerrainV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV15(const PackMapTerrainV15 &p_other);
    PackMapTerrainV15 &operator=(const PackMapTerrainV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtrn<14>{
struct PackMapTerrainChunkV14 {
    dword chunkFlags;
    helpers::Array<word> surfaceIndexArray;
    helpers::Array<qword> surfaceTokenArray;

public:
    PackMapTerrainChunkV14();
    PackMapTerrainChunkV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV14(const PackMapTerrainChunkV14 &p_other);
    PackMapTerrainChunkV14 &operator=(const PackMapTerrainChunkV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV14 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV14();
    PackMapTerrainConstV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV14(const PackMapTerrainConstV14 &p_other);
    PackMapTerrainConstV14 &operator=(const PackMapTerrainConstV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV14 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV14();
    PackMapTerrainTexV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV14(const PackMapTerrainTexV14 &p_other);
    PackMapTerrainTexV14 &operator=(const PackMapTerrainTexV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV14 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV14();
    PackMapTerrainMaterialV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV14(const PackMapTerrainMaterialV14 &p_other);
    PackMapTerrainMaterialV14 &operator=(const PackMapTerrainMaterialV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV14 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV14();
    PackMapTerrainChunkUVDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV14(const PackMapTerrainChunkUVDataV14 &p_other);
    PackMapTerrainChunkUVDataV14 &operator=(const PackMapTerrainChunkUVDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV14 {
    byte tiling[3];
    PackMapTerrainMaterialV14 hiResMaterial;
    PackMapTerrainMaterialV14 loResMaterial;
    PackMapTerrainMaterialV14 faderMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV14> uvData;

public:
    PackMapTerrrainChunkMaterialV14();
    PackMapTerrrainChunkMaterialV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV14(const PackMapTerrrainChunkMaterialV14 &p_other);
    PackMapTerrrainChunkMaterialV14 &operator=(const PackMapTerrrainChunkMaterialV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV14 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV14> constArray;
    helpers::Array<PackMapTerrainTexV14> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV14> materials;
    float2 midFade;
    float2 farFade;

public:
    PackMapTerrainMaterialsV14();
    PackMapTerrainMaterialsV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV14(const PackMapTerrainMaterialsV14 &p_other);
    PackMapTerrainMaterialsV14 &operator=(const PackMapTerrainMaterialsV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV14 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV14> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV14> materials;

public:
    PackMapTerrainV14();
    PackMapTerrainV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV14(const PackMapTerrainV14 &p_other);
    PackMapTerrainV14 &operator=(const PackMapTerrainV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x4105364000000001 */

template <>
struct Gw2Structtrn<13>{
struct PackMapTerrainChunkV13 {
    dword chunkFlags;
    helpers::Array<byte> tileTableArray;

public:
    PackMapTerrainChunkV13();
    PackMapTerrainChunkV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV13(const PackMapTerrainChunkV13 &p_other);
    PackMapTerrainChunkV13 &operator=(const PackMapTerrainChunkV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV13 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV13();
    PackMapTerrainConstV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV13(const PackMapTerrainConstV13 &p_other);
    PackMapTerrainConstV13 &operator=(const PackMapTerrainConstV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV13 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV13();
    PackMapTerrainTexV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV13(const PackMapTerrainTexV13 &p_other);
    PackMapTerrainTexV13 &operator=(const PackMapTerrainTexV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV13 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV13();
    PackMapTerrainMaterialV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV13(const PackMapTerrainMaterialV13 &p_other);
    PackMapTerrainMaterialV13 &operator=(const PackMapTerrainMaterialV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV13 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV13();
    PackMapTerrainChunkUVDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV13(const PackMapTerrainChunkUVDataV13 &p_other);
    PackMapTerrainChunkUVDataV13 &operator=(const PackMapTerrainChunkUVDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV13 {
    byte tiling[3];
    PackMapTerrainMaterialV13 hiResMaterial;
    PackMapTerrainMaterialV13 loResMaterial;
    PackMapTerrainMaterialV13 faderMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV13> uvData;

public:
    PackMapTerrrainChunkMaterialV13();
    PackMapTerrrainChunkMaterialV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV13(const PackMapTerrrainChunkMaterialV13 &p_other);
    PackMapTerrrainChunkMaterialV13 &operator=(const PackMapTerrrainChunkMaterialV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV13 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV13> constArray;
    helpers::Array<PackMapTerrainTexV13> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV13> materials;
    float2 midFade;
    float2 farFade;

public:
    PackMapTerrainMaterialsV13();
    PackMapTerrainMaterialsV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV13(const PackMapTerrainMaterialsV13 &p_other);
    PackMapTerrainMaterialsV13 &operator=(const PackMapTerrainMaterialsV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV13 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV13> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV13> materials;
    helpers::Array<qword> typeArray;

public:
    PackMapTerrainV13();
    PackMapTerrainV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV13(const PackMapTerrainV13 &p_other);
    PackMapTerrainV13 &operator=(const PackMapTerrainV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x4105343000000001 */

template <>
struct Gw2Structtrn<12>{
struct PackMapTerrainChunkV12 {
    dword chunkFlags;
    helpers::Array<byte> tileTableArray;

public:
    PackMapTerrainChunkV12();
    PackMapTerrainChunkV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV12(const PackMapTerrainChunkV12 &p_other);
    PackMapTerrainChunkV12 &operator=(const PackMapTerrainChunkV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV12 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV12();
    PackMapTerrainConstV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV12(const PackMapTerrainConstV12 &p_other);
    PackMapTerrainConstV12 &operator=(const PackMapTerrainConstV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV12 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV12();
    PackMapTerrainTexV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV12(const PackMapTerrainTexV12 &p_other);
    PackMapTerrainTexV12 &operator=(const PackMapTerrainTexV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV12 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV12();
    PackMapTerrainMaterialV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV12(const PackMapTerrainMaterialV12 &p_other);
    PackMapTerrainMaterialV12 &operator=(const PackMapTerrainMaterialV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV12 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV12();
    PackMapTerrainChunkUVDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV12(const PackMapTerrainChunkUVDataV12 &p_other);
    PackMapTerrainChunkUVDataV12 &operator=(const PackMapTerrainChunkUVDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV12 {
    byte tiling[3];
    PackMapTerrainMaterialV12 hiResMaterial;
    PackMapTerrainMaterialV12 loResMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV12> uvData;

public:
    PackMapTerrrainChunkMaterialV12();
    PackMapTerrrainChunkMaterialV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV12(const PackMapTerrrainChunkMaterialV12 &p_other);
    PackMapTerrrainChunkMaterialV12 &operator=(const PackMapTerrrainChunkMaterialV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV12 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV12> constArray;
    helpers::Array<PackMapTerrainTexV12> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV12> materials;

public:
    PackMapTerrainMaterialsV12();
    PackMapTerrainMaterialsV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV12(const PackMapTerrainMaterialsV12 &p_other);
    PackMapTerrainMaterialsV12 &operator=(const PackMapTerrainMaterialsV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV12 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV12> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV12> materials;
    helpers::Array<qword> typeArray;

public:
    PackMapTerrainV12();
    PackMapTerrainV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV12(const PackMapTerrainV12 &p_other);
    PackMapTerrainV12 &operator=(const PackMapTerrainV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x4105339000000001 */

template <>
struct Gw2Structtrn<11>{
struct PackMapTerrainChunkV11 {
    dword chunkFlags;
    helpers::Array<byte> tileTableArray;

public:
    PackMapTerrainChunkV11();
    PackMapTerrainChunkV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV11(const PackMapTerrainChunkV11 &p_other);
    PackMapTerrainChunkV11 &operator=(const PackMapTerrainChunkV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV11 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV11();
    PackMapTerrainConstV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV11(const PackMapTerrainConstV11 &p_other);
    PackMapTerrainConstV11 &operator=(const PackMapTerrainConstV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV11 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV11();
    PackMapTerrainTexV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV11(const PackMapTerrainTexV11 &p_other);
    PackMapTerrainTexV11 &operator=(const PackMapTerrainTexV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV11 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV11();
    PackMapTerrainMaterialV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV11(const PackMapTerrainMaterialV11 &p_other);
    PackMapTerrainMaterialV11 &operator=(const PackMapTerrainMaterialV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV11 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV11();
    PackMapTerrainChunkUVDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV11(const PackMapTerrainChunkUVDataV11 &p_other);
    PackMapTerrainChunkUVDataV11 &operator=(const PackMapTerrainChunkUVDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV11 {
    byte tiling[3];
    PackMapTerrainMaterialV11 hiResMaterial;
    PackMapTerrainMaterialV11 loResMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV11> uvData;

public:
    PackMapTerrrainChunkMaterialV11();
    PackMapTerrrainChunkMaterialV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV11(const PackMapTerrrainChunkMaterialV11 &p_other);
    PackMapTerrrainChunkMaterialV11 &operator=(const PackMapTerrrainChunkMaterialV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV11 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV11> constArray;
    helpers::Array<PackMapTerrainTexV11> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV11> materials;

public:
    PackMapTerrainMaterialsV11();
    PackMapTerrainMaterialsV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV11(const PackMapTerrainMaterialsV11 &p_other);
    PackMapTerrainMaterialsV11 &operator=(const PackMapTerrainMaterialsV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV11 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV11> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV11> materials;
    helpers::Array<qword> typeArray;

public:
    PackMapTerrainV11();
    PackMapTerrainV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV11(const PackMapTerrainV11 &p_other);
    PackMapTerrainV11 &operator=(const PackMapTerrainV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtrn<10>{
struct PackMapTerrainChunkV10 {
    dword chunkFlags;
    helpers::Array<byte> tileTableArray;

public:
    PackMapTerrainChunkV10();
    PackMapTerrainChunkV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkV10(const PackMapTerrainChunkV10 &p_other);
    PackMapTerrainChunkV10 &operator=(const PackMapTerrainChunkV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainConstV10 {
    dword tokenName;
    float4 value;

public:
    PackMapTerrainConstV10();
    PackMapTerrainConstV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainConstV10(const PackMapTerrainConstV10 &p_other);
    PackMapTerrainConstV10 &operator=(const PackMapTerrainConstV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainTexV10 {
    dword tokenName;
    dword flags;
    helpers::FileName filename;
    dword2 flags;
    dword layer;

public:
    PackMapTerrainTexV10();
    PackMapTerrainTexV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainTexV10(const PackMapTerrainTexV10 &p_other);
    PackMapTerrainTexV10 &operator=(const PackMapTerrainTexV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialV10 {
    helpers::FileName materialFile;
    dword fvf;
    helpers::Array<dword> constIndexArray;
    helpers::Array<dword> texIndexArray;

public:
    PackMapTerrainMaterialV10();
    PackMapTerrainMaterialV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialV10(const PackMapTerrainMaterialV10 &p_other);
    PackMapTerrainMaterialV10 &operator=(const PackMapTerrainMaterialV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainChunkUVDataV10 {
    float2 translation;
    float2 xScaleRange;
    float2 yScaleRange;
    float2 scaleSpeed;
    float rotation;

public:
    PackMapTerrainChunkUVDataV10();
    PackMapTerrainChunkUVDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainChunkUVDataV10(const PackMapTerrainChunkUVDataV10 &p_other);
    PackMapTerrainChunkUVDataV10 &operator=(const PackMapTerrainChunkUVDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrrainChunkMaterialV10 {
    byte tiling;
    PackMapTerrainMaterialV10 hiResMaterial;
    PackMapTerrainMaterialV10 loResMaterial;
    helpers::Ptr<PackMapTerrainChunkUVDataV10> uvData;

public:
    PackMapTerrrainChunkMaterialV10();
    PackMapTerrrainChunkMaterialV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrrainChunkMaterialV10(const PackMapTerrrainChunkMaterialV10 &p_other);
    PackMapTerrrainChunkMaterialV10 &operator=(const PackMapTerrrainChunkMaterialV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainMaterialsV10 {
    helpers::FileName pagedImage;
    helpers::Array<PackMapTerrainConstV10> constArray;
    helpers::Array<PackMapTerrainTexV10> texFileArray;
    helpers::Array<PackMapTerrrainChunkMaterialV10> materials;

public:
    PackMapTerrainMaterialsV10();
    PackMapTerrainMaterialsV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainMaterialsV10(const PackMapTerrainMaterialsV10 &p_other);
    PackMapTerrainMaterialsV10 &operator=(const PackMapTerrainMaterialsV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapTerrainV10 {
    dword2 dims;
    float swapDistance;
    helpers::Array<float> heightMapArray;
    helpers::Array<dword> tileFlagArray;
    helpers::Array<PackMapTerrainChunkV10> chunkArray;
    helpers::Ptr<PackMapTerrainMaterialsV10> materials;
    helpers::Array<qword> typeArray;

public:
    PackMapTerrainV10();
    PackMapTerrainV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapTerrainV10(const PackMapTerrainV10 &p_other);
    PackMapTerrainV10 &operator=(const PackMapTerrainV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapTerrainV10 Gw2Struct;
};


/* ===============================================
 * Chunk: trni, versions: 4, strucTab: 0x1420F3E30
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structtrni;

/* Version: 3, ReferencedFunction: 0x410536C000000001 */

template <>
struct Gw2Structtrni<3>{
struct PagedImageLayerDataV3 {
    dword2 rawDims;
    dword2 strippedDims;
    dword rawFormat;
    dword strippedFormat;
    dword diskFormat;

public:
    PagedImageLayerDataV3();
    PagedImageLayerDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV3(const PagedImageLayerDataV3 &p_other);
    PagedImageLayerDataV3 &operator=(const PagedImageLayerDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV3 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV3();
    PagedImagePageDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV3(const PagedImagePageDataV3 &p_other);
    PagedImagePageDataV3 &operator=(const PagedImagePageDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV3 {
    helpers::Array<PagedImageLayerDataV3> layers;
    helpers::Array<PagedImagePageDataV3> rawPages;
    helpers::Array<PagedImagePageDataV3> strippedPages;
    dword flags;

public:
    PagedImageTableDataV3();
    PagedImageTableDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV3(const PagedImageTableDataV3 &p_other);
    PagedImageTableDataV3 &operator=(const PagedImageTableDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPageDataV3 {
    dword layer;
    dword2 coord;
    helpers::Array<byte> data;

public:
    PagedImageEmbeddedPageDataV3();
    PagedImageEmbeddedPageDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPageDataV3(const PagedImageEmbeddedPageDataV3 &p_other);
    PagedImageEmbeddedPageDataV3 &operator=(const PagedImageEmbeddedPageDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPagesDataV3 {
    helpers::Array<PagedImageEmbeddedPageDataV3> rawPages;
    helpers::Array<PagedImageEmbeddedPageDataV3> strippedPages;

public:
    PagedImageEmbeddedPagesDataV3();
    PagedImageEmbeddedPagesDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPagesDataV3(const PagedImageEmbeddedPagesDataV3 &p_other);
    PagedImageEmbeddedPagesDataV3 &operator=(const PagedImageEmbeddedPagesDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapTerrainImg {
    helpers::Ptr<PagedImageTableDataV3> tableData;
    helpers::Ptr<PagedImageEmbeddedPagesDataV3> pageData;

public:
    MapTerrainImg();
    MapTerrainImg(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapTerrainImg(const MapTerrainImg &p_other);
    MapTerrainImg &operator=(const MapTerrainImg &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapTerrainImg Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtrni<2>{
struct PagedImageLayerDataV2 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV2();
    PagedImageLayerDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV2(const PagedImageLayerDataV2 &p_other);
    PagedImageLayerDataV2 &operator=(const PagedImageLayerDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV2 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV2();
    PagedImagePageDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV2(const PagedImagePageDataV2 &p_other);
    PagedImagePageDataV2 &operator=(const PagedImagePageDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV2 {
    helpers::Array<PagedImageLayerDataV2> layers;
    helpers::Array<PagedImagePageDataV2> pages;
    dword flags;

public:
    PagedImageTableDataV2();
    PagedImageTableDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV2(const PagedImageTableDataV2 &p_other);
    PagedImageTableDataV2 &operator=(const PagedImageTableDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPageDataV2 {
    dword layer;
    dword2 coord;
    helpers::Array<byte> rawData;
    helpers::Array<byte> compressedData;

public:
    PagedImageEmbeddedPageDataV2();
    PagedImageEmbeddedPageDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPageDataV2(const PagedImageEmbeddedPageDataV2 &p_other);
    PagedImageEmbeddedPageDataV2 &operator=(const PagedImageEmbeddedPageDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPagesDataV2 {
    helpers::Array<PagedImageEmbeddedPageDataV2> pages;

public:
    PagedImageEmbeddedPagesDataV2();
    PagedImageEmbeddedPagesDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPagesDataV2(const PagedImageEmbeddedPagesDataV2 &p_other);
    PagedImageEmbeddedPagesDataV2 &operator=(const PagedImageEmbeddedPagesDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapTerrainImg {
    helpers::Ptr<PagedImageTableDataV2> tableData;
    helpers::Ptr<PagedImageEmbeddedPagesDataV2> pageData;

public:
    MapTerrainImg();
    MapTerrainImg(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapTerrainImg(const MapTerrainImg &p_other);
    MapTerrainImg &operator=(const MapTerrainImg &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapTerrainImg Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtrni<1>{
struct PagedImageLayerDataV1 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV1();
    PagedImageLayerDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV1(const PagedImageLayerDataV1 &p_other);
    PagedImageLayerDataV1 &operator=(const PagedImageLayerDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV1 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;
    byte4 solidColor;

public:
    PagedImagePageDataV1();
    PagedImagePageDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV1(const PagedImagePageDataV1 &p_other);
    PagedImagePageDataV1 &operator=(const PagedImagePageDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV1 {
    helpers::Array<PagedImageLayerDataV1> layers;
    helpers::Array<PagedImagePageDataV1> pages;

public:
    PagedImageTableDataV1();
    PagedImageTableDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV1(const PagedImageTableDataV1 &p_other);
    PagedImageTableDataV1 &operator=(const PagedImageTableDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPageDataV1 {
    dword layer;
    dword2 coord;
    helpers::Array<byte> rawData;
    helpers::Array<byte> compressedData;

public:
    PagedImageEmbeddedPageDataV1();
    PagedImageEmbeddedPageDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPageDataV1(const PagedImageEmbeddedPageDataV1 &p_other);
    PagedImageEmbeddedPageDataV1 &operator=(const PagedImageEmbeddedPageDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPagesDataV1 {
    helpers::Array<PagedImageEmbeddedPageDataV1> pages;

public:
    PagedImageEmbeddedPagesDataV1();
    PagedImageEmbeddedPagesDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPagesDataV1(const PagedImageEmbeddedPagesDataV1 &p_other);
    PagedImageEmbeddedPagesDataV1 &operator=(const PagedImageEmbeddedPagesDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapTerrainImg {
    helpers::Ptr<PagedImageTableDataV1> tableData;
    helpers::Ptr<PagedImageEmbeddedPagesDataV1> pageData;

public:
    MapTerrainImg();
    MapTerrainImg(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapTerrainImg(const MapTerrainImg &p_other);
    MapTerrainImg &operator=(const MapTerrainImg &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapTerrainImg Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structtrni<0>{
struct PagedImageLayerDataV0 {
    dword2 dims;
    dword2 rawDims;
    dword diskFormat;
    dword rawFormat;
    dword strippedFormat;

public:
    PagedImageLayerDataV0();
    PagedImageLayerDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageLayerDataV0(const PagedImageLayerDataV0 &p_other);
    PagedImageLayerDataV0 &operator=(const PagedImageLayerDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImagePageDataV0 {
    dword layer;
    dword2 coord;
    helpers::FileName filename;
    dword flags;

public:
    PagedImagePageDataV0();
    PagedImagePageDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImagePageDataV0(const PagedImagePageDataV0 &p_other);
    PagedImagePageDataV0 &operator=(const PagedImagePageDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageTableDataV0 {
    helpers::Array<PagedImageLayerDataV0> layers;
    helpers::Array<PagedImagePageDataV0> pages;

public:
    PagedImageTableDataV0();
    PagedImageTableDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageTableDataV0(const PagedImageTableDataV0 &p_other);
    PagedImageTableDataV0 &operator=(const PagedImageTableDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPageDataV0 {
    dword layer;
    dword2 coord;
    helpers::Array<byte> rawData;
    helpers::Array<byte> compressedData;

public:
    PagedImageEmbeddedPageDataV0();
    PagedImageEmbeddedPageDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPageDataV0(const PagedImageEmbeddedPageDataV0 &p_other);
    PagedImageEmbeddedPageDataV0 &operator=(const PagedImageEmbeddedPageDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PagedImageEmbeddedPagesDataV0 {
    helpers::Array<PagedImageEmbeddedPageDataV0> pages;

public:
    PagedImageEmbeddedPagesDataV0();
    PagedImageEmbeddedPagesDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PagedImageEmbeddedPagesDataV0(const PagedImageEmbeddedPagesDataV0 &p_other);
    PagedImageEmbeddedPagesDataV0 &operator=(const PagedImageEmbeddedPagesDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapTerrainImg {
    helpers::Ptr<PagedImageTableDataV0> tableData;
    helpers::Ptr<PagedImageEmbeddedPagesDataV0> pageData;

public:
    MapTerrainImg();
    MapTerrainImg(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapTerrainImg(const MapTerrainImg &p_other);
    MapTerrainImg &operator=(const MapTerrainImg &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapTerrainImg Gw2Struct;
};


/* ===============================================
 * Chunk: watr, versions: 2, strucTab: 0x1420F3E90
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structwatr;

/* Version: 1, ReferencedFunction: 0x4105451000000001 */

template <>
struct Gw2Structwatr<1>{
struct PackMapWaterSurfaceV1 {
    qword guid;
    dword waterSurfaceFlags;
    float waterSurfaceZ;
    helpers::Array<float2> vertices;

public:
    PackMapWaterSurfaceV1();
    PackMapWaterSurfaceV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapWaterSurfaceV1(const PackMapWaterSurfaceV1 &p_other);
    PackMapWaterSurfaceV1 &operator=(const PackMapWaterSurfaceV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapWaterV1 {
    dword waterFlags;
    float waterPlaneZ;
    helpers::Array<PackMapWaterSurfaceV1> waterSurfaces;

public:
    PackMapWaterV1();
    PackMapWaterV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapWaterV1(const PackMapWaterV1 &p_other);
    PackMapWaterV1 &operator=(const PackMapWaterV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapWaterV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structwatr<0>{
struct PackMapWaterV0 {
    helpers::Array<byte> waterFoamData;
    helpers::Array<dword> waterChunks;

public:
    PackMapWaterV0();
    PackMapWaterV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapWaterV0(const PackMapWaterV0 &p_other);
    PackMapWaterV0 &operator=(const PackMapWaterV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapWaterV0 Gw2Struct;
};


/* ===============================================
 * Chunk: edit, versions: 17, strucTab: 0x1420F0AB0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structedit;

/* Version: 16, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<16>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    helpers::Array<dword> layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    helpers::Array<byte> layerStates;
    helpers::Array<helpers::WString> layerNames;
    helpers::Array<dword> layerIds;
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfacePoly {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<float2> vertices;
    float2 range;

public:
    PackMapEditSurfacePoly();
    PackMapEditSurfacePoly(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfacePoly(const PackMapEditSurfacePoly &p_other);
    PackMapEditSurfacePoly &operator=(const PackMapEditSurfacePoly &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoadNode {
    float3 position;
    float radius;

public:
    PackMapEditSurfaceRoadNode();
    PackMapEditSurfaceRoadNode(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoadNode(const PackMapEditSurfaceRoadNode &p_other);
    PackMapEditSurfaceRoadNode &operator=(const PackMapEditSurfaceRoadNode &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoad {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<PackMapEditSurfaceRoadNode> nodes;

public:
    PackMapEditSurfaceRoad();
    PackMapEditSurfaceRoad(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoad(const PackMapEditSurfaceRoad &p_other);
    PackMapEditSurfaceRoad &operator=(const PackMapEditSurfaceRoad &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditNavmeshGenPropMode {
    qword propId;
    byte mode;
    qword animSequence;

public:
    PackMapEditNavmeshGenPropMode();
    PackMapEditNavmeshGenPropMode(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditNavmeshGenPropMode(const PackMapEditNavmeshGenPropMode &p_other);
    PackMapEditNavmeshGenPropMode &operator=(const PackMapEditNavmeshGenPropMode &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditNavMeshData {
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<PackMapEditSurfacePoly> surfacePolys;
    helpers::Array<PackMapEditSurfaceRoad> surfaceRoads;
    helpers::Array<PackMapEditNavmeshGenPropMode> propModesForGeneration;

public:
    PackMapEditNavMeshData();
    PackMapEditNavMeshData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditNavMeshData(const PackMapEditNavMeshData &p_other);
    PackMapEditNavMeshData &operator=(const PackMapEditNavMeshData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditMeasureSpan {
    helpers::WString name;
    qword substrateId0;
    qword substrateId1;
    dword substrateModuleId0;
    dword substrateModuleId1;
    float3 position0;
    float3 position1;
    float3 limits;

public:
    MapEditMeasureSpan();
    MapEditMeasureSpan(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditMeasureSpan(const MapEditMeasureSpan &p_other);
    MapEditMeasureSpan &operator=(const MapEditMeasureSpan &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    PackMapEditNavMeshData navMeshData;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::Array<MapEditMeasureSpan> measureSpans;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<15>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    helpers::Array<dword> layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    helpers::Array<byte> layerStates;
    helpers::Array<helpers::WString> layerNames;
    helpers::Array<dword> layerIds;
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfacePoly {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<float2> vertices;
    float2 range;

public:
    PackMapEditSurfacePoly();
    PackMapEditSurfacePoly(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfacePoly(const PackMapEditSurfacePoly &p_other);
    PackMapEditSurfacePoly &operator=(const PackMapEditSurfacePoly &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoadNode {
    float3 position;
    float radius;

public:
    PackMapEditSurfaceRoadNode();
    PackMapEditSurfaceRoadNode(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoadNode(const PackMapEditSurfaceRoadNode &p_other);
    PackMapEditSurfaceRoadNode &operator=(const PackMapEditSurfaceRoadNode &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoad {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<PackMapEditSurfaceRoadNode> nodes;

public:
    PackMapEditSurfaceRoad();
    PackMapEditSurfaceRoad(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoad(const PackMapEditSurfaceRoad &p_other);
    PackMapEditSurfaceRoad &operator=(const PackMapEditSurfaceRoad &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditNavMeshData {
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<PackMapEditSurfacePoly> surfacePolys;
    helpers::Array<PackMapEditSurfaceRoad> surfaceRoads;

public:
    PackMapEditNavMeshData();
    PackMapEditNavMeshData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditNavMeshData(const PackMapEditNavMeshData &p_other);
    PackMapEditNavMeshData &operator=(const PackMapEditNavMeshData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditMeasureSpan {
    helpers::WString name;
    qword substrateId0;
    qword substrateId1;
    dword substrateModuleId0;
    dword substrateModuleId1;
    float3 position0;
    float3 position1;
    float3 limits;

public:
    MapEditMeasureSpan();
    MapEditMeasureSpan(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditMeasureSpan(const MapEditMeasureSpan &p_other);
    MapEditMeasureSpan &operator=(const MapEditMeasureSpan &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    PackMapEditNavMeshData navMeshData;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::Array<MapEditMeasureSpan> measureSpans;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<14>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    helpers::Array<dword> layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    helpers::Array<byte> layerStates;
    helpers::Array<helpers::WString> layerNames;
    helpers::Array<dword> layerIds;
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfacePoly {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<float2> vertices;
    float2 range;

public:
    PackMapEditSurfacePoly();
    PackMapEditSurfacePoly(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfacePoly(const PackMapEditSurfacePoly &p_other);
    PackMapEditSurfacePoly &operator=(const PackMapEditSurfacePoly &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoadNode {
    float3 position;
    float radius;

public:
    PackMapEditSurfaceRoadNode();
    PackMapEditSurfaceRoadNode(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoadNode(const PackMapEditSurfaceRoadNode &p_other);
    PackMapEditSurfaceRoadNode &operator=(const PackMapEditSurfaceRoadNode &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditSurfaceRoad {
    helpers::WString name;
    dword surfaceType;
    helpers::Array<PackMapEditSurfaceRoadNode> nodes;

public:
    PackMapEditSurfaceRoad();
    PackMapEditSurfaceRoad(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditSurfaceRoad(const PackMapEditSurfaceRoad &p_other);
    PackMapEditSurfaceRoad &operator=(const PackMapEditSurfaceRoad &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditNavMeshData {
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<PackMapEditSurfacePoly> surfacePolys;
    helpers::Array<PackMapEditSurfaceRoad> surfaceRoads;

public:
    PackMapEditNavMeshData();
    PackMapEditNavMeshData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditNavMeshData(const PackMapEditNavMeshData &p_other);
    PackMapEditNavMeshData &operator=(const PackMapEditNavMeshData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    PackMapEditNavMeshData navMeshData;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<13>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    helpers::Array<dword> layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    helpers::Array<byte> layerStates;
    helpers::Array<helpers::WString> layerNames;
    helpers::Array<dword> layerIds;
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<12>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    dword layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    byte layerStates[31];
    helpers::WString layerNames[31];
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<11>{
struct MapEditLayerItem {
    qword guid;
    dword moduleId;
    dword layerFlags;

public:
    MapEditLayerItem();
    MapEditLayerItem(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayerItem(const MapEditLayerItem &p_other);
    MapEditLayerItem &operator=(const MapEditLayerItem &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    byte layerStates[31];
    helpers::WString layerNames[31];
    helpers::Array<MapEditLayerItem> items;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditSnapPoint {
    qword guid;
    dword moduleId;
    dword flags;
    float3 position;
    float3 rotation;
    float scale;

public:
    MapEditSnapPoint();
    MapEditSnapPoint(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditSnapPoint(const MapEditSnapPoint &p_other);
    MapEditSnapPoint &operator=(const MapEditSnapPoint &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::Array<MapEditSnapPoint> snapPoints;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<10>{
struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];
    helpers::WString layerNames[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::WString mapHome;
    byte homeSave;
    helpers::WString reserved;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<9>{
struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];
    helpers::WString layerNames[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;
    helpers::WString mapHome;
    byte homeSave;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<8>{
struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];
    helpers::WString layerNames[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<7>{
struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;
    float2 zRange;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<6>{
struct MapEditRegion {
    helpers::Array<helpers::WString> regions;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditRegion {
    byte3 ambientColor;
    byte3 directionalColor;
    float ambientIntenisty;
    float directionalIntenisty;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword flags;
    float3 position;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditRegion regions;
    MapEditRegion miniMapParams;
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;
    helpers::Array<PackMapEditDirtyChunks> floodPoints;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<5>{
struct MapEditRegion {
    helpers::Array<helpers::WString> regions;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditRegion {
    byte3 ambientColor;
    byte3 directionalColor;
    float ambientIntenisty;
    float directionalIntenisty;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditDirtyChunks {
    dword dirtyFlags;
    dword2 chunkCoord;

public:
    PackMapEditDirtyChunks();
    PackMapEditDirtyChunks(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditDirtyChunks(const PackMapEditDirtyChunks &p_other);
    PackMapEditDirtyChunks &operator=(const PackMapEditDirtyChunks &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditRegion regions;
    MapEditRegion miniMapParams;
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<PackMapEditDirtyChunks> dirtyChunks;
    helpers::Array<MapEditCamLocations> camLocations;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x4016287000000001 */

template <>
struct Gw2Structedit<4>{
struct MapEditRegion {
    helpers::Array<helpers::WString> regions;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditRegion {
    byte3 ambientColor;
    byte3 directionalColor;
    float ambientIntenisty;
    float directionalIntenisty;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    dword layerPropCount[31];
    byte layerStates[31];

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditRegion regions;
    MapEditRegion miniMapParams;
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<MapEditCamLocations> camLocations;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structedit<3>{
struct MapEditRegion {
    helpers::Array<helpers::WString> regions;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditRegion {
    byte3 ambientColor;
    byte3 directionalColor;
    float ambientIntenisty;
    float directionalIntenisty;

public:
    MapEditRegion();
    MapEditRegion(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditRegion(const MapEditRegion &p_other);
    MapEditRegion &operator=(const MapEditRegion &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditLayers {
    helpers::Array<byte> layerStates;

public:
    MapEditLayers();
    MapEditLayers(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditLayers(const MapEditLayers &p_other);
    MapEditLayers &operator=(const MapEditLayers &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotation {
    helpers::WString name;
    dword flags;
    helpers::Array<float2> anchors;

public:
    PackMapEditAnnotation();
    PackMapEditAnnotation(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotation(const PackMapEditAnnotation &p_other);
    PackMapEditAnnotation &operator=(const PackMapEditAnnotation &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapEditAnnotations {
    helpers::Array<PackMapEditAnnotation> annotations;

public:
    PackMapEditAnnotations();
    PackMapEditAnnotations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapEditAnnotations(const PackMapEditAnnotations &p_other);
    PackMapEditAnnotations &operator=(const PackMapEditAnnotations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditCamLocations {
    float attack;
    float rotation;
    float3 position;
    helpers::WString name;

public:
    MapEditCamLocations();
    MapEditCamLocations(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditCamLocations(const MapEditCamLocations &p_other);
    MapEditCamLocations &operator=(const MapEditCamLocations &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapEditData {
    MapEditRegion regions;
    MapEditRegion miniMapParams;
    MapEditLayers layers;
    PackMapEditAnnotations annotations;
    helpers::Array<MapEditCamLocations> camLocations;

public:
    MapEditData();
    MapEditData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapEditData(const MapEditData &p_other);
    MapEditData &operator=(const MapEditData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapEditData Gw2Struct;
};


/* ===============================================
 * Chunk: dcal, versions: 11, strucTab: 0x1420F0900
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structdcal;

/* Version: 10, ReferencedFunction: 0x41052CD000000001 */

template <>
struct Gw2Structdcal<10>{
struct PackMapDecalVertexV9 {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;

public:
    PackMapDecalVertexV9();
    PackMapDecalVertexV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV9(const PackMapDecalVertexV9 &p_other);
    PackMapDecalVertexV9 &operator=(const PackMapDecalVertexV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV10 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    float2 gridSize;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV9> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;
    byte projection;
    qword surfaceId;
    qword id;

public:
    PackMapDecalV10();
    PackMapDecalV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV10(const PackMapDecalV10 &p_other);
    PackMapDecalV10 &operator=(const PackMapDecalV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV10 {
    helpers::Array<PackMapDecalV10> decals;

public:
    PackMapDecalsV10();
    PackMapDecalsV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV10(const PackMapDecalsV10 &p_other);
    PackMapDecalsV10 &operator=(const PackMapDecalsV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x41052A2000000001 */

template <>
struct Gw2Structdcal<9>{
struct PackMapDecalVertexV8 {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;

public:
    PackMapDecalVertexV8();
    PackMapDecalVertexV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV8(const PackMapDecalVertexV8 &p_other);
    PackMapDecalVertexV8 &operator=(const PackMapDecalVertexV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV9 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV8> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;
    byte projection;
    qword surfaceId;
    qword id;

public:
    PackMapDecalV9();
    PackMapDecalV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV9(const PackMapDecalV9 &p_other);
    PackMapDecalV9 &operator=(const PackMapDecalV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV9 {
    helpers::Array<PackMapDecalV9> decals;

public:
    PackMapDecalsV9();
    PackMapDecalsV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV9(const PackMapDecalsV9 &p_other);
    PackMapDecalsV9 &operator=(const PackMapDecalsV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<8>{
struct PackMapDecalVertexV7 {
    float3 position;

public:
    PackMapDecalVertexV7();
    PackMapDecalVertexV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV7(const PackMapDecalVertexV7 &p_other);
    PackMapDecalVertexV7 &operator=(const PackMapDecalVertexV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV8 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV7> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;
    byte projection;
    qword surfaceId;
    qword id;

public:
    PackMapDecalV8();
    PackMapDecalV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV8(const PackMapDecalV8 &p_other);
    PackMapDecalV8 &operator=(const PackMapDecalV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV8 {
    helpers::Array<PackMapDecalV8> decals;

public:
    PackMapDecalsV8();
    PackMapDecalsV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV8(const PackMapDecalsV8 &p_other);
    PackMapDecalsV8 &operator=(const PackMapDecalsV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x410529D000000001 */

template <>
struct Gw2Structdcal<7>{
struct PackMapDecalVertexV6 {
    float3 position;

public:
    PackMapDecalVertexV6();
    PackMapDecalVertexV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV6(const PackMapDecalVertexV6 &p_other);
    PackMapDecalVertexV6 &operator=(const PackMapDecalVertexV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV7 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV6> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;
    byte projection;
    qword id;

public:
    PackMapDecalV7();
    PackMapDecalV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV7(const PackMapDecalV7 &p_other);
    PackMapDecalV7 &operator=(const PackMapDecalV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV7 {
    helpers::Array<PackMapDecalV7> decals;

public:
    PackMapDecalsV7();
    PackMapDecalsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV7(const PackMapDecalsV7 &p_other);
    PackMapDecalsV7 &operator=(const PackMapDecalsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<6>{
struct PackMapDecalVertexV5 {
    float3 position;

public:
    PackMapDecalVertexV5();
    PackMapDecalVertexV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV5(const PackMapDecalVertexV5 &p_other);
    PackMapDecalVertexV5 &operator=(const PackMapDecalVertexV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV6 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV5> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;
    byte projection;

public:
    PackMapDecalV6();
    PackMapDecalV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV6(const PackMapDecalV6 &p_other);
    PackMapDecalV6 &operator=(const PackMapDecalV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV6 {
    helpers::Array<PackMapDecalV6> decals;

public:
    PackMapDecalsV6();
    PackMapDecalsV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV6(const PackMapDecalsV6 &p_other);
    PackMapDecalsV6 &operator=(const PackMapDecalsV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<5>{
struct PackMapDecalVertexV4 {
    float3 position;

public:
    PackMapDecalVertexV4();
    PackMapDecalVertexV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalVertexV4(const PackMapDecalVertexV4 &p_other);
    PackMapDecalVertexV4 &operator=(const PackMapDecalVertexV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalV5 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;
    helpers::Array<PackMapDecalVertexV4> vertices;
    helpers::Array<word> indices;
    helpers::Array<qword> propIds;

public:
    PackMapDecalV5();
    PackMapDecalV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV5(const PackMapDecalV5 &p_other);
    PackMapDecalV5 &operator=(const PackMapDecalV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV5 {
    helpers::Array<PackMapDecalV5> decals;

public:
    PackMapDecalsV5();
    PackMapDecalsV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV5(const PackMapDecalsV5 &p_other);
    PackMapDecalsV5 &operator=(const PackMapDecalsV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<4>{
struct PackMapDecalV4 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;
    helpers::Array<dword> constantTokens;
    helpers::Array<float4> constantValues;

public:
    PackMapDecalV4();
    PackMapDecalV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV4(const PackMapDecalV4 &p_other);
    PackMapDecalV4 &operator=(const PackMapDecalV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV4 {
    helpers::Array<PackMapDecalV4> decals;

public:
    PackMapDecalsV4();
    PackMapDecalsV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV4(const PackMapDecalsV4 &p_other);
    PackMapDecalsV4 &operator=(const PackMapDecalsV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x4105296000000001 */

template <>
struct Gw2Structdcal<3>{
struct PackMapDecalV3 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScaleUV0;
    float2 textureOffsetUV0;
    float2 textureScaleUV1;
    float2 textureOffsetUV1;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;
    float surfaceBias;

public:
    PackMapDecalV3();
    PackMapDecalV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV3(const PackMapDecalV3 &p_other);
    PackMapDecalV3 &operator=(const PackMapDecalV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV3 {
    helpers::Array<PackMapDecalV3> decals;

public:
    PackMapDecalsV3();
    PackMapDecalsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV3(const PackMapDecalsV3 &p_other);
    PackMapDecalsV3 &operator=(const PackMapDecalsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<2>{
struct PackMapDecalV2 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScale;
    float2 textureOffset;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;
    float2 animTranslation;
    float2 animScaleRangeX;
    float2 animScaleRangeY;
    float2 animScaleSpeed;
    float animRotation;

public:
    PackMapDecalV2();
    PackMapDecalV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV2(const PackMapDecalV2 &p_other);
    PackMapDecalV2 &operator=(const PackMapDecalV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV2 {
    helpers::Array<PackMapDecalV2> decals;

public:
    PackMapDecalsV2();
    PackMapDecalsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV2(const PackMapDecalsV2 &p_other);
    PackMapDecalsV2 &operator=(const PackMapDecalsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structdcal<1>{
struct PackMapDecalV1 {
    float3 position;
    float3 extents;
    float3 rotation;
    float2 textureScale;
    float2 textureOffset;
    helpers::FileName materialFilename;
    helpers::Array<helpers::FileName> textureFilenames;
    dword flags;

public:
    PackMapDecalV1();
    PackMapDecalV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalV1(const PackMapDecalV1 &p_other);
    PackMapDecalV1 &operator=(const PackMapDecalV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapDecalsV1 {
    helpers::Array<PackMapDecalV1> decals;

public:
    PackMapDecalsV1();
    PackMapDecalsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapDecalsV1(const PackMapDecalsV1 &p_other);
    PackMapDecalsV1 &operator=(const PackMapDecalsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapDecalsV1 Gw2Struct;
};


/* ===============================================
 * Chunk: exp, versions: 1, strucTab: 0x1420F1F60
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structexp;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structexp<0>{
struct MapExpansionProperty {
    dword type;
    qword val;
    helpers::FileName strVal;

public:
    MapExpansionProperty();
    MapExpansionProperty(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapExpansionProperty(const MapExpansionProperty &p_other);
    MapExpansionProperty &operator=(const MapExpansionProperty &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapExpansionProperties {
    helpers::Array<MapExpansionProperty> properties;

public:
    MapExpansionProperties();
    MapExpansionProperties(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapExpansionProperties(const MapExpansionProperties &p_other);
    MapExpansionProperties &operator=(const MapExpansionProperties &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapExpansionProperties Gw2Struct;
};


/* ===============================================
 * Chunk: pack, versions: 1, strucTab: 0x1420F2610
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structpack;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structpack<0>{
struct MapVariant {
    helpers::WString file;
    helpers::WString name;
    qword token;
    dword flags;

public:
    MapVariant();
    MapVariant(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapVariant(const MapVariant &p_other);
    MapVariant &operator=(const MapVariant &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MapPackage {
    helpers::FileName baseFile;
    helpers::Array<MapVariant> variants;
    dword flags;

public:
    MapPackage();
    MapPackage(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MapPackage(const MapPackage &p_other);
    MapPackage &operator=(const MapPackage &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef MapPackage Gw2Struct;
};


/* ===============================================
 * Chunk: MODL, versions: 71, strucTab: 0x14218F0A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructMODL;

/* Version: 70, ReferencedFunction: 0x410DC70000000001 */

template <>
struct Gw2StructMODL<70>{
struct ModelTextureDataV66 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV66();
    ModelTextureDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV66(const ModelTextureDataV66 &p_other);
    ModelTextureDataV66 &operator=(const ModelTextureDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV66 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV66();
    ModelConstantDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV66(const ModelConstantDataV66 &p_other);
    ModelConstantDataV66 &operator=(const ModelConstantDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV66 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV66();
    ModelMatConstLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV66(const ModelMatConstLinkV66 &p_other);
    ModelMatConstLinkV66 &operator=(const ModelMatConstLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV66 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV66();
    ModelUVTransLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV66(const ModelUVTransLinkV66 &p_other);
    ModelUVTransLinkV66 &operator=(const ModelUVTransLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV66 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV66();
    ModelMaterialTexTransformV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV66(const ModelMaterialTexTransformV66 &p_other);
    ModelMaterialTexTransformV66 &operator=(const ModelMaterialTexTransformV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV66 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV66> textures;
    helpers::Array<ModelConstantDataV66> constants;
    helpers::Array<ModelMatConstLinkV66> matConstLinks;
    helpers::Array<ModelUVTransLinkV66> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV66> texTransforms;
    byte texCoordCount;
    dword sortLayer;

public:
    ModelMaterialDataV66();
    ModelMaterialDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV66(const ModelMaterialDataV66 &p_other);
    ModelMaterialDataV66 &operator=(const ModelMaterialDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV66 {
    qword token;
    helpers::Ptr<ModelMaterialDataV66> materials;

public:
    ModelPermutationDataV66();
    ModelPermutationDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV66(const ModelPermutationDataV66 &p_other);
    ModelPermutationDataV66 &operator=(const ModelPermutationDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV66 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV66();
    ModelParticleCloudV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV66(const ModelParticleCloudV66 &p_other);
    ModelParticleCloudV66 &operator=(const ModelParticleCloudV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV66 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV66();
    ModelParticleCurveV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV66(const ModelParticleCurveV66 &p_other);
    ModelParticleCurveV66 &operator=(const ModelParticleCurveV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V66 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V66();
    ModelMatrix43V66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V66(const ModelMatrix43V66 &p_other);
    ModelMatrix43V66 &operator=(const ModelMatrix43V66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV66 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV66();
    ModelParticleFlipbookV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV66(const ModelParticleFlipbookV66 &p_other);
    ModelParticleFlipbookV66 &operator=(const ModelParticleFlipbookV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PlaneEmitterSettingsV69 {
    float3 alignmentDir;
    byte alignmentType;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float4 texCoordRect;

public:
    PlaneEmitterSettingsV69();
    PlaneEmitterSettingsV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PlaneEmitterSettingsV69(const PlaneEmitterSettingsV69 &p_other);
    PlaneEmitterSettingsV69 &operator=(const PlaneEmitterSettingsV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MeshEmitterSettingsV70 {
    dword alignment;
    float bankThreshold;
    float bankScale;
    helpers::FileName filename;
    float obstacleRadius;
    float2 rotation[3];
    float3 rotationDrag;
    float2 scaleChange[3];
    float2 scaleInitial[3];
    float2 spin[3];

public:
    MeshEmitterSettingsV70();
    MeshEmitterSettingsV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MeshEmitterSettingsV70(const MeshEmitterSettingsV70 &p_other);
    MeshEmitterSettingsV70 &operator=(const MeshEmitterSettingsV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV70 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    qword bone;
    float4 colorBegin[2];
    float4 colorEnd[2];
    float colorPeriod;
    float2 colorFalloff;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV66> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    float2 lifetime;
    helpers::Ptr<ModelParticleCurveV66> scaleCurve;
    dword scaleCurvePreset;
    float drag;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    helpers::Ptr<ModelMatrix43V66> transform;
    byte windInfluence;
    byte spawnShape;
    helpers::Ptr<PlaneEmitterSettingsV69> planeEmitterSettings;
    helpers::Ptr<MeshEmitterSettingsV70> meshEmitterSettings;

public:
    ModelParticleEmitterV70();
    ModelParticleEmitterV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV70(const ModelParticleEmitterV70 &p_other);
    ModelParticleEmitterV70 &operator=(const ModelParticleEmitterV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV70 {
    helpers::Array<ModelParticleCloudV66> clouds;
    helpers::Array<ModelParticleEmitterV70> emitters;

public:
    ModelCloudDataV70();
    ModelCloudDataV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV70(const ModelCloudDataV70 &p_other);
    ModelCloudDataV70 &operator=(const ModelCloudDataV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV66 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V66> transform;

public:
    ModelObstacleDataV66();
    ModelObstacleDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV66(const ModelObstacleDataV66 &p_other);
    ModelObstacleDataV66 &operator=(const ModelObstacleDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV66 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV66();
    ModelStreakV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV66(const ModelStreakV66 &p_other);
    ModelStreakV66 &operator=(const ModelStreakV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV66 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV66();
    ModelStreakAnchorV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV66(const ModelStreakAnchorV66 &p_other);
    ModelStreakAnchorV66 &operator=(const ModelStreakAnchorV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV66 {
    helpers::Array<ModelStreakV66> streaks;
    helpers::Array<ModelStreakAnchorV66> anchors;

public:
    ModelStreakDataV66();
    ModelStreakDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV66(const ModelStreakDataV66 &p_other);
    ModelStreakDataV66 &operator=(const ModelStreakDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV66 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV66();
    ModelEffectLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV66(const ModelEffectLightV66 &p_other);
    ModelEffectLightV66 &operator=(const ModelEffectLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV66 {
    helpers::Array<ModelEffectLightV66> effectLights;

public:
    ModelLightDataV66();
    ModelLightDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV66(const ModelLightDataV66 &p_other);
    ModelLightDataV66 &operator=(const ModelLightDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV66 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV66();
    ModelClothBoneWeightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV66(const ModelClothBoneWeightV66 &p_other);
    ModelClothBoneWeightV66 &operator=(const ModelClothBoneWeightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV66 {
    helpers::Array<ModelClothBoneWeightV66> weights;

public:
    ModelClothMeshGroupV66();
    ModelClothMeshGroupV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV66(const ModelClothMeshGroupV66 &p_other);
    ModelClothMeshGroupV66 &operator=(const ModelClothMeshGroupV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV66 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV66();
    ModelClothGroupBindingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV66(const ModelClothGroupBindingV66 &p_other);
    ModelClothGroupBindingV66 &operator=(const ModelClothGroupBindingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV66 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV66();
    ModelClothSoftLockV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV66(const ModelClothSoftLockV66 &p_other);
    ModelClothSoftLockV66 &operator=(const ModelClothSoftLockV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV66 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV66();
    ModelClothConstraintV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV66(const ModelClothConstraintV66 &p_other);
    ModelClothConstraintV66 &operator=(const ModelClothConstraintV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV66 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV66> groups;
    helpers::Array<ModelClothGroupBindingV66> groupBindings;
    helpers::Array<ModelClothSoftLockV66> softLocks;
    helpers::Array<ModelClothConstraintV66> lod0Constraints;
    helpers::Array<ModelClothConstraintV66> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV66();
    ModelClothDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV66(const ModelClothDataV66 &p_other);
    ModelClothDataV66 &operator=(const ModelClothDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV66 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV66();
    ModelEffectWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV66(const ModelEffectWindV66 &p_other);
    ModelEffectWindV66 &operator=(const ModelEffectWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV66 {
    helpers::Array<ModelEffectWindV66> effectWind;

public:
    ModelWindDataV66();
    ModelWindDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV66(const ModelWindDataV66 &p_other);
    ModelWindDataV66 &operator=(const ModelWindDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV66 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV66();
    ModelLightningSystemV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV66(const ModelLightningSystemV66 &p_other);
    ModelLightningSystemV66 &operator=(const ModelLightningSystemV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV66 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV66();
    ModelLightningBoltV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV66(const ModelLightningBoltV66 &p_other);
    ModelLightningBoltV66 &operator=(const ModelLightningBoltV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV66 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV66();
    ModelLightningNodeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV66(const ModelLightningNodeV66 &p_other);
    ModelLightningNodeV66 &operator=(const ModelLightningNodeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV66 {
    helpers::Array<ModelLightningSystemV66> systems;
    helpers::Array<ModelLightningBoltV66> bolts;
    helpers::Array<ModelLightningNodeV66> nodes;

public:
    ModelLightningDataV66();
    ModelLightningDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV66(const ModelLightningDataV66 &p_other);
    ModelLightningDataV66 &operator=(const ModelLightningDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV66 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV66();
    ModelSoftBodyDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV66(const ModelSoftBodyDataV66 &p_other);
    ModelSoftBodyDataV66 &operator=(const ModelSoftBodyDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV66 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV66();
    ModelBoneOffsetDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV66(const ModelBoneOffsetDataV66 &p_other);
    ModelBoneOffsetDataV66 &operator=(const ModelBoneOffsetDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV66 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV66();
    ModelBoundingSphereV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV66(const ModelBoundingSphereV66 &p_other);
    ModelBoundingSphereV66 &operator=(const ModelBoundingSphereV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV70 {
    helpers::Array<ModelPermutationDataV66> permutations;
    helpers::Ptr<ModelCloudDataV70> cloudData;
    helpers::Array<ModelObstacleDataV66> obstacles;
    helpers::Ptr<ModelStreakDataV66> streakData;
    helpers::Ptr<ModelLightDataV66> lightData;
    helpers::Array<ModelClothDataV66> clothData;
    helpers::Ptr<ModelWindDataV66> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV66> lightningData;
    helpers::Array<ModelSoftBodyDataV66> softBodyData;
    helpers::Array<ModelBoneOffsetDataV66> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV66> boundingSphere;

public:
    ModelFileDataV70();
    ModelFileDataV70(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV70(const ModelFileDataV70 &p_other);
    ModelFileDataV70 &operator=(const ModelFileDataV70 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV70 Gw2Struct;
};

/* Version: 69, ReferencedFunction: 0x410DC69000000001 */

template <>
struct Gw2StructMODL<69>{
struct ModelTextureDataV66 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV66();
    ModelTextureDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV66(const ModelTextureDataV66 &p_other);
    ModelTextureDataV66 &operator=(const ModelTextureDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV66 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV66();
    ModelConstantDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV66(const ModelConstantDataV66 &p_other);
    ModelConstantDataV66 &operator=(const ModelConstantDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV66 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV66();
    ModelMatConstLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV66(const ModelMatConstLinkV66 &p_other);
    ModelMatConstLinkV66 &operator=(const ModelMatConstLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV66 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV66();
    ModelUVTransLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV66(const ModelUVTransLinkV66 &p_other);
    ModelUVTransLinkV66 &operator=(const ModelUVTransLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV66 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV66();
    ModelMaterialTexTransformV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV66(const ModelMaterialTexTransformV66 &p_other);
    ModelMaterialTexTransformV66 &operator=(const ModelMaterialTexTransformV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV66 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV66> textures;
    helpers::Array<ModelConstantDataV66> constants;
    helpers::Array<ModelMatConstLinkV66> matConstLinks;
    helpers::Array<ModelUVTransLinkV66> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV66> texTransforms;
    byte texCoordCount;
    dword sortLayer;

public:
    ModelMaterialDataV66();
    ModelMaterialDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV66(const ModelMaterialDataV66 &p_other);
    ModelMaterialDataV66 &operator=(const ModelMaterialDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV66 {
    qword token;
    helpers::Ptr<ModelMaterialDataV66> materials;

public:
    ModelPermutationDataV66();
    ModelPermutationDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV66(const ModelPermutationDataV66 &p_other);
    ModelPermutationDataV66 &operator=(const ModelPermutationDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV66 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV66();
    ModelParticleCloudV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV66(const ModelParticleCloudV66 &p_other);
    ModelParticleCloudV66 &operator=(const ModelParticleCloudV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV66 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV66();
    ModelParticleCurveV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV66(const ModelParticleCurveV66 &p_other);
    ModelParticleCurveV66 &operator=(const ModelParticleCurveV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V66 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V66();
    ModelMatrix43V66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V66(const ModelMatrix43V66 &p_other);
    ModelMatrix43V66 &operator=(const ModelMatrix43V66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV66 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV66();
    ModelParticleFlipbookV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV66(const ModelParticleFlipbookV66 &p_other);
    ModelParticleFlipbookV66 &operator=(const ModelParticleFlipbookV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PlaneEmitterSettingsV69 {
    float3 alignmentDir;
    byte alignmentType;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float4 texCoordRect;

public:
    PlaneEmitterSettingsV69();
    PlaneEmitterSettingsV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PlaneEmitterSettingsV69(const PlaneEmitterSettingsV69 &p_other);
    PlaneEmitterSettingsV69 &operator=(const PlaneEmitterSettingsV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MeshEmitterSettingsV69 {
    dword alignment;
    float bankThreshold;
    float bankScale;
    helpers::FileName filename;
    float obstacleRadius;
    float2 rotation[3];
    float2 scaleChange[3];
    float2 scaleInitial[3];
    float2 spin[3];

public:
    MeshEmitterSettingsV69();
    MeshEmitterSettingsV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MeshEmitterSettingsV69(const MeshEmitterSettingsV69 &p_other);
    MeshEmitterSettingsV69 &operator=(const MeshEmitterSettingsV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV69 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV66> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    float2 lifetime;
    helpers::Ptr<ModelParticleCurveV66> scaleCurve;
    dword scaleCurvePreset;
    float drag;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    helpers::Ptr<ModelMatrix43V66> transform;
    byte windInfluence;
    byte spawnShape;
    helpers::Ptr<PlaneEmitterSettingsV69> planeEmitterSettings;
    helpers::Ptr<MeshEmitterSettingsV69> meshEmitterSettings;

public:
    ModelParticleEmitterV69();
    ModelParticleEmitterV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV69(const ModelParticleEmitterV69 &p_other);
    ModelParticleEmitterV69 &operator=(const ModelParticleEmitterV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV69 {
    helpers::Array<ModelParticleCloudV66> clouds;
    helpers::Array<ModelParticleEmitterV69> emitters;

public:
    ModelCloudDataV69();
    ModelCloudDataV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV69(const ModelCloudDataV69 &p_other);
    ModelCloudDataV69 &operator=(const ModelCloudDataV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV66 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V66> transform;

public:
    ModelObstacleDataV66();
    ModelObstacleDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV66(const ModelObstacleDataV66 &p_other);
    ModelObstacleDataV66 &operator=(const ModelObstacleDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV66 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV66();
    ModelStreakV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV66(const ModelStreakV66 &p_other);
    ModelStreakV66 &operator=(const ModelStreakV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV66 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV66();
    ModelStreakAnchorV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV66(const ModelStreakAnchorV66 &p_other);
    ModelStreakAnchorV66 &operator=(const ModelStreakAnchorV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV66 {
    helpers::Array<ModelStreakV66> streaks;
    helpers::Array<ModelStreakAnchorV66> anchors;

public:
    ModelStreakDataV66();
    ModelStreakDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV66(const ModelStreakDataV66 &p_other);
    ModelStreakDataV66 &operator=(const ModelStreakDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV66 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV66();
    ModelEffectLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV66(const ModelEffectLightV66 &p_other);
    ModelEffectLightV66 &operator=(const ModelEffectLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV66 {
    helpers::Array<ModelEffectLightV66> effectLights;

public:
    ModelLightDataV66();
    ModelLightDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV66(const ModelLightDataV66 &p_other);
    ModelLightDataV66 &operator=(const ModelLightDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV66 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV66();
    ModelClothBoneWeightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV66(const ModelClothBoneWeightV66 &p_other);
    ModelClothBoneWeightV66 &operator=(const ModelClothBoneWeightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV66 {
    helpers::Array<ModelClothBoneWeightV66> weights;

public:
    ModelClothMeshGroupV66();
    ModelClothMeshGroupV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV66(const ModelClothMeshGroupV66 &p_other);
    ModelClothMeshGroupV66 &operator=(const ModelClothMeshGroupV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV66 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV66();
    ModelClothGroupBindingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV66(const ModelClothGroupBindingV66 &p_other);
    ModelClothGroupBindingV66 &operator=(const ModelClothGroupBindingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV66 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV66();
    ModelClothSoftLockV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV66(const ModelClothSoftLockV66 &p_other);
    ModelClothSoftLockV66 &operator=(const ModelClothSoftLockV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV66 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV66();
    ModelClothConstraintV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV66(const ModelClothConstraintV66 &p_other);
    ModelClothConstraintV66 &operator=(const ModelClothConstraintV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV66 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV66> groups;
    helpers::Array<ModelClothGroupBindingV66> groupBindings;
    helpers::Array<ModelClothSoftLockV66> softLocks;
    helpers::Array<ModelClothConstraintV66> lod0Constraints;
    helpers::Array<ModelClothConstraintV66> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV66();
    ModelClothDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV66(const ModelClothDataV66 &p_other);
    ModelClothDataV66 &operator=(const ModelClothDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV66 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV66();
    ModelEffectWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV66(const ModelEffectWindV66 &p_other);
    ModelEffectWindV66 &operator=(const ModelEffectWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV66 {
    helpers::Array<ModelEffectWindV66> effectWind;

public:
    ModelWindDataV66();
    ModelWindDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV66(const ModelWindDataV66 &p_other);
    ModelWindDataV66 &operator=(const ModelWindDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV66 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV66();
    ModelLightningSystemV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV66(const ModelLightningSystemV66 &p_other);
    ModelLightningSystemV66 &operator=(const ModelLightningSystemV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV66 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV66();
    ModelLightningBoltV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV66(const ModelLightningBoltV66 &p_other);
    ModelLightningBoltV66 &operator=(const ModelLightningBoltV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV66 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV66();
    ModelLightningNodeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV66(const ModelLightningNodeV66 &p_other);
    ModelLightningNodeV66 &operator=(const ModelLightningNodeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV66 {
    helpers::Array<ModelLightningSystemV66> systems;
    helpers::Array<ModelLightningBoltV66> bolts;
    helpers::Array<ModelLightningNodeV66> nodes;

public:
    ModelLightningDataV66();
    ModelLightningDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV66(const ModelLightningDataV66 &p_other);
    ModelLightningDataV66 &operator=(const ModelLightningDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV66 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV66();
    ModelSoftBodyDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV66(const ModelSoftBodyDataV66 &p_other);
    ModelSoftBodyDataV66 &operator=(const ModelSoftBodyDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV66 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV66();
    ModelBoneOffsetDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV66(const ModelBoneOffsetDataV66 &p_other);
    ModelBoneOffsetDataV66 &operator=(const ModelBoneOffsetDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV66 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV66();
    ModelBoundingSphereV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV66(const ModelBoundingSphereV66 &p_other);
    ModelBoundingSphereV66 &operator=(const ModelBoundingSphereV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV69 {
    helpers::Array<ModelPermutationDataV66> permutations;
    helpers::Ptr<ModelCloudDataV69> cloudData;
    helpers::Array<ModelObstacleDataV66> obstacles;
    helpers::Ptr<ModelStreakDataV66> streakData;
    helpers::Ptr<ModelLightDataV66> lightData;
    helpers::Array<ModelClothDataV66> clothData;
    helpers::Ptr<ModelWindDataV66> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV66> lightningData;
    helpers::Array<ModelSoftBodyDataV66> softBodyData;
    helpers::Array<ModelBoneOffsetDataV66> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV66> boundingSphere;

public:
    ModelFileDataV69();
    ModelFileDataV69(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV69(const ModelFileDataV69 &p_other);
    ModelFileDataV69 &operator=(const ModelFileDataV69 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV69 Gw2Struct;
};

/* Version: 68, ReferencedFunction: 0x410DC50000000001 */

template <>
struct Gw2StructMODL<68>{
struct ModelTextureDataV66 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV66();
    ModelTextureDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV66(const ModelTextureDataV66 &p_other);
    ModelTextureDataV66 &operator=(const ModelTextureDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV66 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV66();
    ModelConstantDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV66(const ModelConstantDataV66 &p_other);
    ModelConstantDataV66 &operator=(const ModelConstantDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV66 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV66();
    ModelMatConstLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV66(const ModelMatConstLinkV66 &p_other);
    ModelMatConstLinkV66 &operator=(const ModelMatConstLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV66 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV66();
    ModelUVTransLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV66(const ModelUVTransLinkV66 &p_other);
    ModelUVTransLinkV66 &operator=(const ModelUVTransLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV66 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV66();
    ModelMaterialTexTransformV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV66(const ModelMaterialTexTransformV66 &p_other);
    ModelMaterialTexTransformV66 &operator=(const ModelMaterialTexTransformV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV66 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV66> textures;
    helpers::Array<ModelConstantDataV66> constants;
    helpers::Array<ModelMatConstLinkV66> matConstLinks;
    helpers::Array<ModelUVTransLinkV66> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV66> texTransforms;
    byte texCoordCount;
    dword sortLayer;

public:
    ModelMaterialDataV66();
    ModelMaterialDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV66(const ModelMaterialDataV66 &p_other);
    ModelMaterialDataV66 &operator=(const ModelMaterialDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV66 {
    qword token;
    helpers::Ptr<ModelMaterialDataV66> materials;

public:
    ModelPermutationDataV66();
    ModelPermutationDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV66(const ModelPermutationDataV66 &p_other);
    ModelPermutationDataV66 &operator=(const ModelPermutationDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV66 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV66();
    ModelParticleCloudV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV66(const ModelParticleCloudV66 &p_other);
    ModelParticleCloudV66 &operator=(const ModelParticleCloudV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV66 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV66();
    ModelParticleCurveV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV66(const ModelParticleCurveV66 &p_other);
    ModelParticleCurveV66 &operator=(const ModelParticleCurveV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V66 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V66();
    ModelMatrix43V66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V66(const ModelMatrix43V66 &p_other);
    ModelMatrix43V66 &operator=(const ModelMatrix43V66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV66 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV66();
    ModelParticleFlipbookV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV66(const ModelParticleFlipbookV66 &p_other);
    ModelParticleFlipbookV66 &operator=(const ModelParticleFlipbookV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PlaneEmitterSettingsV67 {
    float3 alignmentDir;
    byte alignmentType;
    float drag;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float4 texCoordRect;

public:
    PlaneEmitterSettingsV67();
    PlaneEmitterSettingsV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PlaneEmitterSettingsV67(const PlaneEmitterSettingsV67 &p_other);
    PlaneEmitterSettingsV67 &operator=(const PlaneEmitterSettingsV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MeshEmitterSettingsV68 {
    dword alignment;
    float bankThreshold;
    float bankScale;
    float2 drag[3];
    helpers::FileName filename;
    float obstacleRadius;
    float2 rotation[3];
    dword rotationSpace;
    float2 scaleChange[3];
    float2 scaleInitial[3];
    float2 spin[3];

public:
    MeshEmitterSettingsV68();
    MeshEmitterSettingsV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MeshEmitterSettingsV68(const MeshEmitterSettingsV68 &p_other);
    MeshEmitterSettingsV68 &operator=(const MeshEmitterSettingsV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV68 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV66> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    float2 lifetime;
    helpers::Ptr<ModelParticleCurveV66> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    helpers::Ptr<ModelMatrix43V66> transform;
    byte windInfluence;
    byte spawnShape;
    helpers::Ptr<PlaneEmitterSettingsV67> planeEmitterSettings;
    helpers::Ptr<MeshEmitterSettingsV68> meshEmitterSettings;

public:
    ModelParticleEmitterV68();
    ModelParticleEmitterV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV68(const ModelParticleEmitterV68 &p_other);
    ModelParticleEmitterV68 &operator=(const ModelParticleEmitterV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV68 {
    helpers::Array<ModelParticleCloudV66> clouds;
    helpers::Array<ModelParticleEmitterV68> emitters;

public:
    ModelCloudDataV68();
    ModelCloudDataV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV68(const ModelCloudDataV68 &p_other);
    ModelCloudDataV68 &operator=(const ModelCloudDataV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV66 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V66> transform;

public:
    ModelObstacleDataV66();
    ModelObstacleDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV66(const ModelObstacleDataV66 &p_other);
    ModelObstacleDataV66 &operator=(const ModelObstacleDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV66 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV66();
    ModelStreakV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV66(const ModelStreakV66 &p_other);
    ModelStreakV66 &operator=(const ModelStreakV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV66 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV66();
    ModelStreakAnchorV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV66(const ModelStreakAnchorV66 &p_other);
    ModelStreakAnchorV66 &operator=(const ModelStreakAnchorV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV66 {
    helpers::Array<ModelStreakV66> streaks;
    helpers::Array<ModelStreakAnchorV66> anchors;

public:
    ModelStreakDataV66();
    ModelStreakDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV66(const ModelStreakDataV66 &p_other);
    ModelStreakDataV66 &operator=(const ModelStreakDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV66 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV66();
    ModelEffectLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV66(const ModelEffectLightV66 &p_other);
    ModelEffectLightV66 &operator=(const ModelEffectLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV66 {
    helpers::Array<ModelEffectLightV66> effectLights;

public:
    ModelLightDataV66();
    ModelLightDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV66(const ModelLightDataV66 &p_other);
    ModelLightDataV66 &operator=(const ModelLightDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV66 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV66();
    ModelClothBoneWeightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV66(const ModelClothBoneWeightV66 &p_other);
    ModelClothBoneWeightV66 &operator=(const ModelClothBoneWeightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV66 {
    helpers::Array<ModelClothBoneWeightV66> weights;

public:
    ModelClothMeshGroupV66();
    ModelClothMeshGroupV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV66(const ModelClothMeshGroupV66 &p_other);
    ModelClothMeshGroupV66 &operator=(const ModelClothMeshGroupV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV66 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV66();
    ModelClothGroupBindingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV66(const ModelClothGroupBindingV66 &p_other);
    ModelClothGroupBindingV66 &operator=(const ModelClothGroupBindingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV66 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV66();
    ModelClothSoftLockV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV66(const ModelClothSoftLockV66 &p_other);
    ModelClothSoftLockV66 &operator=(const ModelClothSoftLockV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV66 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV66();
    ModelClothConstraintV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV66(const ModelClothConstraintV66 &p_other);
    ModelClothConstraintV66 &operator=(const ModelClothConstraintV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV66 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV66> groups;
    helpers::Array<ModelClothGroupBindingV66> groupBindings;
    helpers::Array<ModelClothSoftLockV66> softLocks;
    helpers::Array<ModelClothConstraintV66> lod0Constraints;
    helpers::Array<ModelClothConstraintV66> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV66();
    ModelClothDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV66(const ModelClothDataV66 &p_other);
    ModelClothDataV66 &operator=(const ModelClothDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV66 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV66();
    ModelEffectWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV66(const ModelEffectWindV66 &p_other);
    ModelEffectWindV66 &operator=(const ModelEffectWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV66 {
    helpers::Array<ModelEffectWindV66> effectWind;

public:
    ModelWindDataV66();
    ModelWindDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV66(const ModelWindDataV66 &p_other);
    ModelWindDataV66 &operator=(const ModelWindDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV66 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV66();
    ModelLightningSystemV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV66(const ModelLightningSystemV66 &p_other);
    ModelLightningSystemV66 &operator=(const ModelLightningSystemV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV66 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV66();
    ModelLightningBoltV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV66(const ModelLightningBoltV66 &p_other);
    ModelLightningBoltV66 &operator=(const ModelLightningBoltV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV66 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV66();
    ModelLightningNodeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV66(const ModelLightningNodeV66 &p_other);
    ModelLightningNodeV66 &operator=(const ModelLightningNodeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV66 {
    helpers::Array<ModelLightningSystemV66> systems;
    helpers::Array<ModelLightningBoltV66> bolts;
    helpers::Array<ModelLightningNodeV66> nodes;

public:
    ModelLightningDataV66();
    ModelLightningDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV66(const ModelLightningDataV66 &p_other);
    ModelLightningDataV66 &operator=(const ModelLightningDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV66 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV66();
    ModelSoftBodyDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV66(const ModelSoftBodyDataV66 &p_other);
    ModelSoftBodyDataV66 &operator=(const ModelSoftBodyDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV66 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV66();
    ModelBoneOffsetDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV66(const ModelBoneOffsetDataV66 &p_other);
    ModelBoneOffsetDataV66 &operator=(const ModelBoneOffsetDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV66 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV66();
    ModelBoundingSphereV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV66(const ModelBoundingSphereV66 &p_other);
    ModelBoundingSphereV66 &operator=(const ModelBoundingSphereV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV68 {
    helpers::Array<ModelPermutationDataV66> permutations;
    helpers::Ptr<ModelCloudDataV68> cloudData;
    helpers::Array<ModelObstacleDataV66> obstacles;
    helpers::Ptr<ModelStreakDataV66> streakData;
    helpers::Ptr<ModelLightDataV66> lightData;
    helpers::Array<ModelClothDataV66> clothData;
    helpers::Ptr<ModelWindDataV66> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV66> lightningData;
    helpers::Array<ModelSoftBodyDataV66> softBodyData;
    helpers::Array<ModelBoneOffsetDataV66> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV66> boundingSphere;

public:
    ModelFileDataV68();
    ModelFileDataV68(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV68(const ModelFileDataV68 &p_other);
    ModelFileDataV68 &operator=(const ModelFileDataV68 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV68 Gw2Struct;
};

/* Version: 67, ReferencedFunction: 0x410DC39000000001 */

template <>
struct Gw2StructMODL<67>{
struct ModelTextureDataV66 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV66();
    ModelTextureDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV66(const ModelTextureDataV66 &p_other);
    ModelTextureDataV66 &operator=(const ModelTextureDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV66 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV66();
    ModelConstantDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV66(const ModelConstantDataV66 &p_other);
    ModelConstantDataV66 &operator=(const ModelConstantDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV66 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV66();
    ModelMatConstLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV66(const ModelMatConstLinkV66 &p_other);
    ModelMatConstLinkV66 &operator=(const ModelMatConstLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV66 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV66();
    ModelUVTransLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV66(const ModelUVTransLinkV66 &p_other);
    ModelUVTransLinkV66 &operator=(const ModelUVTransLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV66 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV66();
    ModelMaterialTexTransformV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV66(const ModelMaterialTexTransformV66 &p_other);
    ModelMaterialTexTransformV66 &operator=(const ModelMaterialTexTransformV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV66 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV66> textures;
    helpers::Array<ModelConstantDataV66> constants;
    helpers::Array<ModelMatConstLinkV66> matConstLinks;
    helpers::Array<ModelUVTransLinkV66> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV66> texTransforms;
    byte texCoordCount;
    dword sortLayer;

public:
    ModelMaterialDataV66();
    ModelMaterialDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV66(const ModelMaterialDataV66 &p_other);
    ModelMaterialDataV66 &operator=(const ModelMaterialDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV66 {
    qword token;
    helpers::Ptr<ModelMaterialDataV66> materials;

public:
    ModelPermutationDataV66();
    ModelPermutationDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV66(const ModelPermutationDataV66 &p_other);
    ModelPermutationDataV66 &operator=(const ModelPermutationDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV66 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV66();
    ModelParticleCloudV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV66(const ModelParticleCloudV66 &p_other);
    ModelParticleCloudV66 &operator=(const ModelParticleCloudV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV66 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV66();
    ModelParticleCurveV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV66(const ModelParticleCurveV66 &p_other);
    ModelParticleCurveV66 &operator=(const ModelParticleCurveV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V66 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V66();
    ModelMatrix43V66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V66(const ModelMatrix43V66 &p_other);
    ModelMatrix43V66 &operator=(const ModelMatrix43V66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV66 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV66();
    ModelParticleFlipbookV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV66(const ModelParticleFlipbookV66 &p_other);
    ModelParticleFlipbookV66 &operator=(const ModelParticleFlipbookV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PlaneEmitterSettingsV67 {
    float3 alignmentDir;
    byte alignmentType;
    float drag;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float4 texCoordRect;

public:
    PlaneEmitterSettingsV67();
    PlaneEmitterSettingsV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PlaneEmitterSettingsV67(const PlaneEmitterSettingsV67 &p_other);
    PlaneEmitterSettingsV67 &operator=(const PlaneEmitterSettingsV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct MeshEmitterSettingsV67 {
    dword alignment;
    float bankThreshold;
    float bankScale;
    float2 drag[3];
    helpers::FileName filename;
    float obstacleRadius;
    float3 rotationMin;
    float3 rotationMax;
    dword rotationSpace;
    float2 scaleChange[3];
    float2 scaleInitial[3];
    float3 spinMin;
    float3 spinMax;

public:
    MeshEmitterSettingsV67();
    MeshEmitterSettingsV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    MeshEmitterSettingsV67(const MeshEmitterSettingsV67 &p_other);
    MeshEmitterSettingsV67 &operator=(const MeshEmitterSettingsV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV67 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV66> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    float2 lifetime;
    helpers::Ptr<ModelParticleCurveV66> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    helpers::Ptr<ModelMatrix43V66> transform;
    byte windInfluence;
    byte spawnShape;
    helpers::Ptr<PlaneEmitterSettingsV67> planeEmitterSettings;
    helpers::Ptr<MeshEmitterSettingsV67> meshEmitterSettings;

public:
    ModelParticleEmitterV67();
    ModelParticleEmitterV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV67(const ModelParticleEmitterV67 &p_other);
    ModelParticleEmitterV67 &operator=(const ModelParticleEmitterV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV67 {
    helpers::Array<ModelParticleCloudV66> clouds;
    helpers::Array<ModelParticleEmitterV67> emitters;

public:
    ModelCloudDataV67();
    ModelCloudDataV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV67(const ModelCloudDataV67 &p_other);
    ModelCloudDataV67 &operator=(const ModelCloudDataV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV66 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V66> transform;

public:
    ModelObstacleDataV66();
    ModelObstacleDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV66(const ModelObstacleDataV66 &p_other);
    ModelObstacleDataV66 &operator=(const ModelObstacleDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV66 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV66();
    ModelStreakV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV66(const ModelStreakV66 &p_other);
    ModelStreakV66 &operator=(const ModelStreakV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV66 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV66();
    ModelStreakAnchorV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV66(const ModelStreakAnchorV66 &p_other);
    ModelStreakAnchorV66 &operator=(const ModelStreakAnchorV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV66 {
    helpers::Array<ModelStreakV66> streaks;
    helpers::Array<ModelStreakAnchorV66> anchors;

public:
    ModelStreakDataV66();
    ModelStreakDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV66(const ModelStreakDataV66 &p_other);
    ModelStreakDataV66 &operator=(const ModelStreakDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV66 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV66();
    ModelEffectLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV66(const ModelEffectLightV66 &p_other);
    ModelEffectLightV66 &operator=(const ModelEffectLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV66 {
    helpers::Array<ModelEffectLightV66> effectLights;

public:
    ModelLightDataV66();
    ModelLightDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV66(const ModelLightDataV66 &p_other);
    ModelLightDataV66 &operator=(const ModelLightDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV66 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV66();
    ModelClothBoneWeightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV66(const ModelClothBoneWeightV66 &p_other);
    ModelClothBoneWeightV66 &operator=(const ModelClothBoneWeightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV66 {
    helpers::Array<ModelClothBoneWeightV66> weights;

public:
    ModelClothMeshGroupV66();
    ModelClothMeshGroupV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV66(const ModelClothMeshGroupV66 &p_other);
    ModelClothMeshGroupV66 &operator=(const ModelClothMeshGroupV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV66 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV66();
    ModelClothGroupBindingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV66(const ModelClothGroupBindingV66 &p_other);
    ModelClothGroupBindingV66 &operator=(const ModelClothGroupBindingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV66 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV66();
    ModelClothSoftLockV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV66(const ModelClothSoftLockV66 &p_other);
    ModelClothSoftLockV66 &operator=(const ModelClothSoftLockV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV66 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV66();
    ModelClothConstraintV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV66(const ModelClothConstraintV66 &p_other);
    ModelClothConstraintV66 &operator=(const ModelClothConstraintV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV66 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV66> groups;
    helpers::Array<ModelClothGroupBindingV66> groupBindings;
    helpers::Array<ModelClothSoftLockV66> softLocks;
    helpers::Array<ModelClothConstraintV66> lod0Constraints;
    helpers::Array<ModelClothConstraintV66> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV66();
    ModelClothDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV66(const ModelClothDataV66 &p_other);
    ModelClothDataV66 &operator=(const ModelClothDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV66 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV66();
    ModelEffectWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV66(const ModelEffectWindV66 &p_other);
    ModelEffectWindV66 &operator=(const ModelEffectWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV66 {
    helpers::Array<ModelEffectWindV66> effectWind;

public:
    ModelWindDataV66();
    ModelWindDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV66(const ModelWindDataV66 &p_other);
    ModelWindDataV66 &operator=(const ModelWindDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV66 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV66();
    ModelLightningSystemV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV66(const ModelLightningSystemV66 &p_other);
    ModelLightningSystemV66 &operator=(const ModelLightningSystemV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV66 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV66();
    ModelLightningBoltV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV66(const ModelLightningBoltV66 &p_other);
    ModelLightningBoltV66 &operator=(const ModelLightningBoltV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV66 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV66();
    ModelLightningNodeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV66(const ModelLightningNodeV66 &p_other);
    ModelLightningNodeV66 &operator=(const ModelLightningNodeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV66 {
    helpers::Array<ModelLightningSystemV66> systems;
    helpers::Array<ModelLightningBoltV66> bolts;
    helpers::Array<ModelLightningNodeV66> nodes;

public:
    ModelLightningDataV66();
    ModelLightningDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV66(const ModelLightningDataV66 &p_other);
    ModelLightningDataV66 &operator=(const ModelLightningDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV66 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV66();
    ModelSoftBodyDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV66(const ModelSoftBodyDataV66 &p_other);
    ModelSoftBodyDataV66 &operator=(const ModelSoftBodyDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV66 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV66();
    ModelBoneOffsetDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV66(const ModelBoneOffsetDataV66 &p_other);
    ModelBoneOffsetDataV66 &operator=(const ModelBoneOffsetDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV66 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV66();
    ModelBoundingSphereV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV66(const ModelBoundingSphereV66 &p_other);
    ModelBoundingSphereV66 &operator=(const ModelBoundingSphereV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV67 {
    helpers::Array<ModelPermutationDataV66> permutations;
    helpers::Ptr<ModelCloudDataV67> cloudData;
    helpers::Array<ModelObstacleDataV66> obstacles;
    helpers::Ptr<ModelStreakDataV66> streakData;
    helpers::Ptr<ModelLightDataV66> lightData;
    helpers::Array<ModelClothDataV66> clothData;
    helpers::Ptr<ModelWindDataV66> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV66> lightningData;
    helpers::Array<ModelSoftBodyDataV66> softBodyData;
    helpers::Array<ModelBoneOffsetDataV66> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV66> boundingSphere;

public:
    ModelFileDataV67();
    ModelFileDataV67(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV67(const ModelFileDataV67 &p_other);
    ModelFileDataV67 &operator=(const ModelFileDataV67 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV67 Gw2Struct;
};

/* Version: 66, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<66>{
struct ModelTextureDataV66 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV66();
    ModelTextureDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV66(const ModelTextureDataV66 &p_other);
    ModelTextureDataV66 &operator=(const ModelTextureDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV66 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV66();
    ModelConstantDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV66(const ModelConstantDataV66 &p_other);
    ModelConstantDataV66 &operator=(const ModelConstantDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV66 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV66();
    ModelMatConstLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV66(const ModelMatConstLinkV66 &p_other);
    ModelMatConstLinkV66 &operator=(const ModelMatConstLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV66 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV66();
    ModelUVTransLinkV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV66(const ModelUVTransLinkV66 &p_other);
    ModelUVTransLinkV66 &operator=(const ModelUVTransLinkV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV66 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV66();
    ModelMaterialTexTransformV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV66(const ModelMaterialTexTransformV66 &p_other);
    ModelMaterialTexTransformV66 &operator=(const ModelMaterialTexTransformV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV66 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV66> textures;
    helpers::Array<ModelConstantDataV66> constants;
    helpers::Array<ModelMatConstLinkV66> matConstLinks;
    helpers::Array<ModelUVTransLinkV66> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV66> texTransforms;
    byte texCoordCount;
    dword sortLayer;

public:
    ModelMaterialDataV66();
    ModelMaterialDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV66(const ModelMaterialDataV66 &p_other);
    ModelMaterialDataV66 &operator=(const ModelMaterialDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV66 {
    qword token;
    helpers::Ptr<ModelMaterialDataV66> materials;

public:
    ModelPermutationDataV66();
    ModelPermutationDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV66(const ModelPermutationDataV66 &p_other);
    ModelPermutationDataV66 &operator=(const ModelPermutationDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV66 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV66();
    ModelParticleCloudV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV66(const ModelParticleCloudV66 &p_other);
    ModelParticleCloudV66 &operator=(const ModelParticleCloudV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV66 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV66();
    ModelParticleCurveV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV66(const ModelParticleCurveV66 &p_other);
    ModelParticleCurveV66 &operator=(const ModelParticleCurveV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV66 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV66();
    ModelParticleFlipbookV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV66(const ModelParticleFlipbookV66 &p_other);
    ModelParticleFlipbookV66 &operator=(const ModelParticleFlipbookV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V66 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V66();
    ModelMatrix43V66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V66(const ModelMatrix43V66 &p_other);
    ModelMatrix43V66 &operator=(const ModelMatrix43V66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV66 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV66> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV66> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V66> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV66();
    ModelParticleEmitterV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV66(const ModelParticleEmitterV66 &p_other);
    ModelParticleEmitterV66 &operator=(const ModelParticleEmitterV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV66 {
    helpers::Array<ModelParticleCloudV66> clouds;
    helpers::Array<ModelParticleEmitterV66> emitters;

public:
    ModelCloudDataV66();
    ModelCloudDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV66(const ModelCloudDataV66 &p_other);
    ModelCloudDataV66 &operator=(const ModelCloudDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV66 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V66> transform;

public:
    ModelObstacleDataV66();
    ModelObstacleDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV66(const ModelObstacleDataV66 &p_other);
    ModelObstacleDataV66 &operator=(const ModelObstacleDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV66 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV66();
    ModelStreakV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV66(const ModelStreakV66 &p_other);
    ModelStreakV66 &operator=(const ModelStreakV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV66 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV66();
    ModelStreakAnchorV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV66(const ModelStreakAnchorV66 &p_other);
    ModelStreakAnchorV66 &operator=(const ModelStreakAnchorV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV66 {
    helpers::Array<ModelStreakV66> streaks;
    helpers::Array<ModelStreakAnchorV66> anchors;

public:
    ModelStreakDataV66();
    ModelStreakDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV66(const ModelStreakDataV66 &p_other);
    ModelStreakDataV66 &operator=(const ModelStreakDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV66 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV66();
    ModelEffectLightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV66(const ModelEffectLightV66 &p_other);
    ModelEffectLightV66 &operator=(const ModelEffectLightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV66 {
    helpers::Array<ModelEffectLightV66> effectLights;

public:
    ModelLightDataV66();
    ModelLightDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV66(const ModelLightDataV66 &p_other);
    ModelLightDataV66 &operator=(const ModelLightDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV66 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV66();
    ModelClothBoneWeightV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV66(const ModelClothBoneWeightV66 &p_other);
    ModelClothBoneWeightV66 &operator=(const ModelClothBoneWeightV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV66 {
    helpers::Array<ModelClothBoneWeightV66> weights;

public:
    ModelClothMeshGroupV66();
    ModelClothMeshGroupV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV66(const ModelClothMeshGroupV66 &p_other);
    ModelClothMeshGroupV66 &operator=(const ModelClothMeshGroupV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV66 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV66();
    ModelClothGroupBindingV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV66(const ModelClothGroupBindingV66 &p_other);
    ModelClothGroupBindingV66 &operator=(const ModelClothGroupBindingV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV66 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV66();
    ModelClothSoftLockV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV66(const ModelClothSoftLockV66 &p_other);
    ModelClothSoftLockV66 &operator=(const ModelClothSoftLockV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV66 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV66();
    ModelClothConstraintV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV66(const ModelClothConstraintV66 &p_other);
    ModelClothConstraintV66 &operator=(const ModelClothConstraintV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV66 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV66> groups;
    helpers::Array<ModelClothGroupBindingV66> groupBindings;
    helpers::Array<ModelClothSoftLockV66> softLocks;
    helpers::Array<ModelClothConstraintV66> lod0Constraints;
    helpers::Array<ModelClothConstraintV66> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV66();
    ModelClothDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV66(const ModelClothDataV66 &p_other);
    ModelClothDataV66 &operator=(const ModelClothDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV66 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV66();
    ModelEffectWindV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV66(const ModelEffectWindV66 &p_other);
    ModelEffectWindV66 &operator=(const ModelEffectWindV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV66 {
    helpers::Array<ModelEffectWindV66> effectWind;

public:
    ModelWindDataV66();
    ModelWindDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV66(const ModelWindDataV66 &p_other);
    ModelWindDataV66 &operator=(const ModelWindDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV66 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV66();
    ModelLightningSystemV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV66(const ModelLightningSystemV66 &p_other);
    ModelLightningSystemV66 &operator=(const ModelLightningSystemV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV66 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV66> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV66();
    ModelLightningBoltV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV66(const ModelLightningBoltV66 &p_other);
    ModelLightningBoltV66 &operator=(const ModelLightningBoltV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV66 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV66();
    ModelLightningNodeV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV66(const ModelLightningNodeV66 &p_other);
    ModelLightningNodeV66 &operator=(const ModelLightningNodeV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV66 {
    helpers::Array<ModelLightningSystemV66> systems;
    helpers::Array<ModelLightningBoltV66> bolts;
    helpers::Array<ModelLightningNodeV66> nodes;

public:
    ModelLightningDataV66();
    ModelLightningDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV66(const ModelLightningDataV66 &p_other);
    ModelLightningDataV66 &operator=(const ModelLightningDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV66 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV66();
    ModelSoftBodyDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV66(const ModelSoftBodyDataV66 &p_other);
    ModelSoftBodyDataV66 &operator=(const ModelSoftBodyDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV66 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV66();
    ModelBoneOffsetDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV66(const ModelBoneOffsetDataV66 &p_other);
    ModelBoneOffsetDataV66 &operator=(const ModelBoneOffsetDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV66 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV66();
    ModelBoundingSphereV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV66(const ModelBoundingSphereV66 &p_other);
    ModelBoundingSphereV66 &operator=(const ModelBoundingSphereV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV66 {
    helpers::Array<ModelPermutationDataV66> permutations;
    helpers::Ptr<ModelCloudDataV66> cloudData;
    helpers::Array<ModelObstacleDataV66> obstacles;
    helpers::Ptr<ModelStreakDataV66> streakData;
    helpers::Ptr<ModelLightDataV66> lightData;
    helpers::Array<ModelClothDataV66> clothData;
    helpers::Ptr<ModelWindDataV66> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV66> lightningData;
    helpers::Array<ModelSoftBodyDataV66> softBodyData;
    helpers::Array<ModelBoneOffsetDataV66> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV66> boundingSphere;

public:
    ModelFileDataV66();
    ModelFileDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV66(const ModelFileDataV66 &p_other);
    ModelFileDataV66 &operator=(const ModelFileDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV66 Gw2Struct;
};

/* Version: 65, ReferencedFunction: 0x410DC05000000001 */

template <>
struct Gw2StructMODL<65>{
struct ModelTextureDataV65 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV65();
    ModelTextureDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV65(const ModelTextureDataV65 &p_other);
    ModelTextureDataV65 &operator=(const ModelTextureDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV65 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV65();
    ModelConstantDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV65(const ModelConstantDataV65 &p_other);
    ModelConstantDataV65 &operator=(const ModelConstantDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV65 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV65();
    ModelMatConstLinkV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV65(const ModelMatConstLinkV65 &p_other);
    ModelMatConstLinkV65 &operator=(const ModelMatConstLinkV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV65 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV65();
    ModelUVTransLinkV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV65(const ModelUVTransLinkV65 &p_other);
    ModelUVTransLinkV65 &operator=(const ModelUVTransLinkV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV65 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV65();
    ModelMaterialTexTransformV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV65(const ModelMaterialTexTransformV65 &p_other);
    ModelMaterialTexTransformV65 &operator=(const ModelMaterialTexTransformV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV65 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV65> textures;
    helpers::Array<ModelConstantDataV65> constants;
    helpers::Array<ModelMatConstLinkV65> matConstLinks;
    helpers::Array<ModelUVTransLinkV65> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV65> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV65();
    ModelMaterialDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV65(const ModelMaterialDataV65 &p_other);
    ModelMaterialDataV65 &operator=(const ModelMaterialDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV65 {
    qword token;
    helpers::Ptr<ModelMaterialDataV65> materials;

public:
    ModelPermutationDataV65();
    ModelPermutationDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV65(const ModelPermutationDataV65 &p_other);
    ModelPermutationDataV65 &operator=(const ModelPermutationDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV65 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV65();
    ModelParticleCloudV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV65(const ModelParticleCloudV65 &p_other);
    ModelParticleCloudV65 &operator=(const ModelParticleCloudV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV65 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV65();
    ModelParticleCurveV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV65(const ModelParticleCurveV65 &p_other);
    ModelParticleCurveV65 &operator=(const ModelParticleCurveV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV65 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV65();
    ModelParticleFlipbookV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV65(const ModelParticleFlipbookV65 &p_other);
    ModelParticleFlipbookV65 &operator=(const ModelParticleFlipbookV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V65 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V65();
    ModelMatrix43V65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V65(const ModelMatrix43V65 &p_other);
    ModelMatrix43V65 &operator=(const ModelMatrix43V65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV65 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV65> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV65> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV65> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V65> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV65();
    ModelParticleEmitterV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV65(const ModelParticleEmitterV65 &p_other);
    ModelParticleEmitterV65 &operator=(const ModelParticleEmitterV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV65 {
    helpers::Array<ModelParticleCloudV65> clouds;
    helpers::Array<ModelParticleEmitterV65> emitters;

public:
    ModelCloudDataV65();
    ModelCloudDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV65(const ModelCloudDataV65 &p_other);
    ModelCloudDataV65 &operator=(const ModelCloudDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV65 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V65> transform;

public:
    ModelObstacleDataV65();
    ModelObstacleDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV65(const ModelObstacleDataV65 &p_other);
    ModelObstacleDataV65 &operator=(const ModelObstacleDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV65 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV65();
    ModelStreakV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV65(const ModelStreakV65 &p_other);
    ModelStreakV65 &operator=(const ModelStreakV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV65 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV65();
    ModelStreakAnchorV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV65(const ModelStreakAnchorV65 &p_other);
    ModelStreakAnchorV65 &operator=(const ModelStreakAnchorV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV65 {
    helpers::Array<ModelStreakV65> streaks;
    helpers::Array<ModelStreakAnchorV65> anchors;

public:
    ModelStreakDataV65();
    ModelStreakDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV65(const ModelStreakDataV65 &p_other);
    ModelStreakDataV65 &operator=(const ModelStreakDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV65 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV65();
    ModelEffectLightV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV65(const ModelEffectLightV65 &p_other);
    ModelEffectLightV65 &operator=(const ModelEffectLightV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV65 {
    helpers::Array<ModelEffectLightV65> effectLights;

public:
    ModelLightDataV65();
    ModelLightDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV65(const ModelLightDataV65 &p_other);
    ModelLightDataV65 &operator=(const ModelLightDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV65 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV65();
    ModelClothBoneWeightV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV65(const ModelClothBoneWeightV65 &p_other);
    ModelClothBoneWeightV65 &operator=(const ModelClothBoneWeightV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV65 {
    helpers::Array<ModelClothBoneWeightV65> weights;

public:
    ModelClothMeshGroupV65();
    ModelClothMeshGroupV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV65(const ModelClothMeshGroupV65 &p_other);
    ModelClothMeshGroupV65 &operator=(const ModelClothMeshGroupV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV65 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV65();
    ModelClothGroupBindingV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV65(const ModelClothGroupBindingV65 &p_other);
    ModelClothGroupBindingV65 &operator=(const ModelClothGroupBindingV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV65 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV65();
    ModelClothSoftLockV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV65(const ModelClothSoftLockV65 &p_other);
    ModelClothSoftLockV65 &operator=(const ModelClothSoftLockV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV65 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV65();
    ModelClothConstraintV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV65(const ModelClothConstraintV65 &p_other);
    ModelClothConstraintV65 &operator=(const ModelClothConstraintV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV65 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV65> groups;
    helpers::Array<ModelClothGroupBindingV65> groupBindings;
    helpers::Array<ModelClothSoftLockV65> softLocks;
    helpers::Array<ModelClothConstraintV65> lod0Constraints;
    helpers::Array<ModelClothConstraintV65> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV65();
    ModelClothDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV65(const ModelClothDataV65 &p_other);
    ModelClothDataV65 &operator=(const ModelClothDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV65 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV65();
    ModelEffectWindV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV65(const ModelEffectWindV65 &p_other);
    ModelEffectWindV65 &operator=(const ModelEffectWindV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV65 {
    helpers::Array<ModelEffectWindV65> effectWind;

public:
    ModelWindDataV65();
    ModelWindDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV65(const ModelWindDataV65 &p_other);
    ModelWindDataV65 &operator=(const ModelWindDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV65 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV65();
    ModelLightningSystemV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV65(const ModelLightningSystemV65 &p_other);
    ModelLightningSystemV65 &operator=(const ModelLightningSystemV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV65 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV65> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV65();
    ModelLightningBoltV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV65(const ModelLightningBoltV65 &p_other);
    ModelLightningBoltV65 &operator=(const ModelLightningBoltV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV65 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV65();
    ModelLightningNodeV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV65(const ModelLightningNodeV65 &p_other);
    ModelLightningNodeV65 &operator=(const ModelLightningNodeV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV65 {
    helpers::Array<ModelLightningSystemV65> systems;
    helpers::Array<ModelLightningBoltV65> bolts;
    helpers::Array<ModelLightningNodeV65> nodes;

public:
    ModelLightningDataV65();
    ModelLightningDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV65(const ModelLightningDataV65 &p_other);
    ModelLightningDataV65 &operator=(const ModelLightningDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV65 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV65();
    ModelSoftBodyDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV65(const ModelSoftBodyDataV65 &p_other);
    ModelSoftBodyDataV65 &operator=(const ModelSoftBodyDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV65 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV65();
    ModelBoneOffsetDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV65(const ModelBoneOffsetDataV65 &p_other);
    ModelBoneOffsetDataV65 &operator=(const ModelBoneOffsetDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV65 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV65();
    ModelBoundingSphereV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV65(const ModelBoundingSphereV65 &p_other);
    ModelBoundingSphereV65 &operator=(const ModelBoundingSphereV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV65 {
    helpers::Array<ModelPermutationDataV65> permutations;
    helpers::Ptr<ModelCloudDataV65> cloudData;
    helpers::Array<ModelObstacleDataV65> obstacles;
    helpers::Ptr<ModelStreakDataV65> streakData;
    helpers::Ptr<ModelLightDataV65> lightData;
    helpers::Array<ModelClothDataV65> clothData;
    helpers::Ptr<ModelWindDataV65> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV65> lightningData;
    helpers::Array<ModelSoftBodyDataV65> softBodyData;
    helpers::Array<ModelBoneOffsetDataV65> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV65> boundingSphere;

public:
    ModelFileDataV65();
    ModelFileDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV65(const ModelFileDataV65 &p_other);
    ModelFileDataV65 &operator=(const ModelFileDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV65 Gw2Struct;
};

/* Version: 64, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<64>{
struct ModelTextureDataV64 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV64();
    ModelTextureDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV64(const ModelTextureDataV64 &p_other);
    ModelTextureDataV64 &operator=(const ModelTextureDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV64 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV64();
    ModelConstantDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV64(const ModelConstantDataV64 &p_other);
    ModelConstantDataV64 &operator=(const ModelConstantDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV64 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV64();
    ModelMatConstLinkV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV64(const ModelMatConstLinkV64 &p_other);
    ModelMatConstLinkV64 &operator=(const ModelMatConstLinkV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV64 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV64();
    ModelUVTransLinkV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV64(const ModelUVTransLinkV64 &p_other);
    ModelUVTransLinkV64 &operator=(const ModelUVTransLinkV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV64 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;
    float2 scrollFreq;
    float2 scale;
    float2 scaleFreq;
    float rotate;
    float rotate;

public:
    ModelMaterialTexTransformV64();
    ModelMaterialTexTransformV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV64(const ModelMaterialTexTransformV64 &p_other);
    ModelMaterialTexTransformV64 &operator=(const ModelMaterialTexTransformV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV64 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV64> textures;
    helpers::Array<ModelConstantDataV64> constants;
    helpers::Array<ModelMatConstLinkV64> matConstLinks;
    helpers::Array<ModelUVTransLinkV64> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV64> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV64();
    ModelMaterialDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV64(const ModelMaterialDataV64 &p_other);
    ModelMaterialDataV64 &operator=(const ModelMaterialDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV64 {
    qword token;
    helpers::Ptr<ModelMaterialDataV64> materials;

public:
    ModelPermutationDataV64();
    ModelPermutationDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV64(const ModelPermutationDataV64 &p_other);
    ModelPermutationDataV64 &operator=(const ModelPermutationDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV64 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV64();
    ModelMeshLodDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV64(const ModelMeshLodDataV64 &p_other);
    ModelMeshLodDataV64 &operator=(const ModelMeshLodDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV64 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV64();
    ModelMeshMorphVertV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV64(const ModelMeshMorphVertV64 &p_other);
    ModelMeshMorphVertV64 &operator=(const ModelMeshMorphVertV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV64 {
    helpers::Array<ModelMeshMorphVertV64> positions;
    helpers::Array<ModelMeshMorphVertV64> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV64();
    ModelMeshMorphTargetV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV64(const ModelMeshMorphTargetV64 &p_other);
    ModelMeshMorphTargetV64 &operator=(const ModelMeshMorphTargetV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV64 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV64> lods;
    helpers::Array<ModelMeshMorphTargetV64> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV64();
    ModelMeshDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV64(const ModelMeshDataV64 &p_other);
    ModelMeshDataV64 &operator=(const ModelMeshDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV64 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV64();
    ModelParticleCloudV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV64(const ModelParticleCloudV64 &p_other);
    ModelParticleCloudV64 &operator=(const ModelParticleCloudV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV64 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV64();
    ModelParticleCurveV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV64(const ModelParticleCurveV64 &p_other);
    ModelParticleCurveV64 &operator=(const ModelParticleCurveV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV64 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV64();
    ModelParticleFlipbookV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV64(const ModelParticleFlipbookV64 &p_other);
    ModelParticleFlipbookV64 &operator=(const ModelParticleFlipbookV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V64 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V64();
    ModelMatrix43V64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V64(const ModelMatrix43V64 &p_other);
    ModelMatrix43V64 &operator=(const ModelMatrix43V64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV64 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV64> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV64> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV64> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V64> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV64();
    ModelParticleEmitterV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV64(const ModelParticleEmitterV64 &p_other);
    ModelParticleEmitterV64 &operator=(const ModelParticleEmitterV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV64 {
    helpers::Array<ModelParticleCloudV64> clouds;
    helpers::Array<ModelParticleEmitterV64> emitters;

public:
    ModelCloudDataV64();
    ModelCloudDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV64(const ModelCloudDataV64 &p_other);
    ModelCloudDataV64 &operator=(const ModelCloudDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV64 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V64> transform;

public:
    ModelObstacleDataV64();
    ModelObstacleDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV64(const ModelObstacleDataV64 &p_other);
    ModelObstacleDataV64 &operator=(const ModelObstacleDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV64 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV64();
    ModelStreakV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV64(const ModelStreakV64 &p_other);
    ModelStreakV64 &operator=(const ModelStreakV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV64 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV64();
    ModelStreakAnchorV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV64(const ModelStreakAnchorV64 &p_other);
    ModelStreakAnchorV64 &operator=(const ModelStreakAnchorV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV64 {
    helpers::Array<ModelStreakV64> streaks;
    helpers::Array<ModelStreakAnchorV64> anchors;

public:
    ModelStreakDataV64();
    ModelStreakDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV64(const ModelStreakDataV64 &p_other);
    ModelStreakDataV64 &operator=(const ModelStreakDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV64 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV64();
    ModelEffectLightV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV64(const ModelEffectLightV64 &p_other);
    ModelEffectLightV64 &operator=(const ModelEffectLightV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV64 {
    helpers::Array<ModelEffectLightV64> effectLights;

public:
    ModelLightDataV64();
    ModelLightDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV64(const ModelLightDataV64 &p_other);
    ModelLightDataV64 &operator=(const ModelLightDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV64 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV64();
    ModelClothBoneWeightV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV64(const ModelClothBoneWeightV64 &p_other);
    ModelClothBoneWeightV64 &operator=(const ModelClothBoneWeightV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV64 {
    helpers::Array<ModelClothBoneWeightV64> weights;

public:
    ModelClothMeshGroupV64();
    ModelClothMeshGroupV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV64(const ModelClothMeshGroupV64 &p_other);
    ModelClothMeshGroupV64 &operator=(const ModelClothMeshGroupV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV64 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV64();
    ModelClothGroupBindingV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV64(const ModelClothGroupBindingV64 &p_other);
    ModelClothGroupBindingV64 &operator=(const ModelClothGroupBindingV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV64 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV64();
    ModelClothSoftLockV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV64(const ModelClothSoftLockV64 &p_other);
    ModelClothSoftLockV64 &operator=(const ModelClothSoftLockV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV64 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV64();
    ModelClothConstraintV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV64(const ModelClothConstraintV64 &p_other);
    ModelClothConstraintV64 &operator=(const ModelClothConstraintV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV64 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV64> groups;
    helpers::Array<ModelClothGroupBindingV64> groupBindings;
    helpers::Array<ModelClothSoftLockV64> softLocks;
    helpers::Array<ModelClothConstraintV64> lod0Constraints;
    helpers::Array<ModelClothConstraintV64> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;
    qword visBone;

public:
    ModelClothDataV64();
    ModelClothDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV64(const ModelClothDataV64 &p_other);
    ModelClothDataV64 &operator=(const ModelClothDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV64 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV64();
    ModelEffectWindV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV64(const ModelEffectWindV64 &p_other);
    ModelEffectWindV64 &operator=(const ModelEffectWindV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV64 {
    helpers::Array<ModelEffectWindV64> effectWind;

public:
    ModelWindDataV64();
    ModelWindDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV64(const ModelWindDataV64 &p_other);
    ModelWindDataV64 &operator=(const ModelWindDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV64 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV64();
    ModelLightningSystemV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV64(const ModelLightningSystemV64 &p_other);
    ModelLightningSystemV64 &operator=(const ModelLightningSystemV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV64 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV64> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV64();
    ModelLightningBoltV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV64(const ModelLightningBoltV64 &p_other);
    ModelLightningBoltV64 &operator=(const ModelLightningBoltV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV64 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV64();
    ModelLightningNodeV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV64(const ModelLightningNodeV64 &p_other);
    ModelLightningNodeV64 &operator=(const ModelLightningNodeV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV64 {
    helpers::Array<ModelLightningSystemV64> systems;
    helpers::Array<ModelLightningBoltV64> bolts;
    helpers::Array<ModelLightningNodeV64> nodes;

public:
    ModelLightningDataV64();
    ModelLightningDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV64(const ModelLightningDataV64 &p_other);
    ModelLightningDataV64 &operator=(const ModelLightningDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV64 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV64();
    ModelSoftBodyDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV64(const ModelSoftBodyDataV64 &p_other);
    ModelSoftBodyDataV64 &operator=(const ModelSoftBodyDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV64 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV64();
    ModelBoneOffsetDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV64(const ModelBoneOffsetDataV64 &p_other);
    ModelBoneOffsetDataV64 &operator=(const ModelBoneOffsetDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV64 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV64();
    ModelBoundingSphereV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV64(const ModelBoundingSphereV64 &p_other);
    ModelBoundingSphereV64 &operator=(const ModelBoundingSphereV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV64 {
    helpers::Array<ModelPermutationDataV64> permutations;
    helpers::Ptr<ModelMeshDataV64> meshes;
    helpers::Ptr<ModelCloudDataV64> cloudData;
    helpers::Array<ModelObstacleDataV64> obstacles;
    helpers::Ptr<ModelStreakDataV64> streakData;
    helpers::Ptr<ModelLightDataV64> lightData;
    helpers::Array<ModelClothDataV64> clothData;
    helpers::Ptr<ModelWindDataV64> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV64> lightningData;
    helpers::Array<ModelSoftBodyDataV64> softBodyData;
    helpers::Array<ModelBoneOffsetDataV64> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV64> boundingSphere;

public:
    ModelFileDataV64();
    ModelFileDataV64(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV64(const ModelFileDataV64 &p_other);
    ModelFileDataV64 &operator=(const ModelFileDataV64 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV64 Gw2Struct;
};

/* Version: 63, ReferencedFunction: 0x410DBF7000000001 */

template <>
struct Gw2StructMODL<63>{
struct ModelTextureDataV63 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV63();
    ModelTextureDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV63(const ModelTextureDataV63 &p_other);
    ModelTextureDataV63 &operator=(const ModelTextureDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV63 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV63();
    ModelConstantDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV63(const ModelConstantDataV63 &p_other);
    ModelConstantDataV63 &operator=(const ModelConstantDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV63 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV63();
    ModelMatConstLinkV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV63(const ModelMatConstLinkV63 &p_other);
    ModelMatConstLinkV63 &operator=(const ModelMatConstLinkV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV63 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV63();
    ModelUVTransLinkV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV63(const ModelUVTransLinkV63 &p_other);
    ModelUVTransLinkV63 &operator=(const ModelUVTransLinkV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV63 {
    dword flags;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV63();
    ModelMaterialTexTransformV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV63(const ModelMaterialTexTransformV63 &p_other);
    ModelMaterialTexTransformV63 &operator=(const ModelMaterialTexTransformV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV63 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV63> textures;
    helpers::Array<ModelConstantDataV63> constants;
    helpers::Array<ModelMatConstLinkV63> matConstLinks;
    helpers::Array<ModelUVTransLinkV63> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV63> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV63();
    ModelMaterialDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV63(const ModelMaterialDataV63 &p_other);
    ModelMaterialDataV63 &operator=(const ModelMaterialDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV63 {
    qword token;
    helpers::Ptr<ModelMaterialDataV63> materials;

public:
    ModelPermutationDataV63();
    ModelPermutationDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV63(const ModelPermutationDataV63 &p_other);
    ModelPermutationDataV63 &operator=(const ModelPermutationDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV63 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV63();
    ModelMeshLodDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV63(const ModelMeshLodDataV63 &p_other);
    ModelMeshLodDataV63 &operator=(const ModelMeshLodDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV63 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV63();
    ModelMeshMorphVertV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV63(const ModelMeshMorphVertV63 &p_other);
    ModelMeshMorphVertV63 &operator=(const ModelMeshMorphVertV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV63 {
    helpers::Array<ModelMeshMorphVertV63> positions;
    helpers::Array<ModelMeshMorphVertV63> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV63();
    ModelMeshMorphTargetV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV63(const ModelMeshMorphTargetV63 &p_other);
    ModelMeshMorphTargetV63 &operator=(const ModelMeshMorphTargetV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV63 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV63> lods;
    helpers::Array<ModelMeshMorphTargetV63> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV63();
    ModelMeshDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV63(const ModelMeshDataV63 &p_other);
    ModelMeshDataV63 &operator=(const ModelMeshDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV63 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV63();
    ModelParticleCloudV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV63(const ModelParticleCloudV63 &p_other);
    ModelParticleCloudV63 &operator=(const ModelParticleCloudV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV63 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV63();
    ModelParticleCurveV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV63(const ModelParticleCurveV63 &p_other);
    ModelParticleCurveV63 &operator=(const ModelParticleCurveV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV63 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV63();
    ModelParticleFlipbookV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV63(const ModelParticleFlipbookV63 &p_other);
    ModelParticleFlipbookV63 &operator=(const ModelParticleFlipbookV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V63 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V63();
    ModelMatrix43V63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V63(const ModelMatrix43V63 &p_other);
    ModelMatrix43V63 &operator=(const ModelMatrix43V63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV63 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV63> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV63> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV63> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V63> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV63();
    ModelParticleEmitterV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV63(const ModelParticleEmitterV63 &p_other);
    ModelParticleEmitterV63 &operator=(const ModelParticleEmitterV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV63 {
    helpers::Array<ModelParticleCloudV63> clouds;
    helpers::Array<ModelParticleEmitterV63> emitters;

public:
    ModelCloudDataV63();
    ModelCloudDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV63(const ModelCloudDataV63 &p_other);
    ModelCloudDataV63 &operator=(const ModelCloudDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV63 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V63> transform;

public:
    ModelObstacleDataV63();
    ModelObstacleDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV63(const ModelObstacleDataV63 &p_other);
    ModelObstacleDataV63 &operator=(const ModelObstacleDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV63 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV63();
    ModelStreakV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV63(const ModelStreakV63 &p_other);
    ModelStreakV63 &operator=(const ModelStreakV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV63 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV63();
    ModelStreakAnchorV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV63(const ModelStreakAnchorV63 &p_other);
    ModelStreakAnchorV63 &operator=(const ModelStreakAnchorV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV63 {
    helpers::Array<ModelStreakV63> streaks;
    helpers::Array<ModelStreakAnchorV63> anchors;

public:
    ModelStreakDataV63();
    ModelStreakDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV63(const ModelStreakDataV63 &p_other);
    ModelStreakDataV63 &operator=(const ModelStreakDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV63 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV63();
    ModelEffectLightV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV63(const ModelEffectLightV63 &p_other);
    ModelEffectLightV63 &operator=(const ModelEffectLightV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV63 {
    helpers::Array<ModelEffectLightV63> effectLights;

public:
    ModelLightDataV63();
    ModelLightDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV63(const ModelLightDataV63 &p_other);
    ModelLightDataV63 &operator=(const ModelLightDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV63 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV63();
    ModelClothBoneWeightV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV63(const ModelClothBoneWeightV63 &p_other);
    ModelClothBoneWeightV63 &operator=(const ModelClothBoneWeightV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV63 {
    helpers::Array<ModelClothBoneWeightV63> weights;

public:
    ModelClothMeshGroupV63();
    ModelClothMeshGroupV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV63(const ModelClothMeshGroupV63 &p_other);
    ModelClothMeshGroupV63 &operator=(const ModelClothMeshGroupV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV63 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV63();
    ModelClothGroupBindingV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV63(const ModelClothGroupBindingV63 &p_other);
    ModelClothGroupBindingV63 &operator=(const ModelClothGroupBindingV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV63 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV63();
    ModelClothSoftLockV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV63(const ModelClothSoftLockV63 &p_other);
    ModelClothSoftLockV63 &operator=(const ModelClothSoftLockV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV63 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV63();
    ModelClothConstraintV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV63(const ModelClothConstraintV63 &p_other);
    ModelClothConstraintV63 &operator=(const ModelClothConstraintV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV63 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV63> groups;
    helpers::Array<ModelClothGroupBindingV63> groupBindings;
    helpers::Array<ModelClothSoftLockV63> softLocks;
    helpers::Array<ModelClothConstraintV63> lod0Constraints;
    helpers::Array<ModelClothConstraintV63> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;

public:
    ModelClothDataV63();
    ModelClothDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV63(const ModelClothDataV63 &p_other);
    ModelClothDataV63 &operator=(const ModelClothDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV63 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV63();
    ModelEffectWindV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV63(const ModelEffectWindV63 &p_other);
    ModelEffectWindV63 &operator=(const ModelEffectWindV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV63 {
    helpers::Array<ModelEffectWindV63> effectWind;

public:
    ModelWindDataV63();
    ModelWindDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV63(const ModelWindDataV63 &p_other);
    ModelWindDataV63 &operator=(const ModelWindDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV63 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV63();
    ModelLightningSystemV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV63(const ModelLightningSystemV63 &p_other);
    ModelLightningSystemV63 &operator=(const ModelLightningSystemV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV63 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV63> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV63();
    ModelLightningBoltV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV63(const ModelLightningBoltV63 &p_other);
    ModelLightningBoltV63 &operator=(const ModelLightningBoltV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV63 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV63();
    ModelLightningNodeV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV63(const ModelLightningNodeV63 &p_other);
    ModelLightningNodeV63 &operator=(const ModelLightningNodeV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV63 {
    helpers::Array<ModelLightningSystemV63> systems;
    helpers::Array<ModelLightningBoltV63> bolts;
    helpers::Array<ModelLightningNodeV63> nodes;

public:
    ModelLightningDataV63();
    ModelLightningDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV63(const ModelLightningDataV63 &p_other);
    ModelLightningDataV63 &operator=(const ModelLightningDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV63 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV63();
    ModelSoftBodyDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV63(const ModelSoftBodyDataV63 &p_other);
    ModelSoftBodyDataV63 &operator=(const ModelSoftBodyDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV63 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV63();
    ModelBoneOffsetDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV63(const ModelBoneOffsetDataV63 &p_other);
    ModelBoneOffsetDataV63 &operator=(const ModelBoneOffsetDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV63 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV63();
    ModelBoundingSphereV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV63(const ModelBoundingSphereV63 &p_other);
    ModelBoundingSphereV63 &operator=(const ModelBoundingSphereV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV63 {
    helpers::Array<ModelPermutationDataV63> permutations;
    helpers::Ptr<ModelMeshDataV63> meshes;
    helpers::Ptr<ModelCloudDataV63> cloudData;
    helpers::Array<ModelObstacleDataV63> obstacles;
    helpers::Ptr<ModelStreakDataV63> streakData;
    helpers::Ptr<ModelLightDataV63> lightData;
    helpers::Array<ModelClothDataV63> clothData;
    helpers::Ptr<ModelWindDataV63> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV63> lightningData;
    helpers::Array<ModelSoftBodyDataV63> softBodyData;
    helpers::Array<ModelBoneOffsetDataV63> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV63> boundingSphere;

public:
    ModelFileDataV63();
    ModelFileDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV63(const ModelFileDataV63 &p_other);
    ModelFileDataV63 &operator=(const ModelFileDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV63 Gw2Struct;
};

/* Version: 62, ReferencedFunction: 0x410DBDB000000001 */

template <>
struct Gw2StructMODL<62>{
struct ModelTextureDataV62 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV62();
    ModelTextureDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV62(const ModelTextureDataV62 &p_other);
    ModelTextureDataV62 &operator=(const ModelTextureDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV62 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV62();
    ModelConstantDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV62(const ModelConstantDataV62 &p_other);
    ModelConstantDataV62 &operator=(const ModelConstantDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV62 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV62();
    ModelMatConstLinkV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV62(const ModelMatConstLinkV62 &p_other);
    ModelMatConstLinkV62 &operator=(const ModelMatConstLinkV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV62 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV62();
    ModelUVTransLinkV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV62(const ModelUVTransLinkV62 &p_other);
    ModelUVTransLinkV62 &operator=(const ModelUVTransLinkV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV62 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV62();
    ModelMaterialTexTransformV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV62(const ModelMaterialTexTransformV62 &p_other);
    ModelMaterialTexTransformV62 &operator=(const ModelMaterialTexTransformV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV62 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV62> textures;
    helpers::Array<ModelConstantDataV62> constants;
    helpers::Array<ModelMatConstLinkV62> matConstLinks;
    helpers::Array<ModelUVTransLinkV62> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV62> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV62();
    ModelMaterialDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV62(const ModelMaterialDataV62 &p_other);
    ModelMaterialDataV62 &operator=(const ModelMaterialDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV62 {
    qword token;
    helpers::Ptr<ModelMaterialDataV62> materials;

public:
    ModelPermutationDataV62();
    ModelPermutationDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV62(const ModelPermutationDataV62 &p_other);
    ModelPermutationDataV62 &operator=(const ModelPermutationDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV62 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV62();
    ModelMeshLodDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV62(const ModelMeshLodDataV62 &p_other);
    ModelMeshLodDataV62 &operator=(const ModelMeshLodDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV62 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV62();
    ModelMeshMorphVertV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV62(const ModelMeshMorphVertV62 &p_other);
    ModelMeshMorphVertV62 &operator=(const ModelMeshMorphVertV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV62 {
    helpers::Array<ModelMeshMorphVertV62> positions;
    helpers::Array<ModelMeshMorphVertV62> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV62();
    ModelMeshMorphTargetV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV62(const ModelMeshMorphTargetV62 &p_other);
    ModelMeshMorphTargetV62 &operator=(const ModelMeshMorphTargetV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV62 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV62> lods;
    helpers::Array<ModelMeshMorphTargetV62> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV62();
    ModelMeshDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV62(const ModelMeshDataV62 &p_other);
    ModelMeshDataV62 &operator=(const ModelMeshDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV62 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV62();
    ModelParticleCloudV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV62(const ModelParticleCloudV62 &p_other);
    ModelParticleCloudV62 &operator=(const ModelParticleCloudV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV62 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV62();
    ModelParticleCurveV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV62(const ModelParticleCurveV62 &p_other);
    ModelParticleCurveV62 &operator=(const ModelParticleCurveV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV62 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV62();
    ModelParticleFlipbookV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV62(const ModelParticleFlipbookV62 &p_other);
    ModelParticleFlipbookV62 &operator=(const ModelParticleFlipbookV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V62 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V62();
    ModelMatrix43V62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V62(const ModelMatrix43V62 &p_other);
    ModelMatrix43V62 &operator=(const ModelMatrix43V62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV62 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV62> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV62> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV62> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V62> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV62();
    ModelParticleEmitterV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV62(const ModelParticleEmitterV62 &p_other);
    ModelParticleEmitterV62 &operator=(const ModelParticleEmitterV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV62 {
    helpers::Array<ModelParticleCloudV62> clouds;
    helpers::Array<ModelParticleEmitterV62> emitters;

public:
    ModelCloudDataV62();
    ModelCloudDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV62(const ModelCloudDataV62 &p_other);
    ModelCloudDataV62 &operator=(const ModelCloudDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV62 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V62> transform;

public:
    ModelObstacleDataV62();
    ModelObstacleDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV62(const ModelObstacleDataV62 &p_other);
    ModelObstacleDataV62 &operator=(const ModelObstacleDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV62 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV62();
    ModelStreakV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV62(const ModelStreakV62 &p_other);
    ModelStreakV62 &operator=(const ModelStreakV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV62 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV62();
    ModelStreakAnchorV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV62(const ModelStreakAnchorV62 &p_other);
    ModelStreakAnchorV62 &operator=(const ModelStreakAnchorV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV62 {
    helpers::Array<ModelStreakV62> streaks;
    helpers::Array<ModelStreakAnchorV62> anchors;

public:
    ModelStreakDataV62();
    ModelStreakDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV62(const ModelStreakDataV62 &p_other);
    ModelStreakDataV62 &operator=(const ModelStreakDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV62 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV62();
    ModelEffectLightV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV62(const ModelEffectLightV62 &p_other);
    ModelEffectLightV62 &operator=(const ModelEffectLightV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV62 {
    helpers::Array<ModelEffectLightV62> effectLights;

public:
    ModelLightDataV62();
    ModelLightDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV62(const ModelLightDataV62 &p_other);
    ModelLightDataV62 &operator=(const ModelLightDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV62 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV62();
    ModelClothBoneWeightV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV62(const ModelClothBoneWeightV62 &p_other);
    ModelClothBoneWeightV62 &operator=(const ModelClothBoneWeightV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV62 {
    helpers::Array<ModelClothBoneWeightV62> weights;

public:
    ModelClothMeshGroupV62();
    ModelClothMeshGroupV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV62(const ModelClothMeshGroupV62 &p_other);
    ModelClothMeshGroupV62 &operator=(const ModelClothMeshGroupV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV62 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV62();
    ModelClothGroupBindingV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV62(const ModelClothGroupBindingV62 &p_other);
    ModelClothGroupBindingV62 &operator=(const ModelClothGroupBindingV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV62 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV62();
    ModelClothSoftLockV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV62(const ModelClothSoftLockV62 &p_other);
    ModelClothSoftLockV62 &operator=(const ModelClothSoftLockV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV62 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV62();
    ModelClothConstraintV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV62(const ModelClothConstraintV62 &p_other);
    ModelClothConstraintV62 &operator=(const ModelClothConstraintV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV62 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV62> groups;
    helpers::Array<ModelClothGroupBindingV62> groupBindings;
    helpers::Array<ModelClothSoftLockV62> softLocks;
    helpers::Array<ModelClothConstraintV62> lod0Constraints;
    helpers::Array<ModelClothConstraintV62> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;
    float translateWeight;

public:
    ModelClothDataV62();
    ModelClothDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV62(const ModelClothDataV62 &p_other);
    ModelClothDataV62 &operator=(const ModelClothDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV62 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV62();
    ModelEffectWindV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV62(const ModelEffectWindV62 &p_other);
    ModelEffectWindV62 &operator=(const ModelEffectWindV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV62 {
    helpers::Array<ModelEffectWindV62> effectWind;

public:
    ModelWindDataV62();
    ModelWindDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV62(const ModelWindDataV62 &p_other);
    ModelWindDataV62 &operator=(const ModelWindDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV62 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV62();
    ModelLightningSystemV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV62(const ModelLightningSystemV62 &p_other);
    ModelLightningSystemV62 &operator=(const ModelLightningSystemV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV62 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV62> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV62();
    ModelLightningBoltV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV62(const ModelLightningBoltV62 &p_other);
    ModelLightningBoltV62 &operator=(const ModelLightningBoltV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV62 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV62();
    ModelLightningNodeV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV62(const ModelLightningNodeV62 &p_other);
    ModelLightningNodeV62 &operator=(const ModelLightningNodeV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV62 {
    helpers::Array<ModelLightningSystemV62> systems;
    helpers::Array<ModelLightningBoltV62> bolts;
    helpers::Array<ModelLightningNodeV62> nodes;

public:
    ModelLightningDataV62();
    ModelLightningDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV62(const ModelLightningDataV62 &p_other);
    ModelLightningDataV62 &operator=(const ModelLightningDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV62 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV62();
    ModelSoftBodyDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV62(const ModelSoftBodyDataV62 &p_other);
    ModelSoftBodyDataV62 &operator=(const ModelSoftBodyDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV62 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV62();
    ModelBoneOffsetDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV62(const ModelBoneOffsetDataV62 &p_other);
    ModelBoneOffsetDataV62 &operator=(const ModelBoneOffsetDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoundingSphereV62 {
    float3 center;
    float radius;

public:
    ModelBoundingSphereV62();
    ModelBoundingSphereV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoundingSphereV62(const ModelBoundingSphereV62 &p_other);
    ModelBoundingSphereV62 &operator=(const ModelBoundingSphereV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV62 {
    helpers::Array<ModelPermutationDataV62> permutations;
    helpers::Ptr<ModelMeshDataV62> meshes;
    helpers::Ptr<ModelCloudDataV62> cloudData;
    helpers::Array<ModelObstacleDataV62> obstacles;
    helpers::Ptr<ModelStreakDataV62> streakData;
    helpers::Ptr<ModelLightDataV62> lightData;
    helpers::Array<ModelClothDataV62> clothData;
    helpers::Ptr<ModelWindDataV62> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV62> lightningData;
    helpers::Array<ModelSoftBodyDataV62> softBodyData;
    helpers::Array<ModelBoneOffsetDataV62> boneOffsetData;
    helpers::Ptr<ModelBoundingSphereV62> boundingSphere;

public:
    ModelFileDataV62();
    ModelFileDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV62(const ModelFileDataV62 &p_other);
    ModelFileDataV62 &operator=(const ModelFileDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV62 Gw2Struct;
};

/* Version: 61, ReferencedFunction: 0x410DBD4000000001 */

template <>
struct Gw2StructMODL<61>{
struct ModelTextureDataV61 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV61();
    ModelTextureDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV61(const ModelTextureDataV61 &p_other);
    ModelTextureDataV61 &operator=(const ModelTextureDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV61 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV61();
    ModelConstantDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV61(const ModelConstantDataV61 &p_other);
    ModelConstantDataV61 &operator=(const ModelConstantDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV61 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV61();
    ModelMatConstLinkV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV61(const ModelMatConstLinkV61 &p_other);
    ModelMatConstLinkV61 &operator=(const ModelMatConstLinkV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV61 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV61();
    ModelUVTransLinkV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV61(const ModelUVTransLinkV61 &p_other);
    ModelUVTransLinkV61 &operator=(const ModelUVTransLinkV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV61 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV61();
    ModelMaterialTexTransformV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV61(const ModelMaterialTexTransformV61 &p_other);
    ModelMaterialTexTransformV61 &operator=(const ModelMaterialTexTransformV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV61 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV61> textures;
    helpers::Array<ModelConstantDataV61> constants;
    helpers::Array<ModelMatConstLinkV61> matConstLinks;
    helpers::Array<ModelUVTransLinkV61> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV61> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV61();
    ModelMaterialDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV61(const ModelMaterialDataV61 &p_other);
    ModelMaterialDataV61 &operator=(const ModelMaterialDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV61 {
    qword token;
    helpers::Ptr<ModelMaterialDataV61> materials;

public:
    ModelPermutationDataV61();
    ModelPermutationDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV61(const ModelPermutationDataV61 &p_other);
    ModelPermutationDataV61 &operator=(const ModelPermutationDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV61 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV61();
    ModelMeshLodDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV61(const ModelMeshLodDataV61 &p_other);
    ModelMeshLodDataV61 &operator=(const ModelMeshLodDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV61 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV61();
    ModelMeshMorphVertV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV61(const ModelMeshMorphVertV61 &p_other);
    ModelMeshMorphVertV61 &operator=(const ModelMeshMorphVertV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV61 {
    helpers::Array<ModelMeshMorphVertV61> positions;
    helpers::Array<ModelMeshMorphVertV61> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV61();
    ModelMeshMorphTargetV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV61(const ModelMeshMorphTargetV61 &p_other);
    ModelMeshMorphTargetV61 &operator=(const ModelMeshMorphTargetV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV61 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV61> lods;
    helpers::Array<ModelMeshMorphTargetV61> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV61();
    ModelMeshDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV61(const ModelMeshDataV61 &p_other);
    ModelMeshDataV61 &operator=(const ModelMeshDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV61 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV61();
    ModelTransformDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV61(const ModelTransformDataV61 &p_other);
    ModelTransformDataV61 &operator=(const ModelTransformDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV61 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV61 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV61();
    ModelBoneDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV61(const ModelBoneDataV61 &p_other);
    ModelBoneDataV61 &operator=(const ModelBoneDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV61 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV61();
    ModelBoneSymmetryV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV61(const ModelBoneSymmetryV61 &p_other);
    ModelBoneSymmetryV61 &operator=(const ModelBoneSymmetryV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV61 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV61> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV61> boneSymmetries;

public:
    ModelSkeletonDataV61();
    ModelSkeletonDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV61(const ModelSkeletonDataV61 &p_other);
    ModelSkeletonDataV61 &operator=(const ModelSkeletonDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV61 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV61();
    ModelMeshBindingDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV61(const ModelMeshBindingDataV61 &p_other);
    ModelMeshBindingDataV61 &operator=(const ModelMeshBindingDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV61 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV61();
    ModelTrackMaskV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV61(const ModelTrackMaskV61 &p_other);
    ModelTrackMaskV61 &operator=(const ModelTrackMaskV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV61 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV61> Skeleton;
    ModelTransformDataV61 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV61> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV61> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV61();
    ModelModelDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV61(const ModelModelDataV61 &p_other);
    ModelModelDataV61 &operator=(const ModelModelDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV61 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV61();
    ModelPropertyDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV61(const ModelPropertyDataV61 &p_other);
    ModelPropertyDataV61 &operator=(const ModelPropertyDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV61 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV61();
    ModelParticleCloudV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV61(const ModelParticleCloudV61 &p_other);
    ModelParticleCloudV61 &operator=(const ModelParticleCloudV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV61 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV61();
    ModelParticleCurveV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV61(const ModelParticleCurveV61 &p_other);
    ModelParticleCurveV61 &operator=(const ModelParticleCurveV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV61 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV61();
    ModelParticleFlipbookV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV61(const ModelParticleFlipbookV61 &p_other);
    ModelParticleFlipbookV61 &operator=(const ModelParticleFlipbookV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V61 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V61();
    ModelMatrix43V61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V61(const ModelMatrix43V61 &p_other);
    ModelMatrix43V61 &operator=(const ModelMatrix43V61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV61 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    dword affinity;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV61> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV61> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV61> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V61> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV61();
    ModelParticleEmitterV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV61(const ModelParticleEmitterV61 &p_other);
    ModelParticleEmitterV61 &operator=(const ModelParticleEmitterV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV61 {
    helpers::Array<ModelParticleCloudV61> clouds;
    helpers::Array<ModelParticleEmitterV61> emitters;

public:
    ModelCloudDataV61();
    ModelCloudDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV61(const ModelCloudDataV61 &p_other);
    ModelCloudDataV61 &operator=(const ModelCloudDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV61 {
    dword affinity;
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V61> transform;

public:
    ModelObstacleDataV61();
    ModelObstacleDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV61(const ModelObstacleDataV61 &p_other);
    ModelObstacleDataV61 &operator=(const ModelObstacleDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV61 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV61();
    ModelStreakV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV61(const ModelStreakV61 &p_other);
    ModelStreakV61 &operator=(const ModelStreakV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV61 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV61();
    ModelStreakAnchorV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV61(const ModelStreakAnchorV61 &p_other);
    ModelStreakAnchorV61 &operator=(const ModelStreakAnchorV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV61 {
    helpers::Array<ModelStreakV61> streaks;
    helpers::Array<ModelStreakAnchorV61> anchors;

public:
    ModelStreakDataV61();
    ModelStreakDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV61(const ModelStreakDataV61 &p_other);
    ModelStreakDataV61 &operator=(const ModelStreakDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV61 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV61();
    ModelEffectLightV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV61(const ModelEffectLightV61 &p_other);
    ModelEffectLightV61 &operator=(const ModelEffectLightV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV61 {
    helpers::Array<ModelEffectLightV61> effectLights;

public:
    ModelLightDataV61();
    ModelLightDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV61(const ModelLightDataV61 &p_other);
    ModelLightDataV61 &operator=(const ModelLightDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV61 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV61();
    ModelClothBoneWeightV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV61(const ModelClothBoneWeightV61 &p_other);
    ModelClothBoneWeightV61 &operator=(const ModelClothBoneWeightV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV61 {
    helpers::Array<ModelClothBoneWeightV61> weights;

public:
    ModelClothMeshGroupV61();
    ModelClothMeshGroupV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV61(const ModelClothMeshGroupV61 &p_other);
    ModelClothMeshGroupV61 &operator=(const ModelClothMeshGroupV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV61 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV61();
    ModelClothGroupBindingV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV61(const ModelClothGroupBindingV61 &p_other);
    ModelClothGroupBindingV61 &operator=(const ModelClothGroupBindingV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV61 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV61();
    ModelClothSoftLockV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV61(const ModelClothSoftLockV61 &p_other);
    ModelClothSoftLockV61 &operator=(const ModelClothSoftLockV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV61 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV61();
    ModelClothConstraintV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV61(const ModelClothConstraintV61 &p_other);
    ModelClothConstraintV61 &operator=(const ModelClothConstraintV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV61 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV61> groups;
    helpers::Array<ModelClothGroupBindingV61> groupBindings;
    helpers::Array<ModelClothSoftLockV61> softLocks;
    helpers::Array<ModelClothConstraintV61> lod0Constraints;
    helpers::Array<ModelClothConstraintV61> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV61();
    ModelClothDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV61(const ModelClothDataV61 &p_other);
    ModelClothDataV61 &operator=(const ModelClothDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectWindV61 {
    qword bone;
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectWindV61();
    ModelEffectWindV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectWindV61(const ModelEffectWindV61 &p_other);
    ModelEffectWindV61 &operator=(const ModelEffectWindV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindDataV61 {
    helpers::Array<ModelEffectWindV61> effectWind;

public:
    ModelWindDataV61();
    ModelWindDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindDataV61(const ModelWindDataV61 &p_other);
    ModelWindDataV61 &operator=(const ModelWindDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV61 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV61();
    ModelLightningSystemV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV61(const ModelLightningSystemV61 &p_other);
    ModelLightningSystemV61 &operator=(const ModelLightningSystemV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV61 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV61> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV61();
    ModelLightningBoltV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV61(const ModelLightningBoltV61 &p_other);
    ModelLightningBoltV61 &operator=(const ModelLightningBoltV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV61 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV61();
    ModelLightningNodeV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV61(const ModelLightningNodeV61 &p_other);
    ModelLightningNodeV61 &operator=(const ModelLightningNodeV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV61 {
    helpers::Array<ModelLightningSystemV61> systems;
    helpers::Array<ModelLightningBoltV61> bolts;
    helpers::Array<ModelLightningNodeV61> nodes;

public:
    ModelLightningDataV61();
    ModelLightningDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV61(const ModelLightningDataV61 &p_other);
    ModelLightningDataV61 &operator=(const ModelLightningDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV61 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV61();
    ModelBoneConstraintLinkV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV61(const ModelBoneConstraintLinkV61 &p_other);
    ModelBoneConstraintLinkV61 &operator=(const ModelBoneConstraintLinkV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV61 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV61> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV61();
    ModelBoneConstraintV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV61(const ModelBoneConstraintV61 &p_other);
    ModelBoneConstraintV61 &operator=(const ModelBoneConstraintV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV61 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV61();
    ModelSoftBodyDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV61(const ModelSoftBodyDataV61 &p_other);
    ModelSoftBodyDataV61 &operator=(const ModelSoftBodyDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV61 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV61();
    ModelBoneOffsetDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV61(const ModelBoneOffsetDataV61 &p_other);
    ModelBoneOffsetDataV61 &operator=(const ModelBoneOffsetDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFixedOffsetDataV61 {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetDataV61();
    ModelFixedOffsetDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetDataV61(const ModelFixedOffsetDataV61 &p_other);
    ModelFixedOffsetDataV61 &operator=(const ModelFixedOffsetDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV61 {
    helpers::Array<ModelPermutationDataV61> permutations;
    helpers::Ptr<ModelMeshDataV61> meshes;
    helpers::Ptr<ModelModelDataV61> model;
    helpers::Array<ModelPropertyDataV61> properties;
    helpers::Ptr<ModelCloudDataV61> cloudData;
    helpers::Array<ModelObstacleDataV61> obstacles;
    helpers::Ptr<ModelStreakDataV61> streakData;
    helpers::Ptr<ModelLightDataV61> lightData;
    helpers::Array<ModelClothDataV61> clothData;
    helpers::Ptr<ModelWindDataV61> windData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV61> lightningData;
    helpers::Array<ModelBoneConstraintV61> boneConstraints;
    helpers::Array<ModelSoftBodyDataV61> softBodyData;
    helpers::Array<ModelBoneOffsetDataV61> boneOffsetData;
    helpers::Array<ModelFixedOffsetDataV61> fixedOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV61();
    ModelFileDataV61(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV61(const ModelFileDataV61 &p_other);
    ModelFileDataV61 &operator=(const ModelFileDataV61 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV61 Gw2Struct;
};

/* Version: 60, ReferencedFunction: 0x410DB96000000001 */

template <>
struct Gw2StructMODL<60>{
struct ModelTextureDataV60 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV60();
    ModelTextureDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV60(const ModelTextureDataV60 &p_other);
    ModelTextureDataV60 &operator=(const ModelTextureDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV60 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV60();
    ModelConstantDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV60(const ModelConstantDataV60 &p_other);
    ModelConstantDataV60 &operator=(const ModelConstantDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV60 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV60();
    ModelMatConstLinkV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV60(const ModelMatConstLinkV60 &p_other);
    ModelMatConstLinkV60 &operator=(const ModelMatConstLinkV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV60 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV60();
    ModelUVTransLinkV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV60(const ModelUVTransLinkV60 &p_other);
    ModelUVTransLinkV60 &operator=(const ModelUVTransLinkV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV60 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV60();
    ModelMaterialTexTransformV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV60(const ModelMaterialTexTransformV60 &p_other);
    ModelMaterialTexTransformV60 &operator=(const ModelMaterialTexTransformV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV60 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV60> textures;
    helpers::Array<ModelConstantDataV60> constants;
    helpers::Array<ModelMatConstLinkV60> matConstLinks;
    helpers::Array<ModelUVTransLinkV60> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV60> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV60();
    ModelMaterialDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV60(const ModelMaterialDataV60 &p_other);
    ModelMaterialDataV60 &operator=(const ModelMaterialDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV60 {
    qword token;
    helpers::Ptr<ModelMaterialDataV60> materials;

public:
    ModelPermutationDataV60();
    ModelPermutationDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV60(const ModelPermutationDataV60 &p_other);
    ModelPermutationDataV60 &operator=(const ModelPermutationDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV60 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV60();
    ModelMeshLodDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV60(const ModelMeshLodDataV60 &p_other);
    ModelMeshLodDataV60 &operator=(const ModelMeshLodDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV60 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV60();
    ModelMeshMorphVertV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV60(const ModelMeshMorphVertV60 &p_other);
    ModelMeshMorphVertV60 &operator=(const ModelMeshMorphVertV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV60 {
    helpers::Array<ModelMeshMorphVertV60> positions;
    helpers::Array<ModelMeshMorphVertV60> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV60();
    ModelMeshMorphTargetV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV60(const ModelMeshMorphTargetV60 &p_other);
    ModelMeshMorphTargetV60 &operator=(const ModelMeshMorphTargetV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV60 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV60> lods;
    helpers::Array<ModelMeshMorphTargetV60> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV60();
    ModelMeshDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV60(const ModelMeshDataV60 &p_other);
    ModelMeshDataV60 &operator=(const ModelMeshDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV60 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV60();
    ModelTransformDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV60(const ModelTransformDataV60 &p_other);
    ModelTransformDataV60 &operator=(const ModelTransformDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV60 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV60 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV60();
    ModelBoneDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV60(const ModelBoneDataV60 &p_other);
    ModelBoneDataV60 &operator=(const ModelBoneDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV60 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV60();
    ModelBoneSymmetryV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV60(const ModelBoneSymmetryV60 &p_other);
    ModelBoneSymmetryV60 &operator=(const ModelBoneSymmetryV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV60 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV60> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV60> boneSymmetries;

public:
    ModelSkeletonDataV60();
    ModelSkeletonDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV60(const ModelSkeletonDataV60 &p_other);
    ModelSkeletonDataV60 &operator=(const ModelSkeletonDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV60 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV60();
    ModelMeshBindingDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV60(const ModelMeshBindingDataV60 &p_other);
    ModelMeshBindingDataV60 &operator=(const ModelMeshBindingDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV60 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV60();
    ModelTrackMaskV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV60(const ModelTrackMaskV60 &p_other);
    ModelTrackMaskV60 &operator=(const ModelTrackMaskV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV60 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV60> Skeleton;
    ModelTransformDataV60 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV60> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV60> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV60();
    ModelModelDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV60(const ModelModelDataV60 &p_other);
    ModelModelDataV60 &operator=(const ModelModelDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV60 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV60();
    ModelPropertyDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV60(const ModelPropertyDataV60 &p_other);
    ModelPropertyDataV60 &operator=(const ModelPropertyDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV60 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV60();
    ModelParticleCloudV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV60(const ModelParticleCloudV60 &p_other);
    ModelParticleCloudV60 &operator=(const ModelParticleCloudV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV60 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV60();
    ModelParticleCurveV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV60(const ModelParticleCurveV60 &p_other);
    ModelParticleCurveV60 &operator=(const ModelParticleCurveV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV60 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV60();
    ModelParticleFlipbookV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV60(const ModelParticleFlipbookV60 &p_other);
    ModelParticleFlipbookV60 &operator=(const ModelParticleFlipbookV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V60 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V60();
    ModelMatrix43V60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V60(const ModelMatrix43V60 &p_other);
    ModelMatrix43V60 &operator=(const ModelMatrix43V60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV60 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV60> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV60> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV60> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V60> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV60();
    ModelParticleEmitterV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV60(const ModelParticleEmitterV60 &p_other);
    ModelParticleEmitterV60 &operator=(const ModelParticleEmitterV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV60 {
    helpers::Array<ModelParticleCloudV60> clouds;
    helpers::Array<ModelParticleEmitterV60> emitters;

public:
    ModelCloudDataV60();
    ModelCloudDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV60(const ModelCloudDataV60 &p_other);
    ModelCloudDataV60 &operator=(const ModelCloudDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV60 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V60> transform;

public:
    ModelObstacleDataV60();
    ModelObstacleDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV60(const ModelObstacleDataV60 &p_other);
    ModelObstacleDataV60 &operator=(const ModelObstacleDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV60 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV60();
    ModelStreakV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV60(const ModelStreakV60 &p_other);
    ModelStreakV60 &operator=(const ModelStreakV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV60 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV60();
    ModelStreakAnchorV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV60(const ModelStreakAnchorV60 &p_other);
    ModelStreakAnchorV60 &operator=(const ModelStreakAnchorV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV60 {
    helpers::Array<ModelStreakV60> streaks;
    helpers::Array<ModelStreakAnchorV60> anchors;

public:
    ModelStreakDataV60();
    ModelStreakDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV60(const ModelStreakDataV60 &p_other);
    ModelStreakDataV60 &operator=(const ModelStreakDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV60 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV60();
    ModelEffectLightV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV60(const ModelEffectLightV60 &p_other);
    ModelEffectLightV60 &operator=(const ModelEffectLightV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV60 {
    helpers::Array<ModelEffectLightV60> effectLights;

public:
    ModelLightDataV60();
    ModelLightDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV60(const ModelLightDataV60 &p_other);
    ModelLightDataV60 &operator=(const ModelLightDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV60 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV60();
    ModelClothBoneWeightV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV60(const ModelClothBoneWeightV60 &p_other);
    ModelClothBoneWeightV60 &operator=(const ModelClothBoneWeightV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV60 {
    helpers::Array<ModelClothBoneWeightV60> weights;

public:
    ModelClothMeshGroupV60();
    ModelClothMeshGroupV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV60(const ModelClothMeshGroupV60 &p_other);
    ModelClothMeshGroupV60 &operator=(const ModelClothMeshGroupV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothGroupBindingV60 {
    qword strippedToken;
    helpers::String boneName;
    float3 OBBMin;
    float3 OBBMax;

public:
    ModelClothGroupBindingV60();
    ModelClothGroupBindingV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothGroupBindingV60(const ModelClothGroupBindingV60 &p_other);
    ModelClothGroupBindingV60 &operator=(const ModelClothGroupBindingV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV60 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV60();
    ModelClothSoftLockV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV60(const ModelClothSoftLockV60 &p_other);
    ModelClothSoftLockV60 &operator=(const ModelClothSoftLockV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV60 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV60();
    ModelClothConstraintV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV60(const ModelClothConstraintV60 &p_other);
    ModelClothConstraintV60 &operator=(const ModelClothConstraintV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV60 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV60> groups;
    helpers::Array<ModelClothGroupBindingV60> groupBindings;
    helpers::Array<ModelClothSoftLockV60> softLocks;
    helpers::Array<ModelClothConstraintV60> lod0Constraints;
    helpers::Array<ModelClothConstraintV60> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV60();
    ModelClothDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV60(const ModelClothDataV60 &p_other);
    ModelClothDataV60 &operator=(const ModelClothDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV60 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV60();
    ModelLightningSystemV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV60(const ModelLightningSystemV60 &p_other);
    ModelLightningSystemV60 &operator=(const ModelLightningSystemV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV60 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV60> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV60();
    ModelLightningBoltV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV60(const ModelLightningBoltV60 &p_other);
    ModelLightningBoltV60 &operator=(const ModelLightningBoltV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV60 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV60();
    ModelLightningNodeV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV60(const ModelLightningNodeV60 &p_other);
    ModelLightningNodeV60 &operator=(const ModelLightningNodeV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV60 {
    helpers::Array<ModelLightningSystemV60> systems;
    helpers::Array<ModelLightningBoltV60> bolts;
    helpers::Array<ModelLightningNodeV60> nodes;

public:
    ModelLightningDataV60();
    ModelLightningDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV60(const ModelLightningDataV60 &p_other);
    ModelLightningDataV60 &operator=(const ModelLightningDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV60 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV60();
    ModelBoneConstraintLinkV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV60(const ModelBoneConstraintLinkV60 &p_other);
    ModelBoneConstraintLinkV60 &operator=(const ModelBoneConstraintLinkV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV60 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV60> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV60();
    ModelBoneConstraintV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV60(const ModelBoneConstraintV60 &p_other);
    ModelBoneConstraintV60 &operator=(const ModelBoneConstraintV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV60 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV60();
    ModelSoftBodyDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV60(const ModelSoftBodyDataV60 &p_other);
    ModelSoftBodyDataV60 &operator=(const ModelSoftBodyDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV60 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV60();
    ModelBoneOffsetDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV60(const ModelBoneOffsetDataV60 &p_other);
    ModelBoneOffsetDataV60 &operator=(const ModelBoneOffsetDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFixedOffsetDataV60 {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetDataV60();
    ModelFixedOffsetDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetDataV60(const ModelFixedOffsetDataV60 &p_other);
    ModelFixedOffsetDataV60 &operator=(const ModelFixedOffsetDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV60 {
    helpers::Array<ModelPermutationDataV60> permutations;
    helpers::Ptr<ModelMeshDataV60> meshes;
    helpers::Ptr<ModelModelDataV60> model;
    helpers::Array<ModelPropertyDataV60> properties;
    helpers::Ptr<ModelCloudDataV60> cloudData;
    helpers::Array<ModelObstacleDataV60> obstacles;
    helpers::Ptr<ModelStreakDataV60> streakData;
    helpers::Ptr<ModelLightDataV60> lightData;
    helpers::Array<ModelClothDataV60> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV60> lightningData;
    helpers::Array<ModelBoneConstraintV60> boneConstraints;
    helpers::Array<ModelSoftBodyDataV60> softBodyData;
    helpers::Array<ModelBoneOffsetDataV60> boneOffsetData;
    helpers::Array<ModelFixedOffsetDataV60> fixedOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV60();
    ModelFileDataV60(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV60(const ModelFileDataV60 &p_other);
    ModelFileDataV60 &operator=(const ModelFileDataV60 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV60 Gw2Struct;
};

/* Version: 59, ReferencedFunction: 0x410DB90000000001 */

template <>
struct Gw2StructMODL<59>{
struct ModelTextureDataV59 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV59();
    ModelTextureDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV59(const ModelTextureDataV59 &p_other);
    ModelTextureDataV59 &operator=(const ModelTextureDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV59 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV59();
    ModelConstantDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV59(const ModelConstantDataV59 &p_other);
    ModelConstantDataV59 &operator=(const ModelConstantDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV59 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV59();
    ModelMatConstLinkV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV59(const ModelMatConstLinkV59 &p_other);
    ModelMatConstLinkV59 &operator=(const ModelMatConstLinkV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV59 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV59();
    ModelUVTransLinkV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV59(const ModelUVTransLinkV59 &p_other);
    ModelUVTransLinkV59 &operator=(const ModelUVTransLinkV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV59 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV59();
    ModelMaterialTexTransformV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV59(const ModelMaterialTexTransformV59 &p_other);
    ModelMaterialTexTransformV59 &operator=(const ModelMaterialTexTransformV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV59 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV59> textures;
    helpers::Array<ModelConstantDataV59> constants;
    helpers::Array<ModelMatConstLinkV59> matConstLinks;
    helpers::Array<ModelUVTransLinkV59> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV59> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV59();
    ModelMaterialDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV59(const ModelMaterialDataV59 &p_other);
    ModelMaterialDataV59 &operator=(const ModelMaterialDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV59 {
    qword token;
    helpers::Ptr<ModelMaterialDataV59> materials;

public:
    ModelPermutationDataV59();
    ModelPermutationDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV59(const ModelPermutationDataV59 &p_other);
    ModelPermutationDataV59 &operator=(const ModelPermutationDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV59 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV59();
    ModelMeshLodDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV59(const ModelMeshLodDataV59 &p_other);
    ModelMeshLodDataV59 &operator=(const ModelMeshLodDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV59 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV59();
    ModelMeshMorphVertV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV59(const ModelMeshMorphVertV59 &p_other);
    ModelMeshMorphVertV59 &operator=(const ModelMeshMorphVertV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV59 {
    helpers::Array<ModelMeshMorphVertV59> positions;
    helpers::Array<ModelMeshMorphVertV59> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV59();
    ModelMeshMorphTargetV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV59(const ModelMeshMorphTargetV59 &p_other);
    ModelMeshMorphTargetV59 &operator=(const ModelMeshMorphTargetV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV59 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV59> lods;
    helpers::Array<ModelMeshMorphTargetV59> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV59();
    ModelMeshDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV59(const ModelMeshDataV59 &p_other);
    ModelMeshDataV59 &operator=(const ModelMeshDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV59 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV59();
    ModelTransformDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV59(const ModelTransformDataV59 &p_other);
    ModelTransformDataV59 &operator=(const ModelTransformDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV59 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV59 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV59();
    ModelBoneDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV59(const ModelBoneDataV59 &p_other);
    ModelBoneDataV59 &operator=(const ModelBoneDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV59 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV59();
    ModelBoneSymmetryV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV59(const ModelBoneSymmetryV59 &p_other);
    ModelBoneSymmetryV59 &operator=(const ModelBoneSymmetryV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV59 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV59> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV59> boneSymmetries;

public:
    ModelSkeletonDataV59();
    ModelSkeletonDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV59(const ModelSkeletonDataV59 &p_other);
    ModelSkeletonDataV59 &operator=(const ModelSkeletonDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV59 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV59();
    ModelMeshBindingDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV59(const ModelMeshBindingDataV59 &p_other);
    ModelMeshBindingDataV59 &operator=(const ModelMeshBindingDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV59 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV59();
    ModelTrackMaskV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV59(const ModelTrackMaskV59 &p_other);
    ModelTrackMaskV59 &operator=(const ModelTrackMaskV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV59 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV59> Skeleton;
    ModelTransformDataV59 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV59> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV59> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV59();
    ModelModelDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV59(const ModelModelDataV59 &p_other);
    ModelModelDataV59 &operator=(const ModelModelDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV59 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV59();
    ModelPropertyDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV59(const ModelPropertyDataV59 &p_other);
    ModelPropertyDataV59 &operator=(const ModelPropertyDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV59 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV59();
    ModelParticleCloudV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV59(const ModelParticleCloudV59 &p_other);
    ModelParticleCloudV59 &operator=(const ModelParticleCloudV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV59 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV59();
    ModelParticleCurveV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV59(const ModelParticleCurveV59 &p_other);
    ModelParticleCurveV59 &operator=(const ModelParticleCurveV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV59 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV59();
    ModelParticleFlipbookV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV59(const ModelParticleFlipbookV59 &p_other);
    ModelParticleFlipbookV59 &operator=(const ModelParticleFlipbookV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V59 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V59();
    ModelMatrix43V59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V59(const ModelMatrix43V59 &p_other);
    ModelMatrix43V59 &operator=(const ModelMatrix43V59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV59 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV59> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV59> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV59> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V59> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV59();
    ModelParticleEmitterV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV59(const ModelParticleEmitterV59 &p_other);
    ModelParticleEmitterV59 &operator=(const ModelParticleEmitterV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV59 {
    helpers::Array<ModelParticleCloudV59> clouds;
    helpers::Array<ModelParticleEmitterV59> emitters;

public:
    ModelCloudDataV59();
    ModelCloudDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV59(const ModelCloudDataV59 &p_other);
    ModelCloudDataV59 &operator=(const ModelCloudDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV59 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V59> transform;

public:
    ModelObstacleDataV59();
    ModelObstacleDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV59(const ModelObstacleDataV59 &p_other);
    ModelObstacleDataV59 &operator=(const ModelObstacleDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV59 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV59();
    ModelStreakV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV59(const ModelStreakV59 &p_other);
    ModelStreakV59 &operator=(const ModelStreakV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV59 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV59();
    ModelStreakAnchorV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV59(const ModelStreakAnchorV59 &p_other);
    ModelStreakAnchorV59 &operator=(const ModelStreakAnchorV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV59 {
    helpers::Array<ModelStreakV59> streaks;
    helpers::Array<ModelStreakAnchorV59> anchors;

public:
    ModelStreakDataV59();
    ModelStreakDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV59(const ModelStreakDataV59 &p_other);
    ModelStreakDataV59 &operator=(const ModelStreakDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV59 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV59();
    ModelEffectLightV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV59(const ModelEffectLightV59 &p_other);
    ModelEffectLightV59 &operator=(const ModelEffectLightV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV59 {
    helpers::Array<ModelEffectLightV59> effectLights;

public:
    ModelLightDataV59();
    ModelLightDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV59(const ModelLightDataV59 &p_other);
    ModelLightDataV59 &operator=(const ModelLightDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV59 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV59();
    ModelClothBoneWeightV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV59(const ModelClothBoneWeightV59 &p_other);
    ModelClothBoneWeightV59 &operator=(const ModelClothBoneWeightV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV59 {
    helpers::Array<ModelClothBoneWeightV59> weights;

public:
    ModelClothMeshGroupV59();
    ModelClothMeshGroupV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV59(const ModelClothMeshGroupV59 &p_other);
    ModelClothMeshGroupV59 &operator=(const ModelClothMeshGroupV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV59 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV59();
    ModelClothSoftLockV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV59(const ModelClothSoftLockV59 &p_other);
    ModelClothSoftLockV59 &operator=(const ModelClothSoftLockV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV59 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV59();
    ModelClothConstraintV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV59(const ModelClothConstraintV59 &p_other);
    ModelClothConstraintV59 &operator=(const ModelClothConstraintV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV59 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV59> groups;
    helpers::Array<ModelClothSoftLockV59> softLocks;
    helpers::Array<ModelClothConstraintV59> lod0Constraints;
    helpers::Array<ModelClothConstraintV59> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV59();
    ModelClothDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV59(const ModelClothDataV59 &p_other);
    ModelClothDataV59 &operator=(const ModelClothDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV59 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV59();
    ModelLightningSystemV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV59(const ModelLightningSystemV59 &p_other);
    ModelLightningSystemV59 &operator=(const ModelLightningSystemV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV59 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV59> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float2 texRange;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV59();
    ModelLightningBoltV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV59(const ModelLightningBoltV59 &p_other);
    ModelLightningBoltV59 &operator=(const ModelLightningBoltV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV59 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV59();
    ModelLightningNodeV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV59(const ModelLightningNodeV59 &p_other);
    ModelLightningNodeV59 &operator=(const ModelLightningNodeV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV59 {
    helpers::Array<ModelLightningSystemV59> systems;
    helpers::Array<ModelLightningBoltV59> bolts;
    helpers::Array<ModelLightningNodeV59> nodes;

public:
    ModelLightningDataV59();
    ModelLightningDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV59(const ModelLightningDataV59 &p_other);
    ModelLightningDataV59 &operator=(const ModelLightningDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV59 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV59();
    ModelBoneConstraintLinkV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV59(const ModelBoneConstraintLinkV59 &p_other);
    ModelBoneConstraintLinkV59 &operator=(const ModelBoneConstraintLinkV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV59 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV59> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV59();
    ModelBoneConstraintV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV59(const ModelBoneConstraintV59 &p_other);
    ModelBoneConstraintV59 &operator=(const ModelBoneConstraintV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV59 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV59();
    ModelSoftBodyDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV59(const ModelSoftBodyDataV59 &p_other);
    ModelSoftBodyDataV59 &operator=(const ModelSoftBodyDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV59 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV59();
    ModelBoneOffsetDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV59(const ModelBoneOffsetDataV59 &p_other);
    ModelBoneOffsetDataV59 &operator=(const ModelBoneOffsetDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFixedOffsetDataV59 {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetDataV59();
    ModelFixedOffsetDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetDataV59(const ModelFixedOffsetDataV59 &p_other);
    ModelFixedOffsetDataV59 &operator=(const ModelFixedOffsetDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV59 {
    helpers::Array<ModelPermutationDataV59> permutations;
    helpers::Ptr<ModelMeshDataV59> meshes;
    helpers::Ptr<ModelModelDataV59> model;
    helpers::Array<ModelPropertyDataV59> properties;
    helpers::Ptr<ModelCloudDataV59> cloudData;
    helpers::Array<ModelObstacleDataV59> obstacles;
    helpers::Ptr<ModelStreakDataV59> streakData;
    helpers::Ptr<ModelLightDataV59> lightData;
    helpers::Array<ModelClothDataV59> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV59> lightningData;
    helpers::Array<ModelBoneConstraintV59> boneConstraints;
    helpers::Array<ModelSoftBodyDataV59> softBodyData;
    helpers::Array<ModelBoneOffsetDataV59> boneOffsetData;
    helpers::Array<ModelFixedOffsetDataV59> fixedOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV59();
    ModelFileDataV59(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV59(const ModelFileDataV59 &p_other);
    ModelFileDataV59 &operator=(const ModelFileDataV59 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV59 Gw2Struct;
};

/* Version: 58, ReferencedFunction: 0x410DB7C000000001 */

template <>
struct Gw2StructMODL<58>{
struct ModelTextureDataV58 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV58();
    ModelTextureDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV58(const ModelTextureDataV58 &p_other);
    ModelTextureDataV58 &operator=(const ModelTextureDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV58 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV58();
    ModelConstantDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV58(const ModelConstantDataV58 &p_other);
    ModelConstantDataV58 &operator=(const ModelConstantDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV58 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV58();
    ModelMatConstLinkV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV58(const ModelMatConstLinkV58 &p_other);
    ModelMatConstLinkV58 &operator=(const ModelMatConstLinkV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV58 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV58();
    ModelUVTransLinkV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV58(const ModelUVTransLinkV58 &p_other);
    ModelUVTransLinkV58 &operator=(const ModelUVTransLinkV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV58 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV58();
    ModelMaterialTexTransformV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV58(const ModelMaterialTexTransformV58 &p_other);
    ModelMaterialTexTransformV58 &operator=(const ModelMaterialTexTransformV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV58 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV58> textures;
    helpers::Array<ModelConstantDataV58> constants;
    helpers::Array<ModelMatConstLinkV58> matConstLinks;
    helpers::Array<ModelUVTransLinkV58> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV58> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV58();
    ModelMaterialDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV58(const ModelMaterialDataV58 &p_other);
    ModelMaterialDataV58 &operator=(const ModelMaterialDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV58 {
    qword token;
    helpers::Ptr<ModelMaterialDataV58> materials;

public:
    ModelPermutationDataV58();
    ModelPermutationDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV58(const ModelPermutationDataV58 &p_other);
    ModelPermutationDataV58 &operator=(const ModelPermutationDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV58 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV58();
    ModelMeshLodDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV58(const ModelMeshLodDataV58 &p_other);
    ModelMeshLodDataV58 &operator=(const ModelMeshLodDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV58 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV58();
    ModelMeshMorphVertV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV58(const ModelMeshMorphVertV58 &p_other);
    ModelMeshMorphVertV58 &operator=(const ModelMeshMorphVertV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV58 {
    helpers::Array<ModelMeshMorphVertV58> positions;
    helpers::Array<ModelMeshMorphVertV58> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV58();
    ModelMeshMorphTargetV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV58(const ModelMeshMorphTargetV58 &p_other);
    ModelMeshMorphTargetV58 &operator=(const ModelMeshMorphTargetV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV58 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV58> lods;
    helpers::Array<ModelMeshMorphTargetV58> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV58();
    ModelMeshDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV58(const ModelMeshDataV58 &p_other);
    ModelMeshDataV58 &operator=(const ModelMeshDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV58 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV58();
    ModelTransformDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV58(const ModelTransformDataV58 &p_other);
    ModelTransformDataV58 &operator=(const ModelTransformDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV58 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV58 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV58();
    ModelBoneDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV58(const ModelBoneDataV58 &p_other);
    ModelBoneDataV58 &operator=(const ModelBoneDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV58 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV58();
    ModelBoneSymmetryV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV58(const ModelBoneSymmetryV58 &p_other);
    ModelBoneSymmetryV58 &operator=(const ModelBoneSymmetryV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV58 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV58> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV58> boneSymmetries;

public:
    ModelSkeletonDataV58();
    ModelSkeletonDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV58(const ModelSkeletonDataV58 &p_other);
    ModelSkeletonDataV58 &operator=(const ModelSkeletonDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV58 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV58();
    ModelMeshBindingDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV58(const ModelMeshBindingDataV58 &p_other);
    ModelMeshBindingDataV58 &operator=(const ModelMeshBindingDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV58 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV58();
    ModelTrackMaskV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV58(const ModelTrackMaskV58 &p_other);
    ModelTrackMaskV58 &operator=(const ModelTrackMaskV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV58 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV58> Skeleton;
    ModelTransformDataV58 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV58> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV58> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV58();
    ModelModelDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV58(const ModelModelDataV58 &p_other);
    ModelModelDataV58 &operator=(const ModelModelDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV58 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV58();
    ModelPropertyDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV58(const ModelPropertyDataV58 &p_other);
    ModelPropertyDataV58 &operator=(const ModelPropertyDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV58 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV58();
    ModelParticleCloudV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV58(const ModelParticleCloudV58 &p_other);
    ModelParticleCloudV58 &operator=(const ModelParticleCloudV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV58 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV58();
    ModelParticleCurveV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV58(const ModelParticleCurveV58 &p_other);
    ModelParticleCurveV58 &operator=(const ModelParticleCurveV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV58 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV58();
    ModelParticleFlipbookV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV58(const ModelParticleFlipbookV58 &p_other);
    ModelParticleFlipbookV58 &operator=(const ModelParticleFlipbookV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V58 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V58();
    ModelMatrix43V58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V58(const ModelMatrix43V58 &p_other);
    ModelMatrix43V58 &operator=(const ModelMatrix43V58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV58 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV58> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV58> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV58> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V58> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV58();
    ModelParticleEmitterV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV58(const ModelParticleEmitterV58 &p_other);
    ModelParticleEmitterV58 &operator=(const ModelParticleEmitterV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV58 {
    helpers::Array<ModelParticleCloudV58> clouds;
    helpers::Array<ModelParticleEmitterV58> emitters;

public:
    ModelCloudDataV58();
    ModelCloudDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV58(const ModelCloudDataV58 &p_other);
    ModelCloudDataV58 &operator=(const ModelCloudDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV58 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V58> transform;

public:
    ModelObstacleDataV58();
    ModelObstacleDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV58(const ModelObstacleDataV58 &p_other);
    ModelObstacleDataV58 &operator=(const ModelObstacleDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV58 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV58();
    ModelStreakV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV58(const ModelStreakV58 &p_other);
    ModelStreakV58 &operator=(const ModelStreakV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV58 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV58();
    ModelStreakAnchorV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV58(const ModelStreakAnchorV58 &p_other);
    ModelStreakAnchorV58 &operator=(const ModelStreakAnchorV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV58 {
    helpers::Array<ModelStreakV58> streaks;
    helpers::Array<ModelStreakAnchorV58> anchors;

public:
    ModelStreakDataV58();
    ModelStreakDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV58(const ModelStreakDataV58 &p_other);
    ModelStreakDataV58 &operator=(const ModelStreakDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV58 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV58();
    ModelEffectLightV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV58(const ModelEffectLightV58 &p_other);
    ModelEffectLightV58 &operator=(const ModelEffectLightV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV58 {
    helpers::Array<ModelEffectLightV58> effectLights;

public:
    ModelLightDataV58();
    ModelLightDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV58(const ModelLightDataV58 &p_other);
    ModelLightDataV58 &operator=(const ModelLightDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV58 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV58();
    ModelClothBoneWeightV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV58(const ModelClothBoneWeightV58 &p_other);
    ModelClothBoneWeightV58 &operator=(const ModelClothBoneWeightV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV58 {
    helpers::Array<ModelClothBoneWeightV58> weights;

public:
    ModelClothMeshGroupV58();
    ModelClothMeshGroupV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV58(const ModelClothMeshGroupV58 &p_other);
    ModelClothMeshGroupV58 &operator=(const ModelClothMeshGroupV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV58 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV58();
    ModelClothSoftLockV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV58(const ModelClothSoftLockV58 &p_other);
    ModelClothSoftLockV58 &operator=(const ModelClothSoftLockV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV58 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV58();
    ModelClothConstraintV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV58(const ModelClothConstraintV58 &p_other);
    ModelClothConstraintV58 &operator=(const ModelClothConstraintV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV58 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV58> groups;
    helpers::Array<ModelClothSoftLockV58> softLocks;
    helpers::Array<ModelClothConstraintV58> lod0Constraints;
    helpers::Array<ModelClothConstraintV58> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    helpers::Array<dword> lockedNormals;
    helpers::Array<dword> lockedTanegents;
    helpers::Array<dword> lockedBitangents;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV58();
    ModelClothDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV58(const ModelClothDataV58 &p_other);
    ModelClothDataV58 &operator=(const ModelClothDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV58 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV58();
    ModelLightningSystemV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV58(const ModelLightningSystemV58 &p_other);
    ModelLightningSystemV58 &operator=(const ModelLightningSystemV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV58 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV58> flipbook;
    float fps;
    float frequency;
    dword groupMax;
    dword groupMin;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float texOffset;
    float texScale;
    float texSpeed;
    byte thicknessPreset;
    float2 thicknessRange;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV58();
    ModelLightningBoltV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV58(const ModelLightningBoltV58 &p_other);
    ModelLightningBoltV58 &operator=(const ModelLightningBoltV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV58 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV58();
    ModelLightningNodeV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV58(const ModelLightningNodeV58 &p_other);
    ModelLightningNodeV58 &operator=(const ModelLightningNodeV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV58 {
    helpers::Array<ModelLightningSystemV58> systems;
    helpers::Array<ModelLightningBoltV58> bolts;
    helpers::Array<ModelLightningNodeV58> nodes;

public:
    ModelLightningDataV58();
    ModelLightningDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV58(const ModelLightningDataV58 &p_other);
    ModelLightningDataV58 &operator=(const ModelLightningDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV58 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV58();
    ModelBoneConstraintLinkV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV58(const ModelBoneConstraintLinkV58 &p_other);
    ModelBoneConstraintLinkV58 &operator=(const ModelBoneConstraintLinkV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV58 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV58> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV58();
    ModelBoneConstraintV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV58(const ModelBoneConstraintV58 &p_other);
    ModelBoneConstraintV58 &operator=(const ModelBoneConstraintV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV58 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV58();
    ModelSoftBodyDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV58(const ModelSoftBodyDataV58 &p_other);
    ModelSoftBodyDataV58 &operator=(const ModelSoftBodyDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV58 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV58();
    ModelBoneOffsetDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV58(const ModelBoneOffsetDataV58 &p_other);
    ModelBoneOffsetDataV58 &operator=(const ModelBoneOffsetDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFixedOffsetDataV58 {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetDataV58();
    ModelFixedOffsetDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetDataV58(const ModelFixedOffsetDataV58 &p_other);
    ModelFixedOffsetDataV58 &operator=(const ModelFixedOffsetDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV58 {
    helpers::Array<ModelPermutationDataV58> permutations;
    helpers::Ptr<ModelMeshDataV58> meshes;
    helpers::Ptr<ModelModelDataV58> model;
    helpers::Array<ModelPropertyDataV58> properties;
    helpers::Ptr<ModelCloudDataV58> cloudData;
    helpers::Array<ModelObstacleDataV58> obstacles;
    helpers::Ptr<ModelStreakDataV58> streakData;
    helpers::Ptr<ModelLightDataV58> lightData;
    helpers::Array<ModelClothDataV58> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV58> lightningData;
    helpers::Array<ModelBoneConstraintV58> boneConstraints;
    helpers::Array<ModelSoftBodyDataV58> softBodyData;
    helpers::Array<ModelBoneOffsetDataV58> boneOffsetData;
    helpers::Array<ModelFixedOffsetDataV58> fixedOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV58();
    ModelFileDataV58(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV58(const ModelFileDataV58 &p_other);
    ModelFileDataV58 &operator=(const ModelFileDataV58 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV58 Gw2Struct;
};

/* Version: 57, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<57>{
struct ModelTextureDataV57 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV57();
    ModelTextureDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV57(const ModelTextureDataV57 &p_other);
    ModelTextureDataV57 &operator=(const ModelTextureDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV57 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV57();
    ModelConstantDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV57(const ModelConstantDataV57 &p_other);
    ModelConstantDataV57 &operator=(const ModelConstantDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV57 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV57();
    ModelMatConstLinkV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV57(const ModelMatConstLinkV57 &p_other);
    ModelMatConstLinkV57 &operator=(const ModelMatConstLinkV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV57 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV57();
    ModelUVTransLinkV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV57(const ModelUVTransLinkV57 &p_other);
    ModelUVTransLinkV57 &operator=(const ModelUVTransLinkV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV57 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV57();
    ModelMaterialTexTransformV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV57(const ModelMaterialTexTransformV57 &p_other);
    ModelMaterialTexTransformV57 &operator=(const ModelMaterialTexTransformV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV57 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV57> textures;
    helpers::Array<ModelConstantDataV57> constants;
    helpers::Array<ModelMatConstLinkV57> matConstLinks;
    helpers::Array<ModelUVTransLinkV57> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV57> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV57();
    ModelMaterialDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV57(const ModelMaterialDataV57 &p_other);
    ModelMaterialDataV57 &operator=(const ModelMaterialDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV57 {
    qword token;
    helpers::Ptr<ModelMaterialDataV57> materials;

public:
    ModelPermutationDataV57();
    ModelPermutationDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV57(const ModelPermutationDataV57 &p_other);
    ModelPermutationDataV57 &operator=(const ModelPermutationDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV57 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV57();
    ModelMeshLodDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV57(const ModelMeshLodDataV57 &p_other);
    ModelMeshLodDataV57 &operator=(const ModelMeshLodDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV57 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV57();
    ModelMeshMorphVertV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV57(const ModelMeshMorphVertV57 &p_other);
    ModelMeshMorphVertV57 &operator=(const ModelMeshMorphVertV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV57 {
    helpers::Array<ModelMeshMorphVertV57> positions;
    helpers::Array<ModelMeshMorphVertV57> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV57();
    ModelMeshMorphTargetV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV57(const ModelMeshMorphTargetV57 &p_other);
    ModelMeshMorphTargetV57 &operator=(const ModelMeshMorphTargetV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV57 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV57> lods;
    helpers::Array<ModelMeshMorphTargetV57> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV57();
    ModelMeshDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV57(const ModelMeshDataV57 &p_other);
    ModelMeshDataV57 &operator=(const ModelMeshDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV57 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV57();
    ModelTransformDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV57(const ModelTransformDataV57 &p_other);
    ModelTransformDataV57 &operator=(const ModelTransformDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV57 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV57 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV57();
    ModelBoneDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV57(const ModelBoneDataV57 &p_other);
    ModelBoneDataV57 &operator=(const ModelBoneDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV57 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV57();
    ModelBoneSymmetryV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV57(const ModelBoneSymmetryV57 &p_other);
    ModelBoneSymmetryV57 &operator=(const ModelBoneSymmetryV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV57 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV57> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV57> boneSymmetries;

public:
    ModelSkeletonDataV57();
    ModelSkeletonDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV57(const ModelSkeletonDataV57 &p_other);
    ModelSkeletonDataV57 &operator=(const ModelSkeletonDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV57 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV57();
    ModelMeshBindingDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV57(const ModelMeshBindingDataV57 &p_other);
    ModelMeshBindingDataV57 &operator=(const ModelMeshBindingDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV57 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV57();
    ModelTrackMaskV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV57(const ModelTrackMaskV57 &p_other);
    ModelTrackMaskV57 &operator=(const ModelTrackMaskV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV57 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV57> Skeleton;
    ModelTransformDataV57 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV57> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV57> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV57();
    ModelModelDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV57(const ModelModelDataV57 &p_other);
    ModelModelDataV57 &operator=(const ModelModelDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV57 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV57();
    ModelPropertyDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV57(const ModelPropertyDataV57 &p_other);
    ModelPropertyDataV57 &operator=(const ModelPropertyDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV57 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV57();
    ModelParticleCloudV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV57(const ModelParticleCloudV57 &p_other);
    ModelParticleCloudV57 &operator=(const ModelParticleCloudV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV57 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV57();
    ModelParticleCurveV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV57(const ModelParticleCurveV57 &p_other);
    ModelParticleCurveV57 &operator=(const ModelParticleCurveV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV57 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV57();
    ModelParticleFlipbookV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV57(const ModelParticleFlipbookV57 &p_other);
    ModelParticleFlipbookV57 &operator=(const ModelParticleFlipbookV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V57 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V57();
    ModelMatrix43V57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V57(const ModelMatrix43V57 &p_other);
    ModelMatrix43V57 &operator=(const ModelMatrix43V57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV57 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV57> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV57> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV57> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V57> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV57();
    ModelParticleEmitterV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV57(const ModelParticleEmitterV57 &p_other);
    ModelParticleEmitterV57 &operator=(const ModelParticleEmitterV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV57 {
    helpers::Array<ModelParticleCloudV57> clouds;
    helpers::Array<ModelParticleEmitterV57> emitters;

public:
    ModelCloudDataV57();
    ModelCloudDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV57(const ModelCloudDataV57 &p_other);
    ModelCloudDataV57 &operator=(const ModelCloudDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV57 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V57> transform;

public:
    ModelObstacleDataV57();
    ModelObstacleDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV57(const ModelObstacleDataV57 &p_other);
    ModelObstacleDataV57 &operator=(const ModelObstacleDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV57 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV57();
    ModelStreakV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV57(const ModelStreakV57 &p_other);
    ModelStreakV57 &operator=(const ModelStreakV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV57 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV57();
    ModelStreakAnchorV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV57(const ModelStreakAnchorV57 &p_other);
    ModelStreakAnchorV57 &operator=(const ModelStreakAnchorV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV57 {
    helpers::Array<ModelStreakV57> streaks;
    helpers::Array<ModelStreakAnchorV57> anchors;

public:
    ModelStreakDataV57();
    ModelStreakDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV57(const ModelStreakDataV57 &p_other);
    ModelStreakDataV57 &operator=(const ModelStreakDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV57 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV57();
    ModelEffectLightV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV57(const ModelEffectLightV57 &p_other);
    ModelEffectLightV57 &operator=(const ModelEffectLightV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV57 {
    helpers::Array<ModelEffectLightV57> effectLights;

public:
    ModelLightDataV57();
    ModelLightDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV57(const ModelLightDataV57 &p_other);
    ModelLightDataV57 &operator=(const ModelLightDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV57 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV57();
    ModelClothBoneWeightV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV57(const ModelClothBoneWeightV57 &p_other);
    ModelClothBoneWeightV57 &operator=(const ModelClothBoneWeightV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV57 {
    helpers::Array<ModelClothBoneWeightV57> weights;

public:
    ModelClothMeshGroupV57();
    ModelClothMeshGroupV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV57(const ModelClothMeshGroupV57 &p_other);
    ModelClothMeshGroupV57 &operator=(const ModelClothMeshGroupV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV57 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV57();
    ModelClothSoftLockV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV57(const ModelClothSoftLockV57 &p_other);
    ModelClothSoftLockV57 &operator=(const ModelClothSoftLockV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV57 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV57();
    ModelClothConstraintV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV57(const ModelClothConstraintV57 &p_other);
    ModelClothConstraintV57 &operator=(const ModelClothConstraintV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV57 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV57> groups;
    helpers::Array<ModelClothSoftLockV57> softLocks;
    helpers::Array<ModelClothConstraintV57> lod0Constraints;
    helpers::Array<ModelClothConstraintV57> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV57();
    ModelClothDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV57(const ModelClothDataV57 &p_other);
    ModelClothDataV57 &operator=(const ModelClothDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV57 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV57();
    ModelLightningSystemV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV57(const ModelLightningSystemV57 &p_other);
    ModelLightningSystemV57 &operator=(const ModelLightningSystemV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV57 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV57();
    ModelLightningBoltV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV57(const ModelLightningBoltV57 &p_other);
    ModelLightningBoltV57 &operator=(const ModelLightningBoltV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV57 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV57();
    ModelLightningNodeV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV57(const ModelLightningNodeV57 &p_other);
    ModelLightningNodeV57 &operator=(const ModelLightningNodeV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV57 {
    helpers::Array<ModelLightningSystemV57> systems;
    helpers::Array<ModelLightningBoltV57> bolts;
    helpers::Array<ModelLightningNodeV57> nodes;

public:
    ModelLightningDataV57();
    ModelLightningDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV57(const ModelLightningDataV57 &p_other);
    ModelLightningDataV57 &operator=(const ModelLightningDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV57 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV57();
    ModelBoneConstraintLinkV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV57(const ModelBoneConstraintLinkV57 &p_other);
    ModelBoneConstraintLinkV57 &operator=(const ModelBoneConstraintLinkV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV57 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV57> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV57();
    ModelBoneConstraintV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV57(const ModelBoneConstraintV57 &p_other);
    ModelBoneConstraintV57 &operator=(const ModelBoneConstraintV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV57 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV57();
    ModelSoftBodyDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV57(const ModelSoftBodyDataV57 &p_other);
    ModelSoftBodyDataV57 &operator=(const ModelSoftBodyDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV57 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV57();
    ModelBoneOffsetDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV57(const ModelBoneOffsetDataV57 &p_other);
    ModelBoneOffsetDataV57 &operator=(const ModelBoneOffsetDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFixedOffsetDataV57 {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetDataV57();
    ModelFixedOffsetDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetDataV57(const ModelFixedOffsetDataV57 &p_other);
    ModelFixedOffsetDataV57 &operator=(const ModelFixedOffsetDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV57 {
    helpers::Array<ModelPermutationDataV57> permutations;
    helpers::Ptr<ModelMeshDataV57> meshes;
    helpers::Ptr<ModelModelDataV57> model;
    helpers::Array<ModelPropertyDataV57> properties;
    helpers::Ptr<ModelCloudDataV57> cloudData;
    helpers::Array<ModelObstacleDataV57> obstacles;
    helpers::Ptr<ModelStreakDataV57> streakData;
    helpers::Ptr<ModelLightDataV57> lightData;
    helpers::Array<ModelClothDataV57> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV57> lightningData;
    helpers::Array<ModelBoneConstraintV57> boneConstraints;
    helpers::Array<ModelSoftBodyDataV57> softBodyData;
    helpers::Array<ModelBoneOffsetDataV57> boneOffsetData;
    helpers::Array<ModelFixedOffsetDataV57> fixedOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV57();
    ModelFileDataV57(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV57(const ModelFileDataV57 &p_other);
    ModelFileDataV57 &operator=(const ModelFileDataV57 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV57 Gw2Struct;
};

/* Version: 56, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<56>{
struct ModelTextureDataV56 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV56();
    ModelTextureDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV56(const ModelTextureDataV56 &p_other);
    ModelTextureDataV56 &operator=(const ModelTextureDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV56 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV56();
    ModelConstantDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV56(const ModelConstantDataV56 &p_other);
    ModelConstantDataV56 &operator=(const ModelConstantDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV56 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV56();
    ModelMatConstLinkV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV56(const ModelMatConstLinkV56 &p_other);
    ModelMatConstLinkV56 &operator=(const ModelMatConstLinkV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV56 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV56();
    ModelUVTransLinkV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV56(const ModelUVTransLinkV56 &p_other);
    ModelUVTransLinkV56 &operator=(const ModelUVTransLinkV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV56 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV56();
    ModelMaterialTexTransformV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV56(const ModelMaterialTexTransformV56 &p_other);
    ModelMaterialTexTransformV56 &operator=(const ModelMaterialTexTransformV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV56 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV56> textures;
    helpers::Array<ModelConstantDataV56> constants;
    helpers::Array<ModelMatConstLinkV56> matConstLinks;
    helpers::Array<ModelUVTransLinkV56> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV56> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV56();
    ModelMaterialDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV56(const ModelMaterialDataV56 &p_other);
    ModelMaterialDataV56 &operator=(const ModelMaterialDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV56 {
    qword token;
    helpers::Ptr<ModelMaterialDataV56> materials;

public:
    ModelPermutationDataV56();
    ModelPermutationDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV56(const ModelPermutationDataV56 &p_other);
    ModelPermutationDataV56 &operator=(const ModelPermutationDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV56 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV56();
    ModelMeshLodDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV56(const ModelMeshLodDataV56 &p_other);
    ModelMeshLodDataV56 &operator=(const ModelMeshLodDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV56 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV56();
    ModelMeshMorphVertV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV56(const ModelMeshMorphVertV56 &p_other);
    ModelMeshMorphVertV56 &operator=(const ModelMeshMorphVertV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV56 {
    helpers::Array<ModelMeshMorphVertV56> positions;
    helpers::Array<ModelMeshMorphVertV56> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV56();
    ModelMeshMorphTargetV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV56(const ModelMeshMorphTargetV56 &p_other);
    ModelMeshMorphTargetV56 &operator=(const ModelMeshMorphTargetV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV56 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV56> lods;
    helpers::Array<ModelMeshMorphTargetV56> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV56();
    ModelMeshDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV56(const ModelMeshDataV56 &p_other);
    ModelMeshDataV56 &operator=(const ModelMeshDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV56 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV56();
    ModelTransformDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV56(const ModelTransformDataV56 &p_other);
    ModelTransformDataV56 &operator=(const ModelTransformDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV56 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV56 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV56();
    ModelBoneDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV56(const ModelBoneDataV56 &p_other);
    ModelBoneDataV56 &operator=(const ModelBoneDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV56 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV56();
    ModelBoneSymmetryV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV56(const ModelBoneSymmetryV56 &p_other);
    ModelBoneSymmetryV56 &operator=(const ModelBoneSymmetryV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV56 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV56> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV56> boneSymmetries;

public:
    ModelSkeletonDataV56();
    ModelSkeletonDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV56(const ModelSkeletonDataV56 &p_other);
    ModelSkeletonDataV56 &operator=(const ModelSkeletonDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV56 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV56();
    ModelMeshBindingDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV56(const ModelMeshBindingDataV56 &p_other);
    ModelMeshBindingDataV56 &operator=(const ModelMeshBindingDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV56 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV56();
    ModelTrackMaskV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV56(const ModelTrackMaskV56 &p_other);
    ModelTrackMaskV56 &operator=(const ModelTrackMaskV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV56 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV56> Skeleton;
    ModelTransformDataV56 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV56> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV56> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV56();
    ModelModelDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV56(const ModelModelDataV56 &p_other);
    ModelModelDataV56 &operator=(const ModelModelDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV56 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV56();
    ModelPropertyDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV56(const ModelPropertyDataV56 &p_other);
    ModelPropertyDataV56 &operator=(const ModelPropertyDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV56 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV56();
    ModelParticleCloudV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV56(const ModelParticleCloudV56 &p_other);
    ModelParticleCloudV56 &operator=(const ModelParticleCloudV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV56 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV56();
    ModelParticleCurveV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV56(const ModelParticleCurveV56 &p_other);
    ModelParticleCurveV56 &operator=(const ModelParticleCurveV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV56 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV56();
    ModelParticleFlipbookV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV56(const ModelParticleFlipbookV56 &p_other);
    ModelParticleFlipbookV56 &operator=(const ModelParticleFlipbookV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V56 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V56();
    ModelMatrix43V56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V56(const ModelMatrix43V56 &p_other);
    ModelMatrix43V56 &operator=(const ModelMatrix43V56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV56 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV56> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV56> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV56> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V56> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV56();
    ModelParticleEmitterV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV56(const ModelParticleEmitterV56 &p_other);
    ModelParticleEmitterV56 &operator=(const ModelParticleEmitterV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV56 {
    helpers::Array<ModelParticleCloudV56> clouds;
    helpers::Array<ModelParticleEmitterV56> emitters;

public:
    ModelCloudDataV56();
    ModelCloudDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV56(const ModelCloudDataV56 &p_other);
    ModelCloudDataV56 &operator=(const ModelCloudDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV56 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V56> transform;

public:
    ModelObstacleDataV56();
    ModelObstacleDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV56(const ModelObstacleDataV56 &p_other);
    ModelObstacleDataV56 &operator=(const ModelObstacleDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV56 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV56();
    ModelStreakV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV56(const ModelStreakV56 &p_other);
    ModelStreakV56 &operator=(const ModelStreakV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV56 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV56();
    ModelStreakAnchorV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV56(const ModelStreakAnchorV56 &p_other);
    ModelStreakAnchorV56 &operator=(const ModelStreakAnchorV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV56 {
    helpers::Array<ModelStreakV56> streaks;
    helpers::Array<ModelStreakAnchorV56> anchors;

public:
    ModelStreakDataV56();
    ModelStreakDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV56(const ModelStreakDataV56 &p_other);
    ModelStreakDataV56 &operator=(const ModelStreakDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV56 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV56();
    ModelEffectLightV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV56(const ModelEffectLightV56 &p_other);
    ModelEffectLightV56 &operator=(const ModelEffectLightV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV56 {
    helpers::Array<ModelEffectLightV56> effectLights;

public:
    ModelLightDataV56();
    ModelLightDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV56(const ModelLightDataV56 &p_other);
    ModelLightDataV56 &operator=(const ModelLightDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV56 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV56();
    ModelClothBoneWeightV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV56(const ModelClothBoneWeightV56 &p_other);
    ModelClothBoneWeightV56 &operator=(const ModelClothBoneWeightV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV56 {
    helpers::Array<ModelClothBoneWeightV56> weights;

public:
    ModelClothMeshGroupV56();
    ModelClothMeshGroupV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV56(const ModelClothMeshGroupV56 &p_other);
    ModelClothMeshGroupV56 &operator=(const ModelClothMeshGroupV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV56 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV56();
    ModelClothSoftLockV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV56(const ModelClothSoftLockV56 &p_other);
    ModelClothSoftLockV56 &operator=(const ModelClothSoftLockV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV56 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV56();
    ModelClothConstraintV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV56(const ModelClothConstraintV56 &p_other);
    ModelClothConstraintV56 &operator=(const ModelClothConstraintV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV56 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV56> groups;
    helpers::Array<ModelClothSoftLockV56> softLocks;
    helpers::Array<ModelClothConstraintV56> lod0Constraints;
    helpers::Array<ModelClothConstraintV56> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV56();
    ModelClothDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV56(const ModelClothDataV56 &p_other);
    ModelClothDataV56 &operator=(const ModelClothDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV56 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV56();
    ModelLightningSystemV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV56(const ModelLightningSystemV56 &p_other);
    ModelLightningSystemV56 &operator=(const ModelLightningSystemV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV56 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV56();
    ModelLightningBoltV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV56(const ModelLightningBoltV56 &p_other);
    ModelLightningBoltV56 &operator=(const ModelLightningBoltV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV56 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV56();
    ModelLightningNodeV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV56(const ModelLightningNodeV56 &p_other);
    ModelLightningNodeV56 &operator=(const ModelLightningNodeV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV56 {
    helpers::Array<ModelLightningSystemV56> systems;
    helpers::Array<ModelLightningBoltV56> bolts;
    helpers::Array<ModelLightningNodeV56> nodes;

public:
    ModelLightningDataV56();
    ModelLightningDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV56(const ModelLightningDataV56 &p_other);
    ModelLightningDataV56 &operator=(const ModelLightningDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV56 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV56();
    ModelBoneConstraintLinkV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV56(const ModelBoneConstraintLinkV56 &p_other);
    ModelBoneConstraintLinkV56 &operator=(const ModelBoneConstraintLinkV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV56 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV56> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV56();
    ModelBoneConstraintV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV56(const ModelBoneConstraintV56 &p_other);
    ModelBoneConstraintV56 &operator=(const ModelBoneConstraintV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV56 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV56();
    ModelSoftBodyDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV56(const ModelSoftBodyDataV56 &p_other);
    ModelSoftBodyDataV56 &operator=(const ModelSoftBodyDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV56 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV56();
    ModelBoneOffsetDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV56(const ModelBoneOffsetDataV56 &p_other);
    ModelBoneOffsetDataV56 &operator=(const ModelBoneOffsetDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV56 {
    helpers::Array<ModelPermutationDataV56> permutations;
    helpers::Ptr<ModelMeshDataV56> meshes;
    helpers::Ptr<ModelModelDataV56> model;
    helpers::Array<ModelPropertyDataV56> properties;
    helpers::Ptr<ModelCloudDataV56> cloudData;
    helpers::Array<ModelObstacleDataV56> obstacles;
    helpers::Ptr<ModelStreakDataV56> streakData;
    helpers::Ptr<ModelLightDataV56> lightData;
    helpers::Array<ModelClothDataV56> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV56> lightningData;
    helpers::Array<ModelBoneConstraintV56> boneConstraints;
    helpers::Array<ModelSoftBodyDataV56> softBodyData;
    helpers::Array<ModelBoneOffsetDataV56> boneOffsetData;
    helpers::FileName modelReference;

public:
    ModelFileDataV56();
    ModelFileDataV56(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV56(const ModelFileDataV56 &p_other);
    ModelFileDataV56 &operator=(const ModelFileDataV56 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV56 Gw2Struct;
};

/* Version: 55, ReferencedFunction: 0x410DB6A000000001 */

template <>
struct Gw2StructMODL<55>{
struct ModelTextureDataV55 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV55();
    ModelTextureDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV55(const ModelTextureDataV55 &p_other);
    ModelTextureDataV55 &operator=(const ModelTextureDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV55 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV55();
    ModelConstantDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV55(const ModelConstantDataV55 &p_other);
    ModelConstantDataV55 &operator=(const ModelConstantDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV55 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV55();
    ModelMatConstLinkV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV55(const ModelMatConstLinkV55 &p_other);
    ModelMatConstLinkV55 &operator=(const ModelMatConstLinkV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV55 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV55();
    ModelUVTransLinkV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV55(const ModelUVTransLinkV55 &p_other);
    ModelUVTransLinkV55 &operator=(const ModelUVTransLinkV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV55 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV55();
    ModelMaterialTexTransformV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV55(const ModelMaterialTexTransformV55 &p_other);
    ModelMaterialTexTransformV55 &operator=(const ModelMaterialTexTransformV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV55 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV55> textures;
    helpers::Array<ModelConstantDataV55> constants;
    helpers::Array<ModelMatConstLinkV55> matConstLinks;
    helpers::Array<ModelUVTransLinkV55> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV55> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV55();
    ModelMaterialDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV55(const ModelMaterialDataV55 &p_other);
    ModelMaterialDataV55 &operator=(const ModelMaterialDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV55 {
    qword token;
    helpers::Ptr<ModelMaterialDataV55> materials;

public:
    ModelPermutationDataV55();
    ModelPermutationDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV55(const ModelPermutationDataV55 &p_other);
    ModelPermutationDataV55 &operator=(const ModelPermutationDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV55 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV55();
    ModelMeshLodDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV55(const ModelMeshLodDataV55 &p_other);
    ModelMeshLodDataV55 &operator=(const ModelMeshLodDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV55 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV55();
    ModelMeshMorphVertV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV55(const ModelMeshMorphVertV55 &p_other);
    ModelMeshMorphVertV55 &operator=(const ModelMeshMorphVertV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV55 {
    helpers::Array<ModelMeshMorphVertV55> positions;
    helpers::Array<ModelMeshMorphVertV55> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV55();
    ModelMeshMorphTargetV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV55(const ModelMeshMorphTargetV55 &p_other);
    ModelMeshMorphTargetV55 &operator=(const ModelMeshMorphTargetV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV55 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV55> lods;
    helpers::Array<ModelMeshMorphTargetV55> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV55();
    ModelMeshDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV55(const ModelMeshDataV55 &p_other);
    ModelMeshDataV55 &operator=(const ModelMeshDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV55 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV55();
    ModelTransformDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV55(const ModelTransformDataV55 &p_other);
    ModelTransformDataV55 &operator=(const ModelTransformDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV55 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV55 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV55();
    ModelBoneDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV55(const ModelBoneDataV55 &p_other);
    ModelBoneDataV55 &operator=(const ModelBoneDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV55 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV55();
    ModelBoneSymmetryV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV55(const ModelBoneSymmetryV55 &p_other);
    ModelBoneSymmetryV55 &operator=(const ModelBoneSymmetryV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV55 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV55> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV55> boneSymmetries;

public:
    ModelSkeletonDataV55();
    ModelSkeletonDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV55(const ModelSkeletonDataV55 &p_other);
    ModelSkeletonDataV55 &operator=(const ModelSkeletonDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV55 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV55();
    ModelMeshBindingDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV55(const ModelMeshBindingDataV55 &p_other);
    ModelMeshBindingDataV55 &operator=(const ModelMeshBindingDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV55 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV55();
    ModelTrackMaskV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV55(const ModelTrackMaskV55 &p_other);
    ModelTrackMaskV55 &operator=(const ModelTrackMaskV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV55 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV55> Skeleton;
    ModelTransformDataV55 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV55> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV55> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV55();
    ModelModelDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV55(const ModelModelDataV55 &p_other);
    ModelModelDataV55 &operator=(const ModelModelDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV55 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV55();
    ModelPropertyDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV55(const ModelPropertyDataV55 &p_other);
    ModelPropertyDataV55 &operator=(const ModelPropertyDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV55 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV55();
    ModelParticleCloudV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV55(const ModelParticleCloudV55 &p_other);
    ModelParticleCloudV55 &operator=(const ModelParticleCloudV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV55 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV55();
    ModelParticleCurveV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV55(const ModelParticleCurveV55 &p_other);
    ModelParticleCurveV55 &operator=(const ModelParticleCurveV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV55 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV55();
    ModelParticleFlipbookV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV55(const ModelParticleFlipbookV55 &p_other);
    ModelParticleFlipbookV55 &operator=(const ModelParticleFlipbookV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V55 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V55();
    ModelMatrix43V55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V55(const ModelMatrix43V55 &p_other);
    ModelMatrix43V55 &operator=(const ModelMatrix43V55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV55 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV55> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV55> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV55> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V55> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV55();
    ModelParticleEmitterV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV55(const ModelParticleEmitterV55 &p_other);
    ModelParticleEmitterV55 &operator=(const ModelParticleEmitterV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV55 {
    helpers::Array<ModelParticleCloudV55> clouds;
    helpers::Array<ModelParticleEmitterV55> emitters;

public:
    ModelCloudDataV55();
    ModelCloudDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV55(const ModelCloudDataV55 &p_other);
    ModelCloudDataV55 &operator=(const ModelCloudDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV55 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V55> transform;

public:
    ModelObstacleDataV55();
    ModelObstacleDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV55(const ModelObstacleDataV55 &p_other);
    ModelObstacleDataV55 &operator=(const ModelObstacleDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV55 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV55();
    ModelStreakV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV55(const ModelStreakV55 &p_other);
    ModelStreakV55 &operator=(const ModelStreakV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV55 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV55();
    ModelStreakAnchorV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV55(const ModelStreakAnchorV55 &p_other);
    ModelStreakAnchorV55 &operator=(const ModelStreakAnchorV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV55 {
    helpers::Array<ModelStreakV55> streaks;
    helpers::Array<ModelStreakAnchorV55> anchors;

public:
    ModelStreakDataV55();
    ModelStreakDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV55(const ModelStreakDataV55 &p_other);
    ModelStreakDataV55 &operator=(const ModelStreakDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV55 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV55();
    ModelEffectLightV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV55(const ModelEffectLightV55 &p_other);
    ModelEffectLightV55 &operator=(const ModelEffectLightV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV55 {
    helpers::Array<ModelEffectLightV55> effectLights;

public:
    ModelLightDataV55();
    ModelLightDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV55(const ModelLightDataV55 &p_other);
    ModelLightDataV55 &operator=(const ModelLightDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV55 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV55();
    ModelClothBoneWeightV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV55(const ModelClothBoneWeightV55 &p_other);
    ModelClothBoneWeightV55 &operator=(const ModelClothBoneWeightV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV55 {
    helpers::Array<ModelClothBoneWeightV55> weights;

public:
    ModelClothMeshGroupV55();
    ModelClothMeshGroupV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV55(const ModelClothMeshGroupV55 &p_other);
    ModelClothMeshGroupV55 &operator=(const ModelClothMeshGroupV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV55 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV55();
    ModelClothSoftLockV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV55(const ModelClothSoftLockV55 &p_other);
    ModelClothSoftLockV55 &operator=(const ModelClothSoftLockV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV55 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV55();
    ModelClothConstraintV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV55(const ModelClothConstraintV55 &p_other);
    ModelClothConstraintV55 &operator=(const ModelClothConstraintV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV55 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV55> groups;
    helpers::Array<ModelClothSoftLockV55> softLocks;
    helpers::Array<ModelClothConstraintV55> lod0Constraints;
    helpers::Array<ModelClothConstraintV55> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV55();
    ModelClothDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV55(const ModelClothDataV55 &p_other);
    ModelClothDataV55 &operator=(const ModelClothDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV55 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV55();
    ModelLightningSystemV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV55(const ModelLightningSystemV55 &p_other);
    ModelLightningSystemV55 &operator=(const ModelLightningSystemV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV55 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV55();
    ModelLightningBoltV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV55(const ModelLightningBoltV55 &p_other);
    ModelLightningBoltV55 &operator=(const ModelLightningBoltV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV55 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV55();
    ModelLightningNodeV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV55(const ModelLightningNodeV55 &p_other);
    ModelLightningNodeV55 &operator=(const ModelLightningNodeV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV55 {
    helpers::Array<ModelLightningSystemV55> systems;
    helpers::Array<ModelLightningBoltV55> bolts;
    helpers::Array<ModelLightningNodeV55> nodes;

public:
    ModelLightningDataV55();
    ModelLightningDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV55(const ModelLightningDataV55 &p_other);
    ModelLightningDataV55 &operator=(const ModelLightningDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV55 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV55();
    ModelBoneConstraintLinkV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV55(const ModelBoneConstraintLinkV55 &p_other);
    ModelBoneConstraintLinkV55 &operator=(const ModelBoneConstraintLinkV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV55 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV55> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV55();
    ModelBoneConstraintV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV55(const ModelBoneConstraintV55 &p_other);
    ModelBoneConstraintV55 &operator=(const ModelBoneConstraintV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV55 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV55();
    ModelSoftBodyDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV55(const ModelSoftBodyDataV55 &p_other);
    ModelSoftBodyDataV55 &operator=(const ModelSoftBodyDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV55 {
    qword bone;
    float3 translation;
    float4 rotation;
    float4 boneInverseOffset[3];

public:
    ModelBoneOffsetDataV55();
    ModelBoneOffsetDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV55(const ModelBoneOffsetDataV55 &p_other);
    ModelBoneOffsetDataV55 &operator=(const ModelBoneOffsetDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV55 {
    helpers::Array<ModelPermutationDataV55> permutations;
    helpers::Ptr<ModelMeshDataV55> meshes;
    helpers::Ptr<ModelModelDataV55> model;
    helpers::Array<ModelPropertyDataV55> properties;
    helpers::Ptr<ModelCloudDataV55> cloudData;
    helpers::Array<ModelObstacleDataV55> obstacles;
    helpers::Ptr<ModelStreakDataV55> streakData;
    helpers::Ptr<ModelLightDataV55> lightData;
    helpers::Array<ModelClothDataV55> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV55> lightningData;
    helpers::Array<ModelBoneConstraintV55> boneConstraints;
    helpers::Array<ModelSoftBodyDataV55> softBodyData;
    helpers::Array<ModelBoneOffsetDataV55> boneOffsetData;

public:
    ModelFileDataV55();
    ModelFileDataV55(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV55(const ModelFileDataV55 &p_other);
    ModelFileDataV55 &operator=(const ModelFileDataV55 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV55 Gw2Struct;
};

/* Version: 54, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<54>{
struct ModelTextureDataV54 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV54();
    ModelTextureDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV54(const ModelTextureDataV54 &p_other);
    ModelTextureDataV54 &operator=(const ModelTextureDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV54 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV54();
    ModelConstantDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV54(const ModelConstantDataV54 &p_other);
    ModelConstantDataV54 &operator=(const ModelConstantDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV54 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV54();
    ModelMatConstLinkV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV54(const ModelMatConstLinkV54 &p_other);
    ModelMatConstLinkV54 &operator=(const ModelMatConstLinkV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV54 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV54();
    ModelUVTransLinkV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV54(const ModelUVTransLinkV54 &p_other);
    ModelUVTransLinkV54 &operator=(const ModelUVTransLinkV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV54 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV54();
    ModelMaterialTexTransformV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV54(const ModelMaterialTexTransformV54 &p_other);
    ModelMaterialTexTransformV54 &operator=(const ModelMaterialTexTransformV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV54 {
    qword token;
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV54> textures;
    helpers::Array<ModelConstantDataV54> constants;
    helpers::Array<ModelMatConstLinkV54> matConstLinks;
    helpers::Array<ModelUVTransLinkV54> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV54> texTransforms;
    byte texCoordCount;

public:
    ModelMaterialDataV54();
    ModelMaterialDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV54(const ModelMaterialDataV54 &p_other);
    ModelMaterialDataV54 &operator=(const ModelMaterialDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV54 {
    qword token;
    helpers::Ptr<ModelMaterialDataV54> materials;

public:
    ModelPermutationDataV54();
    ModelPermutationDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV54(const ModelPermutationDataV54 &p_other);
    ModelPermutationDataV54 &operator=(const ModelPermutationDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV54 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV54();
    ModelMeshLodDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV54(const ModelMeshLodDataV54 &p_other);
    ModelMeshLodDataV54 &operator=(const ModelMeshLodDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV54 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV54();
    ModelMeshMorphVertV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV54(const ModelMeshMorphVertV54 &p_other);
    ModelMeshMorphVertV54 &operator=(const ModelMeshMorphVertV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV54 {
    helpers::Array<ModelMeshMorphVertV54> positions;
    helpers::Array<ModelMeshMorphVertV54> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV54();
    ModelMeshMorphTargetV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV54(const ModelMeshMorphTargetV54 &p_other);
    ModelMeshMorphTargetV54 &operator=(const ModelMeshMorphTargetV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV54 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV54> lods;
    helpers::Array<ModelMeshMorphTargetV54> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV54();
    ModelMeshDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV54(const ModelMeshDataV54 &p_other);
    ModelMeshDataV54 &operator=(const ModelMeshDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV54 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV54();
    ModelTransformDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV54(const ModelTransformDataV54 &p_other);
    ModelTransformDataV54 &operator=(const ModelTransformDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV54 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV54 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV54();
    ModelBoneDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV54(const ModelBoneDataV54 &p_other);
    ModelBoneDataV54 &operator=(const ModelBoneDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV54 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV54();
    ModelBoneSymmetryV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV54(const ModelBoneSymmetryV54 &p_other);
    ModelBoneSymmetryV54 &operator=(const ModelBoneSymmetryV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV54 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV54> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<ModelBoneSymmetryV54> boneSymmetries;

public:
    ModelSkeletonDataV54();
    ModelSkeletonDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV54(const ModelSkeletonDataV54 &p_other);
    ModelSkeletonDataV54 &operator=(const ModelSkeletonDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV54 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV54();
    ModelMeshBindingDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV54(const ModelMeshBindingDataV54 &p_other);
    ModelMeshBindingDataV54 &operator=(const ModelMeshBindingDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV54 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV54();
    ModelTrackMaskV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV54(const ModelTrackMaskV54 &p_other);
    ModelTrackMaskV54 &operator=(const ModelTrackMaskV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV54 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV54> Skeleton;
    ModelTransformDataV54 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV54> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV54> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV54();
    ModelModelDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV54(const ModelModelDataV54 &p_other);
    ModelModelDataV54 &operator=(const ModelModelDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV54 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV54();
    ModelPropertyDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV54(const ModelPropertyDataV54 &p_other);
    ModelPropertyDataV54 &operator=(const ModelPropertyDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV54 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV54();
    ModelParticleCloudV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV54(const ModelParticleCloudV54 &p_other);
    ModelParticleCloudV54 &operator=(const ModelParticleCloudV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV54 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV54();
    ModelParticleCurveV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV54(const ModelParticleCurveV54 &p_other);
    ModelParticleCurveV54 &operator=(const ModelParticleCurveV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV54 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV54();
    ModelParticleFlipbookV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV54(const ModelParticleFlipbookV54 &p_other);
    ModelParticleFlipbookV54 &operator=(const ModelParticleFlipbookV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V54 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V54();
    ModelMatrix43V54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V54(const ModelMatrix43V54 &p_other);
    ModelMatrix43V54 &operator=(const ModelMatrix43V54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV54 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV54> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV54> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV54> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    helpers::Ptr<ModelMatrix43V54> transform;
    byte windInfluence;
    byte alignmentType;
    byte spawnShape;

public:
    ModelParticleEmitterV54();
    ModelParticleEmitterV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV54(const ModelParticleEmitterV54 &p_other);
    ModelParticleEmitterV54 &operator=(const ModelParticleEmitterV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV54 {
    helpers::Array<ModelParticleCloudV54> clouds;
    helpers::Array<ModelParticleEmitterV54> emitters;

public:
    ModelCloudDataV54();
    ModelCloudDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV54(const ModelCloudDataV54 &p_other);
    ModelCloudDataV54 &operator=(const ModelCloudDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV54 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V54> transform;

public:
    ModelObstacleDataV54();
    ModelObstacleDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV54(const ModelObstacleDataV54 &p_other);
    ModelObstacleDataV54 &operator=(const ModelObstacleDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV54 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV54();
    ModelStreakV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV54(const ModelStreakV54 &p_other);
    ModelStreakV54 &operator=(const ModelStreakV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV54 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV54();
    ModelStreakAnchorV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV54(const ModelStreakAnchorV54 &p_other);
    ModelStreakAnchorV54 &operator=(const ModelStreakAnchorV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV54 {
    helpers::Array<ModelStreakV54> streaks;
    helpers::Array<ModelStreakAnchorV54> anchors;

public:
    ModelStreakDataV54();
    ModelStreakDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV54(const ModelStreakDataV54 &p_other);
    ModelStreakDataV54 &operator=(const ModelStreakDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV54 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV54();
    ModelEffectLightV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV54(const ModelEffectLightV54 &p_other);
    ModelEffectLightV54 &operator=(const ModelEffectLightV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV54 {
    helpers::Array<ModelEffectLightV54> effectLights;

public:
    ModelLightDataV54();
    ModelLightDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV54(const ModelLightDataV54 &p_other);
    ModelLightDataV54 &operator=(const ModelLightDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV54 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV54();
    ModelClothBoneWeightV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV54(const ModelClothBoneWeightV54 &p_other);
    ModelClothBoneWeightV54 &operator=(const ModelClothBoneWeightV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV54 {
    helpers::Array<ModelClothBoneWeightV54> weights;

public:
    ModelClothMeshGroupV54();
    ModelClothMeshGroupV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV54(const ModelClothMeshGroupV54 &p_other);
    ModelClothMeshGroupV54 &operator=(const ModelClothMeshGroupV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV54 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV54();
    ModelClothSoftLockV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV54(const ModelClothSoftLockV54 &p_other);
    ModelClothSoftLockV54 &operator=(const ModelClothSoftLockV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV54 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV54();
    ModelClothConstraintV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV54(const ModelClothConstraintV54 &p_other);
    ModelClothConstraintV54 &operator=(const ModelClothConstraintV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV54 {
    dword materialIndex;
    float drag;
    float gravity;
    float compressibility;
    float slack;
    float stretchiness;
    float weight;
    float wind;
    PackVertexType mesh;
    helpers::Array<word> indices;
    helpers::Array<ModelClothMeshGroupV54> groups;
    helpers::Array<ModelClothSoftLockV54> softLocks;
    helpers::Array<ModelClothConstraintV54> lod0Constraints;
    helpers::Array<ModelClothConstraintV54> lod1Constraints;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;
    word lockCount;
    word lod1VertexCount;
    byte flags;
    byte rigidness;

public:
    ModelClothDataV54();
    ModelClothDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV54(const ModelClothDataV54 &p_other);
    ModelClothDataV54 &operator=(const ModelClothDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV54 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV54();
    ModelLightningSystemV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV54(const ModelLightningSystemV54 &p_other);
    ModelLightningSystemV54 &operator=(const ModelLightningSystemV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV54 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV54();
    ModelLightningBoltV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV54(const ModelLightningBoltV54 &p_other);
    ModelLightningBoltV54 &operator=(const ModelLightningBoltV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV54 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV54();
    ModelLightningNodeV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV54(const ModelLightningNodeV54 &p_other);
    ModelLightningNodeV54 &operator=(const ModelLightningNodeV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV54 {
    helpers::Array<ModelLightningSystemV54> systems;
    helpers::Array<ModelLightningBoltV54> bolts;
    helpers::Array<ModelLightningNodeV54> nodes;

public:
    ModelLightningDataV54();
    ModelLightningDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV54(const ModelLightningDataV54 &p_other);
    ModelLightningDataV54 &operator=(const ModelLightningDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV54 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV54();
    ModelBoneConstraintLinkV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV54(const ModelBoneConstraintLinkV54 &p_other);
    ModelBoneConstraintLinkV54 &operator=(const ModelBoneConstraintLinkV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV54 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV54> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV54();
    ModelBoneConstraintV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV54(const ModelBoneConstraintV54 &p_other);
    ModelBoneConstraintV54 &operator=(const ModelBoneConstraintV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV54 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV54();
    ModelSoftBodyDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV54(const ModelSoftBodyDataV54 &p_other);
    ModelSoftBodyDataV54 &operator=(const ModelSoftBodyDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV54 {
    qword bone;
    float3 translation;
    float4 rotation;

public:
    ModelBoneOffsetDataV54();
    ModelBoneOffsetDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV54(const ModelBoneOffsetDataV54 &p_other);
    ModelBoneOffsetDataV54 &operator=(const ModelBoneOffsetDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV54 {
    helpers::Array<ModelPermutationDataV54> permutations;
    helpers::Ptr<ModelMeshDataV54> meshes;
    helpers::Ptr<ModelModelDataV54> model;
    helpers::Array<ModelPropertyDataV54> properties;
    helpers::Ptr<ModelCloudDataV54> cloudData;
    helpers::Array<ModelObstacleDataV54> obstacles;
    helpers::Ptr<ModelStreakDataV54> streakData;
    helpers::Ptr<ModelLightDataV54> lightData;
    helpers::Array<ModelClothDataV54> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV54> lightningData;
    helpers::Array<ModelBoneConstraintV54> boneConstraints;
    helpers::Array<ModelSoftBodyDataV54> softBodyData;
    helpers::Array<ModelBoneOffsetDataV54> boneOffsetData;

public:
    ModelFileDataV54();
    ModelFileDataV54(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV54(const ModelFileDataV54 &p_other);
    ModelFileDataV54 &operator=(const ModelFileDataV54 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV54 Gw2Struct;
};

/* Version: 53, ReferencedFunction: 0x410DB35000000001 */

template <>
struct Gw2StructMODL<53>{
struct ModelTextureDataV53 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV53();
    ModelTextureDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV53(const ModelTextureDataV53 &p_other);
    ModelTextureDataV53 &operator=(const ModelTextureDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV53 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV53();
    ModelConstantDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV53(const ModelConstantDataV53 &p_other);
    ModelConstantDataV53 &operator=(const ModelConstantDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV53 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV53();
    ModelMatConstLinkV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV53(const ModelMatConstLinkV53 &p_other);
    ModelMatConstLinkV53 &operator=(const ModelMatConstLinkV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV53 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV53();
    ModelUVTransLinkV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV53(const ModelUVTransLinkV53 &p_other);
    ModelUVTransLinkV53 &operator=(const ModelUVTransLinkV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV53 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV53();
    ModelMaterialTexTransformV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV53(const ModelMaterialTexTransformV53 &p_other);
    ModelMaterialTexTransformV53 &operator=(const ModelMaterialTexTransformV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV53 {
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV53> textures;
    helpers::Array<ModelConstantDataV53> constants;
    helpers::Array<ModelMatConstLinkV53> matConstLinks;
    helpers::Array<ModelUVTransLinkV53> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV53> texTransforms;

public:
    ModelMaterialDataV53();
    ModelMaterialDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV53(const ModelMaterialDataV53 &p_other);
    ModelMaterialDataV53 &operator=(const ModelMaterialDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV53 {
    qword token;
    helpers::Ptr<ModelMaterialDataV53> materials;

public:
    ModelPermutationDataV53();
    ModelPermutationDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV53(const ModelPermutationDataV53 &p_other);
    ModelPermutationDataV53 &operator=(const ModelPermutationDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV53 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV53();
    ModelMeshLodDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV53(const ModelMeshLodDataV53 &p_other);
    ModelMeshLodDataV53 &operator=(const ModelMeshLodDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV53 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV53();
    ModelMeshMorphVertV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV53(const ModelMeshMorphVertV53 &p_other);
    ModelMeshMorphVertV53 &operator=(const ModelMeshMorphVertV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV53 {
    helpers::Array<ModelMeshMorphVertV53> positions;
    helpers::Array<ModelMeshMorphVertV53> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV53();
    ModelMeshMorphTargetV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV53(const ModelMeshMorphTargetV53 &p_other);
    ModelMeshMorphTargetV53 &operator=(const ModelMeshMorphTargetV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV53 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV53> lods;
    helpers::Array<ModelMeshMorphTargetV53> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV53();
    ModelMeshDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV53(const ModelMeshDataV53 &p_other);
    ModelMeshDataV53 &operator=(const ModelMeshDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV53 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV53();
    ModelTransformDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV53(const ModelTransformDataV53 &p_other);
    ModelTransformDataV53 &operator=(const ModelTransformDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV53 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV53 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV53();
    ModelBoneDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV53(const ModelBoneDataV53 &p_other);
    ModelBoneDataV53 &operator=(const ModelBoneDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV53 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV53> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV53();
    ModelSkeletonDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV53(const ModelSkeletonDataV53 &p_other);
    ModelSkeletonDataV53 &operator=(const ModelSkeletonDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV53 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV53();
    ModelMeshBindingDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV53(const ModelMeshBindingDataV53 &p_other);
    ModelMeshBindingDataV53 &operator=(const ModelMeshBindingDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV53 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV53();
    ModelTrackMaskV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV53(const ModelTrackMaskV53 &p_other);
    ModelTrackMaskV53 &operator=(const ModelTrackMaskV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV53 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV53> Skeleton;
    ModelTransformDataV53 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV53> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV53> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV53();
    ModelModelDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV53(const ModelModelDataV53 &p_other);
    ModelModelDataV53 &operator=(const ModelModelDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV53 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV53();
    ModelPropertyDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV53(const ModelPropertyDataV53 &p_other);
    ModelPropertyDataV53 &operator=(const ModelPropertyDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV53 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV53();
    ModelParticleCloudV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV53(const ModelParticleCloudV53 &p_other);
    ModelParticleCloudV53 &operator=(const ModelParticleCloudV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV53 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV53();
    ModelParticleCurveV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV53(const ModelParticleCurveV53 &p_other);
    ModelParticleCurveV53 &operator=(const ModelParticleCurveV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV53 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV53();
    ModelParticleFlipbookV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV53(const ModelParticleFlipbookV53 &p_other);
    ModelParticleFlipbookV53 &operator=(const ModelParticleFlipbookV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV53 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV53> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV53> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV53> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV53();
    ModelParticleEmitterV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV53(const ModelParticleEmitterV53 &p_other);
    ModelParticleEmitterV53 &operator=(const ModelParticleEmitterV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV53 {
    helpers::Array<ModelParticleCloudV53> clouds;
    helpers::Array<ModelParticleEmitterV53> emitters;

public:
    ModelCloudDataV53();
    ModelCloudDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV53(const ModelCloudDataV53 &p_other);
    ModelCloudDataV53 &operator=(const ModelCloudDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatrix43V53 {
    float4 x;
    float4 y;
    float4 z;

public:
    ModelMatrix43V53();
    ModelMatrix43V53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatrix43V53(const ModelMatrix43V53 &p_other);
    ModelMatrix43V53 &operator=(const ModelMatrix43V53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV53 {
    qword bone;
    byte type;
    byte response;
    dword flags;
    float dragCoef;
    float gravityCoef;
    float length;
    float width;
    float height;
    float radius;
    helpers::Ptr<ModelMatrix43V53> transform;

public:
    ModelObstacleDataV53();
    ModelObstacleDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV53(const ModelObstacleDataV53 &p_other);
    ModelObstacleDataV53 &operator=(const ModelObstacleDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV53 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV53();
    ModelStreakV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV53(const ModelStreakV53 &p_other);
    ModelStreakV53 &operator=(const ModelStreakV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV53 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV53();
    ModelStreakAnchorV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV53(const ModelStreakAnchorV53 &p_other);
    ModelStreakAnchorV53 &operator=(const ModelStreakAnchorV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV53 {
    helpers::Array<ModelStreakV53> streaks;
    helpers::Array<ModelStreakAnchorV53> anchors;

public:
    ModelStreakDataV53();
    ModelStreakDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV53(const ModelStreakDataV53 &p_other);
    ModelStreakDataV53 &operator=(const ModelStreakDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV53 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV53();
    ModelEffectLightV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV53(const ModelEffectLightV53 &p_other);
    ModelEffectLightV53 &operator=(const ModelEffectLightV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV53 {
    helpers::Array<ModelEffectLightV53> effectLights;

public:
    ModelLightDataV53();
    ModelLightDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV53(const ModelLightDataV53 &p_other);
    ModelLightDataV53 &operator=(const ModelLightDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV53 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV53();
    ModelClothBoneWeightV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV53(const ModelClothBoneWeightV53 &p_other);
    ModelClothBoneWeightV53 &operator=(const ModelClothBoneWeightV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV53 {
    helpers::Array<ModelClothBoneWeightV53> weights;

public:
    ModelClothMeshGroupV53();
    ModelClothMeshGroupV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV53(const ModelClothMeshGroupV53 &p_other);
    ModelClothMeshGroupV53 &operator=(const ModelClothMeshGroupV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV53 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV53();
    ModelClothSoftLockV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV53(const ModelClothSoftLockV53 &p_other);
    ModelClothSoftLockV53 &operator=(const ModelClothSoftLockV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV53 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV53();
    ModelClothConstraintV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV53(const ModelClothConstraintV53 &p_other);
    ModelClothConstraintV53 &operator=(const ModelClothConstraintV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV53 {
    dword materialIndex;
    byte flags;
    float drag;
    float gravity;
    float compressibility;
    float stretchiness;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV53> groups;
    helpers::Array<ModelClothSoftLockV53> softLocks;
    helpers::Array<ModelClothConstraintV53> lod0Constraints;
    helpers::Array<ModelClothConstraintV53> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<dword> obstacleIndices;

public:
    ModelClothDataV53();
    ModelClothDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV53(const ModelClothDataV53 &p_other);
    ModelClothDataV53 &operator=(const ModelClothDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV53 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV53();
    ModelLightningSystemV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV53(const ModelLightningSystemV53 &p_other);
    ModelLightningSystemV53 &operator=(const ModelLightningSystemV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV53 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV53();
    ModelLightningBoltV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV53(const ModelLightningBoltV53 &p_other);
    ModelLightningBoltV53 &operator=(const ModelLightningBoltV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV53 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV53();
    ModelLightningNodeV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV53(const ModelLightningNodeV53 &p_other);
    ModelLightningNodeV53 &operator=(const ModelLightningNodeV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV53 {
    helpers::Array<ModelLightningSystemV53> systems;
    helpers::Array<ModelLightningBoltV53> bolts;
    helpers::Array<ModelLightningNodeV53> nodes;

public:
    ModelLightningDataV53();
    ModelLightningDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV53(const ModelLightningDataV53 &p_other);
    ModelLightningDataV53 &operator=(const ModelLightningDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV53 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV53();
    ModelBoneConstraintLinkV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV53(const ModelBoneConstraintLinkV53 &p_other);
    ModelBoneConstraintLinkV53 &operator=(const ModelBoneConstraintLinkV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV53 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV53> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV53();
    ModelBoneConstraintV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV53(const ModelBoneConstraintV53 &p_other);
    ModelBoneConstraintV53 &operator=(const ModelBoneConstraintV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV53 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV53();
    ModelSoftBodyDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV53(const ModelSoftBodyDataV53 &p_other);
    ModelSoftBodyDataV53 &operator=(const ModelSoftBodyDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV53 {
    qword bone;
    float3 translation;
    float4 rotation;

public:
    ModelBoneOffsetDataV53();
    ModelBoneOffsetDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV53(const ModelBoneOffsetDataV53 &p_other);
    ModelBoneOffsetDataV53 &operator=(const ModelBoneOffsetDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV53 {
    helpers::Array<ModelPermutationDataV53> permutations;
    helpers::Ptr<ModelMeshDataV53> meshes;
    helpers::Ptr<ModelModelDataV53> model;
    helpers::Array<ModelPropertyDataV53> properties;
    helpers::Ptr<ModelCloudDataV53> cloudData;
    helpers::Array<ModelObstacleDataV53> obstacles;
    helpers::Ptr<ModelStreakDataV53> streakData;
    helpers::Ptr<ModelLightDataV53> lightData;
    helpers::Array<ModelClothDataV53> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV53> lightningData;
    helpers::Array<ModelBoneConstraintV53> boneConstraints;
    helpers::Array<ModelSoftBodyDataV53> softBodyData;
    helpers::Array<ModelBoneOffsetDataV53> boneOffsetData;

public:
    ModelFileDataV53();
    ModelFileDataV53(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV53(const ModelFileDataV53 &p_other);
    ModelFileDataV53 &operator=(const ModelFileDataV53 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV53 Gw2Struct;
};

/* Version: 52, ReferencedFunction: 0x410DB1E000000001 */

template <>
struct Gw2StructMODL<52>{
struct ModelTextureDataV52 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV52();
    ModelTextureDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV52(const ModelTextureDataV52 &p_other);
    ModelTextureDataV52 &operator=(const ModelTextureDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV52 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV52();
    ModelConstantDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV52(const ModelConstantDataV52 &p_other);
    ModelConstantDataV52 &operator=(const ModelConstantDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV52 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV52();
    ModelMatConstLinkV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV52(const ModelMatConstLinkV52 &p_other);
    ModelMatConstLinkV52 &operator=(const ModelMatConstLinkV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV52 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV52();
    ModelUVTransLinkV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV52(const ModelUVTransLinkV52 &p_other);
    ModelUVTransLinkV52 &operator=(const ModelUVTransLinkV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV52 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV52();
    ModelMaterialTexTransformV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV52(const ModelMaterialTexTransformV52 &p_other);
    ModelMaterialTexTransformV52 &operator=(const ModelMaterialTexTransformV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV52 {
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV52> textures;
    helpers::Array<ModelConstantDataV52> constants;
    helpers::Array<ModelMatConstLinkV52> matConstLinks;
    helpers::Array<ModelUVTransLinkV52> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV52> texTransforms;

public:
    ModelMaterialDataV52();
    ModelMaterialDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV52(const ModelMaterialDataV52 &p_other);
    ModelMaterialDataV52 &operator=(const ModelMaterialDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV52 {
    qword token;
    helpers::Ptr<ModelMaterialDataV52> materials;

public:
    ModelPermutationDataV52();
    ModelPermutationDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV52(const ModelPermutationDataV52 &p_other);
    ModelPermutationDataV52 &operator=(const ModelPermutationDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV52 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV52();
    ModelMeshLodDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV52(const ModelMeshLodDataV52 &p_other);
    ModelMeshLodDataV52 &operator=(const ModelMeshLodDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV52 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV52();
    ModelMeshMorphVertV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV52(const ModelMeshMorphVertV52 &p_other);
    ModelMeshMorphVertV52 &operator=(const ModelMeshMorphVertV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV52 {
    helpers::Array<ModelMeshMorphVertV52> positions;
    helpers::Array<ModelMeshMorphVertV52> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV52();
    ModelMeshMorphTargetV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV52(const ModelMeshMorphTargetV52 &p_other);
    ModelMeshMorphTargetV52 &operator=(const ModelMeshMorphTargetV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV52 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV52> lods;
    helpers::Array<ModelMeshMorphTargetV52> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV52();
    ModelMeshDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV52(const ModelMeshDataV52 &p_other);
    ModelMeshDataV52 &operator=(const ModelMeshDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV52 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV52();
    ModelTransformDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV52(const ModelTransformDataV52 &p_other);
    ModelTransformDataV52 &operator=(const ModelTransformDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV52 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV52 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV52();
    ModelBoneDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV52(const ModelBoneDataV52 &p_other);
    ModelBoneDataV52 &operator=(const ModelBoneDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV52 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV52> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV52();
    ModelSkeletonDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV52(const ModelSkeletonDataV52 &p_other);
    ModelSkeletonDataV52 &operator=(const ModelSkeletonDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV52 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV52();
    ModelMeshBindingDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV52(const ModelMeshBindingDataV52 &p_other);
    ModelMeshBindingDataV52 &operator=(const ModelMeshBindingDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV52 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV52();
    ModelTrackMaskV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV52(const ModelTrackMaskV52 &p_other);
    ModelTrackMaskV52 &operator=(const ModelTrackMaskV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV52 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV52> Skeleton;
    ModelTransformDataV52 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV52> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV52> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV52();
    ModelModelDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV52(const ModelModelDataV52 &p_other);
    ModelModelDataV52 &operator=(const ModelModelDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV52 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV52();
    ModelPropertyDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV52(const ModelPropertyDataV52 &p_other);
    ModelPropertyDataV52 &operator=(const ModelPropertyDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV52 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV52();
    ModelParticleCloudV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV52(const ModelParticleCloudV52 &p_other);
    ModelParticleCloudV52 &operator=(const ModelParticleCloudV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV52 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV52();
    ModelParticleCurveV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV52(const ModelParticleCurveV52 &p_other);
    ModelParticleCurveV52 &operator=(const ModelParticleCurveV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV52 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV52();
    ModelParticleFlipbookV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV52(const ModelParticleFlipbookV52 &p_other);
    ModelParticleFlipbookV52 &operator=(const ModelParticleFlipbookV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV52 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV52> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV52> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV52> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV52();
    ModelParticleEmitterV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV52(const ModelParticleEmitterV52 &p_other);
    ModelParticleEmitterV52 &operator=(const ModelParticleEmitterV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV52 {
    helpers::Array<ModelParticleCloudV52> clouds;
    helpers::Array<ModelParticleEmitterV52> emitters;

public:
    ModelCloudDataV52();
    ModelCloudDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV52(const ModelCloudDataV52 &p_other);
    ModelCloudDataV52 &operator=(const ModelCloudDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV52 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV52();
    ModelObstacleDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV52(const ModelObstacleDataV52 &p_other);
    ModelObstacleDataV52 &operator=(const ModelObstacleDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV52 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV52();
    ModelStreakV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV52(const ModelStreakV52 &p_other);
    ModelStreakV52 &operator=(const ModelStreakV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV52 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV52();
    ModelStreakAnchorV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV52(const ModelStreakAnchorV52 &p_other);
    ModelStreakAnchorV52 &operator=(const ModelStreakAnchorV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV52 {
    helpers::Array<ModelStreakV52> streaks;
    helpers::Array<ModelStreakAnchorV52> anchors;

public:
    ModelStreakDataV52();
    ModelStreakDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV52(const ModelStreakDataV52 &p_other);
    ModelStreakDataV52 &operator=(const ModelStreakDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV52 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV52();
    ModelEffectLightV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV52(const ModelEffectLightV52 &p_other);
    ModelEffectLightV52 &operator=(const ModelEffectLightV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV52 {
    helpers::Array<ModelEffectLightV52> effectLights;

public:
    ModelLightDataV52();
    ModelLightDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV52(const ModelLightDataV52 &p_other);
    ModelLightDataV52 &operator=(const ModelLightDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV52 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV52();
    ModelClothBoneWeightV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV52(const ModelClothBoneWeightV52 &p_other);
    ModelClothBoneWeightV52 &operator=(const ModelClothBoneWeightV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV52 {
    helpers::Array<ModelClothBoneWeightV52> weights;

public:
    ModelClothMeshGroupV52();
    ModelClothMeshGroupV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV52(const ModelClothMeshGroupV52 &p_other);
    ModelClothMeshGroupV52 &operator=(const ModelClothMeshGroupV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothSoftLockV52 {
    byte weight;
    word vertIndex;

public:
    ModelClothSoftLockV52();
    ModelClothSoftLockV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothSoftLockV52(const ModelClothSoftLockV52 &p_other);
    ModelClothSoftLockV52 &operator=(const ModelClothSoftLockV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV52 {
    word distance;
    word relationship;
    word vertIndexA;
    word vertIndexB;

public:
    ModelClothConstraintV52();
    ModelClothConstraintV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV52(const ModelClothConstraintV52 &p_other);
    ModelClothConstraintV52 &operator=(const ModelClothConstraintV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV52 {
    qword bone;
    byte type;
    float depth;
    float height;
    float radius;
    float width;

public:
    ModelClothObstacleV52();
    ModelClothObstacleV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV52(const ModelClothObstacleV52 &p_other);
    ModelClothObstacleV52 &operator=(const ModelClothObstacleV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV52 {
    dword materialIndex;
    byte flags;
    float drag;
    float gravity;
    float compressibility;
    float stretchiness;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV52> groups;
    helpers::Array<ModelClothSoftLockV52> softLocks;
    helpers::Array<ModelClothConstraintV52> lod0Constraints;
    helpers::Array<ModelClothConstraintV52> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV52> obstacles;

public:
    ModelClothDataV52();
    ModelClothDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV52(const ModelClothDataV52 &p_other);
    ModelClothDataV52 &operator=(const ModelClothDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV52 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV52();
    ModelLightningSystemV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV52(const ModelLightningSystemV52 &p_other);
    ModelLightningSystemV52 &operator=(const ModelLightningSystemV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV52 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV52();
    ModelLightningBoltV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV52(const ModelLightningBoltV52 &p_other);
    ModelLightningBoltV52 &operator=(const ModelLightningBoltV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV52 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV52();
    ModelLightningNodeV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV52(const ModelLightningNodeV52 &p_other);
    ModelLightningNodeV52 &operator=(const ModelLightningNodeV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV52 {
    helpers::Array<ModelLightningSystemV52> systems;
    helpers::Array<ModelLightningBoltV52> bolts;
    helpers::Array<ModelLightningNodeV52> nodes;

public:
    ModelLightningDataV52();
    ModelLightningDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV52(const ModelLightningDataV52 &p_other);
    ModelLightningDataV52 &operator=(const ModelLightningDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV52 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV52();
    ModelBoneConstraintLinkV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV52(const ModelBoneConstraintLinkV52 &p_other);
    ModelBoneConstraintLinkV52 &operator=(const ModelBoneConstraintLinkV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV52 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV52> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV52();
    ModelBoneConstraintV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV52(const ModelBoneConstraintV52 &p_other);
    ModelBoneConstraintV52 &operator=(const ModelBoneConstraintV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV52 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV52();
    ModelSoftBodyDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV52(const ModelSoftBodyDataV52 &p_other);
    ModelSoftBodyDataV52 &operator=(const ModelSoftBodyDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV52 {
    qword bone;
    float3 offset;

public:
    ModelBoneOffsetDataV52();
    ModelBoneOffsetDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV52(const ModelBoneOffsetDataV52 &p_other);
    ModelBoneOffsetDataV52 &operator=(const ModelBoneOffsetDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV52 {
    helpers::Array<ModelPermutationDataV52> permutations;
    helpers::Ptr<ModelMeshDataV52> meshes;
    helpers::Ptr<ModelModelDataV52> model;
    helpers::Array<ModelPropertyDataV52> properties;
    helpers::Ptr<ModelCloudDataV52> cloudData;
    helpers::Array<ModelObstacleDataV52> obstacles;
    helpers::Ptr<ModelStreakDataV52> streakData;
    helpers::Ptr<ModelLightDataV52> lightData;
    helpers::Array<ModelClothDataV52> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV52> lightningData;
    helpers::Array<ModelBoneConstraintV52> boneConstraints;
    helpers::Array<ModelSoftBodyDataV52> softBodyData;
    helpers::Array<ModelBoneOffsetDataV52> boneOffsetData;

public:
    ModelFileDataV52();
    ModelFileDataV52(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV52(const ModelFileDataV52 &p_other);
    ModelFileDataV52 &operator=(const ModelFileDataV52 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV52 Gw2Struct;
};

/* Version: 51, ReferencedFunction: 0x410DAEF000000001 */

template <>
struct Gw2StructMODL<51>{
struct ModelTextureDataV51 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV51();
    ModelTextureDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV51(const ModelTextureDataV51 &p_other);
    ModelTextureDataV51 &operator=(const ModelTextureDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV51 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV51();
    ModelConstantDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV51(const ModelConstantDataV51 &p_other);
    ModelConstantDataV51 &operator=(const ModelConstantDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV51 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV51();
    ModelMatConstLinkV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV51(const ModelMatConstLinkV51 &p_other);
    ModelMatConstLinkV51 &operator=(const ModelMatConstLinkV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV51 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV51();
    ModelUVTransLinkV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV51(const ModelUVTransLinkV51 &p_other);
    ModelUVTransLinkV51 &operator=(const ModelUVTransLinkV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV51 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV51();
    ModelMaterialTexTransformV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV51(const ModelMaterialTexTransformV51 &p_other);
    ModelMaterialTexTransformV51 &operator=(const ModelMaterialTexTransformV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV51 {
    dword materialId;
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV51> textures;
    helpers::Array<ModelConstantDataV51> constants;
    helpers::Array<ModelMatConstLinkV51> matConstLinks;
    helpers::Array<ModelUVTransLinkV51> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV51> texTransforms;

public:
    ModelMaterialDataV51();
    ModelMaterialDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV51(const ModelMaterialDataV51 &p_other);
    ModelMaterialDataV51 &operator=(const ModelMaterialDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPermutationDataV51 {
    qword token;
    helpers::Ptr<ModelMaterialDataV51> materials;

public:
    ModelPermutationDataV51();
    ModelPermutationDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPermutationDataV51(const ModelPermutationDataV51 &p_other);
    ModelPermutationDataV51 &operator=(const ModelPermutationDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV51 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV51();
    ModelMeshLodDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV51(const ModelMeshLodDataV51 &p_other);
    ModelMeshLodDataV51 &operator=(const ModelMeshLodDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV51 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV51();
    ModelMeshMorphVertV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV51(const ModelMeshMorphVertV51 &p_other);
    ModelMeshMorphVertV51 &operator=(const ModelMeshMorphVertV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV51 {
    helpers::Array<ModelMeshMorphVertV51> positions;
    helpers::Array<ModelMeshMorphVertV51> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV51();
    ModelMeshMorphTargetV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV51(const ModelMeshMorphTargetV51 &p_other);
    ModelMeshMorphTargetV51 &operator=(const ModelMeshMorphTargetV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV51 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV51> lods;
    helpers::Array<ModelMeshMorphTargetV51> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;

public:
    ModelMeshDataV51();
    ModelMeshDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV51(const ModelMeshDataV51 &p_other);
    ModelMeshDataV51 &operator=(const ModelMeshDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV51 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV51();
    ModelTransformDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV51(const ModelTransformDataV51 &p_other);
    ModelTransformDataV51 &operator=(const ModelTransformDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV51 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV51 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV51();
    ModelBoneDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV51(const ModelBoneDataV51 &p_other);
    ModelBoneDataV51 &operator=(const ModelBoneDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV51 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV51> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV51();
    ModelSkeletonDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV51(const ModelSkeletonDataV51 &p_other);
    ModelSkeletonDataV51 &operator=(const ModelSkeletonDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV51 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV51();
    ModelMeshBindingDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV51(const ModelMeshBindingDataV51 &p_other);
    ModelMeshBindingDataV51 &operator=(const ModelMeshBindingDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV51 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV51();
    ModelTrackMaskV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV51(const ModelTrackMaskV51 &p_other);
    ModelTrackMaskV51 &operator=(const ModelTrackMaskV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV51 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV51> Skeleton;
    ModelTransformDataV51 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV51> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV51> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV51();
    ModelModelDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV51(const ModelModelDataV51 &p_other);
    ModelModelDataV51 &operator=(const ModelModelDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV51 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV51();
    ModelPropertyDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV51(const ModelPropertyDataV51 &p_other);
    ModelPropertyDataV51 &operator=(const ModelPropertyDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV51 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV51();
    ModelParticleCloudV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV51(const ModelParticleCloudV51 &p_other);
    ModelParticleCloudV51 &operator=(const ModelParticleCloudV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV51 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV51();
    ModelParticleCurveV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV51(const ModelParticleCurveV51 &p_other);
    ModelParticleCurveV51 &operator=(const ModelParticleCurveV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV51 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV51();
    ModelParticleFlipbookV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV51(const ModelParticleFlipbookV51 &p_other);
    ModelParticleFlipbookV51 &operator=(const ModelParticleFlipbookV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV51 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV51> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV51> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV51> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV51();
    ModelParticleEmitterV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV51(const ModelParticleEmitterV51 &p_other);
    ModelParticleEmitterV51 &operator=(const ModelParticleEmitterV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV51 {
    helpers::Array<ModelParticleCloudV51> clouds;
    helpers::Array<ModelParticleEmitterV51> emitters;

public:
    ModelCloudDataV51();
    ModelCloudDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV51(const ModelCloudDataV51 &p_other);
    ModelCloudDataV51 &operator=(const ModelCloudDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV51 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV51();
    ModelObstacleDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV51(const ModelObstacleDataV51 &p_other);
    ModelObstacleDataV51 &operator=(const ModelObstacleDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV51 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV51();
    ModelStreakV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV51(const ModelStreakV51 &p_other);
    ModelStreakV51 &operator=(const ModelStreakV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV51 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV51();
    ModelStreakAnchorV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV51(const ModelStreakAnchorV51 &p_other);
    ModelStreakAnchorV51 &operator=(const ModelStreakAnchorV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV51 {
    helpers::Array<ModelStreakV51> streaks;
    helpers::Array<ModelStreakAnchorV51> anchors;

public:
    ModelStreakDataV51();
    ModelStreakDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV51(const ModelStreakDataV51 &p_other);
    ModelStreakDataV51 &operator=(const ModelStreakDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV51 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV51();
    ModelEffectLightV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV51(const ModelEffectLightV51 &p_other);
    ModelEffectLightV51 &operator=(const ModelEffectLightV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV51 {
    helpers::Array<ModelEffectLightV51> effectLights;

public:
    ModelLightDataV51();
    ModelLightDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV51(const ModelLightDataV51 &p_other);
    ModelLightDataV51 &operator=(const ModelLightDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV51 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV51();
    ModelClothBoneWeightV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV51(const ModelClothBoneWeightV51 &p_other);
    ModelClothBoneWeightV51 &operator=(const ModelClothBoneWeightV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV51 {
    helpers::Array<ModelClothBoneWeightV51> weights;

public:
    ModelClothMeshGroupV51();
    ModelClothMeshGroupV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV51(const ModelClothMeshGroupV51 &p_other);
    ModelClothMeshGroupV51 &operator=(const ModelClothMeshGroupV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV51 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV51();
    ModelClothConstraintV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV51(const ModelClothConstraintV51 &p_other);
    ModelClothConstraintV51 &operator=(const ModelClothConstraintV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV51 {
    qword bone;
    byte type;
    float depth;
    float height;
    float radius;
    float width;

public:
    ModelClothObstacleV51();
    ModelClothObstacleV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV51(const ModelClothObstacleV51 &p_other);
    ModelClothObstacleV51 &operator=(const ModelClothObstacleV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV51 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV51> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV51> lod0Constraints;
    helpers::Array<ModelClothConstraintV51> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV51> obstacles;

public:
    ModelClothDataV51();
    ModelClothDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV51(const ModelClothDataV51 &p_other);
    ModelClothDataV51 &operator=(const ModelClothDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV51 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV51();
    ModelLightningSystemV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV51(const ModelLightningSystemV51 &p_other);
    ModelLightningSystemV51 &operator=(const ModelLightningSystemV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV51 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV51();
    ModelLightningBoltV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV51(const ModelLightningBoltV51 &p_other);
    ModelLightningBoltV51 &operator=(const ModelLightningBoltV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV51 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float2 radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV51();
    ModelLightningNodeV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV51(const ModelLightningNodeV51 &p_other);
    ModelLightningNodeV51 &operator=(const ModelLightningNodeV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV51 {
    helpers::Array<ModelLightningSystemV51> systems;
    helpers::Array<ModelLightningBoltV51> bolts;
    helpers::Array<ModelLightningNodeV51> nodes;

public:
    ModelLightningDataV51();
    ModelLightningDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV51(const ModelLightningDataV51 &p_other);
    ModelLightningDataV51 &operator=(const ModelLightningDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV51 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV51();
    ModelBoneConstraintLinkV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV51(const ModelBoneConstraintLinkV51 &p_other);
    ModelBoneConstraintLinkV51 &operator=(const ModelBoneConstraintLinkV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV51 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV51> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV51();
    ModelBoneConstraintV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV51(const ModelBoneConstraintV51 &p_other);
    ModelBoneConstraintV51 &operator=(const ModelBoneConstraintV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV51 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV51();
    ModelSoftBodyDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV51(const ModelSoftBodyDataV51 &p_other);
    ModelSoftBodyDataV51 &operator=(const ModelSoftBodyDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV51 {
    qword bone;
    float3 offset;

public:
    ModelBoneOffsetDataV51();
    ModelBoneOffsetDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV51(const ModelBoneOffsetDataV51 &p_other);
    ModelBoneOffsetDataV51 &operator=(const ModelBoneOffsetDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV51 {
    helpers::Array<ModelPermutationDataV51> permutations;
    helpers::Ptr<ModelMeshDataV51> meshes;
    helpers::Ptr<ModelModelDataV51> model;
    helpers::Array<ModelPropertyDataV51> properties;
    helpers::Ptr<ModelCloudDataV51> cloudData;
    helpers::Array<ModelObstacleDataV51> obstacles;
    helpers::Ptr<ModelStreakDataV51> streakData;
    helpers::Ptr<ModelLightDataV51> lightData;
    helpers::Array<ModelClothDataV51> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV51> lightningData;
    helpers::Array<ModelBoneConstraintV51> boneConstraints;
    helpers::Array<ModelSoftBodyDataV51> softBodyData;
    helpers::Array<ModelBoneOffsetDataV51> boneOffsetData;

public:
    ModelFileDataV51();
    ModelFileDataV51(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV51(const ModelFileDataV51 &p_other);
    ModelFileDataV51 &operator=(const ModelFileDataV51 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV51 Gw2Struct;
};

/* Version: 50, ReferencedFunction: 0x410DAEB000000001 */

template <>
struct Gw2StructMODL<50>{
struct ModelTextureDataV50 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV50();
    ModelTextureDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV50(const ModelTextureDataV50 &p_other);
    ModelTextureDataV50 &operator=(const ModelTextureDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV50 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV50();
    ModelConstantDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV50(const ModelConstantDataV50 &p_other);
    ModelConstantDataV50 &operator=(const ModelConstantDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV50 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV50();
    ModelMatConstLinkV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV50(const ModelMatConstLinkV50 &p_other);
    ModelMatConstLinkV50 &operator=(const ModelMatConstLinkV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV50 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV50();
    ModelUVTransLinkV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV50(const ModelUVTransLinkV50 &p_other);
    ModelUVTransLinkV50 &operator=(const ModelUVTransLinkV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV50 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV50();
    ModelMaterialTexTransformV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV50(const ModelMaterialTexTransformV50 &p_other);
    ModelMaterialTexTransformV50 &operator=(const ModelMaterialTexTransformV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV50 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV50> textures;
    helpers::Array<ModelConstantDataV50> constants;
    helpers::Array<ModelMatConstLinkV50> matConstLinks;
    helpers::Array<ModelUVTransLinkV50> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV50> texTransforms;

public:
    ModelMaterialDataV50();
    ModelMaterialDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV50(const ModelMaterialDataV50 &p_other);
    ModelMaterialDataV50 &operator=(const ModelMaterialDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV50 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV50();
    ModelMeshLodDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV50(const ModelMeshLodDataV50 &p_other);
    ModelMeshLodDataV50 &operator=(const ModelMeshLodDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV50 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV50();
    ModelMeshMorphVertV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV50(const ModelMeshMorphVertV50 &p_other);
    ModelMeshMorphVertV50 &operator=(const ModelMeshMorphVertV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV50 {
    helpers::Array<ModelMeshMorphVertV50> positions;
    helpers::Array<ModelMeshMorphVertV50> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV50();
    ModelMeshMorphTargetV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV50(const ModelMeshMorphTargetV50 &p_other);
    ModelMeshMorphTargetV50 &operator=(const ModelMeshMorphTargetV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV50 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV50> lods;
    helpers::Array<ModelMeshMorphTargetV50> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;

public:
    ModelMeshDataV50();
    ModelMeshDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV50(const ModelMeshDataV50 &p_other);
    ModelMeshDataV50 &operator=(const ModelMeshDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV50 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV50();
    ModelTransformDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV50(const ModelTransformDataV50 &p_other);
    ModelTransformDataV50 &operator=(const ModelTransformDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV50 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV50 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV50();
    ModelBoneDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV50(const ModelBoneDataV50 &p_other);
    ModelBoneDataV50 &operator=(const ModelBoneDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV50 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV50> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV50();
    ModelSkeletonDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV50(const ModelSkeletonDataV50 &p_other);
    ModelSkeletonDataV50 &operator=(const ModelSkeletonDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV50 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV50();
    ModelMeshBindingDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV50(const ModelMeshBindingDataV50 &p_other);
    ModelMeshBindingDataV50 &operator=(const ModelMeshBindingDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV50 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV50();
    ModelTrackMaskV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV50(const ModelTrackMaskV50 &p_other);
    ModelTrackMaskV50 &operator=(const ModelTrackMaskV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV50 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV50> Skeleton;
    ModelTransformDataV50 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV50> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV50> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV50();
    ModelModelDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV50(const ModelModelDataV50 &p_other);
    ModelModelDataV50 &operator=(const ModelModelDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV50 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV50();
    ModelPropertyDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV50(const ModelPropertyDataV50 &p_other);
    ModelPropertyDataV50 &operator=(const ModelPropertyDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV50 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV50();
    ModelParticleCloudV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV50(const ModelParticleCloudV50 &p_other);
    ModelParticleCloudV50 &operator=(const ModelParticleCloudV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV50 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV50();
    ModelParticleCurveV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV50(const ModelParticleCurveV50 &p_other);
    ModelParticleCurveV50 &operator=(const ModelParticleCurveV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV50 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV50();
    ModelParticleFlipbookV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV50(const ModelParticleFlipbookV50 &p_other);
    ModelParticleFlipbookV50 &operator=(const ModelParticleFlipbookV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV50 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV50> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV50> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV50> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV50();
    ModelParticleEmitterV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV50(const ModelParticleEmitterV50 &p_other);
    ModelParticleEmitterV50 &operator=(const ModelParticleEmitterV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV50 {
    helpers::Array<ModelParticleCloudV50> clouds;
    helpers::Array<ModelParticleEmitterV50> emitters;

public:
    ModelCloudDataV50();
    ModelCloudDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV50(const ModelCloudDataV50 &p_other);
    ModelCloudDataV50 &operator=(const ModelCloudDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV50 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV50();
    ModelObstacleDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV50(const ModelObstacleDataV50 &p_other);
    ModelObstacleDataV50 &operator=(const ModelObstacleDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV50 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV50();
    ModelStreakV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV50(const ModelStreakV50 &p_other);
    ModelStreakV50 &operator=(const ModelStreakV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV50 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV50();
    ModelStreakAnchorV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV50(const ModelStreakAnchorV50 &p_other);
    ModelStreakAnchorV50 &operator=(const ModelStreakAnchorV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV50 {
    helpers::Array<ModelStreakV50> streaks;
    helpers::Array<ModelStreakAnchorV50> anchors;

public:
    ModelStreakDataV50();
    ModelStreakDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV50(const ModelStreakDataV50 &p_other);
    ModelStreakDataV50 &operator=(const ModelStreakDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV50 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV50();
    ModelEffectLightV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV50(const ModelEffectLightV50 &p_other);
    ModelEffectLightV50 &operator=(const ModelEffectLightV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV50 {
    helpers::Array<ModelEffectLightV50> effectLights;

public:
    ModelLightDataV50();
    ModelLightDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV50(const ModelLightDataV50 &p_other);
    ModelLightDataV50 &operator=(const ModelLightDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV50 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV50();
    ModelClothBoneWeightV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV50(const ModelClothBoneWeightV50 &p_other);
    ModelClothBoneWeightV50 &operator=(const ModelClothBoneWeightV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV50 {
    helpers::Array<ModelClothBoneWeightV50> weights;

public:
    ModelClothMeshGroupV50();
    ModelClothMeshGroupV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV50(const ModelClothMeshGroupV50 &p_other);
    ModelClothMeshGroupV50 &operator=(const ModelClothMeshGroupV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV50 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV50();
    ModelClothConstraintV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV50(const ModelClothConstraintV50 &p_other);
    ModelClothConstraintV50 &operator=(const ModelClothConstraintV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV50 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV50();
    ModelClothObstacleV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV50(const ModelClothObstacleV50 &p_other);
    ModelClothObstacleV50 &operator=(const ModelClothObstacleV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV50 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV50> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV50> lod0Constraints;
    helpers::Array<ModelClothConstraintV50> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV50> obstacles;

public:
    ModelClothDataV50();
    ModelClothDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV50(const ModelClothDataV50 &p_other);
    ModelClothDataV50 &operator=(const ModelClothDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV50 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword fvf;
    dword materialIndex;

public:
    ModelLightningSystemV50();
    ModelLightningSystemV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV50(const ModelLightningSystemV50 &p_other);
    ModelLightningSystemV50 &operator=(const ModelLightningSystemV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV50 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV50();
    ModelLightningBoltV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV50(const ModelLightningBoltV50 &p_other);
    ModelLightningBoltV50 &operator=(const ModelLightningBoltV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV50 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV50();
    ModelLightningNodeV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV50(const ModelLightningNodeV50 &p_other);
    ModelLightningNodeV50 &operator=(const ModelLightningNodeV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV50 {
    helpers::Array<ModelLightningSystemV50> systems;
    helpers::Array<ModelLightningBoltV50> bolts;
    helpers::Array<ModelLightningNodeV50> nodes;

public:
    ModelLightningDataV50();
    ModelLightningDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV50(const ModelLightningDataV50 &p_other);
    ModelLightningDataV50 &operator=(const ModelLightningDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV50 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV50();
    ModelBoneConstraintLinkV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV50(const ModelBoneConstraintLinkV50 &p_other);
    ModelBoneConstraintLinkV50 &operator=(const ModelBoneConstraintLinkV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV50 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV50> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV50();
    ModelBoneConstraintV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV50(const ModelBoneConstraintV50 &p_other);
    ModelBoneConstraintV50 &operator=(const ModelBoneConstraintV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV50 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV50();
    ModelSoftBodyDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV50(const ModelSoftBodyDataV50 &p_other);
    ModelSoftBodyDataV50 &operator=(const ModelSoftBodyDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV50 {
    qword bone;
    float3 offset;

public:
    ModelBoneOffsetDataV50();
    ModelBoneOffsetDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV50(const ModelBoneOffsetDataV50 &p_other);
    ModelBoneOffsetDataV50 &operator=(const ModelBoneOffsetDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV50 {
    helpers::Ptr<ModelMaterialDataV50> materials;
    helpers::Ptr<ModelMeshDataV50> meshes;
    helpers::Ptr<ModelModelDataV50> model;
    helpers::Array<ModelPropertyDataV50> properties;
    helpers::Ptr<ModelCloudDataV50> cloudData;
    helpers::Array<ModelObstacleDataV50> obstacles;
    helpers::Ptr<ModelStreakDataV50> streakData;
    helpers::Ptr<ModelLightDataV50> lightData;
    helpers::Array<ModelClothDataV50> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV50> lightningData;
    helpers::Array<ModelBoneConstraintV50> boneConstraints;
    helpers::Array<ModelSoftBodyDataV50> softBodyData;
    helpers::Array<ModelBoneOffsetDataV50> boneOffsetData;

public:
    ModelFileDataV50();
    ModelFileDataV50(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV50(const ModelFileDataV50 &p_other);
    ModelFileDataV50 &operator=(const ModelFileDataV50 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV50 Gw2Struct;
};

/* Version: 49, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<49>{
struct ModelTextureDataV49 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV49();
    ModelTextureDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV49(const ModelTextureDataV49 &p_other);
    ModelTextureDataV49 &operator=(const ModelTextureDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV49 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV49();
    ModelConstantDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV49(const ModelConstantDataV49 &p_other);
    ModelConstantDataV49 &operator=(const ModelConstantDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV49 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV49();
    ModelMatConstLinkV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV49(const ModelMatConstLinkV49 &p_other);
    ModelMatConstLinkV49 &operator=(const ModelMatConstLinkV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV49 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV49();
    ModelUVTransLinkV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV49(const ModelUVTransLinkV49 &p_other);
    ModelUVTransLinkV49 &operator=(const ModelUVTransLinkV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV49 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV49();
    ModelMaterialTexTransformV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV49(const ModelMaterialTexTransformV49 &p_other);
    ModelMaterialTexTransformV49 &operator=(const ModelMaterialTexTransformV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV49 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV49> textures;
    helpers::Array<ModelConstantDataV49> constants;
    helpers::Array<ModelMatConstLinkV49> matConstLinks;
    helpers::Array<ModelUVTransLinkV49> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV49> texTransforms;

public:
    ModelMaterialDataV49();
    ModelMaterialDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV49(const ModelMaterialDataV49 &p_other);
    ModelMaterialDataV49 &operator=(const ModelMaterialDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV49 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV49();
    ModelMeshLodDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV49(const ModelMeshLodDataV49 &p_other);
    ModelMeshLodDataV49 &operator=(const ModelMeshLodDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV49 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV49();
    ModelMeshMorphVertV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV49(const ModelMeshMorphVertV49 &p_other);
    ModelMeshMorphVertV49 &operator=(const ModelMeshMorphVertV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV49 {
    helpers::Array<ModelMeshMorphVertV49> positions;
    helpers::Array<ModelMeshMorphVertV49> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV49();
    ModelMeshMorphTargetV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV49(const ModelMeshMorphTargetV49 &p_other);
    ModelMeshMorphTargetV49 &operator=(const ModelMeshMorphTargetV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV49 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV49> lods;
    helpers::Array<ModelMeshMorphTargetV49> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;

public:
    ModelMeshDataV49();
    ModelMeshDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV49(const ModelMeshDataV49 &p_other);
    ModelMeshDataV49 &operator=(const ModelMeshDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV49 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV49();
    ModelTransformDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV49(const ModelTransformDataV49 &p_other);
    ModelTransformDataV49 &operator=(const ModelTransformDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV49 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV49 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV49();
    ModelBoneDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV49(const ModelBoneDataV49 &p_other);
    ModelBoneDataV49 &operator=(const ModelBoneDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV49 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV49> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV49();
    ModelSkeletonDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV49(const ModelSkeletonDataV49 &p_other);
    ModelSkeletonDataV49 &operator=(const ModelSkeletonDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV49 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV49();
    ModelMeshBindingDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV49(const ModelMeshBindingDataV49 &p_other);
    ModelMeshBindingDataV49 &operator=(const ModelMeshBindingDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV49 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV49();
    ModelTrackMaskV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV49(const ModelTrackMaskV49 &p_other);
    ModelTrackMaskV49 &operator=(const ModelTrackMaskV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV49 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV49> Skeleton;
    ModelTransformDataV49 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV49> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV49> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV49();
    ModelModelDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV49(const ModelModelDataV49 &p_other);
    ModelModelDataV49 &operator=(const ModelModelDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV49 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV49();
    ModelPropertyDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV49(const ModelPropertyDataV49 &p_other);
    ModelPropertyDataV49 &operator=(const ModelPropertyDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV49 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV49();
    ModelParticleCloudV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV49(const ModelParticleCloudV49 &p_other);
    ModelParticleCloudV49 &operator=(const ModelParticleCloudV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV49 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV49();
    ModelParticleCurveV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV49(const ModelParticleCurveV49 &p_other);
    ModelParticleCurveV49 &operator=(const ModelParticleCurveV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV49 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV49();
    ModelParticleFlipbookV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV49(const ModelParticleFlipbookV49 &p_other);
    ModelParticleFlipbookV49 &operator=(const ModelParticleFlipbookV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV49 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV49> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV49> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV49> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV49();
    ModelParticleEmitterV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV49(const ModelParticleEmitterV49 &p_other);
    ModelParticleEmitterV49 &operator=(const ModelParticleEmitterV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV49 {
    helpers::Array<ModelParticleCloudV49> clouds;
    helpers::Array<ModelParticleEmitterV49> emitters;

public:
    ModelCloudDataV49();
    ModelCloudDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV49(const ModelCloudDataV49 &p_other);
    ModelCloudDataV49 &operator=(const ModelCloudDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV49 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV49();
    ModelObstacleDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV49(const ModelObstacleDataV49 &p_other);
    ModelObstacleDataV49 &operator=(const ModelObstacleDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV49 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV49();
    ModelStreakV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV49(const ModelStreakV49 &p_other);
    ModelStreakV49 &operator=(const ModelStreakV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV49 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV49();
    ModelStreakAnchorV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV49(const ModelStreakAnchorV49 &p_other);
    ModelStreakAnchorV49 &operator=(const ModelStreakAnchorV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV49 {
    helpers::Array<ModelStreakV49> streaks;
    helpers::Array<ModelStreakAnchorV49> anchors;

public:
    ModelStreakDataV49();
    ModelStreakDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV49(const ModelStreakDataV49 &p_other);
    ModelStreakDataV49 &operator=(const ModelStreakDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV49 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV49();
    ModelEffectLightV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV49(const ModelEffectLightV49 &p_other);
    ModelEffectLightV49 &operator=(const ModelEffectLightV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV49 {
    helpers::Array<ModelEffectLightV49> effectLights;

public:
    ModelLightDataV49();
    ModelLightDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV49(const ModelLightDataV49 &p_other);
    ModelLightDataV49 &operator=(const ModelLightDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV49 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV49();
    ModelClothBoneWeightV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV49(const ModelClothBoneWeightV49 &p_other);
    ModelClothBoneWeightV49 &operator=(const ModelClothBoneWeightV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV49 {
    helpers::Array<ModelClothBoneWeightV49> weights;

public:
    ModelClothMeshGroupV49();
    ModelClothMeshGroupV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV49(const ModelClothMeshGroupV49 &p_other);
    ModelClothMeshGroupV49 &operator=(const ModelClothMeshGroupV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV49 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV49();
    ModelClothConstraintV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV49(const ModelClothConstraintV49 &p_other);
    ModelClothConstraintV49 &operator=(const ModelClothConstraintV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV49 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV49();
    ModelClothObstacleV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV49(const ModelClothObstacleV49 &p_other);
    ModelClothObstacleV49 &operator=(const ModelClothObstacleV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV49 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV49> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV49> lod0Constraints;
    helpers::Array<ModelClothConstraintV49> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV49> obstacles;

public:
    ModelClothDataV49();
    ModelClothDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV49(const ModelClothDataV49 &p_other);
    ModelClothDataV49 &operator=(const ModelClothDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV49 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV49();
    ModelLightningSystemV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV49(const ModelLightningSystemV49 &p_other);
    ModelLightningSystemV49 &operator=(const ModelLightningSystemV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV49 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV49();
    ModelLightningBoltV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV49(const ModelLightningBoltV49 &p_other);
    ModelLightningBoltV49 &operator=(const ModelLightningBoltV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV49 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV49();
    ModelLightningNodeV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV49(const ModelLightningNodeV49 &p_other);
    ModelLightningNodeV49 &operator=(const ModelLightningNodeV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV49 {
    helpers::Array<ModelLightningSystemV49> systems;
    helpers::Array<ModelLightningBoltV49> bolts;
    helpers::Array<ModelLightningNodeV49> nodes;

public:
    ModelLightningDataV49();
    ModelLightningDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV49(const ModelLightningDataV49 &p_other);
    ModelLightningDataV49 &operator=(const ModelLightningDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV49 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV49();
    ModelBoneConstraintLinkV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV49(const ModelBoneConstraintLinkV49 &p_other);
    ModelBoneConstraintLinkV49 &operator=(const ModelBoneConstraintLinkV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV49 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV49> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV49();
    ModelBoneConstraintV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV49(const ModelBoneConstraintV49 &p_other);
    ModelBoneConstraintV49 &operator=(const ModelBoneConstraintV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV49 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV49();
    ModelSoftBodyDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV49(const ModelSoftBodyDataV49 &p_other);
    ModelSoftBodyDataV49 &operator=(const ModelSoftBodyDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneOffsetDataV49 {
    qword bone;
    float3 offset;

public:
    ModelBoneOffsetDataV49();
    ModelBoneOffsetDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneOffsetDataV49(const ModelBoneOffsetDataV49 &p_other);
    ModelBoneOffsetDataV49 &operator=(const ModelBoneOffsetDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV49 {
    helpers::Ptr<ModelMaterialDataV49> materials;
    helpers::Ptr<ModelMeshDataV49> meshes;
    helpers::Ptr<ModelModelDataV49> model;
    helpers::Array<ModelPropertyDataV49> properties;
    helpers::Ptr<ModelCloudDataV49> cloudData;
    helpers::Array<ModelObstacleDataV49> obstacles;
    helpers::Ptr<ModelStreakDataV49> streakData;
    helpers::Ptr<ModelLightDataV49> lightData;
    helpers::Array<ModelClothDataV49> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV49> lightningData;
    helpers::Array<ModelBoneConstraintV49> boneConstraints;
    helpers::Array<ModelSoftBodyDataV49> softBodyData;
    helpers::Array<ModelBoneOffsetDataV49> boneOffsetData;

public:
    ModelFileDataV49();
    ModelFileDataV49(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV49(const ModelFileDataV49 &p_other);
    ModelFileDataV49 &operator=(const ModelFileDataV49 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV49 Gw2Struct;
};

/* Version: 48, ReferencedFunction: 0x410DA45000000001 */

template <>
struct Gw2StructMODL<48>{
struct ModelTextureDataV48 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV48();
    ModelTextureDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV48(const ModelTextureDataV48 &p_other);
    ModelTextureDataV48 &operator=(const ModelTextureDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV48 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV48();
    ModelConstantDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV48(const ModelConstantDataV48 &p_other);
    ModelConstantDataV48 &operator=(const ModelConstantDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV48 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV48();
    ModelMatConstLinkV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV48(const ModelMatConstLinkV48 &p_other);
    ModelMatConstLinkV48 &operator=(const ModelMatConstLinkV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV48 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV48();
    ModelUVTransLinkV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV48(const ModelUVTransLinkV48 &p_other);
    ModelUVTransLinkV48 &operator=(const ModelUVTransLinkV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV48 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV48();
    ModelMaterialTexTransformV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV48(const ModelMaterialTexTransformV48 &p_other);
    ModelMaterialTexTransformV48 &operator=(const ModelMaterialTexTransformV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV48 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV48> textures;
    helpers::Array<ModelConstantDataV48> constants;
    helpers::Array<ModelMatConstLinkV48> matConstLinks;
    helpers::Array<ModelUVTransLinkV48> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV48> texTransforms;

public:
    ModelMaterialDataV48();
    ModelMaterialDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV48(const ModelMaterialDataV48 &p_other);
    ModelMaterialDataV48 &operator=(const ModelMaterialDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV48 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV48();
    ModelMeshLodDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV48(const ModelMeshLodDataV48 &p_other);
    ModelMeshLodDataV48 &operator=(const ModelMeshLodDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV48 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV48();
    ModelMeshMorphVertV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV48(const ModelMeshMorphVertV48 &p_other);
    ModelMeshMorphVertV48 &operator=(const ModelMeshMorphVertV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV48 {
    helpers::Array<ModelMeshMorphVertV48> positions;
    helpers::Array<ModelMeshMorphVertV48> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV48();
    ModelMeshMorphTargetV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV48(const ModelMeshMorphTargetV48 &p_other);
    ModelMeshMorphTargetV48 &operator=(const ModelMeshMorphTargetV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV48 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV48> lods;
    helpers::Array<ModelMeshMorphTargetV48> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;

public:
    ModelMeshDataV48();
    ModelMeshDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV48(const ModelMeshDataV48 &p_other);
    ModelMeshDataV48 &operator=(const ModelMeshDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV48 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV48();
    ModelTransformDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV48(const ModelTransformDataV48 &p_other);
    ModelTransformDataV48 &operator=(const ModelTransformDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV48 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV48 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV48();
    ModelBoneDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV48(const ModelBoneDataV48 &p_other);
    ModelBoneDataV48 &operator=(const ModelBoneDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV48 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV48> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV48();
    ModelSkeletonDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV48(const ModelSkeletonDataV48 &p_other);
    ModelSkeletonDataV48 &operator=(const ModelSkeletonDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV48 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV48();
    ModelMeshBindingDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV48(const ModelMeshBindingDataV48 &p_other);
    ModelMeshBindingDataV48 &operator=(const ModelMeshBindingDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV48 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV48();
    ModelTrackMaskV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV48(const ModelTrackMaskV48 &p_other);
    ModelTrackMaskV48 &operator=(const ModelTrackMaskV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV48 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV48> Skeleton;
    ModelTransformDataV48 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV48> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV48> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV48();
    ModelModelDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV48(const ModelModelDataV48 &p_other);
    ModelModelDataV48 &operator=(const ModelModelDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV48 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV48();
    ModelPropertyDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV48(const ModelPropertyDataV48 &p_other);
    ModelPropertyDataV48 &operator=(const ModelPropertyDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV48 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV48();
    ModelParticleCloudV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV48(const ModelParticleCloudV48 &p_other);
    ModelParticleCloudV48 &operator=(const ModelParticleCloudV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV48 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV48();
    ModelParticleCurveV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV48(const ModelParticleCurveV48 &p_other);
    ModelParticleCurveV48 &operator=(const ModelParticleCurveV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV48 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV48();
    ModelParticleFlipbookV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV48(const ModelParticleFlipbookV48 &p_other);
    ModelParticleFlipbookV48 &operator=(const ModelParticleFlipbookV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV48 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV48> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV48> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV48> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV48();
    ModelParticleEmitterV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV48(const ModelParticleEmitterV48 &p_other);
    ModelParticleEmitterV48 &operator=(const ModelParticleEmitterV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV48 {
    helpers::Array<ModelParticleCloudV48> clouds;
    helpers::Array<ModelParticleEmitterV48> emitters;

public:
    ModelCloudDataV48();
    ModelCloudDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV48(const ModelCloudDataV48 &p_other);
    ModelCloudDataV48 &operator=(const ModelCloudDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV48 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV48();
    ModelObstacleDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV48(const ModelObstacleDataV48 &p_other);
    ModelObstacleDataV48 &operator=(const ModelObstacleDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV48 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV48();
    ModelStreakV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV48(const ModelStreakV48 &p_other);
    ModelStreakV48 &operator=(const ModelStreakV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV48 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV48();
    ModelStreakAnchorV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV48(const ModelStreakAnchorV48 &p_other);
    ModelStreakAnchorV48 &operator=(const ModelStreakAnchorV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV48 {
    helpers::Array<ModelStreakV48> streaks;
    helpers::Array<ModelStreakAnchorV48> anchors;

public:
    ModelStreakDataV48();
    ModelStreakDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV48(const ModelStreakDataV48 &p_other);
    ModelStreakDataV48 &operator=(const ModelStreakDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV48 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV48();
    ModelEffectLightV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV48(const ModelEffectLightV48 &p_other);
    ModelEffectLightV48 &operator=(const ModelEffectLightV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV48 {
    helpers::Array<ModelEffectLightV48> effectLights;

public:
    ModelLightDataV48();
    ModelLightDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV48(const ModelLightDataV48 &p_other);
    ModelLightDataV48 &operator=(const ModelLightDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV48 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV48();
    ModelClothBoneWeightV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV48(const ModelClothBoneWeightV48 &p_other);
    ModelClothBoneWeightV48 &operator=(const ModelClothBoneWeightV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV48 {
    helpers::Array<ModelClothBoneWeightV48> weights;

public:
    ModelClothMeshGroupV48();
    ModelClothMeshGroupV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV48(const ModelClothMeshGroupV48 &p_other);
    ModelClothMeshGroupV48 &operator=(const ModelClothMeshGroupV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV48 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV48();
    ModelClothConstraintV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV48(const ModelClothConstraintV48 &p_other);
    ModelClothConstraintV48 &operator=(const ModelClothConstraintV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV48 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV48();
    ModelClothObstacleV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV48(const ModelClothObstacleV48 &p_other);
    ModelClothObstacleV48 &operator=(const ModelClothObstacleV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV48 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV48> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV48> lod0Constraints;
    helpers::Array<ModelClothConstraintV48> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV48> obstacles;

public:
    ModelClothDataV48();
    ModelClothDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV48(const ModelClothDataV48 &p_other);
    ModelClothDataV48 &operator=(const ModelClothDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV48 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV48();
    ModelLightningSystemV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV48(const ModelLightningSystemV48 &p_other);
    ModelLightningSystemV48 &operator=(const ModelLightningSystemV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV48 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV48();
    ModelLightningBoltV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV48(const ModelLightningBoltV48 &p_other);
    ModelLightningBoltV48 &operator=(const ModelLightningBoltV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV48 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV48();
    ModelLightningNodeV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV48(const ModelLightningNodeV48 &p_other);
    ModelLightningNodeV48 &operator=(const ModelLightningNodeV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV48 {
    helpers::Array<ModelLightningSystemV48> systems;
    helpers::Array<ModelLightningBoltV48> bolts;
    helpers::Array<ModelLightningNodeV48> nodes;

public:
    ModelLightningDataV48();
    ModelLightningDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV48(const ModelLightningDataV48 &p_other);
    ModelLightningDataV48 &operator=(const ModelLightningDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV48 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV48();
    ModelBoneConstraintLinkV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV48(const ModelBoneConstraintLinkV48 &p_other);
    ModelBoneConstraintLinkV48 &operator=(const ModelBoneConstraintLinkV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV48 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV48> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV48();
    ModelBoneConstraintV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV48(const ModelBoneConstraintV48 &p_other);
    ModelBoneConstraintV48 &operator=(const ModelBoneConstraintV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV48 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV48();
    ModelSoftBodyDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV48(const ModelSoftBodyDataV48 &p_other);
    ModelSoftBodyDataV48 &operator=(const ModelSoftBodyDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV48 {
    helpers::Ptr<ModelMaterialDataV48> materials;
    helpers::Ptr<ModelMeshDataV48> meshes;
    helpers::Ptr<ModelModelDataV48> model;
    helpers::Array<ModelPropertyDataV48> properties;
    helpers::Ptr<ModelCloudDataV48> cloudData;
    helpers::Array<ModelObstacleDataV48> obstacles;
    helpers::Ptr<ModelStreakDataV48> streakData;
    helpers::Ptr<ModelLightDataV48> lightData;
    helpers::Array<ModelClothDataV48> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV48> lightningData;
    helpers::Array<ModelBoneConstraintV48> boneConstraints;
    helpers::Array<ModelSoftBodyDataV48> softBodyData;

public:
    ModelFileDataV48();
    ModelFileDataV48(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV48(const ModelFileDataV48 &p_other);
    ModelFileDataV48 &operator=(const ModelFileDataV48 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV48 Gw2Struct;
};

/* Version: 47, ReferencedFunction: 0x410DA18000000001 */

template <>
struct Gw2StructMODL<47>{
struct ModelTextureDataV47 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV47();
    ModelTextureDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV47(const ModelTextureDataV47 &p_other);
    ModelTextureDataV47 &operator=(const ModelTextureDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV47 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV47();
    ModelConstantDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV47(const ModelConstantDataV47 &p_other);
    ModelConstantDataV47 &operator=(const ModelConstantDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV47 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV47();
    ModelMatConstLinkV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV47(const ModelMatConstLinkV47 &p_other);
    ModelMatConstLinkV47 &operator=(const ModelMatConstLinkV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV47 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV47();
    ModelUVTransLinkV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV47(const ModelUVTransLinkV47 &p_other);
    ModelUVTransLinkV47 &operator=(const ModelUVTransLinkV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV47 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV47();
    ModelMaterialTexTransformV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV47(const ModelMaterialTexTransformV47 &p_other);
    ModelMaterialTexTransformV47 &operator=(const ModelMaterialTexTransformV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV47 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV47> textures;
    helpers::Array<ModelConstantDataV47> constants;
    helpers::Array<ModelMatConstLinkV47> matConstLinks;
    helpers::Array<ModelUVTransLinkV47> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV47> texTransforms;

public:
    ModelMaterialDataV47();
    ModelMaterialDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV47(const ModelMaterialDataV47 &p_other);
    ModelMaterialDataV47 &operator=(const ModelMaterialDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV47 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV47();
    ModelMeshLodDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV47(const ModelMeshLodDataV47 &p_other);
    ModelMeshLodDataV47 &operator=(const ModelMeshLodDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphVertV47 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV47();
    ModelMeshMorphVertV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV47(const ModelMeshMorphVertV47 &p_other);
    ModelMeshMorphVertV47 &operator=(const ModelMeshMorphVertV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV47 {
    helpers::Array<ModelMeshMorphVertV47> positions;
    helpers::Array<ModelMeshMorphVertV47> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV47();
    ModelMeshMorphTargetV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV47(const ModelMeshMorphTargetV47 &p_other);
    ModelMeshMorphTargetV47 &operator=(const ModelMeshMorphTargetV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV47 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV47> lods;
    helpers::Array<ModelMeshMorphTargetV47> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV47();
    ModelMeshDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV47(const ModelMeshDataV47 &p_other);
    ModelMeshDataV47 &operator=(const ModelMeshDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV47 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV47();
    ModelTransformDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV47(const ModelTransformDataV47 &p_other);
    ModelTransformDataV47 &operator=(const ModelTransformDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV47 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV47 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV47();
    ModelBoneDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV47(const ModelBoneDataV47 &p_other);
    ModelBoneDataV47 &operator=(const ModelBoneDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV47 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV47> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV47();
    ModelSkeletonDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV47(const ModelSkeletonDataV47 &p_other);
    ModelSkeletonDataV47 &operator=(const ModelSkeletonDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV47 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV47();
    ModelMeshBindingDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV47(const ModelMeshBindingDataV47 &p_other);
    ModelMeshBindingDataV47 &operator=(const ModelMeshBindingDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV47 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV47();
    ModelTrackMaskV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV47(const ModelTrackMaskV47 &p_other);
    ModelTrackMaskV47 &operator=(const ModelTrackMaskV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV47 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV47> Skeleton;
    ModelTransformDataV47 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV47> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV47> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV47();
    ModelModelDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV47(const ModelModelDataV47 &p_other);
    ModelModelDataV47 &operator=(const ModelModelDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV47 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV47();
    ModelPropertyDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV47(const ModelPropertyDataV47 &p_other);
    ModelPropertyDataV47 &operator=(const ModelPropertyDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV47 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV47();
    ModelParticleCloudV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV47(const ModelParticleCloudV47 &p_other);
    ModelParticleCloudV47 &operator=(const ModelParticleCloudV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV47 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV47();
    ModelParticleCurveV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV47(const ModelParticleCurveV47 &p_other);
    ModelParticleCurveV47 &operator=(const ModelParticleCurveV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV47 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV47();
    ModelParticleFlipbookV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV47(const ModelParticleFlipbookV47 &p_other);
    ModelParticleFlipbookV47 &operator=(const ModelParticleFlipbookV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV47 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV47> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV47> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV47> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV47();
    ModelParticleEmitterV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV47(const ModelParticleEmitterV47 &p_other);
    ModelParticleEmitterV47 &operator=(const ModelParticleEmitterV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV47 {
    helpers::Array<ModelParticleCloudV47> clouds;
    helpers::Array<ModelParticleEmitterV47> emitters;

public:
    ModelCloudDataV47();
    ModelCloudDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV47(const ModelCloudDataV47 &p_other);
    ModelCloudDataV47 &operator=(const ModelCloudDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV47 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV47();
    ModelObstacleDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV47(const ModelObstacleDataV47 &p_other);
    ModelObstacleDataV47 &operator=(const ModelObstacleDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV47 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV47();
    ModelStreakV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV47(const ModelStreakV47 &p_other);
    ModelStreakV47 &operator=(const ModelStreakV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV47 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV47();
    ModelStreakAnchorV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV47(const ModelStreakAnchorV47 &p_other);
    ModelStreakAnchorV47 &operator=(const ModelStreakAnchorV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV47 {
    helpers::Array<ModelStreakV47> streaks;
    helpers::Array<ModelStreakAnchorV47> anchors;

public:
    ModelStreakDataV47();
    ModelStreakDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV47(const ModelStreakDataV47 &p_other);
    ModelStreakDataV47 &operator=(const ModelStreakDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV47 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV47();
    ModelEffectLightV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV47(const ModelEffectLightV47 &p_other);
    ModelEffectLightV47 &operator=(const ModelEffectLightV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV47 {
    helpers::Array<ModelEffectLightV47> effectLights;

public:
    ModelLightDataV47();
    ModelLightDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV47(const ModelLightDataV47 &p_other);
    ModelLightDataV47 &operator=(const ModelLightDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV47 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV47();
    ModelClothBoneWeightV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV47(const ModelClothBoneWeightV47 &p_other);
    ModelClothBoneWeightV47 &operator=(const ModelClothBoneWeightV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV47 {
    helpers::Array<ModelClothBoneWeightV47> weights;

public:
    ModelClothMeshGroupV47();
    ModelClothMeshGroupV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV47(const ModelClothMeshGroupV47 &p_other);
    ModelClothMeshGroupV47 &operator=(const ModelClothMeshGroupV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV47 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV47();
    ModelClothConstraintV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV47(const ModelClothConstraintV47 &p_other);
    ModelClothConstraintV47 &operator=(const ModelClothConstraintV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV47 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV47();
    ModelClothObstacleV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV47(const ModelClothObstacleV47 &p_other);
    ModelClothObstacleV47 &operator=(const ModelClothObstacleV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV47 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV47> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV47> lod0Constraints;
    helpers::Array<ModelClothConstraintV47> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV47> obstacles;

public:
    ModelClothDataV47();
    ModelClothDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV47(const ModelClothDataV47 &p_other);
    ModelClothDataV47 &operator=(const ModelClothDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV47 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV47();
    ModelLightningSystemV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV47(const ModelLightningSystemV47 &p_other);
    ModelLightningSystemV47 &operator=(const ModelLightningSystemV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV47 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV47();
    ModelLightningBoltV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV47(const ModelLightningBoltV47 &p_other);
    ModelLightningBoltV47 &operator=(const ModelLightningBoltV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV47 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV47();
    ModelLightningNodeV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV47(const ModelLightningNodeV47 &p_other);
    ModelLightningNodeV47 &operator=(const ModelLightningNodeV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV47 {
    helpers::Array<ModelLightningSystemV47> systems;
    helpers::Array<ModelLightningBoltV47> bolts;
    helpers::Array<ModelLightningNodeV47> nodes;

public:
    ModelLightningDataV47();
    ModelLightningDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV47(const ModelLightningDataV47 &p_other);
    ModelLightningDataV47 &operator=(const ModelLightningDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV47 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV47();
    ModelBoneConstraintLinkV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV47(const ModelBoneConstraintLinkV47 &p_other);
    ModelBoneConstraintLinkV47 &operator=(const ModelBoneConstraintLinkV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV47 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV47> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV47();
    ModelBoneConstraintV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV47(const ModelBoneConstraintV47 &p_other);
    ModelBoneConstraintV47 &operator=(const ModelBoneConstraintV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV47 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV47();
    ModelSoftBodyDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV47(const ModelSoftBodyDataV47 &p_other);
    ModelSoftBodyDataV47 &operator=(const ModelSoftBodyDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV47 {
    helpers::Ptr<ModelMaterialDataV47> materials;
    helpers::Ptr<ModelMeshDataV47> meshes;
    helpers::Ptr<ModelModelDataV47> model;
    helpers::Array<ModelPropertyDataV47> properties;
    helpers::Ptr<ModelCloudDataV47> cloudData;
    helpers::Array<ModelObstacleDataV47> obstacles;
    helpers::Ptr<ModelStreakDataV47> streakData;
    helpers::Ptr<ModelLightDataV47> lightData;
    helpers::Array<ModelClothDataV47> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV47> lightningData;
    helpers::Array<ModelBoneConstraintV47> boneConstraints;
    helpers::Array<ModelSoftBodyDataV47> softBodyData;

public:
    ModelFileDataV47();
    ModelFileDataV47(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV47(const ModelFileDataV47 &p_other);
    ModelFileDataV47 &operator=(const ModelFileDataV47 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV47 Gw2Struct;
};

/* Version: 46, ReferencedFunction: 0x410DA0E000000001 */

template <>
struct Gw2StructMODL<46>{
struct ModelTextureDataV46 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV46();
    ModelTextureDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV46(const ModelTextureDataV46 &p_other);
    ModelTextureDataV46 &operator=(const ModelTextureDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV46 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV46();
    ModelConstantDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV46(const ModelConstantDataV46 &p_other);
    ModelConstantDataV46 &operator=(const ModelConstantDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV46 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV46();
    ModelMatConstLinkV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV46(const ModelMatConstLinkV46 &p_other);
    ModelMatConstLinkV46 &operator=(const ModelMatConstLinkV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV46 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV46();
    ModelUVTransLinkV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV46(const ModelUVTransLinkV46 &p_other);
    ModelUVTransLinkV46 &operator=(const ModelUVTransLinkV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV46 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV46();
    ModelMaterialTexTransformV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV46(const ModelMaterialTexTransformV46 &p_other);
    ModelMaterialTexTransformV46 &operator=(const ModelMaterialTexTransformV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV46 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV46> textures;
    helpers::Array<ModelConstantDataV46> constants;
    helpers::Array<ModelMatConstLinkV46> matConstLinks;
    helpers::Array<ModelUVTransLinkV46> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV46> texTransforms;

public:
    ModelMaterialDataV46();
    ModelMaterialDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV46(const ModelMaterialDataV46 &p_other);
    ModelMaterialDataV46 &operator=(const ModelMaterialDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV46 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV46();
    ModelMeshLodDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV46(const ModelMeshLodDataV46 &p_other);
    ModelMeshLodDataV46 &operator=(const ModelMeshLodDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV46 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV46();
    ModelMeshMorphTargetV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV46(const ModelMeshMorphTargetV46 &p_other);
    ModelMeshMorphTargetV46 &operator=(const ModelMeshMorphTargetV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV46 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV46> lods;
    helpers::Array<ModelMeshMorphTargetV46> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV46();
    ModelMeshDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV46(const ModelMeshDataV46 &p_other);
    ModelMeshDataV46 &operator=(const ModelMeshDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV46 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV46();
    ModelTransformDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV46(const ModelTransformDataV46 &p_other);
    ModelTransformDataV46 &operator=(const ModelTransformDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV46 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV46 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV46();
    ModelBoneDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV46(const ModelBoneDataV46 &p_other);
    ModelBoneDataV46 &operator=(const ModelBoneDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV46 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV46> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV46();
    ModelSkeletonDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV46(const ModelSkeletonDataV46 &p_other);
    ModelSkeletonDataV46 &operator=(const ModelSkeletonDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV46 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV46();
    ModelMeshBindingDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV46(const ModelMeshBindingDataV46 &p_other);
    ModelMeshBindingDataV46 &operator=(const ModelMeshBindingDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV46 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV46();
    ModelTrackMaskV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV46(const ModelTrackMaskV46 &p_other);
    ModelTrackMaskV46 &operator=(const ModelTrackMaskV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV46 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV46> Skeleton;
    ModelTransformDataV46 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV46> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV46> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV46();
    ModelModelDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV46(const ModelModelDataV46 &p_other);
    ModelModelDataV46 &operator=(const ModelModelDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV46 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV46();
    ModelPropertyDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV46(const ModelPropertyDataV46 &p_other);
    ModelPropertyDataV46 &operator=(const ModelPropertyDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV46 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV46();
    ModelParticleCloudV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV46(const ModelParticleCloudV46 &p_other);
    ModelParticleCloudV46 &operator=(const ModelParticleCloudV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV46 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV46();
    ModelParticleCurveV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV46(const ModelParticleCurveV46 &p_other);
    ModelParticleCurveV46 &operator=(const ModelParticleCurveV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV46 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV46();
    ModelParticleFlipbookV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV46(const ModelParticleFlipbookV46 &p_other);
    ModelParticleFlipbookV46 &operator=(const ModelParticleFlipbookV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV46 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV46> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV46> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV46> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV46();
    ModelParticleEmitterV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV46(const ModelParticleEmitterV46 &p_other);
    ModelParticleEmitterV46 &operator=(const ModelParticleEmitterV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV46 {
    helpers::Array<ModelParticleCloudV46> clouds;
    helpers::Array<ModelParticleEmitterV46> emitters;

public:
    ModelCloudDataV46();
    ModelCloudDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV46(const ModelCloudDataV46 &p_other);
    ModelCloudDataV46 &operator=(const ModelCloudDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV46 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV46();
    ModelObstacleDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV46(const ModelObstacleDataV46 &p_other);
    ModelObstacleDataV46 &operator=(const ModelObstacleDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV46 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV46();
    ModelStreakV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV46(const ModelStreakV46 &p_other);
    ModelStreakV46 &operator=(const ModelStreakV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV46 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV46();
    ModelStreakAnchorV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV46(const ModelStreakAnchorV46 &p_other);
    ModelStreakAnchorV46 &operator=(const ModelStreakAnchorV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV46 {
    helpers::Array<ModelStreakV46> streaks;
    helpers::Array<ModelStreakAnchorV46> anchors;

public:
    ModelStreakDataV46();
    ModelStreakDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV46(const ModelStreakDataV46 &p_other);
    ModelStreakDataV46 &operator=(const ModelStreakDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV46 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV46();
    ModelEffectLightV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV46(const ModelEffectLightV46 &p_other);
    ModelEffectLightV46 &operator=(const ModelEffectLightV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV46 {
    helpers::Array<ModelEffectLightV46> effectLights;

public:
    ModelLightDataV46();
    ModelLightDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV46(const ModelLightDataV46 &p_other);
    ModelLightDataV46 &operator=(const ModelLightDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV46 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV46();
    ModelClothBoneWeightV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV46(const ModelClothBoneWeightV46 &p_other);
    ModelClothBoneWeightV46 &operator=(const ModelClothBoneWeightV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV46 {
    helpers::Array<ModelClothBoneWeightV46> weights;

public:
    ModelClothMeshGroupV46();
    ModelClothMeshGroupV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV46(const ModelClothMeshGroupV46 &p_other);
    ModelClothMeshGroupV46 &operator=(const ModelClothMeshGroupV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV46 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV46();
    ModelClothConstraintV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV46(const ModelClothConstraintV46 &p_other);
    ModelClothConstraintV46 &operator=(const ModelClothConstraintV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV46 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV46();
    ModelClothObstacleV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV46(const ModelClothObstacleV46 &p_other);
    ModelClothObstacleV46 &operator=(const ModelClothObstacleV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV46 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV46> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV46> lod0Constraints;
    helpers::Array<ModelClothConstraintV46> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV46> obstacles;

public:
    ModelClothDataV46();
    ModelClothDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV46(const ModelClothDataV46 &p_other);
    ModelClothDataV46 &operator=(const ModelClothDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV46 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV46();
    ModelLightningSystemV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV46(const ModelLightningSystemV46 &p_other);
    ModelLightningSystemV46 &operator=(const ModelLightningSystemV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV46 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV46();
    ModelLightningBoltV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV46(const ModelLightningBoltV46 &p_other);
    ModelLightningBoltV46 &operator=(const ModelLightningBoltV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV46 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV46();
    ModelLightningNodeV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV46(const ModelLightningNodeV46 &p_other);
    ModelLightningNodeV46 &operator=(const ModelLightningNodeV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV46 {
    helpers::Array<ModelLightningSystemV46> systems;
    helpers::Array<ModelLightningBoltV46> bolts;
    helpers::Array<ModelLightningNodeV46> nodes;

public:
    ModelLightningDataV46();
    ModelLightningDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV46(const ModelLightningDataV46 &p_other);
    ModelLightningDataV46 &operator=(const ModelLightningDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV46 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV46();
    ModelBoneConstraintLinkV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV46(const ModelBoneConstraintLinkV46 &p_other);
    ModelBoneConstraintLinkV46 &operator=(const ModelBoneConstraintLinkV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV46 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV46> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV46();
    ModelBoneConstraintV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV46(const ModelBoneConstraintV46 &p_other);
    ModelBoneConstraintV46 &operator=(const ModelBoneConstraintV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV46 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV46();
    ModelSoftBodyDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV46(const ModelSoftBodyDataV46 &p_other);
    ModelSoftBodyDataV46 &operator=(const ModelSoftBodyDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV46 {
    helpers::Ptr<ModelMaterialDataV46> materials;
    helpers::Ptr<ModelMeshDataV46> meshes;
    helpers::Ptr<ModelModelDataV46> model;
    helpers::Array<ModelPropertyDataV46> properties;
    helpers::Ptr<ModelCloudDataV46> cloudData;
    helpers::Array<ModelObstacleDataV46> obstacles;
    helpers::Ptr<ModelStreakDataV46> streakData;
    helpers::Ptr<ModelLightDataV46> lightData;
    helpers::Array<ModelClothDataV46> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV46> lightningData;
    helpers::Array<ModelBoneConstraintV46> boneConstraints;
    helpers::Array<ModelSoftBodyDataV46> softBodyData;

public:
    ModelFileDataV46();
    ModelFileDataV46(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV46(const ModelFileDataV46 &p_other);
    ModelFileDataV46 &operator=(const ModelFileDataV46 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV46 Gw2Struct;
};

/* Version: 45, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<45>{
struct ModelTextureDataV45 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV45();
    ModelTextureDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV45(const ModelTextureDataV45 &p_other);
    ModelTextureDataV45 &operator=(const ModelTextureDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV45 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV45();
    ModelConstantDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV45(const ModelConstantDataV45 &p_other);
    ModelConstantDataV45 &operator=(const ModelConstantDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV45 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV45();
    ModelMatConstLinkV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV45(const ModelMatConstLinkV45 &p_other);
    ModelMatConstLinkV45 &operator=(const ModelMatConstLinkV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV45 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV45();
    ModelUVTransLinkV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV45(const ModelUVTransLinkV45 &p_other);
    ModelUVTransLinkV45 &operator=(const ModelUVTransLinkV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialTexTransformV45 {
    byte random;
    byte uvIndex;
    byte columns;
    byte rows;
    word count;
    float fps;
    float2 scroll;

public:
    ModelMaterialTexTransformV45();
    ModelMaterialTexTransformV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialTexTransformV45(const ModelMaterialTexTransformV45 &p_other);
    ModelMaterialTexTransformV45 &operator=(const ModelMaterialTexTransformV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV45 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV45> textures;
    helpers::Array<ModelConstantDataV45> constants;
    helpers::Array<ModelMatConstLinkV45> matConstLinks;
    helpers::Array<ModelUVTransLinkV45> uvTransLinks;
    helpers::Array<ModelMaterialTexTransformV45> texTransforms;

public:
    ModelMaterialDataV45();
    ModelMaterialDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV45(const ModelMaterialDataV45 &p_other);
    ModelMaterialDataV45 &operator=(const ModelMaterialDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV45 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV45();
    ModelMeshLodDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV45(const ModelMeshLodDataV45 &p_other);
    ModelMeshLodDataV45 &operator=(const ModelMeshLodDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV45 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV45();
    ModelMeshMorphTargetV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV45(const ModelMeshMorphTargetV45 &p_other);
    ModelMeshMorphTargetV45 &operator=(const ModelMeshMorphTargetV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV45 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV45> lods;
    helpers::Array<ModelMeshMorphTargetV45> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV45();
    ModelMeshDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV45(const ModelMeshDataV45 &p_other);
    ModelMeshDataV45 &operator=(const ModelMeshDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV45 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV45();
    ModelTransformDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV45(const ModelTransformDataV45 &p_other);
    ModelTransformDataV45 &operator=(const ModelTransformDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV45 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV45 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV45();
    ModelBoneDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV45(const ModelBoneDataV45 &p_other);
    ModelBoneDataV45 &operator=(const ModelBoneDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV45 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV45> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV45();
    ModelSkeletonDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV45(const ModelSkeletonDataV45 &p_other);
    ModelSkeletonDataV45 &operator=(const ModelSkeletonDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV45 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV45();
    ModelMeshBindingDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV45(const ModelMeshBindingDataV45 &p_other);
    ModelMeshBindingDataV45 &operator=(const ModelMeshBindingDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV45 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV45();
    ModelTrackMaskV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV45(const ModelTrackMaskV45 &p_other);
    ModelTrackMaskV45 &operator=(const ModelTrackMaskV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV45 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV45> Skeleton;
    ModelTransformDataV45 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV45> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV45> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV45();
    ModelModelDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV45(const ModelModelDataV45 &p_other);
    ModelModelDataV45 &operator=(const ModelModelDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV45 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV45();
    ModelPropertyDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV45(const ModelPropertyDataV45 &p_other);
    ModelPropertyDataV45 &operator=(const ModelPropertyDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV45 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV45();
    ModelParticleCloudV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV45(const ModelParticleCloudV45 &p_other);
    ModelParticleCloudV45 &operator=(const ModelParticleCloudV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV45 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV45();
    ModelParticleCurveV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV45(const ModelParticleCurveV45 &p_other);
    ModelParticleCurveV45 &operator=(const ModelParticleCurveV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV45 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV45();
    ModelParticleFlipbookV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV45(const ModelParticleFlipbookV45 &p_other);
    ModelParticleFlipbookV45 &operator=(const ModelParticleFlipbookV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV45 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV45> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV45> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV45> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV45();
    ModelParticleEmitterV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV45(const ModelParticleEmitterV45 &p_other);
    ModelParticleEmitterV45 &operator=(const ModelParticleEmitterV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV45 {
    helpers::Array<ModelParticleCloudV45> clouds;
    helpers::Array<ModelParticleEmitterV45> emitters;

public:
    ModelCloudDataV45();
    ModelCloudDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV45(const ModelCloudDataV45 &p_other);
    ModelCloudDataV45 &operator=(const ModelCloudDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV45 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV45();
    ModelObstacleDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV45(const ModelObstacleDataV45 &p_other);
    ModelObstacleDataV45 &operator=(const ModelObstacleDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV45 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV45();
    ModelStreakV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV45(const ModelStreakV45 &p_other);
    ModelStreakV45 &operator=(const ModelStreakV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV45 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV45();
    ModelStreakAnchorV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV45(const ModelStreakAnchorV45 &p_other);
    ModelStreakAnchorV45 &operator=(const ModelStreakAnchorV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV45 {
    helpers::Array<ModelStreakV45> streaks;
    helpers::Array<ModelStreakAnchorV45> anchors;

public:
    ModelStreakDataV45();
    ModelStreakDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV45(const ModelStreakDataV45 &p_other);
    ModelStreakDataV45 &operator=(const ModelStreakDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV45 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV45();
    ModelEffectLightV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV45(const ModelEffectLightV45 &p_other);
    ModelEffectLightV45 &operator=(const ModelEffectLightV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV45 {
    helpers::Array<ModelEffectLightV45> effectLights;

public:
    ModelLightDataV45();
    ModelLightDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV45(const ModelLightDataV45 &p_other);
    ModelLightDataV45 &operator=(const ModelLightDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV45 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV45();
    ModelClothBoneWeightV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV45(const ModelClothBoneWeightV45 &p_other);
    ModelClothBoneWeightV45 &operator=(const ModelClothBoneWeightV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV45 {
    helpers::Array<ModelClothBoneWeightV45> weights;

public:
    ModelClothMeshGroupV45();
    ModelClothMeshGroupV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV45(const ModelClothMeshGroupV45 &p_other);
    ModelClothMeshGroupV45 &operator=(const ModelClothMeshGroupV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV45 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV45();
    ModelClothConstraintV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV45(const ModelClothConstraintV45 &p_other);
    ModelClothConstraintV45 &operator=(const ModelClothConstraintV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV45 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV45();
    ModelClothObstacleV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV45(const ModelClothObstacleV45 &p_other);
    ModelClothObstacleV45 &operator=(const ModelClothObstacleV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV45 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV45> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV45> lod0Constraints;
    helpers::Array<ModelClothConstraintV45> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV45> obstacles;

public:
    ModelClothDataV45();
    ModelClothDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV45(const ModelClothDataV45 &p_other);
    ModelClothDataV45 &operator=(const ModelClothDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV45 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV45();
    ModelLightningSystemV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV45(const ModelLightningSystemV45 &p_other);
    ModelLightningSystemV45 &operator=(const ModelLightningSystemV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV45 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV45();
    ModelLightningBoltV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV45(const ModelLightningBoltV45 &p_other);
    ModelLightningBoltV45 &operator=(const ModelLightningBoltV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV45 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV45();
    ModelLightningNodeV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV45(const ModelLightningNodeV45 &p_other);
    ModelLightningNodeV45 &operator=(const ModelLightningNodeV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV45 {
    helpers::Array<ModelLightningSystemV45> systems;
    helpers::Array<ModelLightningBoltV45> bolts;
    helpers::Array<ModelLightningNodeV45> nodes;

public:
    ModelLightningDataV45();
    ModelLightningDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV45(const ModelLightningDataV45 &p_other);
    ModelLightningDataV45 &operator=(const ModelLightningDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV45 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV45();
    ModelBoneConstraintLinkV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV45(const ModelBoneConstraintLinkV45 &p_other);
    ModelBoneConstraintLinkV45 &operator=(const ModelBoneConstraintLinkV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV45 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV45> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV45();
    ModelBoneConstraintV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV45(const ModelBoneConstraintV45 &p_other);
    ModelBoneConstraintV45 &operator=(const ModelBoneConstraintV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV45 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV45();
    ModelSoftBodyDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV45(const ModelSoftBodyDataV45 &p_other);
    ModelSoftBodyDataV45 &operator=(const ModelSoftBodyDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV45 {
    helpers::Ptr<ModelMaterialDataV45> materials;
    helpers::Ptr<ModelMeshDataV45> meshes;
    helpers::Ptr<ModelModelDataV45> model;
    helpers::Array<ModelPropertyDataV45> properties;
    helpers::Ptr<ModelCloudDataV45> cloudData;
    helpers::Array<ModelObstacleDataV45> obstacles;
    helpers::Ptr<ModelStreakDataV45> streakData;
    helpers::Ptr<ModelLightDataV45> lightData;
    helpers::Array<ModelClothDataV45> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV45> lightningData;
    helpers::Array<ModelBoneConstraintV45> boneConstraints;
    helpers::Array<ModelSoftBodyDataV45> softBodyData;

public:
    ModelFileDataV45();
    ModelFileDataV45(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV45(const ModelFileDataV45 &p_other);
    ModelFileDataV45 &operator=(const ModelFileDataV45 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV45 Gw2Struct;
};

/* Version: 44, ReferencedFunction: 0x410D9E9000000001 */

template <>
struct Gw2StructMODL<44>{
struct ModelTextureDataV44 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV44();
    ModelTextureDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV44(const ModelTextureDataV44 &p_other);
    ModelTextureDataV44 &operator=(const ModelTextureDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV44 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV44();
    ModelConstantDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV44(const ModelConstantDataV44 &p_other);
    ModelConstantDataV44 &operator=(const ModelConstantDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV44 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV44();
    ModelMatConstLinkV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV44(const ModelMatConstLinkV44 &p_other);
    ModelMatConstLinkV44 &operator=(const ModelMatConstLinkV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV44 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV44();
    ModelUVTransLinkV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV44(const ModelUVTransLinkV44 &p_other);
    ModelUVTransLinkV44 &operator=(const ModelUVTransLinkV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV44 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV44> textures;
    helpers::Array<ModelConstantDataV44> constants;
    helpers::Array<ModelMatConstLinkV44> matConstLinks;
    helpers::Array<ModelUVTransLinkV44> uvTransLinks;

public:
    ModelMaterialDataV44();
    ModelMaterialDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV44(const ModelMaterialDataV44 &p_other);
    ModelMaterialDataV44 &operator=(const ModelMaterialDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV44 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV44();
    ModelMeshLodDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV44(const ModelMeshLodDataV44 &p_other);
    ModelMeshLodDataV44 &operator=(const ModelMeshLodDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV44 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV44();
    ModelMeshMorphTargetV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV44(const ModelMeshMorphTargetV44 &p_other);
    ModelMeshMorphTargetV44 &operator=(const ModelMeshMorphTargetV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV44 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV44> lods;
    helpers::Array<ModelMeshMorphTargetV44> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV44();
    ModelMeshDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV44(const ModelMeshDataV44 &p_other);
    ModelMeshDataV44 &operator=(const ModelMeshDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV44 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV44();
    ModelTransformDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV44(const ModelTransformDataV44 &p_other);
    ModelTransformDataV44 &operator=(const ModelTransformDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV44 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV44 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV44();
    ModelBoneDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV44(const ModelBoneDataV44 &p_other);
    ModelBoneDataV44 &operator=(const ModelBoneDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV44 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV44> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV44();
    ModelSkeletonDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV44(const ModelSkeletonDataV44 &p_other);
    ModelSkeletonDataV44 &operator=(const ModelSkeletonDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV44 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV44();
    ModelMeshBindingDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV44(const ModelMeshBindingDataV44 &p_other);
    ModelMeshBindingDataV44 &operator=(const ModelMeshBindingDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV44 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV44();
    ModelTrackMaskV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV44(const ModelTrackMaskV44 &p_other);
    ModelTrackMaskV44 &operator=(const ModelTrackMaskV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV44 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV44> Skeleton;
    ModelTransformDataV44 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV44> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV44> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV44();
    ModelModelDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV44(const ModelModelDataV44 &p_other);
    ModelModelDataV44 &operator=(const ModelModelDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV44 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV44();
    ModelPropertyDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV44(const ModelPropertyDataV44 &p_other);
    ModelPropertyDataV44 &operator=(const ModelPropertyDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV44 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV44();
    ModelParticleCloudV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV44(const ModelParticleCloudV44 &p_other);
    ModelParticleCloudV44 &operator=(const ModelParticleCloudV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV44 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV44();
    ModelParticleCurveV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV44(const ModelParticleCurveV44 &p_other);
    ModelParticleCurveV44 &operator=(const ModelParticleCurveV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV44 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV44();
    ModelParticleFlipbookV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV44(const ModelParticleFlipbookV44 &p_other);
    ModelParticleFlipbookV44 &operator=(const ModelParticleFlipbookV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV44 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV44> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV44> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV44> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV44();
    ModelParticleEmitterV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV44(const ModelParticleEmitterV44 &p_other);
    ModelParticleEmitterV44 &operator=(const ModelParticleEmitterV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV44 {
    helpers::Array<ModelParticleCloudV44> clouds;
    helpers::Array<ModelParticleEmitterV44> emitters;

public:
    ModelCloudDataV44();
    ModelCloudDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV44(const ModelCloudDataV44 &p_other);
    ModelCloudDataV44 &operator=(const ModelCloudDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV44 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV44();
    ModelObstacleDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV44(const ModelObstacleDataV44 &p_other);
    ModelObstacleDataV44 &operator=(const ModelObstacleDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV44 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV44();
    ModelStreakV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV44(const ModelStreakV44 &p_other);
    ModelStreakV44 &operator=(const ModelStreakV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV44 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV44();
    ModelStreakAnchorV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV44(const ModelStreakAnchorV44 &p_other);
    ModelStreakAnchorV44 &operator=(const ModelStreakAnchorV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV44 {
    helpers::Array<ModelStreakV44> streaks;
    helpers::Array<ModelStreakAnchorV44> anchors;

public:
    ModelStreakDataV44();
    ModelStreakDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV44(const ModelStreakDataV44 &p_other);
    ModelStreakDataV44 &operator=(const ModelStreakDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV44 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV44();
    ModelEffectLightV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV44(const ModelEffectLightV44 &p_other);
    ModelEffectLightV44 &operator=(const ModelEffectLightV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV44 {
    helpers::Array<ModelEffectLightV44> effectLights;

public:
    ModelLightDataV44();
    ModelLightDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV44(const ModelLightDataV44 &p_other);
    ModelLightDataV44 &operator=(const ModelLightDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV44 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV44();
    ModelClothBoneWeightV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV44(const ModelClothBoneWeightV44 &p_other);
    ModelClothBoneWeightV44 &operator=(const ModelClothBoneWeightV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV44 {
    helpers::Array<ModelClothBoneWeightV44> weights;

public:
    ModelClothMeshGroupV44();
    ModelClothMeshGroupV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV44(const ModelClothMeshGroupV44 &p_other);
    ModelClothMeshGroupV44 &operator=(const ModelClothMeshGroupV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV44 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV44();
    ModelClothConstraintV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV44(const ModelClothConstraintV44 &p_other);
    ModelClothConstraintV44 &operator=(const ModelClothConstraintV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV44 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV44();
    ModelClothObstacleV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV44(const ModelClothObstacleV44 &p_other);
    ModelClothObstacleV44 &operator=(const ModelClothObstacleV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV44 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV44> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV44> lod0Constraints;
    helpers::Array<ModelClothConstraintV44> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV44> obstacles;

public:
    ModelClothDataV44();
    ModelClothDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV44(const ModelClothDataV44 &p_other);
    ModelClothDataV44 &operator=(const ModelClothDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV44 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV44();
    ModelLightningSystemV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV44(const ModelLightningSystemV44 &p_other);
    ModelLightningSystemV44 &operator=(const ModelLightningSystemV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV44 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV44();
    ModelLightningBoltV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV44(const ModelLightningBoltV44 &p_other);
    ModelLightningBoltV44 &operator=(const ModelLightningBoltV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV44 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV44();
    ModelLightningNodeV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV44(const ModelLightningNodeV44 &p_other);
    ModelLightningNodeV44 &operator=(const ModelLightningNodeV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV44 {
    helpers::Array<ModelLightningSystemV44> systems;
    helpers::Array<ModelLightningBoltV44> bolts;
    helpers::Array<ModelLightningNodeV44> nodes;

public:
    ModelLightningDataV44();
    ModelLightningDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV44(const ModelLightningDataV44 &p_other);
    ModelLightningDataV44 &operator=(const ModelLightningDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV44 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV44();
    ModelBoneConstraintLinkV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV44(const ModelBoneConstraintLinkV44 &p_other);
    ModelBoneConstraintLinkV44 &operator=(const ModelBoneConstraintLinkV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV44 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV44> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV44();
    ModelBoneConstraintV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV44(const ModelBoneConstraintV44 &p_other);
    ModelBoneConstraintV44 &operator=(const ModelBoneConstraintV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV44 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV44();
    ModelSoftBodyDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV44(const ModelSoftBodyDataV44 &p_other);
    ModelSoftBodyDataV44 &operator=(const ModelSoftBodyDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV44 {
    helpers::Ptr<ModelMaterialDataV44> materials;
    helpers::Ptr<ModelMeshDataV44> meshes;
    helpers::Ptr<ModelModelDataV44> model;
    helpers::Array<ModelPropertyDataV44> properties;
    helpers::Ptr<ModelCloudDataV44> cloudData;
    helpers::Array<ModelObstacleDataV44> obstacles;
    helpers::Ptr<ModelStreakDataV44> streakData;
    helpers::Ptr<ModelLightDataV44> lightData;
    helpers::Array<ModelClothDataV44> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV44> lightningData;
    helpers::Array<ModelBoneConstraintV44> boneConstraints;
    helpers::Array<ModelSoftBodyDataV44> softBodyData;

public:
    ModelFileDataV44();
    ModelFileDataV44(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV44(const ModelFileDataV44 &p_other);
    ModelFileDataV44 &operator=(const ModelFileDataV44 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV44 Gw2Struct;
};

/* Version: 43, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<43>{
struct ModelTextureDataV43 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV43();
    ModelTextureDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV43(const ModelTextureDataV43 &p_other);
    ModelTextureDataV43 &operator=(const ModelTextureDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV43 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV43();
    ModelConstantDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV43(const ModelConstantDataV43 &p_other);
    ModelConstantDataV43 &operator=(const ModelConstantDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV43 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV43();
    ModelMatConstLinkV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV43(const ModelMatConstLinkV43 &p_other);
    ModelMatConstLinkV43 &operator=(const ModelMatConstLinkV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV43 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV43();
    ModelUVTransLinkV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV43(const ModelUVTransLinkV43 &p_other);
    ModelUVTransLinkV43 &operator=(const ModelUVTransLinkV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV43 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV43> textures;
    helpers::Array<ModelConstantDataV43> constants;
    helpers::Array<ModelMatConstLinkV43> matConstLinks;
    helpers::Array<ModelUVTransLinkV43> uvTransLinks;

public:
    ModelMaterialDataV43();
    ModelMaterialDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV43(const ModelMaterialDataV43 &p_other);
    ModelMaterialDataV43 &operator=(const ModelMaterialDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV43 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV43();
    ModelMeshLodDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV43(const ModelMeshLodDataV43 &p_other);
    ModelMeshLodDataV43 &operator=(const ModelMeshLodDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV43 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV43();
    ModelMeshMorphTargetV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV43(const ModelMeshMorphTargetV43 &p_other);
    ModelMeshMorphTargetV43 &operator=(const ModelMeshMorphTargetV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV43 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV43> lods;
    helpers::Array<ModelMeshMorphTargetV43> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV43();
    ModelMeshDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV43(const ModelMeshDataV43 &p_other);
    ModelMeshDataV43 &operator=(const ModelMeshDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV43 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV43();
    ModelTransformDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV43(const ModelTransformDataV43 &p_other);
    ModelTransformDataV43 &operator=(const ModelTransformDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV43 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV43 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV43();
    ModelBoneDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV43(const ModelBoneDataV43 &p_other);
    ModelBoneDataV43 &operator=(const ModelBoneDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV43 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV43> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelSkeletonDataV43();
    ModelSkeletonDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV43(const ModelSkeletonDataV43 &p_other);
    ModelSkeletonDataV43 &operator=(const ModelSkeletonDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV43 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV43();
    ModelMeshBindingDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV43(const ModelMeshBindingDataV43 &p_other);
    ModelMeshBindingDataV43 &operator=(const ModelMeshBindingDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV43 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV43();
    ModelTrackMaskV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV43(const ModelTrackMaskV43 &p_other);
    ModelTrackMaskV43 &operator=(const ModelTrackMaskV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV43 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV43> Skeleton;
    ModelTransformDataV43 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV43> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV43> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV43();
    ModelModelDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV43(const ModelModelDataV43 &p_other);
    ModelModelDataV43 &operator=(const ModelModelDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV43 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV43();
    ModelPropertyDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV43(const ModelPropertyDataV43 &p_other);
    ModelPropertyDataV43 &operator=(const ModelPropertyDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV43 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV43();
    ModelParticleCloudV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV43(const ModelParticleCloudV43 &p_other);
    ModelParticleCloudV43 &operator=(const ModelParticleCloudV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV43 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV43();
    ModelParticleCurveV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV43(const ModelParticleCurveV43 &p_other);
    ModelParticleCurveV43 &operator=(const ModelParticleCurveV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV43 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV43();
    ModelParticleFlipbookV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV43(const ModelParticleFlipbookV43 &p_other);
    ModelParticleFlipbookV43 &operator=(const ModelParticleFlipbookV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV43 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV43> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV43> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV43> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV43();
    ModelParticleEmitterV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV43(const ModelParticleEmitterV43 &p_other);
    ModelParticleEmitterV43 &operator=(const ModelParticleEmitterV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV43 {
    helpers::Array<ModelParticleCloudV43> clouds;
    helpers::Array<ModelParticleEmitterV43> emitters;

public:
    ModelCloudDataV43();
    ModelCloudDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV43(const ModelCloudDataV43 &p_other);
    ModelCloudDataV43 &operator=(const ModelCloudDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV43 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV43();
    ModelObstacleDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV43(const ModelObstacleDataV43 &p_other);
    ModelObstacleDataV43 &operator=(const ModelObstacleDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV43 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV43();
    ModelStreakV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV43(const ModelStreakV43 &p_other);
    ModelStreakV43 &operator=(const ModelStreakV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV43 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV43();
    ModelStreakAnchorV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV43(const ModelStreakAnchorV43 &p_other);
    ModelStreakAnchorV43 &operator=(const ModelStreakAnchorV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV43 {
    helpers::Array<ModelStreakV43> streaks;
    helpers::Array<ModelStreakAnchorV43> anchors;

public:
    ModelStreakDataV43();
    ModelStreakDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV43(const ModelStreakDataV43 &p_other);
    ModelStreakDataV43 &operator=(const ModelStreakDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV43 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV43();
    ModelEffectLightV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV43(const ModelEffectLightV43 &p_other);
    ModelEffectLightV43 &operator=(const ModelEffectLightV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV43 {
    helpers::Array<ModelEffectLightV43> effectLights;

public:
    ModelLightDataV43();
    ModelLightDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV43(const ModelLightDataV43 &p_other);
    ModelLightDataV43 &operator=(const ModelLightDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV43 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV43();
    ModelClothBoneWeightV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV43(const ModelClothBoneWeightV43 &p_other);
    ModelClothBoneWeightV43 &operator=(const ModelClothBoneWeightV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV43 {
    helpers::Array<ModelClothBoneWeightV43> weights;

public:
    ModelClothMeshGroupV43();
    ModelClothMeshGroupV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV43(const ModelClothMeshGroupV43 &p_other);
    ModelClothMeshGroupV43 &operator=(const ModelClothMeshGroupV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV43 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV43();
    ModelClothConstraintV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV43(const ModelClothConstraintV43 &p_other);
    ModelClothConstraintV43 &operator=(const ModelClothConstraintV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV43 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV43();
    ModelClothObstacleV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV43(const ModelClothObstacleV43 &p_other);
    ModelClothObstacleV43 &operator=(const ModelClothObstacleV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV43 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV43> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV43> lod0Constraints;
    helpers::Array<ModelClothConstraintV43> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV43> obstacles;

public:
    ModelClothDataV43();
    ModelClothDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV43(const ModelClothDataV43 &p_other);
    ModelClothDataV43 &operator=(const ModelClothDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV43 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV43();
    ModelLightningSystemV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV43(const ModelLightningSystemV43 &p_other);
    ModelLightningSystemV43 &operator=(const ModelLightningSystemV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV43 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV43();
    ModelLightningBoltV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV43(const ModelLightningBoltV43 &p_other);
    ModelLightningBoltV43 &operator=(const ModelLightningBoltV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV43 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV43();
    ModelLightningNodeV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV43(const ModelLightningNodeV43 &p_other);
    ModelLightningNodeV43 &operator=(const ModelLightningNodeV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV43 {
    helpers::Array<ModelLightningSystemV43> systems;
    helpers::Array<ModelLightningBoltV43> bolts;
    helpers::Array<ModelLightningNodeV43> nodes;

public:
    ModelLightningDataV43();
    ModelLightningDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV43(const ModelLightningDataV43 &p_other);
    ModelLightningDataV43 &operator=(const ModelLightningDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV43 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV43();
    ModelBoneConstraintLinkV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV43(const ModelBoneConstraintLinkV43 &p_other);
    ModelBoneConstraintLinkV43 &operator=(const ModelBoneConstraintLinkV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV43 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV43> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV43();
    ModelBoneConstraintV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV43(const ModelBoneConstraintV43 &p_other);
    ModelBoneConstraintV43 &operator=(const ModelBoneConstraintV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV43 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV43();
    ModelSoftBodyDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV43(const ModelSoftBodyDataV43 &p_other);
    ModelSoftBodyDataV43 &operator=(const ModelSoftBodyDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV43 {
    helpers::Ptr<ModelMaterialDataV43> materials;
    helpers::Ptr<ModelMeshDataV43> meshes;
    helpers::Ptr<ModelModelDataV43> model;
    helpers::Array<ModelPropertyDataV43> properties;
    helpers::Ptr<ModelCloudDataV43> cloudData;
    helpers::Array<ModelObstacleDataV43> obstacles;
    helpers::Ptr<ModelStreakDataV43> streakData;
    helpers::Ptr<ModelLightDataV43> lightData;
    helpers::Array<ModelClothDataV43> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV43> lightningData;
    helpers::Array<ModelBoneConstraintV43> boneConstraints;
    helpers::Array<ModelSoftBodyDataV43> softBodyData;

public:
    ModelFileDataV43();
    ModelFileDataV43(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV43(const ModelFileDataV43 &p_other);
    ModelFileDataV43 &operator=(const ModelFileDataV43 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV43 Gw2Struct;
};

/* Version: 42, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<42>{
struct ModelTextureDataV42 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV42();
    ModelTextureDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV42(const ModelTextureDataV42 &p_other);
    ModelTextureDataV42 &operator=(const ModelTextureDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV42 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV42();
    ModelConstantDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV42(const ModelConstantDataV42 &p_other);
    ModelConstantDataV42 &operator=(const ModelConstantDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV42 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV42();
    ModelMatConstLinkV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV42(const ModelMatConstLinkV42 &p_other);
    ModelMatConstLinkV42 &operator=(const ModelMatConstLinkV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV42 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV42();
    ModelUVTransLinkV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV42(const ModelUVTransLinkV42 &p_other);
    ModelUVTransLinkV42 &operator=(const ModelUVTransLinkV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV42 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV42> textures;
    helpers::Array<ModelConstantDataV42> constants;
    helpers::Array<ModelMatConstLinkV42> matConstLinks;
    helpers::Array<ModelUVTransLinkV42> uvTransLinks;

public:
    ModelMaterialDataV42();
    ModelMaterialDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV42(const ModelMaterialDataV42 &p_other);
    ModelMaterialDataV42 &operator=(const ModelMaterialDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV42 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV42();
    ModelMeshLodDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV42(const ModelMeshLodDataV42 &p_other);
    ModelMeshLodDataV42 &operator=(const ModelMeshLodDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV42 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV42();
    ModelMeshMorphTargetV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV42(const ModelMeshMorphTargetV42 &p_other);
    ModelMeshMorphTargetV42 &operator=(const ModelMeshMorphTargetV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV42 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV42> lods;
    helpers::Array<ModelMeshMorphTargetV42> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV42();
    ModelMeshDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV42(const ModelMeshDataV42 &p_other);
    ModelMeshDataV42 &operator=(const ModelMeshDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV42 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV42();
    ModelTransformDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV42(const ModelTransformDataV42 &p_other);
    ModelTransformDataV42 &operator=(const ModelTransformDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV42 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV42 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV42();
    ModelBoneDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV42(const ModelBoneDataV42 &p_other);
    ModelBoneDataV42 &operator=(const ModelBoneDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV42 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV42> Bones;
    dword LODType;

public:
    ModelSkeletonDataV42();
    ModelSkeletonDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV42(const ModelSkeletonDataV42 &p_other);
    ModelSkeletonDataV42 &operator=(const ModelSkeletonDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV42 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV42();
    ModelMeshBindingDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV42(const ModelMeshBindingDataV42 &p_other);
    ModelMeshBindingDataV42 &operator=(const ModelMeshBindingDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV42 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV42();
    ModelTrackMaskV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV42(const ModelTrackMaskV42 &p_other);
    ModelTrackMaskV42 &operator=(const ModelTrackMaskV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV42 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV42> Skeleton;
    ModelTransformDataV42 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV42> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV42> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV42();
    ModelModelDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV42(const ModelModelDataV42 &p_other);
    ModelModelDataV42 &operator=(const ModelModelDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV42 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV42();
    ModelPropertyDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV42(const ModelPropertyDataV42 &p_other);
    ModelPropertyDataV42 &operator=(const ModelPropertyDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV42 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV42();
    ModelParticleCloudV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV42(const ModelParticleCloudV42 &p_other);
    ModelParticleCloudV42 &operator=(const ModelParticleCloudV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV42 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV42();
    ModelParticleCurveV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV42(const ModelParticleCurveV42 &p_other);
    ModelParticleCurveV42 &operator=(const ModelParticleCurveV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV42 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV42();
    ModelParticleFlipbookV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV42(const ModelParticleFlipbookV42 &p_other);
    ModelParticleFlipbookV42 &operator=(const ModelParticleFlipbookV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV42 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV42> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV42> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV42> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV42();
    ModelParticleEmitterV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV42(const ModelParticleEmitterV42 &p_other);
    ModelParticleEmitterV42 &operator=(const ModelParticleEmitterV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV42 {
    helpers::Array<ModelParticleCloudV42> clouds;
    helpers::Array<ModelParticleEmitterV42> emitters;

public:
    ModelCloudDataV42();
    ModelCloudDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV42(const ModelCloudDataV42 &p_other);
    ModelCloudDataV42 &operator=(const ModelCloudDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV42 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV42();
    ModelObstacleDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV42(const ModelObstacleDataV42 &p_other);
    ModelObstacleDataV42 &operator=(const ModelObstacleDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV42 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV42();
    ModelStreakV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV42(const ModelStreakV42 &p_other);
    ModelStreakV42 &operator=(const ModelStreakV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV42 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV42();
    ModelStreakAnchorV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV42(const ModelStreakAnchorV42 &p_other);
    ModelStreakAnchorV42 &operator=(const ModelStreakAnchorV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV42 {
    helpers::Array<ModelStreakV42> streaks;
    helpers::Array<ModelStreakAnchorV42> anchors;

public:
    ModelStreakDataV42();
    ModelStreakDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV42(const ModelStreakDataV42 &p_other);
    ModelStreakDataV42 &operator=(const ModelStreakDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV42 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV42();
    ModelEffectLightV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV42(const ModelEffectLightV42 &p_other);
    ModelEffectLightV42 &operator=(const ModelEffectLightV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV42 {
    helpers::Array<ModelEffectLightV42> effectLights;

public:
    ModelLightDataV42();
    ModelLightDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV42(const ModelLightDataV42 &p_other);
    ModelLightDataV42 &operator=(const ModelLightDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV42 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV42();
    ModelClothBoneWeightV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV42(const ModelClothBoneWeightV42 &p_other);
    ModelClothBoneWeightV42 &operator=(const ModelClothBoneWeightV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV42 {
    helpers::Array<ModelClothBoneWeightV42> weights;

public:
    ModelClothMeshGroupV42();
    ModelClothMeshGroupV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV42(const ModelClothMeshGroupV42 &p_other);
    ModelClothMeshGroupV42 &operator=(const ModelClothMeshGroupV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV42 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV42();
    ModelClothConstraintV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV42(const ModelClothConstraintV42 &p_other);
    ModelClothConstraintV42 &operator=(const ModelClothConstraintV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV42 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV42();
    ModelClothObstacleV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV42(const ModelClothObstacleV42 &p_other);
    ModelClothObstacleV42 &operator=(const ModelClothObstacleV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV42 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV42> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV42> lod0Constraints;
    helpers::Array<ModelClothConstraintV42> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV42> obstacles;

public:
    ModelClothDataV42();
    ModelClothDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV42(const ModelClothDataV42 &p_other);
    ModelClothDataV42 &operator=(const ModelClothDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV42 {
    qword bone;
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV42();
    ModelLightningSystemV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV42(const ModelLightningSystemV42 &p_other);
    ModelLightningSystemV42 &operator=(const ModelLightningSystemV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV42 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV42();
    ModelLightningBoltV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV42(const ModelLightningBoltV42 &p_other);
    ModelLightningBoltV42 &operator=(const ModelLightningBoltV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV42 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV42();
    ModelLightningNodeV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV42(const ModelLightningNodeV42 &p_other);
    ModelLightningNodeV42 &operator=(const ModelLightningNodeV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV42 {
    helpers::Array<ModelLightningSystemV42> systems;
    helpers::Array<ModelLightningBoltV42> bolts;
    helpers::Array<ModelLightningNodeV42> nodes;

public:
    ModelLightningDataV42();
    ModelLightningDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV42(const ModelLightningDataV42 &p_other);
    ModelLightningDataV42 &operator=(const ModelLightningDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV42 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV42();
    ModelBoneConstraintLinkV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV42(const ModelBoneConstraintLinkV42 &p_other);
    ModelBoneConstraintLinkV42 &operator=(const ModelBoneConstraintLinkV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV42 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV42> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV42();
    ModelBoneConstraintV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV42(const ModelBoneConstraintV42 &p_other);
    ModelBoneConstraintV42 &operator=(const ModelBoneConstraintV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV42 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV42();
    ModelSoftBodyDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV42(const ModelSoftBodyDataV42 &p_other);
    ModelSoftBodyDataV42 &operator=(const ModelSoftBodyDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV42 {
    helpers::Ptr<ModelMaterialDataV42> materials;
    helpers::Ptr<ModelMeshDataV42> meshes;
    helpers::Ptr<ModelModelDataV42> model;
    helpers::Array<ModelPropertyDataV42> properties;
    helpers::Ptr<ModelCloudDataV42> cloudData;
    helpers::Array<ModelObstacleDataV42> obstacles;
    helpers::Ptr<ModelStreakDataV42> streakData;
    helpers::Ptr<ModelLightDataV42> lightData;
    helpers::Array<ModelClothDataV42> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV42> lightningData;
    helpers::Array<ModelBoneConstraintV42> boneConstraints;
    helpers::Array<ModelSoftBodyDataV42> softBodyData;

public:
    ModelFileDataV42();
    ModelFileDataV42(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV42(const ModelFileDataV42 &p_other);
    ModelFileDataV42 &operator=(const ModelFileDataV42 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV42 Gw2Struct;
};

/* Version: 41, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<41>{
struct ModelTextureDataV41 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV41();
    ModelTextureDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV41(const ModelTextureDataV41 &p_other);
    ModelTextureDataV41 &operator=(const ModelTextureDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV41 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV41();
    ModelConstantDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV41(const ModelConstantDataV41 &p_other);
    ModelConstantDataV41 &operator=(const ModelConstantDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV41 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV41();
    ModelMatConstLinkV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV41(const ModelMatConstLinkV41 &p_other);
    ModelMatConstLinkV41 &operator=(const ModelMatConstLinkV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV41 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV41();
    ModelUVTransLinkV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV41(const ModelUVTransLinkV41 &p_other);
    ModelUVTransLinkV41 &operator=(const ModelUVTransLinkV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV41 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV41> textures;
    helpers::Array<ModelConstantDataV41> constants;
    helpers::Array<ModelMatConstLinkV41> matConstLinks;
    helpers::Array<ModelUVTransLinkV41> uvTransLinks;

public:
    ModelMaterialDataV41();
    ModelMaterialDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV41(const ModelMaterialDataV41 &p_other);
    ModelMaterialDataV41 &operator=(const ModelMaterialDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV41 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV41();
    ModelMeshLodDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV41(const ModelMeshLodDataV41 &p_other);
    ModelMeshLodDataV41 &operator=(const ModelMeshLodDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV41 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV41();
    ModelMeshMorphTargetV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV41(const ModelMeshMorphTargetV41 &p_other);
    ModelMeshMorphTargetV41 &operator=(const ModelMeshMorphTargetV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV41 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV41> lods;
    helpers::Array<ModelMeshMorphTargetV41> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV41();
    ModelMeshDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV41(const ModelMeshDataV41 &p_other);
    ModelMeshDataV41 &operator=(const ModelMeshDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV41 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV41();
    ModelTransformDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV41(const ModelTransformDataV41 &p_other);
    ModelTransformDataV41 &operator=(const ModelTransformDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV41 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV41 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV41();
    ModelBoneDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV41(const ModelBoneDataV41 &p_other);
    ModelBoneDataV41 &operator=(const ModelBoneDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV41 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV41> Bones;
    dword LODType;

public:
    ModelSkeletonDataV41();
    ModelSkeletonDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV41(const ModelSkeletonDataV41 &p_other);
    ModelSkeletonDataV41 &operator=(const ModelSkeletonDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV41 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV41();
    ModelMeshBindingDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV41(const ModelMeshBindingDataV41 &p_other);
    ModelMeshBindingDataV41 &operator=(const ModelMeshBindingDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV41 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV41();
    ModelTrackMaskV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV41(const ModelTrackMaskV41 &p_other);
    ModelTrackMaskV41 &operator=(const ModelTrackMaskV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV41 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV41> Skeleton;
    ModelTransformDataV41 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV41> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV41> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV41();
    ModelModelDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV41(const ModelModelDataV41 &p_other);
    ModelModelDataV41 &operator=(const ModelModelDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV41 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV41();
    ModelPropertyDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV41(const ModelPropertyDataV41 &p_other);
    ModelPropertyDataV41 &operator=(const ModelPropertyDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV41 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV41();
    ModelParticleCloudV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV41(const ModelParticleCloudV41 &p_other);
    ModelParticleCloudV41 &operator=(const ModelParticleCloudV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV41 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV41();
    ModelParticleCurveV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV41(const ModelParticleCurveV41 &p_other);
    ModelParticleCurveV41 &operator=(const ModelParticleCurveV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV41 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV41();
    ModelParticleFlipbookV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV41(const ModelParticleFlipbookV41 &p_other);
    ModelParticleFlipbookV41 &operator=(const ModelParticleFlipbookV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV41 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV41> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV41> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV41> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV41();
    ModelParticleEmitterV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV41(const ModelParticleEmitterV41 &p_other);
    ModelParticleEmitterV41 &operator=(const ModelParticleEmitterV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV41 {
    helpers::Array<ModelParticleCloudV41> clouds;
    helpers::Array<ModelParticleEmitterV41> emitters;

public:
    ModelCloudDataV41();
    ModelCloudDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV41(const ModelCloudDataV41 &p_other);
    ModelCloudDataV41 &operator=(const ModelCloudDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV41 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV41();
    ModelObstacleDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV41(const ModelObstacleDataV41 &p_other);
    ModelObstacleDataV41 &operator=(const ModelObstacleDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV41 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV41();
    ModelStreakV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV41(const ModelStreakV41 &p_other);
    ModelStreakV41 &operator=(const ModelStreakV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV41 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV41();
    ModelStreakAnchorV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV41(const ModelStreakAnchorV41 &p_other);
    ModelStreakAnchorV41 &operator=(const ModelStreakAnchorV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV41 {
    helpers::Array<ModelStreakV41> streaks;
    helpers::Array<ModelStreakAnchorV41> anchors;

public:
    ModelStreakDataV41();
    ModelStreakDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV41(const ModelStreakDataV41 &p_other);
    ModelStreakDataV41 &operator=(const ModelStreakDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV41 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV41();
    ModelEffectLightV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV41(const ModelEffectLightV41 &p_other);
    ModelEffectLightV41 &operator=(const ModelEffectLightV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV41 {
    helpers::Array<ModelEffectLightV41> effectLights;

public:
    ModelLightDataV41();
    ModelLightDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV41(const ModelLightDataV41 &p_other);
    ModelLightDataV41 &operator=(const ModelLightDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV41 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV41();
    ModelClothBoneWeightV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV41(const ModelClothBoneWeightV41 &p_other);
    ModelClothBoneWeightV41 &operator=(const ModelClothBoneWeightV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV41 {
    helpers::Array<ModelClothBoneWeightV41> weights;

public:
    ModelClothMeshGroupV41();
    ModelClothMeshGroupV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV41(const ModelClothMeshGroupV41 &p_other);
    ModelClothMeshGroupV41 &operator=(const ModelClothMeshGroupV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV41 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV41();
    ModelClothConstraintV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV41(const ModelClothConstraintV41 &p_other);
    ModelClothConstraintV41 &operator=(const ModelClothConstraintV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV41 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV41();
    ModelClothObstacleV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV41(const ModelClothObstacleV41 &p_other);
    ModelClothObstacleV41 &operator=(const ModelClothObstacleV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV41 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV41> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV41> lod0Constraints;
    helpers::Array<ModelClothConstraintV41> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV41> obstacles;

public:
    ModelClothDataV41();
    ModelClothDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV41(const ModelClothDataV41 &p_other);
    ModelClothDataV41 &operator=(const ModelClothDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV41 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV41();
    ModelLightningSystemV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV41(const ModelLightningSystemV41 &p_other);
    ModelLightningSystemV41 &operator=(const ModelLightningSystemV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV41 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV41();
    ModelLightningBoltV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV41(const ModelLightningBoltV41 &p_other);
    ModelLightningBoltV41 &operator=(const ModelLightningBoltV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV41 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV41();
    ModelLightningNodeV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV41(const ModelLightningNodeV41 &p_other);
    ModelLightningNodeV41 &operator=(const ModelLightningNodeV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV41 {
    helpers::Array<ModelLightningSystemV41> systems;
    helpers::Array<ModelLightningBoltV41> bolts;
    helpers::Array<ModelLightningNodeV41> nodes;

public:
    ModelLightningDataV41();
    ModelLightningDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV41(const ModelLightningDataV41 &p_other);
    ModelLightningDataV41 &operator=(const ModelLightningDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV41 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV41();
    ModelBoneConstraintLinkV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV41(const ModelBoneConstraintLinkV41 &p_other);
    ModelBoneConstraintLinkV41 &operator=(const ModelBoneConstraintLinkV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV41 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV41> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV41();
    ModelBoneConstraintV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV41(const ModelBoneConstraintV41 &p_other);
    ModelBoneConstraintV41 &operator=(const ModelBoneConstraintV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSoftBodyDataV41 {
    dword materialIndex;
    dword flags;
    dword vertexFvf;
    helpers::Array<byte> vertBytes;
    helpers::Array<word> indices;
    helpers::Array<qword> bones;

public:
    ModelSoftBodyDataV41();
    ModelSoftBodyDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSoftBodyDataV41(const ModelSoftBodyDataV41 &p_other);
    ModelSoftBodyDataV41 &operator=(const ModelSoftBodyDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV41 {
    helpers::Ptr<ModelMaterialDataV41> materials;
    helpers::Ptr<ModelMeshDataV41> meshes;
    helpers::Ptr<ModelModelDataV41> model;
    helpers::Array<ModelPropertyDataV41> properties;
    helpers::Ptr<ModelCloudDataV41> cloudData;
    helpers::Array<ModelObstacleDataV41> obstacles;
    helpers::Ptr<ModelStreakDataV41> streakData;
    helpers::Ptr<ModelLightDataV41> lightData;
    helpers::Array<ModelClothDataV41> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV41> lightningData;
    helpers::Array<ModelBoneConstraintV41> boneConstraints;
    helpers::Array<ModelSoftBodyDataV41> softBodyData;

public:
    ModelFileDataV41();
    ModelFileDataV41(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV41(const ModelFileDataV41 &p_other);
    ModelFileDataV41 &operator=(const ModelFileDataV41 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV41 Gw2Struct;
};

/* Version: 40, ReferencedFunction: 0x410D9E5000000001 */

template <>
struct Gw2StructMODL<40>{
struct ModelTextureDataV40 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV40();
    ModelTextureDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV40(const ModelTextureDataV40 &p_other);
    ModelTextureDataV40 &operator=(const ModelTextureDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV40 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV40();
    ModelConstantDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV40(const ModelConstantDataV40 &p_other);
    ModelConstantDataV40 &operator=(const ModelConstantDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV40 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV40();
    ModelMatConstLinkV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV40(const ModelMatConstLinkV40 &p_other);
    ModelMatConstLinkV40 &operator=(const ModelMatConstLinkV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV40 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV40();
    ModelUVTransLinkV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV40(const ModelUVTransLinkV40 &p_other);
    ModelUVTransLinkV40 &operator=(const ModelUVTransLinkV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV40 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV40> textures;
    helpers::Array<ModelConstantDataV40> constants;
    helpers::Array<ModelMatConstLinkV40> matConstLinks;
    helpers::Array<ModelUVTransLinkV40> uvTransLinks;

public:
    ModelMaterialDataV40();
    ModelMaterialDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV40(const ModelMaterialDataV40 &p_other);
    ModelMaterialDataV40 &operator=(const ModelMaterialDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV40 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV40();
    ModelMeshLodDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV40(const ModelMeshLodDataV40 &p_other);
    ModelMeshLodDataV40 &operator=(const ModelMeshLodDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV40 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV40();
    ModelMeshMorphTargetV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV40(const ModelMeshMorphTargetV40 &p_other);
    ModelMeshMorphTargetV40 &operator=(const ModelMeshMorphTargetV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV40 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV40> lods;
    helpers::Array<ModelMeshMorphTargetV40> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV40();
    ModelMeshDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV40(const ModelMeshDataV40 &p_other);
    ModelMeshDataV40 &operator=(const ModelMeshDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV40 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV40();
    ModelTransformDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV40(const ModelTransformDataV40 &p_other);
    ModelTransformDataV40 &operator=(const ModelTransformDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV40 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV40 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV40();
    ModelBoneDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV40(const ModelBoneDataV40 &p_other);
    ModelBoneDataV40 &operator=(const ModelBoneDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV40 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV40> Bones;
    dword LODType;

public:
    ModelSkeletonDataV40();
    ModelSkeletonDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV40(const ModelSkeletonDataV40 &p_other);
    ModelSkeletonDataV40 &operator=(const ModelSkeletonDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV40 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV40();
    ModelMeshBindingDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV40(const ModelMeshBindingDataV40 &p_other);
    ModelMeshBindingDataV40 &operator=(const ModelMeshBindingDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV40 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV40();
    ModelTrackMaskV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV40(const ModelTrackMaskV40 &p_other);
    ModelTrackMaskV40 &operator=(const ModelTrackMaskV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV40 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV40> Skeleton;
    ModelTransformDataV40 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV40> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV40> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV40();
    ModelModelDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV40(const ModelModelDataV40 &p_other);
    ModelModelDataV40 &operator=(const ModelModelDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV40 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV40();
    ModelPropertyDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV40(const ModelPropertyDataV40 &p_other);
    ModelPropertyDataV40 &operator=(const ModelPropertyDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV40 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword fvf;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV40();
    ModelParticleCloudV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV40(const ModelParticleCloudV40 &p_other);
    ModelParticleCloudV40 &operator=(const ModelParticleCloudV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV40 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV40();
    ModelParticleCurveV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV40(const ModelParticleCurveV40 &p_other);
    ModelParticleCurveV40 &operator=(const ModelParticleCurveV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV40 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV40();
    ModelParticleFlipbookV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV40(const ModelParticleFlipbookV40 &p_other);
    ModelParticleFlipbookV40 &operator=(const ModelParticleFlipbookV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV40 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    float offset;
    helpers::Ptr<ModelParticleCurveV40> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV40> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV40> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 velocityInherit;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV40();
    ModelParticleEmitterV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV40(const ModelParticleEmitterV40 &p_other);
    ModelParticleEmitterV40 &operator=(const ModelParticleEmitterV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV40 {
    helpers::Array<ModelParticleCloudV40> clouds;
    helpers::Array<ModelParticleEmitterV40> emitters;

public:
    ModelCloudDataV40();
    ModelCloudDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV40(const ModelCloudDataV40 &p_other);
    ModelCloudDataV40 &operator=(const ModelCloudDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV40 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV40();
    ModelObstacleDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV40(const ModelObstacleDataV40 &p_other);
    ModelObstacleDataV40 &operator=(const ModelObstacleDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV40 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV40();
    ModelStreakV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV40(const ModelStreakV40 &p_other);
    ModelStreakV40 &operator=(const ModelStreakV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV40 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV40();
    ModelStreakAnchorV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV40(const ModelStreakAnchorV40 &p_other);
    ModelStreakAnchorV40 &operator=(const ModelStreakAnchorV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV40 {
    helpers::Array<ModelStreakV40> streaks;
    helpers::Array<ModelStreakAnchorV40> anchors;

public:
    ModelStreakDataV40();
    ModelStreakDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV40(const ModelStreakDataV40 &p_other);
    ModelStreakDataV40 &operator=(const ModelStreakDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV40 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV40();
    ModelEffectLightV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV40(const ModelEffectLightV40 &p_other);
    ModelEffectLightV40 &operator=(const ModelEffectLightV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV40 {
    helpers::Array<ModelEffectLightV40> effectLights;

public:
    ModelLightDataV40();
    ModelLightDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV40(const ModelLightDataV40 &p_other);
    ModelLightDataV40 &operator=(const ModelLightDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV40 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV40();
    ModelClothBoneWeightV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV40(const ModelClothBoneWeightV40 &p_other);
    ModelClothBoneWeightV40 &operator=(const ModelClothBoneWeightV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV40 {
    helpers::Array<ModelClothBoneWeightV40> weights;

public:
    ModelClothMeshGroupV40();
    ModelClothMeshGroupV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV40(const ModelClothMeshGroupV40 &p_other);
    ModelClothMeshGroupV40 &operator=(const ModelClothMeshGroupV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV40 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV40();
    ModelClothConstraintV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV40(const ModelClothConstraintV40 &p_other);
    ModelClothConstraintV40 &operator=(const ModelClothConstraintV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV40 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV40();
    ModelClothObstacleV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV40(const ModelClothObstacleV40 &p_other);
    ModelClothObstacleV40 &operator=(const ModelClothObstacleV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV40 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV40> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV40> lod0Constraints;
    helpers::Array<ModelClothConstraintV40> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV40> obstacles;

public:
    ModelClothDataV40();
    ModelClothDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV40(const ModelClothDataV40 &p_other);
    ModelClothDataV40 &operator=(const ModelClothDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV40 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV40();
    ModelLightningSystemV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV40(const ModelLightningSystemV40 &p_other);
    ModelLightningSystemV40 &operator=(const ModelLightningSystemV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV40 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV40();
    ModelLightningBoltV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV40(const ModelLightningBoltV40 &p_other);
    ModelLightningBoltV40 &operator=(const ModelLightningBoltV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV40 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV40();
    ModelLightningNodeV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV40(const ModelLightningNodeV40 &p_other);
    ModelLightningNodeV40 &operator=(const ModelLightningNodeV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV40 {
    helpers::Array<ModelLightningSystemV40> systems;
    helpers::Array<ModelLightningBoltV40> bolts;
    helpers::Array<ModelLightningNodeV40> nodes;

public:
    ModelLightningDataV40();
    ModelLightningDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV40(const ModelLightningDataV40 &p_other);
    ModelLightningDataV40 &operator=(const ModelLightningDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV40 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV40();
    ModelBoneConstraintLinkV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV40(const ModelBoneConstraintLinkV40 &p_other);
    ModelBoneConstraintLinkV40 &operator=(const ModelBoneConstraintLinkV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV40 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV40> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV40();
    ModelBoneConstraintV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV40(const ModelBoneConstraintV40 &p_other);
    ModelBoneConstraintV40 &operator=(const ModelBoneConstraintV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV40 {
    helpers::Ptr<ModelMaterialDataV40> materials;
    helpers::Ptr<ModelMeshDataV40> meshes;
    helpers::Ptr<ModelModelDataV40> model;
    helpers::Array<ModelPropertyDataV40> properties;
    helpers::Ptr<ModelCloudDataV40> cloudData;
    helpers::Array<ModelObstacleDataV40> obstacles;
    helpers::Ptr<ModelStreakDataV40> streakData;
    helpers::Ptr<ModelLightDataV40> lightData;
    helpers::Array<ModelClothDataV40> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV40> lightningData;
    helpers::Array<ModelBoneConstraintV40> boneConstraints;

public:
    ModelFileDataV40();
    ModelFileDataV40(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV40(const ModelFileDataV40 &p_other);
    ModelFileDataV40 &operator=(const ModelFileDataV40 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV40 Gw2Struct;
};

/* Version: 39, ReferencedFunction: 0x410D9DC000000001 */

template <>
struct Gw2StructMODL<39>{
struct ModelTextureDataV39 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV39();
    ModelTextureDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV39(const ModelTextureDataV39 &p_other);
    ModelTextureDataV39 &operator=(const ModelTextureDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV39 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV39();
    ModelConstantDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV39(const ModelConstantDataV39 &p_other);
    ModelConstantDataV39 &operator=(const ModelConstantDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV39 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV39();
    ModelMatConstLinkV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV39(const ModelMatConstLinkV39 &p_other);
    ModelMatConstLinkV39 &operator=(const ModelMatConstLinkV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV39 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV39();
    ModelUVTransLinkV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV39(const ModelUVTransLinkV39 &p_other);
    ModelUVTransLinkV39 &operator=(const ModelUVTransLinkV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV39 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV39> textures;
    helpers::Array<ModelConstantDataV39> constants;
    helpers::Array<ModelMatConstLinkV39> matConstLinks;
    helpers::Array<ModelUVTransLinkV39> uvTransLinks;

public:
    ModelMaterialDataV39();
    ModelMaterialDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV39(const ModelMaterialDataV39 &p_other);
    ModelMaterialDataV39 &operator=(const ModelMaterialDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV39 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV39();
    ModelMeshLodDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV39(const ModelMeshLodDataV39 &p_other);
    ModelMeshLodDataV39 &operator=(const ModelMeshLodDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV39 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV39();
    ModelMeshMorphTargetV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV39(const ModelMeshMorphTargetV39 &p_other);
    ModelMeshMorphTargetV39 &operator=(const ModelMeshMorphTargetV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV39 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV39> lods;
    helpers::Array<ModelMeshMorphTargetV39> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV39();
    ModelMeshDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV39(const ModelMeshDataV39 &p_other);
    ModelMeshDataV39 &operator=(const ModelMeshDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV39 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV39();
    ModelTransformDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV39(const ModelTransformDataV39 &p_other);
    ModelTransformDataV39 &operator=(const ModelTransformDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV39 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV39 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV39();
    ModelBoneDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV39(const ModelBoneDataV39 &p_other);
    ModelBoneDataV39 &operator=(const ModelBoneDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV39 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV39> Bones;
    dword LODType;

public:
    ModelSkeletonDataV39();
    ModelSkeletonDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV39(const ModelSkeletonDataV39 &p_other);
    ModelSkeletonDataV39 &operator=(const ModelSkeletonDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV39 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV39();
    ModelMeshBindingDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV39(const ModelMeshBindingDataV39 &p_other);
    ModelMeshBindingDataV39 &operator=(const ModelMeshBindingDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV39 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV39();
    ModelTrackMaskV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV39(const ModelTrackMaskV39 &p_other);
    ModelTrackMaskV39 &operator=(const ModelTrackMaskV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV39 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV39> Skeleton;
    ModelTransformDataV39 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV39> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV39> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV39();
    ModelModelDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV39(const ModelModelDataV39 &p_other);
    ModelModelDataV39 &operator=(const ModelModelDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV39 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV39();
    ModelPropertyDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV39(const ModelPropertyDataV39 &p_other);
    ModelPropertyDataV39 &operator=(const ModelPropertyDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV39 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV39();
    ModelParticleCloudV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV39(const ModelParticleCloudV39 &p_other);
    ModelParticleCloudV39 &operator=(const ModelParticleCloudV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV39 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV39();
    ModelParticleCurveV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV39(const ModelParticleCurveV39 &p_other);
    ModelParticleCurveV39 &operator=(const ModelParticleCurveV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV39 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV39();
    ModelParticleFlipbookV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV39(const ModelParticleFlipbookV39 &p_other);
    ModelParticleFlipbookV39 &operator=(const ModelParticleFlipbookV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV39 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV39> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV39> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV39> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV39();
    ModelParticleEmitterV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV39(const ModelParticleEmitterV39 &p_other);
    ModelParticleEmitterV39 &operator=(const ModelParticleEmitterV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV39 {
    helpers::Array<ModelParticleCloudV39> clouds;
    helpers::Array<ModelParticleEmitterV39> emitters;

public:
    ModelCloudDataV39();
    ModelCloudDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV39(const ModelCloudDataV39 &p_other);
    ModelCloudDataV39 &operator=(const ModelCloudDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV39 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV39();
    ModelObstacleDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV39(const ModelObstacleDataV39 &p_other);
    ModelObstacleDataV39 &operator=(const ModelObstacleDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV39 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV39();
    ModelStreakV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV39(const ModelStreakV39 &p_other);
    ModelStreakV39 &operator=(const ModelStreakV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV39 {
    qword bone;
    dword colorStart;
    dword colorEnd;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV39();
    ModelStreakAnchorV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV39(const ModelStreakAnchorV39 &p_other);
    ModelStreakAnchorV39 &operator=(const ModelStreakAnchorV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV39 {
    helpers::Array<ModelStreakV39> streaks;
    helpers::Array<ModelStreakAnchorV39> anchors;

public:
    ModelStreakDataV39();
    ModelStreakDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV39(const ModelStreakDataV39 &p_other);
    ModelStreakDataV39 &operator=(const ModelStreakDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV39 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV39();
    ModelEffectLightV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV39(const ModelEffectLightV39 &p_other);
    ModelEffectLightV39 &operator=(const ModelEffectLightV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV39 {
    helpers::Array<ModelEffectLightV39> effectLights;

public:
    ModelLightDataV39();
    ModelLightDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV39(const ModelLightDataV39 &p_other);
    ModelLightDataV39 &operator=(const ModelLightDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV39 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV39();
    ModelClothBoneWeightV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV39(const ModelClothBoneWeightV39 &p_other);
    ModelClothBoneWeightV39 &operator=(const ModelClothBoneWeightV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV39 {
    helpers::Array<ModelClothBoneWeightV39> weights;

public:
    ModelClothMeshGroupV39();
    ModelClothMeshGroupV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV39(const ModelClothMeshGroupV39 &p_other);
    ModelClothMeshGroupV39 &operator=(const ModelClothMeshGroupV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV39 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV39();
    ModelClothConstraintV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV39(const ModelClothConstraintV39 &p_other);
    ModelClothConstraintV39 &operator=(const ModelClothConstraintV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV39 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV39();
    ModelClothObstacleV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV39(const ModelClothObstacleV39 &p_other);
    ModelClothObstacleV39 &operator=(const ModelClothObstacleV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV39 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV39> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV39> lod0Constraints;
    helpers::Array<ModelClothConstraintV39> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV39> obstacles;

public:
    ModelClothDataV39();
    ModelClothDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV39(const ModelClothDataV39 &p_other);
    ModelClothDataV39 &operator=(const ModelClothDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV39 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV39();
    ModelLightningSystemV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV39(const ModelLightningSystemV39 &p_other);
    ModelLightningSystemV39 &operator=(const ModelLightningSystemV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV39 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV39();
    ModelLightningBoltV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV39(const ModelLightningBoltV39 &p_other);
    ModelLightningBoltV39 &operator=(const ModelLightningBoltV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV39 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV39();
    ModelLightningNodeV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV39(const ModelLightningNodeV39 &p_other);
    ModelLightningNodeV39 &operator=(const ModelLightningNodeV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV39 {
    helpers::Array<ModelLightningSystemV39> systems;
    helpers::Array<ModelLightningBoltV39> bolts;
    helpers::Array<ModelLightningNodeV39> nodes;

public:
    ModelLightningDataV39();
    ModelLightningDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV39(const ModelLightningDataV39 &p_other);
    ModelLightningDataV39 &operator=(const ModelLightningDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV39 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV39();
    ModelBoneConstraintLinkV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV39(const ModelBoneConstraintLinkV39 &p_other);
    ModelBoneConstraintLinkV39 &operator=(const ModelBoneConstraintLinkV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV39 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV39> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV39();
    ModelBoneConstraintV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV39(const ModelBoneConstraintV39 &p_other);
    ModelBoneConstraintV39 &operator=(const ModelBoneConstraintV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV39 {
    helpers::Ptr<ModelMaterialDataV39> materials;
    helpers::Ptr<ModelMeshDataV39> meshes;
    helpers::Ptr<ModelModelDataV39> model;
    helpers::Array<ModelPropertyDataV39> properties;
    helpers::Ptr<ModelCloudDataV39> cloudData;
    helpers::Array<ModelObstacleDataV39> obstacles;
    helpers::Ptr<ModelStreakDataV39> streakData;
    helpers::Ptr<ModelLightDataV39> lightData;
    helpers::Array<ModelClothDataV39> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV39> lightningData;
    helpers::Array<ModelBoneConstraintV39> boneConstraints;

public:
    ModelFileDataV39();
    ModelFileDataV39(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV39(const ModelFileDataV39 &p_other);
    ModelFileDataV39 &operator=(const ModelFileDataV39 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV39 Gw2Struct;
};

/* Version: 38, ReferencedFunction: 0x410D9BC000000001 */

template <>
struct Gw2StructMODL<38>{
struct ModelTextureDataV38 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV38();
    ModelTextureDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV38(const ModelTextureDataV38 &p_other);
    ModelTextureDataV38 &operator=(const ModelTextureDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV38 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV38();
    ModelConstantDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV38(const ModelConstantDataV38 &p_other);
    ModelConstantDataV38 &operator=(const ModelConstantDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV38 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV38();
    ModelMatConstLinkV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV38(const ModelMatConstLinkV38 &p_other);
    ModelMatConstLinkV38 &operator=(const ModelMatConstLinkV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV38 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV38();
    ModelUVTransLinkV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV38(const ModelUVTransLinkV38 &p_other);
    ModelUVTransLinkV38 &operator=(const ModelUVTransLinkV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV38 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV38> textures;
    helpers::Array<ModelConstantDataV38> constants;
    helpers::Array<ModelMatConstLinkV38> matConstLinks;
    helpers::Array<ModelUVTransLinkV38> uvTransLinks;

public:
    ModelMaterialDataV38();
    ModelMaterialDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV38(const ModelMaterialDataV38 &p_other);
    ModelMaterialDataV38 &operator=(const ModelMaterialDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV38 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV38();
    ModelMeshLodDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV38(const ModelMeshLodDataV38 &p_other);
    ModelMeshLodDataV38 &operator=(const ModelMeshLodDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV38 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV38();
    ModelMeshMorphTargetV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV38(const ModelMeshMorphTargetV38 &p_other);
    ModelMeshMorphTargetV38 &operator=(const ModelMeshMorphTargetV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV38 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV38> lods;
    helpers::Array<ModelMeshMorphTargetV38> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV38();
    ModelMeshDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV38(const ModelMeshDataV38 &p_other);
    ModelMeshDataV38 &operator=(const ModelMeshDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV38 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV38();
    ModelTransformDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV38(const ModelTransformDataV38 &p_other);
    ModelTransformDataV38 &operator=(const ModelTransformDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV38 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV38 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV38();
    ModelBoneDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV38(const ModelBoneDataV38 &p_other);
    ModelBoneDataV38 &operator=(const ModelBoneDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV38 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV38> Bones;
    dword LODType;

public:
    ModelSkeletonDataV38();
    ModelSkeletonDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV38(const ModelSkeletonDataV38 &p_other);
    ModelSkeletonDataV38 &operator=(const ModelSkeletonDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV38 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV38();
    ModelMeshBindingDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV38(const ModelMeshBindingDataV38 &p_other);
    ModelMeshBindingDataV38 &operator=(const ModelMeshBindingDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV38 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV38();
    ModelTrackMaskV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV38(const ModelTrackMaskV38 &p_other);
    ModelTrackMaskV38 &operator=(const ModelTrackMaskV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV38 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV38> Skeleton;
    ModelTransformDataV38 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV38> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV38> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV38();
    ModelModelDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV38(const ModelModelDataV38 &p_other);
    ModelModelDataV38 &operator=(const ModelModelDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV38 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV38();
    ModelPropertyDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV38(const ModelPropertyDataV38 &p_other);
    ModelPropertyDataV38 &operator=(const ModelPropertyDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV38 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV38();
    ModelParticleCloudV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV38(const ModelParticleCloudV38 &p_other);
    ModelParticleCloudV38 &operator=(const ModelParticleCloudV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV38 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV38();
    ModelParticleCurveV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV38(const ModelParticleCurveV38 &p_other);
    ModelParticleCurveV38 &operator=(const ModelParticleCurveV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV38 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV38();
    ModelParticleFlipbookV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV38(const ModelParticleFlipbookV38 &p_other);
    ModelParticleFlipbookV38 &operator=(const ModelParticleFlipbookV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV38 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV38> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV38> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV38> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV38();
    ModelParticleEmitterV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV38(const ModelParticleEmitterV38 &p_other);
    ModelParticleEmitterV38 &operator=(const ModelParticleEmitterV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV38 {
    helpers::Array<ModelParticleCloudV38> clouds;
    helpers::Array<ModelParticleEmitterV38> emitters;

public:
    ModelCloudDataV38();
    ModelCloudDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV38(const ModelCloudDataV38 &p_other);
    ModelCloudDataV38 &operator=(const ModelCloudDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV38 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV38();
    ModelObstacleDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV38(const ModelObstacleDataV38 &p_other);
    ModelObstacleDataV38 &operator=(const ModelObstacleDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV38 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV38();
    ModelStreakV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV38(const ModelStreakV38 &p_other);
    ModelStreakV38 &operator=(const ModelStreakV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV38 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV38();
    ModelStreakAnchorV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV38(const ModelStreakAnchorV38 &p_other);
    ModelStreakAnchorV38 &operator=(const ModelStreakAnchorV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV38 {
    helpers::Array<ModelStreakV38> streaks;
    helpers::Array<ModelStreakAnchorV38> anchors;

public:
    ModelStreakDataV38();
    ModelStreakDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV38(const ModelStreakDataV38 &p_other);
    ModelStreakDataV38 &operator=(const ModelStreakDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV38 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV38();
    ModelEffectLightV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV38(const ModelEffectLightV38 &p_other);
    ModelEffectLightV38 &operator=(const ModelEffectLightV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV38 {
    helpers::Array<ModelEffectLightV38> effectLights;

public:
    ModelLightDataV38();
    ModelLightDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV38(const ModelLightDataV38 &p_other);
    ModelLightDataV38 &operator=(const ModelLightDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV38 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV38();
    ModelClothBoneWeightV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV38(const ModelClothBoneWeightV38 &p_other);
    ModelClothBoneWeightV38 &operator=(const ModelClothBoneWeightV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV38 {
    helpers::Array<ModelClothBoneWeightV38> weights;

public:
    ModelClothMeshGroupV38();
    ModelClothMeshGroupV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV38(const ModelClothMeshGroupV38 &p_other);
    ModelClothMeshGroupV38 &operator=(const ModelClothMeshGroupV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV38 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV38();
    ModelClothConstraintV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV38(const ModelClothConstraintV38 &p_other);
    ModelClothConstraintV38 &operator=(const ModelClothConstraintV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV38 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV38();
    ModelClothObstacleV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV38(const ModelClothObstacleV38 &p_other);
    ModelClothObstacleV38 &operator=(const ModelClothObstacleV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV38 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV38> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV38> lod0Constraints;
    helpers::Array<ModelClothConstraintV38> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV38> obstacles;

public:
    ModelClothDataV38();
    ModelClothDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV38(const ModelClothDataV38 &p_other);
    ModelClothDataV38 &operator=(const ModelClothDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV38 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV38();
    ModelLightningSystemV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV38(const ModelLightningSystemV38 &p_other);
    ModelLightningSystemV38 &operator=(const ModelLightningSystemV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV38 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV38();
    ModelLightningBoltV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV38(const ModelLightningBoltV38 &p_other);
    ModelLightningBoltV38 &operator=(const ModelLightningBoltV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV38 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV38();
    ModelLightningNodeV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV38(const ModelLightningNodeV38 &p_other);
    ModelLightningNodeV38 &operator=(const ModelLightningNodeV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV38 {
    helpers::Array<ModelLightningSystemV38> systems;
    helpers::Array<ModelLightningBoltV38> bolts;
    helpers::Array<ModelLightningNodeV38> nodes;

public:
    ModelLightningDataV38();
    ModelLightningDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV38(const ModelLightningDataV38 &p_other);
    ModelLightningDataV38 &operator=(const ModelLightningDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV38 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV38();
    ModelBoneConstraintLinkV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV38(const ModelBoneConstraintLinkV38 &p_other);
    ModelBoneConstraintLinkV38 &operator=(const ModelBoneConstraintLinkV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV38 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV38> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV38();
    ModelBoneConstraintV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV38(const ModelBoneConstraintV38 &p_other);
    ModelBoneConstraintV38 &operator=(const ModelBoneConstraintV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV38 {
    helpers::Ptr<ModelMaterialDataV38> materials;
    helpers::Ptr<ModelMeshDataV38> meshes;
    helpers::Ptr<ModelModelDataV38> model;
    helpers::Array<ModelPropertyDataV38> properties;
    helpers::Ptr<ModelCloudDataV38> cloudData;
    helpers::Array<ModelObstacleDataV38> obstacles;
    helpers::Ptr<ModelStreakDataV38> streakData;
    helpers::Ptr<ModelLightDataV38> lightData;
    helpers::Array<ModelClothDataV38> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV38> lightningData;
    helpers::Array<ModelBoneConstraintV38> boneConstraints;

public:
    ModelFileDataV38();
    ModelFileDataV38(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV38(const ModelFileDataV38 &p_other);
    ModelFileDataV38 &operator=(const ModelFileDataV38 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV38 Gw2Struct;
};

/* Version: 37, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<37>{
struct ModelTextureDataV37 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV37();
    ModelTextureDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV37(const ModelTextureDataV37 &p_other);
    ModelTextureDataV37 &operator=(const ModelTextureDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV37 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV37();
    ModelConstantDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV37(const ModelConstantDataV37 &p_other);
    ModelConstantDataV37 &operator=(const ModelConstantDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV37 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV37();
    ModelMatConstLinkV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV37(const ModelMatConstLinkV37 &p_other);
    ModelMatConstLinkV37 &operator=(const ModelMatConstLinkV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV37 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV37();
    ModelUVTransLinkV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV37(const ModelUVTransLinkV37 &p_other);
    ModelUVTransLinkV37 &operator=(const ModelUVTransLinkV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV37 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV37> textures;
    helpers::Array<ModelConstantDataV37> constants;
    helpers::Array<ModelMatConstLinkV37> matConstLinks;
    helpers::Array<ModelUVTransLinkV37> uvTransLinks;

public:
    ModelMaterialDataV37();
    ModelMaterialDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV37(const ModelMaterialDataV37 &p_other);
    ModelMaterialDataV37 &operator=(const ModelMaterialDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV37 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV37();
    ModelMeshLodDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV37(const ModelMeshLodDataV37 &p_other);
    ModelMeshLodDataV37 &operator=(const ModelMeshLodDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV37 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV37();
    ModelMeshMorphTargetV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV37(const ModelMeshMorphTargetV37 &p_other);
    ModelMeshMorphTargetV37 &operator=(const ModelMeshMorphTargetV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV37 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV37> lods;
    helpers::Array<ModelMeshMorphTargetV37> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV37();
    ModelMeshDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV37(const ModelMeshDataV37 &p_other);
    ModelMeshDataV37 &operator=(const ModelMeshDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV37 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV37();
    ModelTransformDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV37(const ModelTransformDataV37 &p_other);
    ModelTransformDataV37 &operator=(const ModelTransformDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV37 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV37 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV37();
    ModelBoneDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV37(const ModelBoneDataV37 &p_other);
    ModelBoneDataV37 &operator=(const ModelBoneDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV37 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV37> Bones;
    dword LODType;

public:
    ModelSkeletonDataV37();
    ModelSkeletonDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV37(const ModelSkeletonDataV37 &p_other);
    ModelSkeletonDataV37 &operator=(const ModelSkeletonDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV37 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV37();
    ModelMeshBindingDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV37(const ModelMeshBindingDataV37 &p_other);
    ModelMeshBindingDataV37 &operator=(const ModelMeshBindingDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV37 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV37();
    ModelTrackMaskV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV37(const ModelTrackMaskV37 &p_other);
    ModelTrackMaskV37 &operator=(const ModelTrackMaskV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV37 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV37> Skeleton;
    ModelTransformDataV37 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV37> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV37> trackMasks;
    float3 center;
    float radius;

public:
    ModelModelDataV37();
    ModelModelDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV37(const ModelModelDataV37 &p_other);
    ModelModelDataV37 &operator=(const ModelModelDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV37 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV37();
    ModelPropertyDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV37(const ModelPropertyDataV37 &p_other);
    ModelPropertyDataV37 &operator=(const ModelPropertyDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV37 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV37();
    ModelParticleCloudV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV37(const ModelParticleCloudV37 &p_other);
    ModelParticleCloudV37 &operator=(const ModelParticleCloudV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV37 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV37();
    ModelParticleCurveV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV37(const ModelParticleCurveV37 &p_other);
    ModelParticleCurveV37 &operator=(const ModelParticleCurveV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV37 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV37();
    ModelParticleFlipbookV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV37(const ModelParticleFlipbookV37 &p_other);
    ModelParticleFlipbookV37 &operator=(const ModelParticleFlipbookV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV37 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV37> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV37> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV37> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV37();
    ModelParticleEmitterV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV37(const ModelParticleEmitterV37 &p_other);
    ModelParticleEmitterV37 &operator=(const ModelParticleEmitterV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV37 {
    helpers::Array<ModelParticleCloudV37> clouds;
    helpers::Array<ModelParticleEmitterV37> emitters;

public:
    ModelCloudDataV37();
    ModelCloudDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV37(const ModelCloudDataV37 &p_other);
    ModelCloudDataV37 &operator=(const ModelCloudDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV37 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV37();
    ModelObstacleDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV37(const ModelObstacleDataV37 &p_other);
    ModelObstacleDataV37 &operator=(const ModelObstacleDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV37 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV37();
    ModelStreakV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV37(const ModelStreakV37 &p_other);
    ModelStreakV37 &operator=(const ModelStreakV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV37 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV37();
    ModelStreakAnchorV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV37(const ModelStreakAnchorV37 &p_other);
    ModelStreakAnchorV37 &operator=(const ModelStreakAnchorV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV37 {
    helpers::Array<ModelStreakV37> streaks;
    helpers::Array<ModelStreakAnchorV37> anchors;

public:
    ModelStreakDataV37();
    ModelStreakDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV37(const ModelStreakDataV37 &p_other);
    ModelStreakDataV37 &operator=(const ModelStreakDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV37 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV37();
    ModelEffectLightV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV37(const ModelEffectLightV37 &p_other);
    ModelEffectLightV37 &operator=(const ModelEffectLightV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV37 {
    helpers::Array<ModelEffectLightV37> effectLights;

public:
    ModelLightDataV37();
    ModelLightDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV37(const ModelLightDataV37 &p_other);
    ModelLightDataV37 &operator=(const ModelLightDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV37 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV37();
    ModelClothBoneWeightV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV37(const ModelClothBoneWeightV37 &p_other);
    ModelClothBoneWeightV37 &operator=(const ModelClothBoneWeightV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV37 {
    helpers::Array<ModelClothBoneWeightV37> weights;

public:
    ModelClothMeshGroupV37();
    ModelClothMeshGroupV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV37(const ModelClothMeshGroupV37 &p_other);
    ModelClothMeshGroupV37 &operator=(const ModelClothMeshGroupV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV37 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV37();
    ModelClothConstraintV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV37(const ModelClothConstraintV37 &p_other);
    ModelClothConstraintV37 &operator=(const ModelClothConstraintV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV37 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV37();
    ModelClothObstacleV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV37(const ModelClothObstacleV37 &p_other);
    ModelClothObstacleV37 &operator=(const ModelClothObstacleV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV37 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV37> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV37> lod0Constraints;
    helpers::Array<ModelClothConstraintV37> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV37> obstacles;

public:
    ModelClothDataV37();
    ModelClothDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV37(const ModelClothDataV37 &p_other);
    ModelClothDataV37 &operator=(const ModelClothDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV37 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV37();
    ModelLightningSystemV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV37(const ModelLightningSystemV37 &p_other);
    ModelLightningSystemV37 &operator=(const ModelLightningSystemV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV37 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV37();
    ModelLightningBoltV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV37(const ModelLightningBoltV37 &p_other);
    ModelLightningBoltV37 &operator=(const ModelLightningBoltV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV37 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV37();
    ModelLightningNodeV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV37(const ModelLightningNodeV37 &p_other);
    ModelLightningNodeV37 &operator=(const ModelLightningNodeV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV37 {
    helpers::Array<ModelLightningSystemV37> systems;
    helpers::Array<ModelLightningBoltV37> bolts;
    helpers::Array<ModelLightningNodeV37> nodes;

public:
    ModelLightningDataV37();
    ModelLightningDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV37(const ModelLightningDataV37 &p_other);
    ModelLightningDataV37 &operator=(const ModelLightningDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV37 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV37();
    ModelBoneConstraintLinkV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV37(const ModelBoneConstraintLinkV37 &p_other);
    ModelBoneConstraintLinkV37 &operator=(const ModelBoneConstraintLinkV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV37 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV37> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV37();
    ModelBoneConstraintV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV37(const ModelBoneConstraintV37 &p_other);
    ModelBoneConstraintV37 &operator=(const ModelBoneConstraintV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV37 {
    helpers::Ptr<ModelMaterialDataV37> materials;
    helpers::Ptr<ModelMeshDataV37> meshes;
    helpers::Ptr<ModelModelDataV37> model;
    helpers::Array<ModelPropertyDataV37> properties;
    helpers::Ptr<ModelCloudDataV37> cloudData;
    helpers::Array<ModelObstacleDataV37> obstacles;
    helpers::Ptr<ModelStreakDataV37> streakData;
    helpers::Ptr<ModelLightDataV37> lightData;
    helpers::Array<ModelClothDataV37> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV37> lightningData;
    helpers::Array<ModelBoneConstraintV37> boneConstraints;

public:
    ModelFileDataV37();
    ModelFileDataV37(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV37(const ModelFileDataV37 &p_other);
    ModelFileDataV37 &operator=(const ModelFileDataV37 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV37 Gw2Struct;
};

/* Version: 36, ReferencedFunction: 0x410D9A7000000001 */

template <>
struct Gw2StructMODL<36>{
struct ModelTextureDataV36 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV36();
    ModelTextureDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV36(const ModelTextureDataV36 &p_other);
    ModelTextureDataV36 &operator=(const ModelTextureDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV36 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV36();
    ModelConstantDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV36(const ModelConstantDataV36 &p_other);
    ModelConstantDataV36 &operator=(const ModelConstantDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV36 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV36();
    ModelMatConstLinkV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV36(const ModelMatConstLinkV36 &p_other);
    ModelMatConstLinkV36 &operator=(const ModelMatConstLinkV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV36 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV36();
    ModelUVTransLinkV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV36(const ModelUVTransLinkV36 &p_other);
    ModelUVTransLinkV36 &operator=(const ModelUVTransLinkV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV36 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV36> textures;
    helpers::Array<ModelConstantDataV36> constants;
    helpers::Array<ModelMatConstLinkV36> matConstLinks;
    helpers::Array<ModelUVTransLinkV36> uvTransLinks;

public:
    ModelMaterialDataV36();
    ModelMaterialDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV36(const ModelMaterialDataV36 &p_other);
    ModelMaterialDataV36 &operator=(const ModelMaterialDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV36 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV36();
    ModelMeshLodDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV36(const ModelMeshLodDataV36 &p_other);
    ModelMeshLodDataV36 &operator=(const ModelMeshLodDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV36 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV36();
    ModelMeshMorphTargetV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV36(const ModelMeshMorphTargetV36 &p_other);
    ModelMeshMorphTargetV36 &operator=(const ModelMeshMorphTargetV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV36 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV36> lods;
    helpers::Array<ModelMeshMorphTargetV36> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV36();
    ModelMeshDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV36(const ModelMeshDataV36 &p_other);
    ModelMeshDataV36 &operator=(const ModelMeshDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV36 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV36();
    ModelTransformDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV36(const ModelTransformDataV36 &p_other);
    ModelTransformDataV36 &operator=(const ModelTransformDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV36 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV36 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV36();
    ModelBoneDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV36(const ModelBoneDataV36 &p_other);
    ModelBoneDataV36 &operator=(const ModelBoneDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV36 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV36> Bones;
    dword LODType;

public:
    ModelSkeletonDataV36();
    ModelSkeletonDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV36(const ModelSkeletonDataV36 &p_other);
    ModelSkeletonDataV36 &operator=(const ModelSkeletonDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV36 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV36();
    ModelMeshBindingDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV36(const ModelMeshBindingDataV36 &p_other);
    ModelMeshBindingDataV36 &operator=(const ModelMeshBindingDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV36 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV36();
    ModelTrackMaskV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV36(const ModelTrackMaskV36 &p_other);
    ModelTrackMaskV36 &operator=(const ModelTrackMaskV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV36 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV36> Skeleton;
    ModelTransformDataV36 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV36> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV36> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV36();
    ModelModelDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV36(const ModelModelDataV36 &p_other);
    ModelModelDataV36 &operator=(const ModelModelDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV36 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV36();
    ModelPropertyDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV36(const ModelPropertyDataV36 &p_other);
    ModelPropertyDataV36 &operator=(const ModelPropertyDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV36 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV36();
    ModelParticleCloudV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV36(const ModelParticleCloudV36 &p_other);
    ModelParticleCloudV36 &operator=(const ModelParticleCloudV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV36 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV36();
    ModelParticleCurveV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV36(const ModelParticleCurveV36 &p_other);
    ModelParticleCurveV36 &operator=(const ModelParticleCurveV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV36 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV36();
    ModelParticleFlipbookV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV36(const ModelParticleFlipbookV36 &p_other);
    ModelParticleFlipbookV36 &operator=(const ModelParticleFlipbookV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV36 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV36> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV36> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV36> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV36();
    ModelParticleEmitterV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV36(const ModelParticleEmitterV36 &p_other);
    ModelParticleEmitterV36 &operator=(const ModelParticleEmitterV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV36 {
    helpers::Array<ModelParticleCloudV36> clouds;
    helpers::Array<ModelParticleEmitterV36> emitters;

public:
    ModelCloudDataV36();
    ModelCloudDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV36(const ModelCloudDataV36 &p_other);
    ModelCloudDataV36 &operator=(const ModelCloudDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV36 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV36();
    ModelObstacleDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV36(const ModelObstacleDataV36 &p_other);
    ModelObstacleDataV36 &operator=(const ModelObstacleDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV36 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV36();
    ModelStreakV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV36(const ModelStreakV36 &p_other);
    ModelStreakV36 &operator=(const ModelStreakV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV36 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV36();
    ModelStreakAnchorV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV36(const ModelStreakAnchorV36 &p_other);
    ModelStreakAnchorV36 &operator=(const ModelStreakAnchorV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV36 {
    helpers::Array<ModelStreakV36> streaks;
    helpers::Array<ModelStreakAnchorV36> anchors;

public:
    ModelStreakDataV36();
    ModelStreakDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV36(const ModelStreakDataV36 &p_other);
    ModelStreakDataV36 &operator=(const ModelStreakDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV36 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV36();
    ModelEffectLightV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV36(const ModelEffectLightV36 &p_other);
    ModelEffectLightV36 &operator=(const ModelEffectLightV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV36 {
    helpers::Array<ModelEffectLightV36> effectLights;

public:
    ModelLightDataV36();
    ModelLightDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV36(const ModelLightDataV36 &p_other);
    ModelLightDataV36 &operator=(const ModelLightDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV36 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV36();
    ModelClothBoneWeightV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV36(const ModelClothBoneWeightV36 &p_other);
    ModelClothBoneWeightV36 &operator=(const ModelClothBoneWeightV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV36 {
    helpers::Array<ModelClothBoneWeightV36> weights;

public:
    ModelClothMeshGroupV36();
    ModelClothMeshGroupV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV36(const ModelClothMeshGroupV36 &p_other);
    ModelClothMeshGroupV36 &operator=(const ModelClothMeshGroupV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV36 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV36();
    ModelClothConstraintV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV36(const ModelClothConstraintV36 &p_other);
    ModelClothConstraintV36 &operator=(const ModelClothConstraintV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV36 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV36();
    ModelClothObstacleV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV36(const ModelClothObstacleV36 &p_other);
    ModelClothObstacleV36 &operator=(const ModelClothObstacleV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV36 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV36> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV36> lod0Constraints;
    helpers::Array<ModelClothConstraintV36> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV36> obstacles;

public:
    ModelClothDataV36();
    ModelClothDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV36(const ModelClothDataV36 &p_other);
    ModelClothDataV36 &operator=(const ModelClothDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV36 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV36();
    ModelLightningSystemV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV36(const ModelLightningSystemV36 &p_other);
    ModelLightningSystemV36 &operator=(const ModelLightningSystemV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV36 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV36();
    ModelLightningBoltV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV36(const ModelLightningBoltV36 &p_other);
    ModelLightningBoltV36 &operator=(const ModelLightningBoltV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV36 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV36();
    ModelLightningNodeV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV36(const ModelLightningNodeV36 &p_other);
    ModelLightningNodeV36 &operator=(const ModelLightningNodeV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV36 {
    helpers::Array<ModelLightningSystemV36> systems;
    helpers::Array<ModelLightningBoltV36> bolts;
    helpers::Array<ModelLightningNodeV36> nodes;

public:
    ModelLightningDataV36();
    ModelLightningDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV36(const ModelLightningDataV36 &p_other);
    ModelLightningDataV36 &operator=(const ModelLightningDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV36 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV36();
    ModelBoneConstraintLinkV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV36(const ModelBoneConstraintLinkV36 &p_other);
    ModelBoneConstraintLinkV36 &operator=(const ModelBoneConstraintLinkV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV36 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV36> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV36();
    ModelBoneConstraintV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV36(const ModelBoneConstraintV36 &p_other);
    ModelBoneConstraintV36 &operator=(const ModelBoneConstraintV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV36 {
    helpers::Ptr<ModelMaterialDataV36> materials;
    helpers::Ptr<ModelMeshDataV36> meshes;
    helpers::Ptr<ModelModelDataV36> model;
    helpers::Array<ModelPropertyDataV36> properties;
    helpers::Ptr<ModelCloudDataV36> cloudData;
    helpers::Array<ModelObstacleDataV36> obstacles;
    helpers::Ptr<ModelStreakDataV36> streakData;
    helpers::Ptr<ModelLightDataV36> lightData;
    helpers::Array<ModelClothDataV36> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV36> lightningData;
    helpers::Array<ModelBoneConstraintV36> boneConstraints;

public:
    ModelFileDataV36();
    ModelFileDataV36(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV36(const ModelFileDataV36 &p_other);
    ModelFileDataV36 &operator=(const ModelFileDataV36 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV36 Gw2Struct;
};

/* Version: 35, ReferencedFunction: 0x410D997000000001 */

template <>
struct Gw2StructMODL<35>{
struct ModelTextureDataV35 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV35();
    ModelTextureDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV35(const ModelTextureDataV35 &p_other);
    ModelTextureDataV35 &operator=(const ModelTextureDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV35 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV35();
    ModelConstantDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV35(const ModelConstantDataV35 &p_other);
    ModelConstantDataV35 &operator=(const ModelConstantDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV35 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV35();
    ModelMatConstLinkV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV35(const ModelMatConstLinkV35 &p_other);
    ModelMatConstLinkV35 &operator=(const ModelMatConstLinkV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV35 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV35();
    ModelUVTransLinkV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV35(const ModelUVTransLinkV35 &p_other);
    ModelUVTransLinkV35 &operator=(const ModelUVTransLinkV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV35 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV35> textures;
    helpers::Array<ModelConstantDataV35> constants;
    helpers::Array<ModelMatConstLinkV35> matConstLinks;
    helpers::Array<ModelUVTransLinkV35> uvTransLinks;

public:
    ModelMaterialDataV35();
    ModelMaterialDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV35(const ModelMaterialDataV35 &p_other);
    ModelMaterialDataV35 &operator=(const ModelMaterialDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV35 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV35();
    ModelMeshLodDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV35(const ModelMeshLodDataV35 &p_other);
    ModelMeshLodDataV35 &operator=(const ModelMeshLodDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV35 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV35();
    ModelMeshMorphTargetV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV35(const ModelMeshMorphTargetV35 &p_other);
    ModelMeshMorphTargetV35 &operator=(const ModelMeshMorphTargetV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV35 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV35> lods;
    helpers::Array<ModelMeshMorphTargetV35> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV35();
    ModelMeshDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV35(const ModelMeshDataV35 &p_other);
    ModelMeshDataV35 &operator=(const ModelMeshDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV35 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV35();
    ModelTransformDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV35(const ModelTransformDataV35 &p_other);
    ModelTransformDataV35 &operator=(const ModelTransformDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV35 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV35 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV35();
    ModelBoneDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV35(const ModelBoneDataV35 &p_other);
    ModelBoneDataV35 &operator=(const ModelBoneDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV35 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV35> Bones;
    dword LODType;

public:
    ModelSkeletonDataV35();
    ModelSkeletonDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV35(const ModelSkeletonDataV35 &p_other);
    ModelSkeletonDataV35 &operator=(const ModelSkeletonDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV35 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV35();
    ModelMeshBindingDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV35(const ModelMeshBindingDataV35 &p_other);
    ModelMeshBindingDataV35 &operator=(const ModelMeshBindingDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV35 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV35();
    ModelTrackMaskV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV35(const ModelTrackMaskV35 &p_other);
    ModelTrackMaskV35 &operator=(const ModelTrackMaskV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV35 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV35> Skeleton;
    ModelTransformDataV35 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV35> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV35> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV35();
    ModelModelDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV35(const ModelModelDataV35 &p_other);
    ModelModelDataV35 &operator=(const ModelModelDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV35 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV35();
    ModelPropertyDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV35(const ModelPropertyDataV35 &p_other);
    ModelPropertyDataV35 &operator=(const ModelPropertyDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV35 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV35();
    ModelParticleCloudV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV35(const ModelParticleCloudV35 &p_other);
    ModelParticleCloudV35 &operator=(const ModelParticleCloudV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV35 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV35();
    ModelParticleCurveV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV35(const ModelParticleCurveV35 &p_other);
    ModelParticleCurveV35 &operator=(const ModelParticleCurveV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV35 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV35();
    ModelParticleFlipbookV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV35(const ModelParticleFlipbookV35 &p_other);
    ModelParticleFlipbookV35 &operator=(const ModelParticleFlipbookV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV35 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV35> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV35> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV35> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV35();
    ModelParticleEmitterV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV35(const ModelParticleEmitterV35 &p_other);
    ModelParticleEmitterV35 &operator=(const ModelParticleEmitterV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV35 {
    helpers::Array<ModelParticleCloudV35> clouds;
    helpers::Array<ModelParticleEmitterV35> emitters;

public:
    ModelCloudDataV35();
    ModelCloudDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV35(const ModelCloudDataV35 &p_other);
    ModelCloudDataV35 &operator=(const ModelCloudDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV35 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV35();
    ModelObstacleDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV35(const ModelObstacleDataV35 &p_other);
    ModelObstacleDataV35 &operator=(const ModelObstacleDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV35 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV35();
    ModelStreakV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV35(const ModelStreakV35 &p_other);
    ModelStreakV35 &operator=(const ModelStreakV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV35 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV35();
    ModelStreakAnchorV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV35(const ModelStreakAnchorV35 &p_other);
    ModelStreakAnchorV35 &operator=(const ModelStreakAnchorV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV35 {
    helpers::Array<ModelStreakV35> streaks;
    helpers::Array<ModelStreakAnchorV35> anchors;

public:
    ModelStreakDataV35();
    ModelStreakDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV35(const ModelStreakDataV35 &p_other);
    ModelStreakDataV35 &operator=(const ModelStreakDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV35 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV35();
    ModelEffectLightV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV35(const ModelEffectLightV35 &p_other);
    ModelEffectLightV35 &operator=(const ModelEffectLightV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV35 {
    helpers::Array<ModelEffectLightV35> effectLights;

public:
    ModelLightDataV35();
    ModelLightDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV35(const ModelLightDataV35 &p_other);
    ModelLightDataV35 &operator=(const ModelLightDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV35 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV35();
    ModelClothBoneWeightV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV35(const ModelClothBoneWeightV35 &p_other);
    ModelClothBoneWeightV35 &operator=(const ModelClothBoneWeightV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV35 {
    helpers::Array<ModelClothBoneWeightV35> weights;

public:
    ModelClothMeshGroupV35();
    ModelClothMeshGroupV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV35(const ModelClothMeshGroupV35 &p_other);
    ModelClothMeshGroupV35 &operator=(const ModelClothMeshGroupV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV35 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV35();
    ModelClothConstraintV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV35(const ModelClothConstraintV35 &p_other);
    ModelClothConstraintV35 &operator=(const ModelClothConstraintV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV35 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV35();
    ModelClothObstacleV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV35(const ModelClothObstacleV35 &p_other);
    ModelClothObstacleV35 &operator=(const ModelClothObstacleV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV35 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV35> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV35> lod0Constraints;
    helpers::Array<ModelClothConstraintV35> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV35> obstacles;

public:
    ModelClothDataV35();
    ModelClothDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV35(const ModelClothDataV35 &p_other);
    ModelClothDataV35 &operator=(const ModelClothDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV35 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV35();
    ModelLightningSystemV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV35(const ModelLightningSystemV35 &p_other);
    ModelLightningSystemV35 &operator=(const ModelLightningSystemV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV35 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin[3];
    dword colorEnd[3];
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float2 opacity;
    byte opacityPreset;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV35();
    ModelLightningBoltV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV35(const ModelLightningBoltV35 &p_other);
    ModelLightningBoltV35 &operator=(const ModelLightningBoltV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV35 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    float updatePos;

public:
    ModelLightningNodeV35();
    ModelLightningNodeV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV35(const ModelLightningNodeV35 &p_other);
    ModelLightningNodeV35 &operator=(const ModelLightningNodeV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV35 {
    helpers::Array<ModelLightningSystemV35> systems;
    helpers::Array<ModelLightningBoltV35> bolts;
    helpers::Array<ModelLightningNodeV35> nodes;

public:
    ModelLightningDataV35();
    ModelLightningDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV35(const ModelLightningDataV35 &p_other);
    ModelLightningDataV35 &operator=(const ModelLightningDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV35 {
    qword token;
    word flags;
    float twistOffset;
    byte animBlend;
    byte drag;
    float ellipseRatio;
    byte gravity;
    float collisionRadius;
    byte wind;
    float2 angle;
    byte angleStrength;
    byte angleType;
    float2 distanceInner;
    byte distanceInnerStrength;
    byte distanceInnerType;
    float2 distanceOuter;
    byte distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    byte twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV35();
    ModelBoneConstraintV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV35(const ModelBoneConstraintV35 &p_other);
    ModelBoneConstraintV35 &operator=(const ModelBoneConstraintV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV35 {
    helpers::Ptr<ModelMaterialDataV35> materials;
    helpers::Ptr<ModelMeshDataV35> meshes;
    helpers::Ptr<ModelModelDataV35> model;
    helpers::Array<ModelPropertyDataV35> properties;
    helpers::Ptr<ModelCloudDataV35> cloudData;
    helpers::Array<ModelObstacleDataV35> obstacles;
    helpers::Ptr<ModelStreakDataV35> streakData;
    helpers::Ptr<ModelLightDataV35> lightData;
    helpers::Array<ModelClothDataV35> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV35> lightningData;
    helpers::Array<ModelBoneConstraintV35> boneConstraints;

public:
    ModelFileDataV35();
    ModelFileDataV35(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV35(const ModelFileDataV35 &p_other);
    ModelFileDataV35 &operator=(const ModelFileDataV35 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV35 Gw2Struct;
};

/* Version: 34, ReferencedFunction: 0x410D982000000001 */

template <>
struct Gw2StructMODL<34>{
struct ModelTextureDataV34 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV34();
    ModelTextureDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV34(const ModelTextureDataV34 &p_other);
    ModelTextureDataV34 &operator=(const ModelTextureDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV34 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV34();
    ModelConstantDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV34(const ModelConstantDataV34 &p_other);
    ModelConstantDataV34 &operator=(const ModelConstantDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV34 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV34();
    ModelMatConstLinkV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV34(const ModelMatConstLinkV34 &p_other);
    ModelMatConstLinkV34 &operator=(const ModelMatConstLinkV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV34 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV34();
    ModelUVTransLinkV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV34(const ModelUVTransLinkV34 &p_other);
    ModelUVTransLinkV34 &operator=(const ModelUVTransLinkV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV34 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV34> textures;
    helpers::Array<ModelConstantDataV34> constants;
    helpers::Array<ModelMatConstLinkV34> matConstLinks;
    helpers::Array<ModelUVTransLinkV34> uvTransLinks;

public:
    ModelMaterialDataV34();
    ModelMaterialDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV34(const ModelMaterialDataV34 &p_other);
    ModelMaterialDataV34 &operator=(const ModelMaterialDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV34 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV34();
    ModelMeshLodDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV34(const ModelMeshLodDataV34 &p_other);
    ModelMeshLodDataV34 &operator=(const ModelMeshLodDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV34 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV34();
    ModelMeshMorphTargetV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV34(const ModelMeshMorphTargetV34 &p_other);
    ModelMeshMorphTargetV34 &operator=(const ModelMeshMorphTargetV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV34 {
    qword visBone;
    helpers::Array<ModelMeshLodDataV34> lods;
    helpers::Array<ModelMeshMorphTargetV34> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV34();
    ModelMeshDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV34(const ModelMeshDataV34 &p_other);
    ModelMeshDataV34 &operator=(const ModelMeshDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV34 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV34();
    ModelTransformDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV34(const ModelTransformDataV34 &p_other);
    ModelTransformDataV34 &operator=(const ModelTransformDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV34 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV34 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV34();
    ModelBoneDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV34(const ModelBoneDataV34 &p_other);
    ModelBoneDataV34 &operator=(const ModelBoneDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV34 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV34> Bones;
    dword LODType;

public:
    ModelSkeletonDataV34();
    ModelSkeletonDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV34(const ModelSkeletonDataV34 &p_other);
    ModelSkeletonDataV34 &operator=(const ModelSkeletonDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV34 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV34();
    ModelMeshBindingDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV34(const ModelMeshBindingDataV34 &p_other);
    ModelMeshBindingDataV34 &operator=(const ModelMeshBindingDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV34 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV34();
    ModelTrackMaskV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV34(const ModelTrackMaskV34 &p_other);
    ModelTrackMaskV34 &operator=(const ModelTrackMaskV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV34 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV34> Skeleton;
    ModelTransformDataV34 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV34> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV34> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV34();
    ModelModelDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV34(const ModelModelDataV34 &p_other);
    ModelModelDataV34 &operator=(const ModelModelDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV34 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV34();
    ModelPropertyDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV34(const ModelPropertyDataV34 &p_other);
    ModelPropertyDataV34 &operator=(const ModelPropertyDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV34 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV34();
    ModelParticleCloudV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV34(const ModelParticleCloudV34 &p_other);
    ModelParticleCloudV34 &operator=(const ModelParticleCloudV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV34 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV34();
    ModelParticleCurveV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV34(const ModelParticleCurveV34 &p_other);
    ModelParticleCurveV34 &operator=(const ModelParticleCurveV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV34 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV34();
    ModelParticleFlipbookV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV34(const ModelParticleFlipbookV34 &p_other);
    ModelParticleFlipbookV34 &operator=(const ModelParticleFlipbookV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV34 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV34> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV34> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV34> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    byte windInfluence;

public:
    ModelParticleEmitterV34();
    ModelParticleEmitterV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV34(const ModelParticleEmitterV34 &p_other);
    ModelParticleEmitterV34 &operator=(const ModelParticleEmitterV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV34 {
    helpers::Array<ModelParticleCloudV34> clouds;
    helpers::Array<ModelParticleEmitterV34> emitters;

public:
    ModelCloudDataV34();
    ModelCloudDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV34(const ModelCloudDataV34 &p_other);
    ModelCloudDataV34 &operator=(const ModelCloudDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV34 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelObstacleDataV34();
    ModelObstacleDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV34(const ModelObstacleDataV34 &p_other);
    ModelObstacleDataV34 &operator=(const ModelObstacleDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV34 {
    float3 acceleration;
    float3 velocity;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    float wind;

public:
    ModelStreakV34();
    ModelStreakV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV34(const ModelStreakV34 &p_other);
    ModelStreakV34 &operator=(const ModelStreakV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV34 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV34();
    ModelStreakAnchorV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV34(const ModelStreakAnchorV34 &p_other);
    ModelStreakAnchorV34 &operator=(const ModelStreakAnchorV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV34 {
    helpers::Array<ModelStreakV34> streaks;
    helpers::Array<ModelStreakAnchorV34> anchors;

public:
    ModelStreakDataV34();
    ModelStreakDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV34(const ModelStreakDataV34 &p_other);
    ModelStreakDataV34 &operator=(const ModelStreakDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV34 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;

public:
    ModelEffectLightV34();
    ModelEffectLightV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV34(const ModelEffectLightV34 &p_other);
    ModelEffectLightV34 &operator=(const ModelEffectLightV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV34 {
    helpers::Array<ModelEffectLightV34> effectLights;

public:
    ModelLightDataV34();
    ModelLightDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV34(const ModelLightDataV34 &p_other);
    ModelLightDataV34 &operator=(const ModelLightDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV34 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV34();
    ModelClothBoneWeightV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV34(const ModelClothBoneWeightV34 &p_other);
    ModelClothBoneWeightV34 &operator=(const ModelClothBoneWeightV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV34 {
    helpers::Array<ModelClothBoneWeightV34> weights;

public:
    ModelClothMeshGroupV34();
    ModelClothMeshGroupV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV34(const ModelClothMeshGroupV34 &p_other);
    ModelClothMeshGroupV34 &operator=(const ModelClothMeshGroupV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV34 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV34();
    ModelClothConstraintV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV34(const ModelClothConstraintV34 &p_other);
    ModelClothConstraintV34 &operator=(const ModelClothConstraintV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV34 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV34();
    ModelClothObstacleV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV34(const ModelClothObstacleV34 &p_other);
    ModelClothObstacleV34 &operator=(const ModelClothObstacleV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV34 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV34> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV34> lod0Constraints;
    helpers::Array<ModelClothConstraintV34> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV34> obstacles;

public:
    ModelClothDataV34();
    ModelClothDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV34(const ModelClothDataV34 &p_other);
    ModelClothDataV34 &operator=(const ModelClothDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV34 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV34();
    ModelLightningSystemV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV34(const ModelLightningSystemV34 &p_other);
    ModelLightningSystemV34 &operator=(const ModelLightningSystemV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV34 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin;
    dword colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV34();
    ModelLightningBoltV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV34(const ModelLightningBoltV34 &p_other);
    ModelLightningBoltV34 &operator=(const ModelLightningBoltV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV34 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;

public:
    ModelLightningNodeV34();
    ModelLightningNodeV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV34(const ModelLightningNodeV34 &p_other);
    ModelLightningNodeV34 &operator=(const ModelLightningNodeV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV34 {
    helpers::Array<ModelLightningSystemV34> systems;
    helpers::Array<ModelLightningBoltV34> bolts;
    helpers::Array<ModelLightningNodeV34> nodes;

public:
    ModelLightningDataV34();
    ModelLightningDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV34(const ModelLightningDataV34 &p_other);
    ModelLightningDataV34 &operator=(const ModelLightningDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV34 {
    qword token;
    word flags;
    float twistOffset;
    byte animBlend;
    byte drag;
    float ellipseRatio;
    byte gravity;
    float collisionRadius;
    byte wind;
    float2 angle;
    byte angleStrength;
    byte angleType;
    float2 distanceInner;
    byte distanceInnerStrength;
    byte distanceInnerType;
    float2 distanceOuter;
    byte distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    byte twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV34();
    ModelBoneConstraintV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV34(const ModelBoneConstraintV34 &p_other);
    ModelBoneConstraintV34 &operator=(const ModelBoneConstraintV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV34 {
    helpers::Ptr<ModelMaterialDataV34> materials;
    helpers::Ptr<ModelMeshDataV34> meshes;
    helpers::Ptr<ModelModelDataV34> model;
    helpers::Array<ModelPropertyDataV34> properties;
    helpers::Ptr<ModelCloudDataV34> cloudData;
    helpers::Array<ModelObstacleDataV34> obstacles;
    helpers::Ptr<ModelStreakDataV34> streakData;
    helpers::Ptr<ModelLightDataV34> lightData;
    helpers::Array<ModelClothDataV34> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV34> lightningData;
    helpers::Array<ModelBoneConstraintV34> boneConstraints;

public:
    ModelFileDataV34();
    ModelFileDataV34(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV34(const ModelFileDataV34 &p_other);
    ModelFileDataV34 &operator=(const ModelFileDataV34 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV34 Gw2Struct;
};

/* Version: 33, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<33>{
struct ModelTextureDataV33 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV33();
    ModelTextureDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV33(const ModelTextureDataV33 &p_other);
    ModelTextureDataV33 &operator=(const ModelTextureDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV33 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV33();
    ModelConstantDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV33(const ModelConstantDataV33 &p_other);
    ModelConstantDataV33 &operator=(const ModelConstantDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV33 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV33();
    ModelMatConstLinkV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV33(const ModelMatConstLinkV33 &p_other);
    ModelMatConstLinkV33 &operator=(const ModelMatConstLinkV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV33 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV33();
    ModelUVTransLinkV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV33(const ModelUVTransLinkV33 &p_other);
    ModelUVTransLinkV33 &operator=(const ModelUVTransLinkV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV33 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV33> textures;
    helpers::Array<ModelConstantDataV33> constants;
    helpers::Array<ModelMatConstLinkV33> matConstLinks;
    helpers::Array<ModelUVTransLinkV33> uvTransLinks;

public:
    ModelMaterialDataV33();
    ModelMaterialDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV33(const ModelMaterialDataV33 &p_other);
    ModelMaterialDataV33 &operator=(const ModelMaterialDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV33 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV33();
    ModelMeshLodDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV33(const ModelMeshLodDataV33 &p_other);
    ModelMeshLodDataV33 &operator=(const ModelMeshLodDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV33 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV33();
    ModelMeshMorphTargetV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV33(const ModelMeshMorphTargetV33 &p_other);
    ModelMeshMorphTargetV33 &operator=(const ModelMeshMorphTargetV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV33 {
    helpers::Array<ModelMeshLodDataV33> lods;
    helpers::Array<ModelMeshMorphTargetV33> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV33();
    ModelMeshDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV33(const ModelMeshDataV33 &p_other);
    ModelMeshDataV33 &operator=(const ModelMeshDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV33 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV33();
    ModelTransformDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV33(const ModelTransformDataV33 &p_other);
    ModelTransformDataV33 &operator=(const ModelTransformDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV33 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV33 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV33();
    ModelBoneDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV33(const ModelBoneDataV33 &p_other);
    ModelBoneDataV33 &operator=(const ModelBoneDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV33 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV33> Bones;
    dword LODType;

public:
    ModelSkeletonDataV33();
    ModelSkeletonDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV33(const ModelSkeletonDataV33 &p_other);
    ModelSkeletonDataV33 &operator=(const ModelSkeletonDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV33 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV33();
    ModelMeshBindingDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV33(const ModelMeshBindingDataV33 &p_other);
    ModelMeshBindingDataV33 &operator=(const ModelMeshBindingDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV33 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV33();
    ModelTrackMaskV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV33(const ModelTrackMaskV33 &p_other);
    ModelTrackMaskV33 &operator=(const ModelTrackMaskV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV33 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV33> Skeleton;
    ModelTransformDataV33 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV33> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV33> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV33();
    ModelModelDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV33(const ModelModelDataV33 &p_other);
    ModelModelDataV33 &operator=(const ModelModelDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV33 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV33();
    ModelPropertyDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV33(const ModelPropertyDataV33 &p_other);
    ModelPropertyDataV33 &operator=(const ModelPropertyDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV33 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV33();
    ModelParticleCloudV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV33(const ModelParticleCloudV33 &p_other);
    ModelParticleCloudV33 &operator=(const ModelParticleCloudV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV33 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV33();
    ModelParticleCurveV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV33(const ModelParticleCurveV33 &p_other);
    ModelParticleCurveV33 &operator=(const ModelParticleCurveV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV33 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV33();
    ModelParticleFlipbookV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV33(const ModelParticleFlipbookV33 &p_other);
    ModelParticleFlipbookV33 &operator=(const ModelParticleFlipbookV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV33 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV33> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV33> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV33> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV33();
    ModelParticleEmitterV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV33(const ModelParticleEmitterV33 &p_other);
    ModelParticleEmitterV33 &operator=(const ModelParticleEmitterV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV33 {
    helpers::Array<ModelParticleCloudV33> clouds;
    helpers::Array<ModelParticleEmitterV33> emitters;

public:
    ModelCloudDataV33();
    ModelCloudDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV33(const ModelCloudDataV33 &p_other);
    ModelCloudDataV33 &operator=(const ModelCloudDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV33 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV33();
    ModelObstacleDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV33(const ModelObstacleDataV33 &p_other);
    ModelObstacleDataV33 &operator=(const ModelObstacleDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV33 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV33();
    ModelStreakV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV33(const ModelStreakV33 &p_other);
    ModelStreakV33 &operator=(const ModelStreakV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV33 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV33();
    ModelStreakAnchorV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV33(const ModelStreakAnchorV33 &p_other);
    ModelStreakAnchorV33 &operator=(const ModelStreakAnchorV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV33 {
    helpers::Array<ModelStreakV33> streaks;
    helpers::Array<ModelStreakAnchorV33> anchors;

public:
    ModelStreakDataV33();
    ModelStreakDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV33(const ModelStreakDataV33 &p_other);
    ModelStreakDataV33 &operator=(const ModelStreakDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV33 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV33();
    ModelEffectLightV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV33(const ModelEffectLightV33 &p_other);
    ModelEffectLightV33 &operator=(const ModelEffectLightV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV33 {
    helpers::Array<ModelEffectLightV33> effectLights;

public:
    ModelLightDataV33();
    ModelLightDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV33(const ModelLightDataV33 &p_other);
    ModelLightDataV33 &operator=(const ModelLightDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV33 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV33();
    ModelClothBoneWeightV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV33(const ModelClothBoneWeightV33 &p_other);
    ModelClothBoneWeightV33 &operator=(const ModelClothBoneWeightV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV33 {
    helpers::Array<ModelClothBoneWeightV33> weights;

public:
    ModelClothMeshGroupV33();
    ModelClothMeshGroupV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV33(const ModelClothMeshGroupV33 &p_other);
    ModelClothMeshGroupV33 &operator=(const ModelClothMeshGroupV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV33 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV33();
    ModelClothConstraintV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV33(const ModelClothConstraintV33 &p_other);
    ModelClothConstraintV33 &operator=(const ModelClothConstraintV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV33 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV33();
    ModelClothObstacleV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV33(const ModelClothObstacleV33 &p_other);
    ModelClothObstacleV33 &operator=(const ModelClothObstacleV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV33 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV33> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV33> lod0Constraints;
    helpers::Array<ModelClothConstraintV33> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV33> obstacles;

public:
    ModelClothDataV33();
    ModelClothDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV33(const ModelClothDataV33 &p_other);
    ModelClothDataV33 &operator=(const ModelClothDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV33 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV33();
    ModelLightningSystemV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV33(const ModelLightningSystemV33 &p_other);
    ModelLightningSystemV33 &operator=(const ModelLightningSystemV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV33 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin;
    dword colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV33();
    ModelLightningBoltV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV33(const ModelLightningBoltV33 &p_other);
    ModelLightningBoltV33 &operator=(const ModelLightningBoltV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV33 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    dword visBoneIndex;

public:
    ModelLightningNodeV33();
    ModelLightningNodeV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV33(const ModelLightningNodeV33 &p_other);
    ModelLightningNodeV33 &operator=(const ModelLightningNodeV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV33 {
    helpers::Array<ModelLightningSystemV33> systems;
    helpers::Array<ModelLightningBoltV33> bolts;
    helpers::Array<ModelLightningNodeV33> nodes;

public:
    ModelLightningDataV33();
    ModelLightningDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV33(const ModelLightningDataV33 &p_other);
    ModelLightningDataV33 &operator=(const ModelLightningDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV33 {
    qword token;
    word flags;
    float twistOffset;
    byte animBlend;
    byte drag;
    float ellipseRatio;
    byte gravity;
    float collisionRadius;
    byte wind;
    float2 angle;
    byte angleStrength;
    byte angleType;
    float2 distanceInner;
    byte distanceInnerStrength;
    byte distanceInnerType;
    float2 distanceOuter;
    byte distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    byte twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV33();
    ModelBoneConstraintV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV33(const ModelBoneConstraintV33 &p_other);
    ModelBoneConstraintV33 &operator=(const ModelBoneConstraintV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV33 {
    helpers::Ptr<ModelMaterialDataV33> materials;
    helpers::Ptr<ModelMeshDataV33> meshes;
    helpers::Ptr<ModelModelDataV33> model;
    helpers::Array<ModelPropertyDataV33> properties;
    helpers::Ptr<ModelCloudDataV33> cloudData;
    helpers::Array<ModelObstacleDataV33> obstacles;
    helpers::Ptr<ModelStreakDataV33> streakData;
    helpers::Ptr<ModelLightDataV33> lightData;
    helpers::Array<ModelClothDataV33> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV33> lightningData;
    helpers::Array<ModelBoneConstraintV33> boneConstraints;

public:
    ModelFileDataV33();
    ModelFileDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV33(const ModelFileDataV33 &p_other);
    ModelFileDataV33 &operator=(const ModelFileDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV33 Gw2Struct;
};

/* Version: 32, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<32>{
struct ModelTextureDataV32 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV32();
    ModelTextureDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV32(const ModelTextureDataV32 &p_other);
    ModelTextureDataV32 &operator=(const ModelTextureDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV32 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV32();
    ModelConstantDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV32(const ModelConstantDataV32 &p_other);
    ModelConstantDataV32 &operator=(const ModelConstantDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV32 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV32();
    ModelMatConstLinkV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV32(const ModelMatConstLinkV32 &p_other);
    ModelMatConstLinkV32 &operator=(const ModelMatConstLinkV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV32 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV32();
    ModelUVTransLinkV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV32(const ModelUVTransLinkV32 &p_other);
    ModelUVTransLinkV32 &operator=(const ModelUVTransLinkV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV32 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV32> textures;
    helpers::Array<ModelConstantDataV32> constants;
    helpers::Array<ModelMatConstLinkV32> matConstLinks;
    helpers::Array<ModelUVTransLinkV32> uvTransLinks;

public:
    ModelMaterialDataV32();
    ModelMaterialDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV32(const ModelMaterialDataV32 &p_other);
    ModelMaterialDataV32 &operator=(const ModelMaterialDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV32 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV32();
    ModelMeshLodDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV32(const ModelMeshLodDataV32 &p_other);
    ModelMeshLodDataV32 &operator=(const ModelMeshLodDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV32 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV32();
    ModelMeshMorphTargetV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV32(const ModelMeshMorphTargetV32 &p_other);
    ModelMeshMorphTargetV32 &operator=(const ModelMeshMorphTargetV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV32 {
    helpers::Array<ModelMeshLodDataV32> lods;
    helpers::Array<ModelMeshMorphTargetV32> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV32();
    ModelMeshDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV32(const ModelMeshDataV32 &p_other);
    ModelMeshDataV32 &operator=(const ModelMeshDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV32 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV32();
    ModelTransformDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV32(const ModelTransformDataV32 &p_other);
    ModelTransformDataV32 &operator=(const ModelTransformDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV32 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV32 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV32();
    ModelBoneDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV32(const ModelBoneDataV32 &p_other);
    ModelBoneDataV32 &operator=(const ModelBoneDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV32 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV32> Bones;
    dword LODType;

public:
    ModelSkeletonDataV32();
    ModelSkeletonDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV32(const ModelSkeletonDataV32 &p_other);
    ModelSkeletonDataV32 &operator=(const ModelSkeletonDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV32 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV32();
    ModelMeshBindingDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV32(const ModelMeshBindingDataV32 &p_other);
    ModelMeshBindingDataV32 &operator=(const ModelMeshBindingDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV32 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV32();
    ModelTrackMaskV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV32(const ModelTrackMaskV32 &p_other);
    ModelTrackMaskV32 &operator=(const ModelTrackMaskV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV32 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV32> Skeleton;
    ModelTransformDataV32 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV32> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV32> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV32();
    ModelModelDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV32(const ModelModelDataV32 &p_other);
    ModelModelDataV32 &operator=(const ModelModelDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV32 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV32();
    ModelPropertyDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV32(const ModelPropertyDataV32 &p_other);
    ModelPropertyDataV32 &operator=(const ModelPropertyDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV32 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV32();
    ModelParticleCloudV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV32(const ModelParticleCloudV32 &p_other);
    ModelParticleCloudV32 &operator=(const ModelParticleCloudV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV32 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV32();
    ModelParticleCurveV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV32(const ModelParticleCurveV32 &p_other);
    ModelParticleCurveV32 &operator=(const ModelParticleCurveV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV32 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV32();
    ModelParticleFlipbookV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV32(const ModelParticleFlipbookV32 &p_other);
    ModelParticleFlipbookV32 &operator=(const ModelParticleFlipbookV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV32 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV32> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV32> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV32> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV32();
    ModelParticleEmitterV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV32(const ModelParticleEmitterV32 &p_other);
    ModelParticleEmitterV32 &operator=(const ModelParticleEmitterV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV32 {
    helpers::Array<ModelParticleCloudV32> clouds;
    helpers::Array<ModelParticleEmitterV32> emitters;

public:
    ModelCloudDataV32();
    ModelCloudDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV32(const ModelCloudDataV32 &p_other);
    ModelCloudDataV32 &operator=(const ModelCloudDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV32 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV32();
    ModelObstacleDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV32(const ModelObstacleDataV32 &p_other);
    ModelObstacleDataV32 &operator=(const ModelObstacleDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV32 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV32();
    ModelStreakV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV32(const ModelStreakV32 &p_other);
    ModelStreakV32 &operator=(const ModelStreakV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV32 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV32();
    ModelStreakAnchorV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV32(const ModelStreakAnchorV32 &p_other);
    ModelStreakAnchorV32 &operator=(const ModelStreakAnchorV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV32 {
    helpers::Array<ModelStreakV32> streaks;
    helpers::Array<ModelStreakAnchorV32> anchors;

public:
    ModelStreakDataV32();
    ModelStreakDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV32(const ModelStreakDataV32 &p_other);
    ModelStreakDataV32 &operator=(const ModelStreakDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV32 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV32();
    ModelEffectLightV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV32(const ModelEffectLightV32 &p_other);
    ModelEffectLightV32 &operator=(const ModelEffectLightV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV32 {
    helpers::Array<ModelEffectLightV32> effectLights;

public:
    ModelLightDataV32();
    ModelLightDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV32(const ModelLightDataV32 &p_other);
    ModelLightDataV32 &operator=(const ModelLightDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV32 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV32();
    ModelClothBoneWeightV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV32(const ModelClothBoneWeightV32 &p_other);
    ModelClothBoneWeightV32 &operator=(const ModelClothBoneWeightV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV32 {
    helpers::Array<ModelClothBoneWeightV32> weights;

public:
    ModelClothMeshGroupV32();
    ModelClothMeshGroupV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV32(const ModelClothMeshGroupV32 &p_other);
    ModelClothMeshGroupV32 &operator=(const ModelClothMeshGroupV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV32 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV32();
    ModelClothConstraintV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV32(const ModelClothConstraintV32 &p_other);
    ModelClothConstraintV32 &operator=(const ModelClothConstraintV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV32 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV32();
    ModelClothObstacleV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV32(const ModelClothObstacleV32 &p_other);
    ModelClothObstacleV32 &operator=(const ModelClothObstacleV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV32 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV32> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV32> lod0Constraints;
    helpers::Array<ModelClothConstraintV32> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV32> obstacles;

public:
    ModelClothDataV32();
    ModelClothDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV32(const ModelClothDataV32 &p_other);
    ModelClothDataV32 &operator=(const ModelClothDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningSystemV32 {
    helpers::Array<word> boltIndices;
    dword flags;
    dword materialIndex;

public:
    ModelLightningSystemV32();
    ModelLightningSystemV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningSystemV32(const ModelLightningSystemV32 &p_other);
    ModelLightningSystemV32 &operator=(const ModelLightningSystemV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningBoltV32 {
    qword bone;
    helpers::Array<word> nodeIndices;
    dword colorBegin;
    dword colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    dword flags;
    float fps;
    float probability;
    float2 lifetime;
    word numSegments;
    float period;
    float texOffset;
    float texScale;
    float texSpeed;
    float thickness;
    byte thicknessPreset;
    byte type;
    float variance;
    byte variancePreset;
    float noise;

public:
    ModelLightningBoltV32();
    ModelLightningBoltV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningBoltV32(const ModelLightningBoltV32 &p_other);
    ModelLightningBoltV32 &operator=(const ModelLightningBoltV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningNodeV32 {
    qword bone;
    helpers::Array<word> childrenIndices;
    dword flags;
    float probability;
    float radius;
    byte shape;
    dword visBoneIndex;

public:
    ModelLightningNodeV32();
    ModelLightningNodeV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningNodeV32(const ModelLightningNodeV32 &p_other);
    ModelLightningNodeV32 &operator=(const ModelLightningNodeV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningDataV32 {
    helpers::Array<ModelLightningSystemV32> systems;
    helpers::Array<ModelLightningBoltV32> bolts;
    helpers::Array<ModelLightningNodeV32> nodes;

public:
    ModelLightningDataV32();
    ModelLightningDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningDataV32(const ModelLightningDataV32 &p_other);
    ModelLightningDataV32 &operator=(const ModelLightningDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV32 {
    helpers::Ptr<ModelMaterialDataV32> materials;
    helpers::Ptr<ModelMeshDataV32> meshes;
    helpers::Ptr<ModelModelDataV32> model;
    helpers::Array<ModelPropertyDataV32> properties;
    helpers::Ptr<ModelCloudDataV32> cloudData;
    helpers::Array<ModelObstacleDataV32> obstacles;
    helpers::Ptr<ModelStreakDataV32> streakData;
    helpers::Ptr<ModelLightDataV32> lightData;
    helpers::Array<ModelClothDataV32> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;
    helpers::Ptr<ModelLightningDataV32> lightningData;

public:
    ModelFileDataV32();
    ModelFileDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV32(const ModelFileDataV32 &p_other);
    ModelFileDataV32 &operator=(const ModelFileDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV32 Gw2Struct;
};

/* Version: 31, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<31>{
struct ModelTextureDataV31 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV31();
    ModelTextureDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV31(const ModelTextureDataV31 &p_other);
    ModelTextureDataV31 &operator=(const ModelTextureDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV31 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV31();
    ModelConstantDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV31(const ModelConstantDataV31 &p_other);
    ModelConstantDataV31 &operator=(const ModelConstantDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV31 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV31();
    ModelMatConstLinkV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV31(const ModelMatConstLinkV31 &p_other);
    ModelMatConstLinkV31 &operator=(const ModelMatConstLinkV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV31 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV31();
    ModelUVTransLinkV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV31(const ModelUVTransLinkV31 &p_other);
    ModelUVTransLinkV31 &operator=(const ModelUVTransLinkV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV31 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV31> textures;
    helpers::Array<ModelConstantDataV31> constants;
    helpers::Array<ModelMatConstLinkV31> matConstLinks;
    helpers::Array<ModelUVTransLinkV31> uvTransLinks;

public:
    ModelMaterialDataV31();
    ModelMaterialDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV31(const ModelMaterialDataV31 &p_other);
    ModelMaterialDataV31 &operator=(const ModelMaterialDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV31 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV31();
    ModelMeshLodDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV31(const ModelMeshLodDataV31 &p_other);
    ModelMeshLodDataV31 &operator=(const ModelMeshLodDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV31 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV31();
    ModelMeshMorphTargetV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV31(const ModelMeshMorphTargetV31 &p_other);
    ModelMeshMorphTargetV31 &operator=(const ModelMeshMorphTargetV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV31 {
    helpers::Array<ModelMeshLodDataV31> lods;
    helpers::Array<ModelMeshMorphTargetV31> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV31();
    ModelMeshDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV31(const ModelMeshDataV31 &p_other);
    ModelMeshDataV31 &operator=(const ModelMeshDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV31 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV31();
    ModelTransformDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV31(const ModelTransformDataV31 &p_other);
    ModelTransformDataV31 &operator=(const ModelTransformDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV31 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV31 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV31();
    ModelBoneDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV31(const ModelBoneDataV31 &p_other);
    ModelBoneDataV31 &operator=(const ModelBoneDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV31 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV31> Bones;
    dword LODType;

public:
    ModelSkeletonDataV31();
    ModelSkeletonDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV31(const ModelSkeletonDataV31 &p_other);
    ModelSkeletonDataV31 &operator=(const ModelSkeletonDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV31 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV31();
    ModelMeshBindingDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV31(const ModelMeshBindingDataV31 &p_other);
    ModelMeshBindingDataV31 &operator=(const ModelMeshBindingDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV31 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV31();
    ModelTrackMaskV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV31(const ModelTrackMaskV31 &p_other);
    ModelTrackMaskV31 &operator=(const ModelTrackMaskV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV31 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV31> Skeleton;
    ModelTransformDataV31 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV31> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV31> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV31();
    ModelModelDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV31(const ModelModelDataV31 &p_other);
    ModelModelDataV31 &operator=(const ModelModelDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV31 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV31();
    ModelPropertyDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV31(const ModelPropertyDataV31 &p_other);
    ModelPropertyDataV31 &operator=(const ModelPropertyDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV31 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV31();
    ModelParticleCloudV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV31(const ModelParticleCloudV31 &p_other);
    ModelParticleCloudV31 &operator=(const ModelParticleCloudV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV31 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV31();
    ModelParticleCurveV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV31(const ModelParticleCurveV31 &p_other);
    ModelParticleCurveV31 &operator=(const ModelParticleCurveV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV31 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV31();
    ModelParticleFlipbookV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV31(const ModelParticleFlipbookV31 &p_other);
    ModelParticleFlipbookV31 &operator=(const ModelParticleFlipbookV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV31 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV31> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV31> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV31> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV31();
    ModelParticleEmitterV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV31(const ModelParticleEmitterV31 &p_other);
    ModelParticleEmitterV31 &operator=(const ModelParticleEmitterV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV31 {
    helpers::Array<ModelParticleCloudV31> clouds;
    helpers::Array<ModelParticleEmitterV31> emitters;

public:
    ModelCloudDataV31();
    ModelCloudDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV31(const ModelCloudDataV31 &p_other);
    ModelCloudDataV31 &operator=(const ModelCloudDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV31 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV31();
    ModelObstacleDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV31(const ModelObstacleDataV31 &p_other);
    ModelObstacleDataV31 &operator=(const ModelObstacleDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV31 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV31();
    ModelStreakV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV31(const ModelStreakV31 &p_other);
    ModelStreakV31 &operator=(const ModelStreakV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV31 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;
    dword flags;
    float texV;

public:
    ModelStreakAnchorV31();
    ModelStreakAnchorV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV31(const ModelStreakAnchorV31 &p_other);
    ModelStreakAnchorV31 &operator=(const ModelStreakAnchorV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV31 {
    helpers::Array<ModelStreakV31> streaks;
    helpers::Array<ModelStreakAnchorV31> anchors;

public:
    ModelStreakDataV31();
    ModelStreakDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV31(const ModelStreakDataV31 &p_other);
    ModelStreakDataV31 &operator=(const ModelStreakDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV31 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV31();
    ModelEffectLightV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV31(const ModelEffectLightV31 &p_other);
    ModelEffectLightV31 &operator=(const ModelEffectLightV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV31 {
    helpers::Array<ModelEffectLightV31> effectLights;

public:
    ModelLightDataV31();
    ModelLightDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV31(const ModelLightDataV31 &p_other);
    ModelLightDataV31 &operator=(const ModelLightDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV31 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV31();
    ModelClothBoneWeightV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV31(const ModelClothBoneWeightV31 &p_other);
    ModelClothBoneWeightV31 &operator=(const ModelClothBoneWeightV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV31 {
    helpers::Array<ModelClothBoneWeightV31> weights;

public:
    ModelClothMeshGroupV31();
    ModelClothMeshGroupV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV31(const ModelClothMeshGroupV31 &p_other);
    ModelClothMeshGroupV31 &operator=(const ModelClothMeshGroupV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV31 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV31();
    ModelClothConstraintV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV31(const ModelClothConstraintV31 &p_other);
    ModelClothConstraintV31 &operator=(const ModelClothConstraintV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV31 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV31();
    ModelClothObstacleV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV31(const ModelClothObstacleV31 &p_other);
    ModelClothObstacleV31 &operator=(const ModelClothObstacleV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV31 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV31> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV31> lod0Constraints;
    helpers::Array<ModelClothConstraintV31> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV31> obstacles;

public:
    ModelClothDataV31();
    ModelClothDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV31(const ModelClothDataV31 &p_other);
    ModelClothDataV31 &operator=(const ModelClothDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV31 {
    helpers::Ptr<ModelMaterialDataV31> materials;
    helpers::Ptr<ModelMeshDataV31> meshes;
    helpers::Ptr<ModelModelDataV31> model;
    helpers::Array<ModelPropertyDataV31> properties;
    helpers::Ptr<ModelCloudDataV31> cloudData;
    helpers::Array<ModelObstacleDataV31> obstacles;
    helpers::Ptr<ModelStreakDataV31> streakData;
    helpers::Ptr<ModelLightDataV31> lightData;
    helpers::Array<ModelClothDataV31> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV31();
    ModelFileDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV31(const ModelFileDataV31 &p_other);
    ModelFileDataV31 &operator=(const ModelFileDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV31 Gw2Struct;
};

/* Version: 30, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<30>{
struct ModelTextureDataV30 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV30();
    ModelTextureDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV30(const ModelTextureDataV30 &p_other);
    ModelTextureDataV30 &operator=(const ModelTextureDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV30 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV30();
    ModelConstantDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV30(const ModelConstantDataV30 &p_other);
    ModelConstantDataV30 &operator=(const ModelConstantDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV30 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV30();
    ModelMatConstLinkV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV30(const ModelMatConstLinkV30 &p_other);
    ModelMatConstLinkV30 &operator=(const ModelMatConstLinkV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV30 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV30();
    ModelUVTransLinkV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV30(const ModelUVTransLinkV30 &p_other);
    ModelUVTransLinkV30 &operator=(const ModelUVTransLinkV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV30 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV30> textures;
    helpers::Array<ModelConstantDataV30> constants;
    helpers::Array<ModelMatConstLinkV30> matConstLinks;
    helpers::Array<ModelUVTransLinkV30> uvTransLinks;

public:
    ModelMaterialDataV30();
    ModelMaterialDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV30(const ModelMaterialDataV30 &p_other);
    ModelMaterialDataV30 &operator=(const ModelMaterialDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV30 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV30();
    ModelMeshLodDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV30(const ModelMeshLodDataV30 &p_other);
    ModelMeshLodDataV30 &operator=(const ModelMeshLodDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV30 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV30();
    ModelMeshMorphTargetV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV30(const ModelMeshMorphTargetV30 &p_other);
    ModelMeshMorphTargetV30 &operator=(const ModelMeshMorphTargetV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV30 {
    helpers::Array<ModelMeshLodDataV30> lods;
    helpers::Array<ModelMeshMorphTargetV30> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV30();
    ModelMeshDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV30(const ModelMeshDataV30 &p_other);
    ModelMeshDataV30 &operator=(const ModelMeshDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV30 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV30();
    ModelTransformDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV30(const ModelTransformDataV30 &p_other);
    ModelTransformDataV30 &operator=(const ModelTransformDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV30 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV30 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV30();
    ModelBoneDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV30(const ModelBoneDataV30 &p_other);
    ModelBoneDataV30 &operator=(const ModelBoneDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV30 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV30> Bones;
    dword LODType;

public:
    ModelSkeletonDataV30();
    ModelSkeletonDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV30(const ModelSkeletonDataV30 &p_other);
    ModelSkeletonDataV30 &operator=(const ModelSkeletonDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV30 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV30();
    ModelMeshBindingDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV30(const ModelMeshBindingDataV30 &p_other);
    ModelMeshBindingDataV30 &operator=(const ModelMeshBindingDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV30 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV30();
    ModelTrackMaskV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV30(const ModelTrackMaskV30 &p_other);
    ModelTrackMaskV30 &operator=(const ModelTrackMaskV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV30 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV30> Skeleton;
    ModelTransformDataV30 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV30> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV30> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV30();
    ModelModelDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV30(const ModelModelDataV30 &p_other);
    ModelModelDataV30 &operator=(const ModelModelDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV30 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV30();
    ModelPropertyDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV30(const ModelPropertyDataV30 &p_other);
    ModelPropertyDataV30 &operator=(const ModelPropertyDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV30 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV30();
    ModelParticleCloudV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV30(const ModelParticleCloudV30 &p_other);
    ModelParticleCloudV30 &operator=(const ModelParticleCloudV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV30 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV30();
    ModelParticleCurveV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV30(const ModelParticleCurveV30 &p_other);
    ModelParticleCurveV30 &operator=(const ModelParticleCurveV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV30 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV30();
    ModelParticleFlipbookV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV30(const ModelParticleFlipbookV30 &p_other);
    ModelParticleFlipbookV30 &operator=(const ModelParticleFlipbookV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV30 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV30> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV30> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV30> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV30();
    ModelParticleEmitterV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV30(const ModelParticleEmitterV30 &p_other);
    ModelParticleEmitterV30 &operator=(const ModelParticleEmitterV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV30 {
    helpers::Array<ModelParticleCloudV30> clouds;
    helpers::Array<ModelParticleEmitterV30> emitters;

public:
    ModelCloudDataV30();
    ModelCloudDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV30(const ModelCloudDataV30 &p_other);
    ModelCloudDataV30 &operator=(const ModelCloudDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV30 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV30();
    ModelObstacleDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV30(const ModelObstacleDataV30 &p_other);
    ModelObstacleDataV30 &operator=(const ModelObstacleDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV30 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV30();
    ModelStreakV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV30(const ModelStreakV30 &p_other);
    ModelStreakV30 &operator=(const ModelStreakV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV30 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV30();
    ModelStreakAnchorV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV30(const ModelStreakAnchorV30 &p_other);
    ModelStreakAnchorV30 &operator=(const ModelStreakAnchorV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV30 {
    helpers::Array<ModelStreakV30> streaks;
    helpers::Array<ModelStreakAnchorV30> anchors;

public:
    ModelStreakDataV30();
    ModelStreakDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV30(const ModelStreakDataV30 &p_other);
    ModelStreakDataV30 &operator=(const ModelStreakDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV30 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV30();
    ModelEffectLightV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV30(const ModelEffectLightV30 &p_other);
    ModelEffectLightV30 &operator=(const ModelEffectLightV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV30 {
    helpers::Array<ModelEffectLightV30> effectLights;

public:
    ModelLightDataV30();
    ModelLightDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV30(const ModelLightDataV30 &p_other);
    ModelLightDataV30 &operator=(const ModelLightDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV30 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV30();
    ModelClothBoneWeightV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV30(const ModelClothBoneWeightV30 &p_other);
    ModelClothBoneWeightV30 &operator=(const ModelClothBoneWeightV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV30 {
    helpers::Array<ModelClothBoneWeightV30> weights;

public:
    ModelClothMeshGroupV30();
    ModelClothMeshGroupV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV30(const ModelClothMeshGroupV30 &p_other);
    ModelClothMeshGroupV30 &operator=(const ModelClothMeshGroupV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV30 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV30();
    ModelClothConstraintV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV30(const ModelClothConstraintV30 &p_other);
    ModelClothConstraintV30 &operator=(const ModelClothConstraintV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV30 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV30();
    ModelClothObstacleV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV30(const ModelClothObstacleV30 &p_other);
    ModelClothObstacleV30 &operator=(const ModelClothObstacleV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV30 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV30> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV30> lod0Constraints;
    helpers::Array<ModelClothConstraintV30> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV30> obstacles;

public:
    ModelClothDataV30();
    ModelClothDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV30(const ModelClothDataV30 &p_other);
    ModelClothDataV30 &operator=(const ModelClothDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV30 {
    helpers::Ptr<ModelMaterialDataV30> materials;
    helpers::Ptr<ModelMeshDataV30> meshes;
    helpers::Ptr<ModelModelDataV30> model;
    helpers::Array<ModelPropertyDataV30> properties;
    helpers::Ptr<ModelCloudDataV30> cloudData;
    helpers::Array<ModelObstacleDataV30> obstacles;
    helpers::Ptr<ModelStreakDataV30> streakData;
    helpers::Ptr<ModelLightDataV30> lightData;
    helpers::Array<ModelClothDataV30> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV30();
    ModelFileDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV30(const ModelFileDataV30 &p_other);
    ModelFileDataV30 &operator=(const ModelFileDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV30 Gw2Struct;
};

/* Version: 29, ReferencedFunction: 0x410D974000000001 */

template <>
struct Gw2StructMODL<29>{
struct ModelTextureDataV29 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    dword uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV29();
    ModelTextureDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV29(const ModelTextureDataV29 &p_other);
    ModelTextureDataV29 &operator=(const ModelTextureDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV29 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV29();
    ModelConstantDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV29(const ModelConstantDataV29 &p_other);
    ModelConstantDataV29 &operator=(const ModelConstantDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstLinkV29 {
    qword linkToken;
    dword constantToken;

public:
    ModelMatConstLinkV29();
    ModelMatConstLinkV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstLinkV29(const ModelMatConstLinkV29 &p_other);
    ModelMatConstLinkV29 &operator=(const ModelMatConstLinkV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransLinkV29 {
    qword linkToken;
    dword uvAnimId;
    byte type;

public:
    ModelUVTransLinkV29();
    ModelUVTransLinkV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransLinkV29(const ModelUVTransLinkV29 &p_other);
    ModelUVTransLinkV29 &operator=(const ModelUVTransLinkV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV29 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV29> textures;
    helpers::Array<ModelConstantDataV29> constants;
    helpers::Array<ModelMatConstLinkV29> matConstLinks;
    helpers::Array<ModelUVTransLinkV29> uvTransLinks;

public:
    ModelMaterialDataV29();
    ModelMaterialDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV29(const ModelMaterialDataV29 &p_other);
    ModelMaterialDataV29 &operator=(const ModelMaterialDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV29 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV29();
    ModelMeshLodDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV29(const ModelMeshLodDataV29 &p_other);
    ModelMeshLodDataV29 &operator=(const ModelMeshLodDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV29 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV29();
    ModelMeshMorphTargetV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV29(const ModelMeshMorphTargetV29 &p_other);
    ModelMeshMorphTargetV29 &operator=(const ModelMeshMorphTargetV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV29 {
    helpers::Array<ModelMeshLodDataV29> lods;
    helpers::Array<ModelMeshMorphTargetV29> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV29();
    ModelMeshDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV29(const ModelMeshDataV29 &p_other);
    ModelMeshDataV29 &operator=(const ModelMeshDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV29 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV29();
    ModelTransformDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV29(const ModelTransformDataV29 &p_other);
    ModelTransformDataV29 &operator=(const ModelTransformDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV29 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV29 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV29();
    ModelBoneDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV29(const ModelBoneDataV29 &p_other);
    ModelBoneDataV29 &operator=(const ModelBoneDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV29 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV29> Bones;
    dword LODType;

public:
    ModelSkeletonDataV29();
    ModelSkeletonDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV29(const ModelSkeletonDataV29 &p_other);
    ModelSkeletonDataV29 &operator=(const ModelSkeletonDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV29 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV29();
    ModelMeshBindingDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV29(const ModelMeshBindingDataV29 &p_other);
    ModelMeshBindingDataV29 &operator=(const ModelMeshBindingDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV29 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV29();
    ModelTrackMaskV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV29(const ModelTrackMaskV29 &p_other);
    ModelTrackMaskV29 &operator=(const ModelTrackMaskV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV29 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV29> Skeleton;
    ModelTransformDataV29 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV29> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV29> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV29();
    ModelModelDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV29(const ModelModelDataV29 &p_other);
    ModelModelDataV29 &operator=(const ModelModelDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV29 {
    qword id;
    dword type;
    dword mergeIndex;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV29();
    ModelPropertyDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV29(const ModelPropertyDataV29 &p_other);
    ModelPropertyDataV29 &operator=(const ModelPropertyDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV29 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV29();
    ModelParticleCloudV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV29(const ModelParticleCloudV29 &p_other);
    ModelParticleCloudV29 &operator=(const ModelParticleCloudV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV29 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV29();
    ModelParticleCurveV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV29(const ModelParticleCurveV29 &p_other);
    ModelParticleCurveV29 &operator=(const ModelParticleCurveV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV29 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV29();
    ModelParticleFlipbookV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV29(const ModelParticleFlipbookV29 &p_other);
    ModelParticleFlipbookV29 &operator=(const ModelParticleFlipbookV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV29 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV29> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV29> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV29> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV29();
    ModelParticleEmitterV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV29(const ModelParticleEmitterV29 &p_other);
    ModelParticleEmitterV29 &operator=(const ModelParticleEmitterV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV29 {
    helpers::Array<ModelParticleCloudV29> clouds;
    helpers::Array<ModelParticleEmitterV29> emitters;

public:
    ModelCloudDataV29();
    ModelCloudDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV29(const ModelCloudDataV29 &p_other);
    ModelCloudDataV29 &operator=(const ModelCloudDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV29 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV29();
    ModelObstacleDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV29(const ModelObstacleDataV29 &p_other);
    ModelObstacleDataV29 &operator=(const ModelObstacleDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV29 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV29();
    ModelStreakV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV29(const ModelStreakV29 &p_other);
    ModelStreakV29 &operator=(const ModelStreakV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV29 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV29();
    ModelStreakAnchorV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV29(const ModelStreakAnchorV29 &p_other);
    ModelStreakAnchorV29 &operator=(const ModelStreakAnchorV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV29 {
    helpers::Array<ModelStreakV29> streaks;
    helpers::Array<ModelStreakAnchorV29> anchors;

public:
    ModelStreakDataV29();
    ModelStreakDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV29(const ModelStreakDataV29 &p_other);
    ModelStreakDataV29 &operator=(const ModelStreakDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV29 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV29();
    ModelEffectLightV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV29(const ModelEffectLightV29 &p_other);
    ModelEffectLightV29 &operator=(const ModelEffectLightV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV29 {
    helpers::Array<ModelEffectLightV29> effectLights;

public:
    ModelLightDataV29();
    ModelLightDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV29(const ModelLightDataV29 &p_other);
    ModelLightDataV29 &operator=(const ModelLightDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV29 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV29();
    ModelClothBoneWeightV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV29(const ModelClothBoneWeightV29 &p_other);
    ModelClothBoneWeightV29 &operator=(const ModelClothBoneWeightV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV29 {
    helpers::Array<ModelClothBoneWeightV29> weights;

public:
    ModelClothMeshGroupV29();
    ModelClothMeshGroupV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV29(const ModelClothMeshGroupV29 &p_other);
    ModelClothMeshGroupV29 &operator=(const ModelClothMeshGroupV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV29 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV29();
    ModelClothConstraintV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV29(const ModelClothConstraintV29 &p_other);
    ModelClothConstraintV29 &operator=(const ModelClothConstraintV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothObstacleV29 {
    qword bone;
    byte type;

public:
    ModelClothObstacleV29();
    ModelClothObstacleV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothObstacleV29(const ModelClothObstacleV29 &p_other);
    ModelClothObstacleV29 &operator=(const ModelClothObstacleV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV29 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV29> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV29> lod0Constraints;
    helpers::Array<ModelClothConstraintV29> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;
    helpers::Array<ModelClothObstacleV29> obstacles;

public:
    ModelClothDataV29();
    ModelClothDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV29(const ModelClothDataV29 &p_other);
    ModelClothDataV29 &operator=(const ModelClothDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV29 {
    helpers::Ptr<ModelMaterialDataV29> materials;
    helpers::Ptr<ModelMeshDataV29> meshes;
    helpers::Ptr<ModelModelDataV29> model;
    helpers::Array<ModelPropertyDataV29> properties;
    helpers::Ptr<ModelCloudDataV29> cloudData;
    helpers::Array<ModelObstacleDataV29> obstacles;
    helpers::Ptr<ModelStreakDataV29> streakData;
    helpers::Ptr<ModelLightDataV29> lightData;
    helpers::Array<ModelClothDataV29> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV29();
    ModelFileDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV29(const ModelFileDataV29 &p_other);
    ModelFileDataV29 &operator=(const ModelFileDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV29 Gw2Struct;
};

/* Version: 28, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<28>{
struct ModelTextureDataV28 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV28();
    ModelTextureDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV28(const ModelTextureDataV28 &p_other);
    ModelTextureDataV28 &operator=(const ModelTextureDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV28 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV28();
    ModelConstantDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV28(const ModelConstantDataV28 &p_other);
    ModelConstantDataV28 &operator=(const ModelConstantDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV28 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV28> textures;
    helpers::Array<ModelConstantDataV28> constants;

public:
    ModelMaterialDataV28();
    ModelMaterialDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV28(const ModelMaterialDataV28 &p_other);
    ModelMaterialDataV28 &operator=(const ModelMaterialDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV28 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV28();
    ModelMeshLodDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV28(const ModelMeshLodDataV28 &p_other);
    ModelMeshLodDataV28 &operator=(const ModelMeshLodDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV28 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV28();
    ModelMeshMorphTargetV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV28(const ModelMeshMorphTargetV28 &p_other);
    ModelMeshMorphTargetV28 &operator=(const ModelMeshMorphTargetV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV28 {
    helpers::Array<ModelMeshLodDataV28> lods;
    helpers::Array<ModelMeshMorphTargetV28> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;

public:
    ModelMeshDataV28();
    ModelMeshDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV28(const ModelMeshDataV28 &p_other);
    ModelMeshDataV28 &operator=(const ModelMeshDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV28 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV28();
    ModelTransformDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV28(const ModelTransformDataV28 &p_other);
    ModelTransformDataV28 &operator=(const ModelTransformDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV28 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV28 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV28();
    ModelBoneDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV28(const ModelBoneDataV28 &p_other);
    ModelBoneDataV28 &operator=(const ModelBoneDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV28 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV28> Bones;
    dword LODType;

public:
    ModelSkeletonDataV28();
    ModelSkeletonDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV28(const ModelSkeletonDataV28 &p_other);
    ModelSkeletonDataV28 &operator=(const ModelSkeletonDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV28 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV28();
    ModelMeshBindingDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV28(const ModelMeshBindingDataV28 &p_other);
    ModelMeshBindingDataV28 &operator=(const ModelMeshBindingDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV28 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV28();
    ModelTrackMaskV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV28(const ModelTrackMaskV28 &p_other);
    ModelTrackMaskV28 &operator=(const ModelTrackMaskV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV28 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV28> Skeleton;
    ModelTransformDataV28 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV28> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV28> trackMasks;
    helpers::Array<byte> skeletonHash;
    float3 center;
    float radius;

public:
    ModelModelDataV28();
    ModelModelDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV28(const ModelModelDataV28 &p_other);
    ModelModelDataV28 &operator=(const ModelModelDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV28 {
    qword id;
    dword type;
    dword mergeIndex;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV28();
    ModelPropertyDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV28(const ModelPropertyDataV28 &p_other);
    ModelPropertyDataV28 &operator=(const ModelPropertyDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV28 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV28();
    ModelParticleCloudV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV28(const ModelParticleCloudV28 &p_other);
    ModelParticleCloudV28 &operator=(const ModelParticleCloudV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV28 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV28();
    ModelParticleCurveV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV28(const ModelParticleCurveV28 &p_other);
    ModelParticleCurveV28 &operator=(const ModelParticleCurveV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV28 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV28();
    ModelParticleFlipbookV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV28(const ModelParticleFlipbookV28 &p_other);
    ModelParticleFlipbookV28 &operator=(const ModelParticleFlipbookV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV28 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV28> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV28> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV28> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV28();
    ModelParticleEmitterV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV28(const ModelParticleEmitterV28 &p_other);
    ModelParticleEmitterV28 &operator=(const ModelParticleEmitterV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV28 {
    helpers::Array<ModelParticleCloudV28> clouds;
    helpers::Array<ModelParticleEmitterV28> emitters;

public:
    ModelCloudDataV28();
    ModelCloudDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV28(const ModelCloudDataV28 &p_other);
    ModelCloudDataV28 &operator=(const ModelCloudDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV28 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV28();
    ModelObstacleDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV28(const ModelObstacleDataV28 &p_other);
    ModelObstacleDataV28 &operator=(const ModelObstacleDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV28 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV28();
    ModelStreakV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV28(const ModelStreakV28 &p_other);
    ModelStreakV28 &operator=(const ModelStreakV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV28 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV28();
    ModelStreakAnchorV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV28(const ModelStreakAnchorV28 &p_other);
    ModelStreakAnchorV28 &operator=(const ModelStreakAnchorV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV28 {
    helpers::Array<ModelStreakV28> streaks;
    helpers::Array<ModelStreakAnchorV28> anchors;

public:
    ModelStreakDataV28();
    ModelStreakDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV28(const ModelStreakDataV28 &p_other);
    ModelStreakDataV28 &operator=(const ModelStreakDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV28 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV28();
    ModelEffectLightV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV28(const ModelEffectLightV28 &p_other);
    ModelEffectLightV28 &operator=(const ModelEffectLightV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV28 {
    helpers::Array<ModelEffectLightV28> effectLights;

public:
    ModelLightDataV28();
    ModelLightDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV28(const ModelLightDataV28 &p_other);
    ModelLightDataV28 &operator=(const ModelLightDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV28 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV28();
    ModelClothBoneWeightV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV28(const ModelClothBoneWeightV28 &p_other);
    ModelClothBoneWeightV28 &operator=(const ModelClothBoneWeightV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV28 {
    helpers::Array<ModelClothBoneWeightV28> weights;

public:
    ModelClothMeshGroupV28();
    ModelClothMeshGroupV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV28(const ModelClothMeshGroupV28 &p_other);
    ModelClothMeshGroupV28 &operator=(const ModelClothMeshGroupV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV28 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV28();
    ModelClothConstraintV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV28(const ModelClothConstraintV28 &p_other);
    ModelClothConstraintV28 &operator=(const ModelClothConstraintV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV28 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV28> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV28> lod0Constraints;
    helpers::Array<ModelClothConstraintV28> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV28();
    ModelClothDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV28(const ModelClothDataV28 &p_other);
    ModelClothDataV28 &operator=(const ModelClothDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV28 {
    helpers::Ptr<ModelMaterialDataV28> materials;
    helpers::Ptr<ModelMeshDataV28> meshes;
    helpers::Ptr<ModelModelDataV28> model;
    helpers::Array<ModelPropertyDataV28> properties;
    helpers::Ptr<ModelCloudDataV28> cloudData;
    helpers::Array<ModelObstacleDataV28> obstacles;
    helpers::Ptr<ModelStreakDataV28> streakData;
    helpers::Ptr<ModelLightDataV28> lightData;
    helpers::Array<ModelClothDataV28> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV28();
    ModelFileDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV28(const ModelFileDataV28 &p_other);
    ModelFileDataV28 &operator=(const ModelFileDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV28 Gw2Struct;
};

/* Version: 27, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<27>{
struct ModelTextureDataV27 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV27();
    ModelTextureDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV27(const ModelTextureDataV27 &p_other);
    ModelTextureDataV27 &operator=(const ModelTextureDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV27 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV27();
    ModelConstantDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV27(const ModelConstantDataV27 &p_other);
    ModelConstantDataV27 &operator=(const ModelConstantDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV27 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV27> textures;
    helpers::Array<ModelConstantDataV27> constants;

public:
    ModelMaterialDataV27();
    ModelMaterialDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV27(const ModelMaterialDataV27 &p_other);
    ModelMaterialDataV27 &operator=(const ModelMaterialDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV27 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV27();
    ModelMeshLodDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV27(const ModelMeshLodDataV27 &p_other);
    ModelMeshLodDataV27 &operator=(const ModelMeshLodDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV27 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV27();
    ModelMeshMorphTargetV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV27(const ModelMeshMorphTargetV27 &p_other);
    ModelMeshMorphTargetV27 &operator=(const ModelMeshMorphTargetV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV27 {
    helpers::Array<ModelMeshLodDataV27> lods;
    helpers::Array<ModelMeshMorphTargetV27> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    qword meshName;

public:
    ModelMeshDataV27();
    ModelMeshDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV27(const ModelMeshDataV27 &p_other);
    ModelMeshDataV27 &operator=(const ModelMeshDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV27 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV27();
    ModelTransformDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV27(const ModelTransformDataV27 &p_other);
    ModelTransformDataV27 &operator=(const ModelTransformDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV27 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV27 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV27();
    ModelBoneDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV27(const ModelBoneDataV27 &p_other);
    ModelBoneDataV27 &operator=(const ModelBoneDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV27 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV27> Bones;
    dword LODType;

public:
    ModelSkeletonDataV27();
    ModelSkeletonDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV27(const ModelSkeletonDataV27 &p_other);
    ModelSkeletonDataV27 &operator=(const ModelSkeletonDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV27 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV27();
    ModelMeshBindingDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV27(const ModelMeshBindingDataV27 &p_other);
    ModelMeshBindingDataV27 &operator=(const ModelMeshBindingDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV27 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV27();
    ModelTrackMaskV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV27(const ModelTrackMaskV27 &p_other);
    ModelTrackMaskV27 &operator=(const ModelTrackMaskV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV27 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV27> Skeleton;
    ModelTransformDataV27 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV27> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV27> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV27();
    ModelModelDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV27(const ModelModelDataV27 &p_other);
    ModelModelDataV27 &operator=(const ModelModelDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV27 {
    qword id;
    dword type;
    dword mergeIndex;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV27();
    ModelPropertyDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV27(const ModelPropertyDataV27 &p_other);
    ModelPropertyDataV27 &operator=(const ModelPropertyDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV27 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV27();
    ModelParticleCloudV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV27(const ModelParticleCloudV27 &p_other);
    ModelParticleCloudV27 &operator=(const ModelParticleCloudV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV27 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV27();
    ModelParticleCurveV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV27(const ModelParticleCurveV27 &p_other);
    ModelParticleCurveV27 &operator=(const ModelParticleCurveV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV27 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV27();
    ModelParticleFlipbookV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV27(const ModelParticleFlipbookV27 &p_other);
    ModelParticleFlipbookV27 &operator=(const ModelParticleFlipbookV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV27 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV27> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV27> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV27> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV27();
    ModelParticleEmitterV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV27(const ModelParticleEmitterV27 &p_other);
    ModelParticleEmitterV27 &operator=(const ModelParticleEmitterV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV27 {
    helpers::Array<ModelParticleCloudV27> clouds;
    helpers::Array<ModelParticleEmitterV27> emitters;

public:
    ModelCloudDataV27();
    ModelCloudDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV27(const ModelCloudDataV27 &p_other);
    ModelCloudDataV27 &operator=(const ModelCloudDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV27 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV27();
    ModelObstacleDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV27(const ModelObstacleDataV27 &p_other);
    ModelObstacleDataV27 &operator=(const ModelObstacleDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV27 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV27();
    ModelStreakV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV27(const ModelStreakV27 &p_other);
    ModelStreakV27 &operator=(const ModelStreakV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV27 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV27();
    ModelStreakAnchorV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV27(const ModelStreakAnchorV27 &p_other);
    ModelStreakAnchorV27 &operator=(const ModelStreakAnchorV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV27 {
    helpers::Array<ModelStreakV27> streaks;
    helpers::Array<ModelStreakAnchorV27> anchors;

public:
    ModelStreakDataV27();
    ModelStreakDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV27(const ModelStreakDataV27 &p_other);
    ModelStreakDataV27 &operator=(const ModelStreakDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV27 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV27();
    ModelEffectLightV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV27(const ModelEffectLightV27 &p_other);
    ModelEffectLightV27 &operator=(const ModelEffectLightV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV27 {
    helpers::Array<ModelEffectLightV27> effectLights;

public:
    ModelLightDataV27();
    ModelLightDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV27(const ModelLightDataV27 &p_other);
    ModelLightDataV27 &operator=(const ModelLightDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV27 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV27();
    ModelClothBoneWeightV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV27(const ModelClothBoneWeightV27 &p_other);
    ModelClothBoneWeightV27 &operator=(const ModelClothBoneWeightV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV27 {
    helpers::Array<ModelClothBoneWeightV27> weights;

public:
    ModelClothMeshGroupV27();
    ModelClothMeshGroupV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV27(const ModelClothMeshGroupV27 &p_other);
    ModelClothMeshGroupV27 &operator=(const ModelClothMeshGroupV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV27 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV27();
    ModelClothConstraintV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV27(const ModelClothConstraintV27 &p_other);
    ModelClothConstraintV27 &operator=(const ModelClothConstraintV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV27 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV27> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV27> lod0Constraints;
    helpers::Array<ModelClothConstraintV27> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV27();
    ModelClothDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV27(const ModelClothDataV27 &p_other);
    ModelClothDataV27 &operator=(const ModelClothDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV27 {
    helpers::Ptr<ModelMaterialDataV27> materials;
    helpers::Ptr<ModelMeshDataV27> meshes;
    helpers::Ptr<ModelModelDataV27> model;
    helpers::Array<ModelPropertyDataV27> properties;
    helpers::Ptr<ModelCloudDataV27> cloudData;
    helpers::Array<ModelObstacleDataV27> obstacles;
    helpers::Ptr<ModelStreakDataV27> streakData;
    helpers::Ptr<ModelLightDataV27> lightData;
    helpers::Array<ModelClothDataV27> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV27();
    ModelFileDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV27(const ModelFileDataV27 &p_other);
    ModelFileDataV27 &operator=(const ModelFileDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV27 Gw2Struct;
};

/* Version: 26, ReferencedFunction: 0x410D938000000001 */

template <>
struct Gw2StructMODL<26>{
struct ModelTextureDataV26 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV26();
    ModelTextureDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV26(const ModelTextureDataV26 &p_other);
    ModelTextureDataV26 &operator=(const ModelTextureDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV26 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV26();
    ModelConstantDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV26(const ModelConstantDataV26 &p_other);
    ModelConstantDataV26 &operator=(const ModelConstantDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV26 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV26> textures;
    helpers::Array<ModelConstantDataV26> constants;

public:
    ModelMaterialDataV26();
    ModelMaterialDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV26(const ModelMaterialDataV26 &p_other);
    ModelMaterialDataV26 &operator=(const ModelMaterialDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV26 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV26();
    ModelMeshLodDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV26(const ModelMeshLodDataV26 &p_other);
    ModelMeshLodDataV26 &operator=(const ModelMeshLodDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV26 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV26();
    ModelMeshMorphTargetV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV26(const ModelMeshMorphTargetV26 &p_other);
    ModelMeshMorphTargetV26 &operator=(const ModelMeshMorphTargetV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV26 {
    helpers::Array<ModelMeshLodDataV26> lods;
    helpers::Array<ModelMeshMorphTargetV26> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV26();
    ModelMeshDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV26(const ModelMeshDataV26 &p_other);
    ModelMeshDataV26 &operator=(const ModelMeshDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV26 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV26();
    ModelTransformDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV26(const ModelTransformDataV26 &p_other);
    ModelTransformDataV26 &operator=(const ModelTransformDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV26 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV26 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV26();
    ModelBoneDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV26(const ModelBoneDataV26 &p_other);
    ModelBoneDataV26 &operator=(const ModelBoneDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV26 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV26> Bones;
    dword LODType;

public:
    ModelSkeletonDataV26();
    ModelSkeletonDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV26(const ModelSkeletonDataV26 &p_other);
    ModelSkeletonDataV26 &operator=(const ModelSkeletonDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV26 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV26();
    ModelMeshBindingDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV26(const ModelMeshBindingDataV26 &p_other);
    ModelMeshBindingDataV26 &operator=(const ModelMeshBindingDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV26 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV26();
    ModelTrackMaskV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV26(const ModelTrackMaskV26 &p_other);
    ModelTrackMaskV26 &operator=(const ModelTrackMaskV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV26 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV26> Skeleton;
    ModelTransformDataV26 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV26> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV26> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV26();
    ModelModelDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV26(const ModelModelDataV26 &p_other);
    ModelModelDataV26 &operator=(const ModelModelDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV26 {
    qword id;
    dword type;
    dword mergeIndex;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyDataV26();
    ModelPropertyDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV26(const ModelPropertyDataV26 &p_other);
    ModelPropertyDataV26 &operator=(const ModelPropertyDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV26 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV26();
    ModelParticleCloudV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV26(const ModelParticleCloudV26 &p_other);
    ModelParticleCloudV26 &operator=(const ModelParticleCloudV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV26 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV26();
    ModelParticleCurveV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV26(const ModelParticleCurveV26 &p_other);
    ModelParticleCurveV26 &operator=(const ModelParticleCurveV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV26 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV26();
    ModelParticleFlipbookV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV26(const ModelParticleFlipbookV26 &p_other);
    ModelParticleFlipbookV26 &operator=(const ModelParticleFlipbookV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV26 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV26> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV26> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV26> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV26();
    ModelParticleEmitterV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV26(const ModelParticleEmitterV26 &p_other);
    ModelParticleEmitterV26 &operator=(const ModelParticleEmitterV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV26 {
    helpers::Array<ModelParticleCloudV26> clouds;
    helpers::Array<ModelParticleEmitterV26> emitters;

public:
    ModelCloudDataV26();
    ModelCloudDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV26(const ModelCloudDataV26 &p_other);
    ModelCloudDataV26 &operator=(const ModelCloudDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV26 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV26();
    ModelObstacleDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV26(const ModelObstacleDataV26 &p_other);
    ModelObstacleDataV26 &operator=(const ModelObstacleDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV26 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV26();
    ModelStreakV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV26(const ModelStreakV26 &p_other);
    ModelStreakV26 &operator=(const ModelStreakV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV26 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV26();
    ModelStreakAnchorV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV26(const ModelStreakAnchorV26 &p_other);
    ModelStreakAnchorV26 &operator=(const ModelStreakAnchorV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV26 {
    helpers::Array<ModelStreakV26> streaks;
    helpers::Array<ModelStreakAnchorV26> anchors;

public:
    ModelStreakDataV26();
    ModelStreakDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV26(const ModelStreakDataV26 &p_other);
    ModelStreakDataV26 &operator=(const ModelStreakDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV26 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV26();
    ModelEffectLightV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV26(const ModelEffectLightV26 &p_other);
    ModelEffectLightV26 &operator=(const ModelEffectLightV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV26 {
    helpers::Array<ModelEffectLightV26> effectLights;

public:
    ModelLightDataV26();
    ModelLightDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV26(const ModelLightDataV26 &p_other);
    ModelLightDataV26 &operator=(const ModelLightDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV26 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV26();
    ModelClothBoneWeightV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV26(const ModelClothBoneWeightV26 &p_other);
    ModelClothBoneWeightV26 &operator=(const ModelClothBoneWeightV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV26 {
    helpers::Array<ModelClothBoneWeightV26> weights;

public:
    ModelClothMeshGroupV26();
    ModelClothMeshGroupV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV26(const ModelClothMeshGroupV26 &p_other);
    ModelClothMeshGroupV26 &operator=(const ModelClothMeshGroupV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV26 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV26();
    ModelClothConstraintV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV26(const ModelClothConstraintV26 &p_other);
    ModelClothConstraintV26 &operator=(const ModelClothConstraintV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV26 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV26> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV26> lod0Constraints;
    helpers::Array<ModelClothConstraintV26> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV26();
    ModelClothDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV26(const ModelClothDataV26 &p_other);
    ModelClothDataV26 &operator=(const ModelClothDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV26 {
    helpers::Ptr<ModelMaterialDataV26> materials;
    helpers::Ptr<ModelMeshDataV26> meshes;
    helpers::Ptr<ModelModelDataV26> model;
    helpers::Array<ModelPropertyDataV26> properties;
    helpers::Ptr<ModelCloudDataV26> cloudData;
    helpers::Array<ModelObstacleDataV26> obstacles;
    helpers::Ptr<ModelStreakDataV26> streakData;
    helpers::Ptr<ModelLightDataV26> lightData;
    helpers::Array<ModelClothDataV26> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV26();
    ModelFileDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV26(const ModelFileDataV26 &p_other);
    ModelFileDataV26 &operator=(const ModelFileDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV26 Gw2Struct;
};

/* Version: 25, ReferencedFunction: 0x410D919000000001 */

template <>
struct Gw2StructMODL<25>{
struct ModelTextureDataV25 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV25();
    ModelTextureDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV25(const ModelTextureDataV25 &p_other);
    ModelTextureDataV25 &operator=(const ModelTextureDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV25 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV25();
    ModelConstantDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV25(const ModelConstantDataV25 &p_other);
    ModelConstantDataV25 &operator=(const ModelConstantDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV25 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV25> textures;
    helpers::Array<ModelConstantDataV25> constants;

public:
    ModelMaterialDataV25();
    ModelMaterialDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV25(const ModelMaterialDataV25 &p_other);
    ModelMaterialDataV25 &operator=(const ModelMaterialDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV25 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV25();
    ModelMeshLodDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV25(const ModelMeshLodDataV25 &p_other);
    ModelMeshLodDataV25 &operator=(const ModelMeshLodDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV25 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV25();
    ModelMeshMorphTargetV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV25(const ModelMeshMorphTargetV25 &p_other);
    ModelMeshMorphTargetV25 &operator=(const ModelMeshMorphTargetV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV25 {
    helpers::Array<ModelMeshLodDataV25> lods;
    helpers::Array<ModelMeshMorphTargetV25> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV25();
    ModelMeshDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV25(const ModelMeshDataV25 &p_other);
    ModelMeshDataV25 &operator=(const ModelMeshDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV25 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV25();
    ModelTransformDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV25(const ModelTransformDataV25 &p_other);
    ModelTransformDataV25 &operator=(const ModelTransformDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV25 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV25 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV25();
    ModelBoneDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV25(const ModelBoneDataV25 &p_other);
    ModelBoneDataV25 &operator=(const ModelBoneDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV25 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV25> Bones;
    dword LODType;

public:
    ModelSkeletonDataV25();
    ModelSkeletonDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV25(const ModelSkeletonDataV25 &p_other);
    ModelSkeletonDataV25 &operator=(const ModelSkeletonDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV25 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV25();
    ModelMeshBindingDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV25(const ModelMeshBindingDataV25 &p_other);
    ModelMeshBindingDataV25 &operator=(const ModelMeshBindingDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV25 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV25();
    ModelTrackMaskV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV25(const ModelTrackMaskV25 &p_other);
    ModelTrackMaskV25 &operator=(const ModelTrackMaskV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV25 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV25> Skeleton;
    ModelTransformDataV25 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV25> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV25> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV25();
    ModelModelDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV25(const ModelModelDataV25 &p_other);
    ModelModelDataV25 &operator=(const ModelModelDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV25 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV25();
    ModelFloatPropertyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV25(const ModelFloatPropertyDataV25 &p_other);
    ModelFloatPropertyDataV25 &operator=(const ModelFloatPropertyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV25 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV25> floatValues;

public:
    ModelPropertyDataV25();
    ModelPropertyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV25(const ModelPropertyDataV25 &p_other);
    ModelPropertyDataV25 &operator=(const ModelPropertyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV25 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV25();
    ModelParticleCloudV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV25(const ModelParticleCloudV25 &p_other);
    ModelParticleCloudV25 &operator=(const ModelParticleCloudV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV25 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV25();
    ModelParticleCurveV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV25(const ModelParticleCurveV25 &p_other);
    ModelParticleCurveV25 &operator=(const ModelParticleCurveV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV25 {
    byte columns;
    byte count;
    float fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV25();
    ModelParticleFlipbookV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV25(const ModelParticleFlipbookV25 &p_other);
    ModelParticleFlipbookV25 &operator=(const ModelParticleFlipbookV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV25 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV25> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV25> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV25> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV25();
    ModelParticleEmitterV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV25(const ModelParticleEmitterV25 &p_other);
    ModelParticleEmitterV25 &operator=(const ModelParticleEmitterV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV25 {
    helpers::Array<ModelParticleCloudV25> clouds;
    helpers::Array<ModelParticleEmitterV25> emitters;

public:
    ModelCloudDataV25();
    ModelCloudDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV25(const ModelCloudDataV25 &p_other);
    ModelCloudDataV25 &operator=(const ModelCloudDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV25 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV25();
    ModelObstacleDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV25(const ModelObstacleDataV25 &p_other);
    ModelObstacleDataV25 &operator=(const ModelObstacleDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV25 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    float jitter;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV25();
    ModelStreakV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV25(const ModelStreakV25 &p_other);
    ModelStreakV25 &operator=(const ModelStreakV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV25 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV25();
    ModelStreakAnchorV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV25(const ModelStreakAnchorV25 &p_other);
    ModelStreakAnchorV25 &operator=(const ModelStreakAnchorV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV25 {
    helpers::Array<ModelStreakV25> streaks;
    helpers::Array<ModelStreakAnchorV25> anchors;

public:
    ModelStreakDataV25();
    ModelStreakDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV25(const ModelStreakDataV25 &p_other);
    ModelStreakDataV25 &operator=(const ModelStreakDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV25 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV25();
    ModelEffectLightV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV25(const ModelEffectLightV25 &p_other);
    ModelEffectLightV25 &operator=(const ModelEffectLightV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV25 {
    helpers::Array<ModelEffectLightV25> effectLights;

public:
    ModelLightDataV25();
    ModelLightDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV25(const ModelLightDataV25 &p_other);
    ModelLightDataV25 &operator=(const ModelLightDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV25 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV25();
    ModelClothBoneWeightV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV25(const ModelClothBoneWeightV25 &p_other);
    ModelClothBoneWeightV25 &operator=(const ModelClothBoneWeightV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV25 {
    helpers::Array<ModelClothBoneWeightV25> weights;

public:
    ModelClothMeshGroupV25();
    ModelClothMeshGroupV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV25(const ModelClothMeshGroupV25 &p_other);
    ModelClothMeshGroupV25 &operator=(const ModelClothMeshGroupV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV25 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV25();
    ModelClothConstraintV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV25(const ModelClothConstraintV25 &p_other);
    ModelClothConstraintV25 &operator=(const ModelClothConstraintV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV25 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV25> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV25> lod0Constraints;
    helpers::Array<ModelClothConstraintV25> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV25();
    ModelClothDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV25(const ModelClothDataV25 &p_other);
    ModelClothDataV25 &operator=(const ModelClothDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV25 {
    helpers::Ptr<ModelMaterialDataV25> materials;
    helpers::Ptr<ModelMeshDataV25> meshes;
    helpers::Ptr<ModelModelDataV25> model;
    helpers::Ptr<ModelPropertyDataV25> properties;
    helpers::Ptr<ModelCloudDataV25> cloudData;
    helpers::Array<ModelObstacleDataV25> obstacles;
    helpers::Ptr<ModelStreakDataV25> streakData;
    helpers::Ptr<ModelLightDataV25> lightData;
    helpers::Array<ModelClothDataV25> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV25();
    ModelFileDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV25(const ModelFileDataV25 &p_other);
    ModelFileDataV25 &operator=(const ModelFileDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV25 Gw2Struct;
};

/* Version: 24, ReferencedFunction: 0x410D913000000001 */

template <>
struct Gw2StructMODL<24>{
struct ModelTextureDataV24 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV24();
    ModelTextureDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV24(const ModelTextureDataV24 &p_other);
    ModelTextureDataV24 &operator=(const ModelTextureDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV24 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV24();
    ModelConstantDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV24(const ModelConstantDataV24 &p_other);
    ModelConstantDataV24 &operator=(const ModelConstantDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV24 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV24> textures;
    helpers::Array<ModelConstantDataV24> constants;

public:
    ModelMaterialDataV24();
    ModelMaterialDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV24(const ModelMaterialDataV24 &p_other);
    ModelMaterialDataV24 &operator=(const ModelMaterialDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV24 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV24();
    ModelMeshLodDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV24(const ModelMeshLodDataV24 &p_other);
    ModelMeshLodDataV24 &operator=(const ModelMeshLodDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV24 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV24();
    ModelMeshMorphTargetV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV24(const ModelMeshMorphTargetV24 &p_other);
    ModelMeshMorphTargetV24 &operator=(const ModelMeshMorphTargetV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV24 {
    helpers::Array<ModelMeshLodDataV24> lods;
    helpers::Array<ModelMeshMorphTargetV24> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV24();
    ModelMeshDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV24(const ModelMeshDataV24 &p_other);
    ModelMeshDataV24 &operator=(const ModelMeshDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV24 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV24();
    ModelTransformDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV24(const ModelTransformDataV24 &p_other);
    ModelTransformDataV24 &operator=(const ModelTransformDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV24 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV24 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV24();
    ModelBoneDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV24(const ModelBoneDataV24 &p_other);
    ModelBoneDataV24 &operator=(const ModelBoneDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV24 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV24> Bones;
    dword LODType;

public:
    ModelSkeletonDataV24();
    ModelSkeletonDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV24(const ModelSkeletonDataV24 &p_other);
    ModelSkeletonDataV24 &operator=(const ModelSkeletonDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV24 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV24();
    ModelMeshBindingDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV24(const ModelMeshBindingDataV24 &p_other);
    ModelMeshBindingDataV24 &operator=(const ModelMeshBindingDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV24 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV24();
    ModelTrackMaskV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV24(const ModelTrackMaskV24 &p_other);
    ModelTrackMaskV24 &operator=(const ModelTrackMaskV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV24 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV24> Skeleton;
    ModelTransformDataV24 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV24> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV24> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV24();
    ModelModelDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV24(const ModelModelDataV24 &p_other);
    ModelModelDataV24 &operator=(const ModelModelDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV24 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV24();
    ModelFloatPropertyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV24(const ModelFloatPropertyDataV24 &p_other);
    ModelFloatPropertyDataV24 &operator=(const ModelFloatPropertyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV24 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV24> floatValues;

public:
    ModelPropertyDataV24();
    ModelPropertyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV24(const ModelPropertyDataV24 &p_other);
    ModelPropertyDataV24 &operator=(const ModelPropertyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV24 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV24();
    ModelParticleCloudV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV24(const ModelParticleCloudV24 &p_other);
    ModelParticleCloudV24 &operator=(const ModelParticleCloudV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV24 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV24();
    ModelParticleCurveV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV24(const ModelParticleCurveV24 &p_other);
    ModelParticleCurveV24 &operator=(const ModelParticleCurveV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV24 {
    byte columns;
    byte count;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV24();
    ModelParticleFlipbookV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV24(const ModelParticleFlipbookV24 &p_other);
    ModelParticleFlipbookV24 &operator=(const ModelParticleFlipbookV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV24 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    dword emitterFlags;
    helpers::Ptr<ModelParticleCurveV24> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV24> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV24> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV24();
    ModelParticleEmitterV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV24(const ModelParticleEmitterV24 &p_other);
    ModelParticleEmitterV24 &operator=(const ModelParticleEmitterV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV24 {
    helpers::Array<ModelParticleCloudV24> clouds;
    helpers::Array<ModelParticleEmitterV24> emitters;

public:
    ModelCloudDataV24();
    ModelCloudDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV24(const ModelCloudDataV24 &p_other);
    ModelCloudDataV24 &operator=(const ModelCloudDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV24 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV24();
    ModelObstacleDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV24(const ModelObstacleDataV24 &p_other);
    ModelObstacleDataV24 &operator=(const ModelObstacleDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV24 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV24();
    ModelStreakV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV24(const ModelStreakV24 &p_other);
    ModelStreakV24 &operator=(const ModelStreakV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV24 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV24();
    ModelStreakAnchorV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV24(const ModelStreakAnchorV24 &p_other);
    ModelStreakAnchorV24 &operator=(const ModelStreakAnchorV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV24 {
    helpers::Array<ModelStreakV24> streaks;
    helpers::Array<ModelStreakAnchorV24> anchors;

public:
    ModelStreakDataV24();
    ModelStreakDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV24(const ModelStreakDataV24 &p_other);
    ModelStreakDataV24 &operator=(const ModelStreakDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV24 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV24();
    ModelEffectLightV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV24(const ModelEffectLightV24 &p_other);
    ModelEffectLightV24 &operator=(const ModelEffectLightV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV24 {
    helpers::Array<ModelEffectLightV24> effectLights;

public:
    ModelLightDataV24();
    ModelLightDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV24(const ModelLightDataV24 &p_other);
    ModelLightDataV24 &operator=(const ModelLightDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV24 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV24();
    ModelClothBoneWeightV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV24(const ModelClothBoneWeightV24 &p_other);
    ModelClothBoneWeightV24 &operator=(const ModelClothBoneWeightV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV24 {
    helpers::Array<ModelClothBoneWeightV24> weights;

public:
    ModelClothMeshGroupV24();
    ModelClothMeshGroupV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV24(const ModelClothMeshGroupV24 &p_other);
    ModelClothMeshGroupV24 &operator=(const ModelClothMeshGroupV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV24 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV24();
    ModelClothConstraintV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV24(const ModelClothConstraintV24 &p_other);
    ModelClothConstraintV24 &operator=(const ModelClothConstraintV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV24 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV24> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV24> lod0Constraints;
    helpers::Array<ModelClothConstraintV24> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV24();
    ModelClothDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV24(const ModelClothDataV24 &p_other);
    ModelClothDataV24 &operator=(const ModelClothDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV24 {
    helpers::Ptr<ModelMaterialDataV24> materials;
    helpers::Ptr<ModelMeshDataV24> meshes;
    helpers::Ptr<ModelModelDataV24> model;
    helpers::Ptr<ModelPropertyDataV24> properties;
    helpers::Ptr<ModelCloudDataV24> cloudData;
    helpers::Array<ModelObstacleDataV24> obstacles;
    helpers::Ptr<ModelStreakDataV24> streakData;
    helpers::Ptr<ModelLightDataV24> lightData;
    helpers::Array<ModelClothDataV24> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV24();
    ModelFileDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV24(const ModelFileDataV24 &p_other);
    ModelFileDataV24 &operator=(const ModelFileDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV24 Gw2Struct;
};

/* Version: 23, ReferencedFunction: 0x410D90B000000001 */

template <>
struct Gw2StructMODL<23>{
struct ModelTextureDataV23 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV23();
    ModelTextureDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV23(const ModelTextureDataV23 &p_other);
    ModelTextureDataV23 &operator=(const ModelTextureDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV23 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV23();
    ModelConstantDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV23(const ModelConstantDataV23 &p_other);
    ModelConstantDataV23 &operator=(const ModelConstantDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV23 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV23> textures;
    helpers::Array<ModelConstantDataV23> constants;

public:
    ModelMaterialDataV23();
    ModelMaterialDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV23(const ModelMaterialDataV23 &p_other);
    ModelMaterialDataV23 &operator=(const ModelMaterialDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV23 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV23();
    ModelMeshLodDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV23(const ModelMeshLodDataV23 &p_other);
    ModelMeshLodDataV23 &operator=(const ModelMeshLodDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV23 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV23();
    ModelMeshMorphTargetV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV23(const ModelMeshMorphTargetV23 &p_other);
    ModelMeshMorphTargetV23 &operator=(const ModelMeshMorphTargetV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV23 {
    helpers::Array<ModelMeshLodDataV23> lods;
    helpers::Array<ModelMeshMorphTargetV23> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV23();
    ModelMeshDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV23(const ModelMeshDataV23 &p_other);
    ModelMeshDataV23 &operator=(const ModelMeshDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV23 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV23();
    ModelTransformDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV23(const ModelTransformDataV23 &p_other);
    ModelTransformDataV23 &operator=(const ModelTransformDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV23 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV23 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV23();
    ModelBoneDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV23(const ModelBoneDataV23 &p_other);
    ModelBoneDataV23 &operator=(const ModelBoneDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV23 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV23> Bones;
    dword LODType;

public:
    ModelSkeletonDataV23();
    ModelSkeletonDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV23(const ModelSkeletonDataV23 &p_other);
    ModelSkeletonDataV23 &operator=(const ModelSkeletonDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV23 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV23();
    ModelMeshBindingDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV23(const ModelMeshBindingDataV23 &p_other);
    ModelMeshBindingDataV23 &operator=(const ModelMeshBindingDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV23 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV23();
    ModelTrackMaskV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV23(const ModelTrackMaskV23 &p_other);
    ModelTrackMaskV23 &operator=(const ModelTrackMaskV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV23 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV23> Skeleton;
    ModelTransformDataV23 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV23> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV23> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV23();
    ModelModelDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV23(const ModelModelDataV23 &p_other);
    ModelModelDataV23 &operator=(const ModelModelDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV23 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV23();
    ModelFloatPropertyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV23(const ModelFloatPropertyDataV23 &p_other);
    ModelFloatPropertyDataV23 &operator=(const ModelFloatPropertyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV23 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV23> floatValues;

public:
    ModelPropertyDataV23();
    ModelPropertyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV23(const ModelPropertyDataV23 &p_other);
    ModelPropertyDataV23 &operator=(const ModelPropertyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV23 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV23();
    ModelParticleCloudV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV23(const ModelParticleCloudV23 &p_other);
    ModelParticleCloudV23 &operator=(const ModelParticleCloudV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV23 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV23();
    ModelParticleCurveV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV23(const ModelParticleCurveV23 &p_other);
    ModelParticleCurveV23 &operator=(const ModelParticleCurveV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV23 {
    byte columns;
    byte count;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV23();
    ModelParticleFlipbookV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV23(const ModelParticleFlipbookV23 &p_other);
    ModelParticleFlipbookV23 &operator=(const ModelParticleFlipbookV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV23 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV23> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV23> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV23> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV23();
    ModelParticleEmitterV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV23(const ModelParticleEmitterV23 &p_other);
    ModelParticleEmitterV23 &operator=(const ModelParticleEmitterV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV23 {
    helpers::Array<ModelParticleCloudV23> clouds;
    helpers::Array<ModelParticleEmitterV23> emitters;

public:
    ModelCloudDataV23();
    ModelCloudDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV23(const ModelCloudDataV23 &p_other);
    ModelCloudDataV23 &operator=(const ModelCloudDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelObstacleDataV23 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelObstacleDataV23();
    ModelObstacleDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelObstacleDataV23(const ModelObstacleDataV23 &p_other);
    ModelObstacleDataV23 &operator=(const ModelObstacleDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV23 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV23();
    ModelStreakV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV23(const ModelStreakV23 &p_other);
    ModelStreakV23 &operator=(const ModelStreakV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV23 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV23();
    ModelStreakAnchorV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV23(const ModelStreakAnchorV23 &p_other);
    ModelStreakAnchorV23 &operator=(const ModelStreakAnchorV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV23 {
    helpers::Array<ModelStreakV23> streaks;
    helpers::Array<ModelStreakAnchorV23> anchors;

public:
    ModelStreakDataV23();
    ModelStreakDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV23(const ModelStreakDataV23 &p_other);
    ModelStreakDataV23 &operator=(const ModelStreakDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV23 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV23();
    ModelEffectLightV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV23(const ModelEffectLightV23 &p_other);
    ModelEffectLightV23 &operator=(const ModelEffectLightV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV23 {
    helpers::Array<ModelEffectLightV23> effectLights;

public:
    ModelLightDataV23();
    ModelLightDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV23(const ModelLightDataV23 &p_other);
    ModelLightDataV23 &operator=(const ModelLightDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV23 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV23();
    ModelClothBoneWeightV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV23(const ModelClothBoneWeightV23 &p_other);
    ModelClothBoneWeightV23 &operator=(const ModelClothBoneWeightV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV23 {
    helpers::Array<ModelClothBoneWeightV23> weights;

public:
    ModelClothMeshGroupV23();
    ModelClothMeshGroupV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV23(const ModelClothMeshGroupV23 &p_other);
    ModelClothMeshGroupV23 &operator=(const ModelClothMeshGroupV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV23 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV23();
    ModelClothConstraintV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV23(const ModelClothConstraintV23 &p_other);
    ModelClothConstraintV23 &operator=(const ModelClothConstraintV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV23 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV23> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV23> lod0Constraints;
    helpers::Array<ModelClothConstraintV23> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV23();
    ModelClothDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV23(const ModelClothDataV23 &p_other);
    ModelClothDataV23 &operator=(const ModelClothDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV23 {
    helpers::Ptr<ModelMaterialDataV23> materials;
    helpers::Ptr<ModelMeshDataV23> meshes;
    helpers::Ptr<ModelModelDataV23> model;
    helpers::Ptr<ModelPropertyDataV23> properties;
    helpers::Ptr<ModelCloudDataV23> cloudData;
    helpers::Array<ModelObstacleDataV23> obstacles;
    helpers::Ptr<ModelStreakDataV23> streakData;
    helpers::Ptr<ModelLightDataV23> lightData;
    helpers::Array<ModelClothDataV23> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV23();
    ModelFileDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV23(const ModelFileDataV23 &p_other);
    ModelFileDataV23 &operator=(const ModelFileDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV23 Gw2Struct;
};

/* Version: 22, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<22>{
struct ModelTextureDataV22 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV22();
    ModelTextureDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV22(const ModelTextureDataV22 &p_other);
    ModelTextureDataV22 &operator=(const ModelTextureDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV22 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV22();
    ModelConstantDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV22(const ModelConstantDataV22 &p_other);
    ModelConstantDataV22 &operator=(const ModelConstantDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV22 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV22> textures;
    helpers::Array<ModelConstantDataV22> constants;

public:
    ModelMaterialDataV22();
    ModelMaterialDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV22(const ModelMaterialDataV22 &p_other);
    ModelMaterialDataV22 &operator=(const ModelMaterialDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV22 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV22();
    ModelMeshLodDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV22(const ModelMeshLodDataV22 &p_other);
    ModelMeshLodDataV22 &operator=(const ModelMeshLodDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV22 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV22();
    ModelMeshMorphTargetV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV22(const ModelMeshMorphTargetV22 &p_other);
    ModelMeshMorphTargetV22 &operator=(const ModelMeshMorphTargetV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV22 {
    helpers::Array<ModelMeshLodDataV22> lods;
    helpers::Array<ModelMeshMorphTargetV22> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV22();
    ModelMeshDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV22(const ModelMeshDataV22 &p_other);
    ModelMeshDataV22 &operator=(const ModelMeshDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV22 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV22();
    ModelTransformDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV22(const ModelTransformDataV22 &p_other);
    ModelTransformDataV22 &operator=(const ModelTransformDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV22 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV22 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV22();
    ModelBoneDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV22(const ModelBoneDataV22 &p_other);
    ModelBoneDataV22 &operator=(const ModelBoneDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV22 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV22> Bones;
    dword LODType;

public:
    ModelSkeletonDataV22();
    ModelSkeletonDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV22(const ModelSkeletonDataV22 &p_other);
    ModelSkeletonDataV22 &operator=(const ModelSkeletonDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV22 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV22();
    ModelMeshBindingDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV22(const ModelMeshBindingDataV22 &p_other);
    ModelMeshBindingDataV22 &operator=(const ModelMeshBindingDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV22 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV22();
    ModelTrackMaskV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV22(const ModelTrackMaskV22 &p_other);
    ModelTrackMaskV22 &operator=(const ModelTrackMaskV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV22 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV22> Skeleton;
    ModelTransformDataV22 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV22> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV22> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV22();
    ModelModelDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV22(const ModelModelDataV22 &p_other);
    ModelModelDataV22 &operator=(const ModelModelDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV22 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV22();
    ModelFloatPropertyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV22(const ModelFloatPropertyDataV22 &p_other);
    ModelFloatPropertyDataV22 &operator=(const ModelFloatPropertyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV22 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV22> floatValues;

public:
    ModelPropertyDataV22();
    ModelPropertyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV22(const ModelPropertyDataV22 &p_other);
    ModelPropertyDataV22 &operator=(const ModelPropertyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV22 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV22();
    ModelParticleCloudV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV22(const ModelParticleCloudV22 &p_other);
    ModelParticleCloudV22 &operator=(const ModelParticleCloudV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV22 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV22();
    ModelParticleCurveV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV22(const ModelParticleCurveV22 &p_other);
    ModelParticleCurveV22 &operator=(const ModelParticleCurveV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV22 {
    byte columns;
    byte count;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV22();
    ModelParticleFlipbookV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV22(const ModelParticleFlipbookV22 &p_other);
    ModelParticleFlipbookV22 &operator=(const ModelParticleFlipbookV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV22 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV22> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV22> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV22> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV22();
    ModelParticleEmitterV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV22(const ModelParticleEmitterV22 &p_other);
    ModelParticleEmitterV22 &operator=(const ModelParticleEmitterV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV22 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV22();
    ModelParticleObstacleV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV22(const ModelParticleObstacleV22 &p_other);
    ModelParticleObstacleV22 &operator=(const ModelParticleObstacleV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV22 {
    helpers::Array<ModelParticleCloudV22> clouds;
    helpers::Array<ModelParticleEmitterV22> emitters;
    helpers::Array<ModelParticleObstacleV22> obstacles;

public:
    ModelCloudDataV22();
    ModelCloudDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV22(const ModelCloudDataV22 &p_other);
    ModelCloudDataV22 &operator=(const ModelCloudDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV22 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV22();
    ModelStreakV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV22(const ModelStreakV22 &p_other);
    ModelStreakV22 &operator=(const ModelStreakV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV22 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV22();
    ModelStreakAnchorV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV22(const ModelStreakAnchorV22 &p_other);
    ModelStreakAnchorV22 &operator=(const ModelStreakAnchorV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV22 {
    helpers::Array<ModelStreakV22> streaks;
    helpers::Array<ModelStreakAnchorV22> anchors;

public:
    ModelStreakDataV22();
    ModelStreakDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV22(const ModelStreakDataV22 &p_other);
    ModelStreakDataV22 &operator=(const ModelStreakDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV22 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV22();
    ModelEffectLightV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV22(const ModelEffectLightV22 &p_other);
    ModelEffectLightV22 &operator=(const ModelEffectLightV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV22 {
    helpers::Array<ModelEffectLightV22> effectLights;

public:
    ModelLightDataV22();
    ModelLightDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV22(const ModelLightDataV22 &p_other);
    ModelLightDataV22 &operator=(const ModelLightDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV22 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV22();
    ModelClothBoneWeightV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV22(const ModelClothBoneWeightV22 &p_other);
    ModelClothBoneWeightV22 &operator=(const ModelClothBoneWeightV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV22 {
    helpers::Array<ModelClothBoneWeightV22> weights;

public:
    ModelClothMeshGroupV22();
    ModelClothMeshGroupV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV22(const ModelClothMeshGroupV22 &p_other);
    ModelClothMeshGroupV22 &operator=(const ModelClothMeshGroupV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV22 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV22();
    ModelClothConstraintV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV22(const ModelClothConstraintV22 &p_other);
    ModelClothConstraintV22 &operator=(const ModelClothConstraintV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV22 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV22> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV22> lod0Constraints;
    helpers::Array<ModelClothConstraintV22> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV22();
    ModelClothDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV22(const ModelClothDataV22 &p_other);
    ModelClothDataV22 &operator=(const ModelClothDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV22 {
    helpers::Ptr<ModelMaterialDataV22> materials;
    helpers::Ptr<ModelMeshDataV22> meshes;
    helpers::Ptr<ModelModelDataV22> model;
    helpers::Ptr<ModelPropertyDataV22> properties;
    helpers::Ptr<ModelCloudDataV22> cloudData;
    helpers::Ptr<ModelStreakDataV22> streakData;
    helpers::Ptr<ModelLightDataV22> lightData;
    helpers::Array<ModelClothDataV22> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV22();
    ModelFileDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV22(const ModelFileDataV22 &p_other);
    ModelFileDataV22 &operator=(const ModelFileDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV22 Gw2Struct;
};

/* Version: 21, ReferencedFunction: 0x410D8FE000000001 */

template <>
struct Gw2StructMODL<21>{
struct ModelTextureDataV21 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV21();
    ModelTextureDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV21(const ModelTextureDataV21 &p_other);
    ModelTextureDataV21 &operator=(const ModelTextureDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV21 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV21();
    ModelConstantDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV21(const ModelConstantDataV21 &p_other);
    ModelConstantDataV21 &operator=(const ModelConstantDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV21 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV21> textures;
    helpers::Array<ModelConstantDataV21> constants;

public:
    ModelMaterialDataV21();
    ModelMaterialDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV21(const ModelMaterialDataV21 &p_other);
    ModelMaterialDataV21 &operator=(const ModelMaterialDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV21 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV21();
    ModelMeshLodDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV21(const ModelMeshLodDataV21 &p_other);
    ModelMeshLodDataV21 &operator=(const ModelMeshLodDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV21 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV21();
    ModelMeshMorphTargetV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV21(const ModelMeshMorphTargetV21 &p_other);
    ModelMeshMorphTargetV21 &operator=(const ModelMeshMorphTargetV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV21 {
    helpers::Array<ModelMeshLodDataV21> lods;
    helpers::Array<ModelMeshMorphTargetV21> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV21();
    ModelMeshDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV21(const ModelMeshDataV21 &p_other);
    ModelMeshDataV21 &operator=(const ModelMeshDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV21 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV21();
    ModelTransformDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV21(const ModelTransformDataV21 &p_other);
    ModelTransformDataV21 &operator=(const ModelTransformDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV21 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV21 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV21();
    ModelBoneDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV21(const ModelBoneDataV21 &p_other);
    ModelBoneDataV21 &operator=(const ModelBoneDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV21 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV21> Bones;
    dword LODType;

public:
    ModelSkeletonDataV21();
    ModelSkeletonDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV21(const ModelSkeletonDataV21 &p_other);
    ModelSkeletonDataV21 &operator=(const ModelSkeletonDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV21 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV21();
    ModelMeshBindingDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV21(const ModelMeshBindingDataV21 &p_other);
    ModelMeshBindingDataV21 &operator=(const ModelMeshBindingDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV21 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV21();
    ModelTrackMaskV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV21(const ModelTrackMaskV21 &p_other);
    ModelTrackMaskV21 &operator=(const ModelTrackMaskV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV21 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV21> Skeleton;
    ModelTransformDataV21 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV21> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV21> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV21();
    ModelModelDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV21(const ModelModelDataV21 &p_other);
    ModelModelDataV21 &operator=(const ModelModelDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV21 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV21();
    ModelFloatPropertyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV21(const ModelFloatPropertyDataV21 &p_other);
    ModelFloatPropertyDataV21 &operator=(const ModelFloatPropertyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV21 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV21> floatValues;

public:
    ModelPropertyDataV21();
    ModelPropertyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV21(const ModelPropertyDataV21 &p_other);
    ModelPropertyDataV21 &operator=(const ModelPropertyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV21 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    float3 velocity;

public:
    ModelParticleCloudV21();
    ModelParticleCloudV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV21(const ModelParticleCloudV21 &p_other);
    ModelParticleCloudV21 &operator=(const ModelParticleCloudV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV21 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV21();
    ModelParticleCurveV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV21(const ModelParticleCurveV21 &p_other);
    ModelParticleCurveV21 &operator=(const ModelParticleCurveV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV21 {
    byte columns;
    byte count;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV21();
    ModelParticleFlipbookV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV21(const ModelParticleFlipbookV21 &p_other);
    ModelParticleFlipbookV21 &operator=(const ModelParticleFlipbookV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV21 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    byte alignmentType;
    float3 alignmentDir;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float colorPeriod;
    float2 colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV21> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV21> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV21> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;
    byte windInfluence;

public:
    ModelParticleEmitterV21();
    ModelParticleEmitterV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV21(const ModelParticleEmitterV21 &p_other);
    ModelParticleEmitterV21 &operator=(const ModelParticleEmitterV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV21 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV21();
    ModelParticleObstacleV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV21(const ModelParticleObstacleV21 &p_other);
    ModelParticleObstacleV21 &operator=(const ModelParticleObstacleV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV21 {
    helpers::Array<ModelParticleCloudV21> clouds;
    helpers::Array<ModelParticleEmitterV21> emitters;
    helpers::Array<ModelParticleObstacleV21> obstacles;

public:
    ModelCloudDataV21();
    ModelCloudDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV21(const ModelCloudDataV21 &p_other);
    ModelCloudDataV21 &operator=(const ModelCloudDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV21 {
    float3 acceleration;
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float noise;
    float spawnDist;
    float stretchDist;
    float texScale;
    dword visBoneIndex;
    float wind;

public:
    ModelStreakV21();
    ModelStreakV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV21(const ModelStreakV21 &p_other);
    ModelStreakV21 &operator=(const ModelStreakV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV21 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV21();
    ModelStreakAnchorV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV21(const ModelStreakAnchorV21 &p_other);
    ModelStreakAnchorV21 &operator=(const ModelStreakAnchorV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV21 {
    helpers::Array<ModelStreakV21> streaks;
    helpers::Array<ModelStreakAnchorV21> anchors;

public:
    ModelStreakDataV21();
    ModelStreakDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV21(const ModelStreakDataV21 &p_other);
    ModelStreakDataV21 &operator=(const ModelStreakDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV21 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV21();
    ModelEffectLightV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV21(const ModelEffectLightV21 &p_other);
    ModelEffectLightV21 &operator=(const ModelEffectLightV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV21 {
    helpers::Array<ModelEffectLightV21> effectLights;

public:
    ModelLightDataV21();
    ModelLightDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV21(const ModelLightDataV21 &p_other);
    ModelLightDataV21 &operator=(const ModelLightDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV21 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV21();
    ModelClothBoneWeightV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV21(const ModelClothBoneWeightV21 &p_other);
    ModelClothBoneWeightV21 &operator=(const ModelClothBoneWeightV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV21 {
    helpers::Array<ModelClothBoneWeightV21> weights;

public:
    ModelClothMeshGroupV21();
    ModelClothMeshGroupV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV21(const ModelClothMeshGroupV21 &p_other);
    ModelClothMeshGroupV21 &operator=(const ModelClothMeshGroupV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV21 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV21();
    ModelClothConstraintV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV21(const ModelClothConstraintV21 &p_other);
    ModelClothConstraintV21 &operator=(const ModelClothConstraintV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV21 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV21> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV21> lod0Constraints;
    helpers::Array<ModelClothConstraintV21> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV21();
    ModelClothDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV21(const ModelClothDataV21 &p_other);
    ModelClothDataV21 &operator=(const ModelClothDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV21 {
    helpers::Ptr<ModelMaterialDataV21> materials;
    helpers::Ptr<ModelMeshDataV21> meshes;
    helpers::Ptr<ModelModelDataV21> model;
    helpers::Ptr<ModelPropertyDataV21> properties;
    helpers::Ptr<ModelCloudDataV21> cloudData;
    helpers::Ptr<ModelStreakDataV21> streakData;
    helpers::Ptr<ModelLightDataV21> lightData;
    helpers::Array<ModelClothDataV21> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV21();
    ModelFileDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV21(const ModelFileDataV21 &p_other);
    ModelFileDataV21 &operator=(const ModelFileDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV21 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x410D8DC000000001 */

template <>
struct Gw2StructMODL<20>{
struct ModelTextureDataV20 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV20();
    ModelTextureDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV20(const ModelTextureDataV20 &p_other);
    ModelTextureDataV20 &operator=(const ModelTextureDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV20 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV20();
    ModelConstantDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV20(const ModelConstantDataV20 &p_other);
    ModelConstantDataV20 &operator=(const ModelConstantDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV20 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV20> textures;
    helpers::Array<ModelConstantDataV20> constants;

public:
    ModelMaterialDataV20();
    ModelMaterialDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV20(const ModelMaterialDataV20 &p_other);
    ModelMaterialDataV20 &operator=(const ModelMaterialDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV20 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV20();
    ModelMeshLodDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV20(const ModelMeshLodDataV20 &p_other);
    ModelMeshLodDataV20 &operator=(const ModelMeshLodDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV20 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV20();
    ModelMeshMorphTargetV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV20(const ModelMeshMorphTargetV20 &p_other);
    ModelMeshMorphTargetV20 &operator=(const ModelMeshMorphTargetV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV20 {
    helpers::Array<ModelMeshLodDataV20> lods;
    helpers::Array<ModelMeshMorphTargetV20> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV20();
    ModelMeshDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV20(const ModelMeshDataV20 &p_other);
    ModelMeshDataV20 &operator=(const ModelMeshDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV20 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV20();
    ModelTransformDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV20(const ModelTransformDataV20 &p_other);
    ModelTransformDataV20 &operator=(const ModelTransformDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV20 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV20 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV20();
    ModelBoneDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV20(const ModelBoneDataV20 &p_other);
    ModelBoneDataV20 &operator=(const ModelBoneDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV20 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV20> Bones;
    dword LODType;

public:
    ModelSkeletonDataV20();
    ModelSkeletonDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV20(const ModelSkeletonDataV20 &p_other);
    ModelSkeletonDataV20 &operator=(const ModelSkeletonDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV20 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV20();
    ModelMeshBindingDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV20(const ModelMeshBindingDataV20 &p_other);
    ModelMeshBindingDataV20 &operator=(const ModelMeshBindingDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV20 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV20();
    ModelTrackMaskV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV20(const ModelTrackMaskV20 &p_other);
    ModelTrackMaskV20 &operator=(const ModelTrackMaskV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV20 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV20> Skeleton;
    ModelTransformDataV20 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV20> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<ModelTrackMaskV20> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV20();
    ModelModelDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV20(const ModelModelDataV20 &p_other);
    ModelModelDataV20 &operator=(const ModelModelDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV20 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV20();
    ModelFloatPropertyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV20(const ModelFloatPropertyDataV20 &p_other);
    ModelFloatPropertyDataV20 &operator=(const ModelFloatPropertyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV20 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV20> floatValues;

public:
    ModelPropertyDataV20();
    ModelPropertyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV20(const ModelPropertyDataV20 &p_other);
    ModelPropertyDataV20 &operator=(const ModelPropertyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV20 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV20();
    ModelParticleCloudV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV20(const ModelParticleCloudV20 &p_other);
    ModelParticleCloudV20 &operator=(const ModelParticleCloudV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV20 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV20();
    ModelParticleCurveV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV20(const ModelParticleCurveV20 &p_other);
    ModelParticleCurveV20 &operator=(const ModelParticleCurveV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV20 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV20();
    ModelParticleFlipbookV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV20(const ModelParticleFlipbookV20 &p_other);
    ModelParticleFlipbookV20 &operator=(const ModelParticleFlipbookV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV20 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV20> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV20> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV20> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV20();
    ModelParticleEmitterV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV20(const ModelParticleEmitterV20 &p_other);
    ModelParticleEmitterV20 &operator=(const ModelParticleEmitterV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV20 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV20();
    ModelParticleObstacleV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV20(const ModelParticleObstacleV20 &p_other);
    ModelParticleObstacleV20 &operator=(const ModelParticleObstacleV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV20 {
    helpers::Array<ModelParticleCloudV20> clouds;
    helpers::Array<ModelParticleEmitterV20> emitters;
    helpers::Array<ModelParticleObstacleV20> obstacles;

public:
    ModelCloudDataV20();
    ModelCloudDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV20(const ModelCloudDataV20 &p_other);
    ModelCloudDataV20 &operator=(const ModelCloudDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV20 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV20();
    ModelStreakV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV20(const ModelStreakV20 &p_other);
    ModelStreakV20 &operator=(const ModelStreakV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV20 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV20();
    ModelStreakAnchorV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV20(const ModelStreakAnchorV20 &p_other);
    ModelStreakAnchorV20 &operator=(const ModelStreakAnchorV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV20 {
    helpers::Array<ModelStreakV20> streaks;
    helpers::Array<ModelStreakAnchorV20> anchors;

public:
    ModelStreakDataV20();
    ModelStreakDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV20(const ModelStreakDataV20 &p_other);
    ModelStreakDataV20 &operator=(const ModelStreakDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV20 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV20();
    ModelEffectLightV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV20(const ModelEffectLightV20 &p_other);
    ModelEffectLightV20 &operator=(const ModelEffectLightV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV20 {
    helpers::Array<ModelEffectLightV20> effectLights;

public:
    ModelLightDataV20();
    ModelLightDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV20(const ModelLightDataV20 &p_other);
    ModelLightDataV20 &operator=(const ModelLightDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV20 {
    qword token;
    byte weight;

public:
    ModelClothBoneWeightV20();
    ModelClothBoneWeightV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV20(const ModelClothBoneWeightV20 &p_other);
    ModelClothBoneWeightV20 &operator=(const ModelClothBoneWeightV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV20 {
    helpers::Array<ModelClothBoneWeightV20> weights;

public:
    ModelClothMeshGroupV20();
    ModelClothMeshGroupV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV20(const ModelClothMeshGroupV20 &p_other);
    ModelClothMeshGroupV20 &operator=(const ModelClothMeshGroupV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV20 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV20();
    ModelClothConstraintV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV20(const ModelClothConstraintV20 &p_other);
    ModelClothConstraintV20 &operator=(const ModelClothConstraintV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV20 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV20> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV20> lod0Constraints;
    helpers::Array<ModelClothConstraintV20> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV20();
    ModelClothDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV20(const ModelClothDataV20 &p_other);
    ModelClothDataV20 &operator=(const ModelClothDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV20 {
    helpers::Ptr<ModelMaterialDataV20> materials;
    helpers::Ptr<ModelMeshDataV20> meshes;
    helpers::Ptr<ModelModelDataV20> model;
    helpers::Ptr<ModelPropertyDataV20> properties;
    helpers::Ptr<ModelCloudDataV20> cloudData;
    helpers::Ptr<ModelStreakDataV20> streakData;
    helpers::Ptr<ModelLightDataV20> lightData;
    helpers::Array<ModelClothDataV20> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV20();
    ModelFileDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV20(const ModelFileDataV20 &p_other);
    ModelFileDataV20 &operator=(const ModelFileDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV20 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<19>{
struct ModelTextureDataV19 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV19();
    ModelTextureDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV19(const ModelTextureDataV19 &p_other);
    ModelTextureDataV19 &operator=(const ModelTextureDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV19 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV19();
    ModelConstantDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV19(const ModelConstantDataV19 &p_other);
    ModelConstantDataV19 &operator=(const ModelConstantDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV19 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV19> textures;
    helpers::Array<ModelConstantDataV19> constants;

public:
    ModelMaterialDataV19();
    ModelMaterialDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV19(const ModelMaterialDataV19 &p_other);
    ModelMaterialDataV19 &operator=(const ModelMaterialDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV19 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV19();
    ModelMeshLodDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV19(const ModelMeshLodDataV19 &p_other);
    ModelMeshLodDataV19 &operator=(const ModelMeshLodDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV19 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV19();
    ModelMeshMorphTargetV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV19(const ModelMeshMorphTargetV19 &p_other);
    ModelMeshMorphTargetV19 &operator=(const ModelMeshMorphTargetV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV19 {
    helpers::Array<ModelMeshLodDataV19> lods;
    helpers::Array<ModelMeshMorphTargetV19> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV19();
    ModelMeshDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV19(const ModelMeshDataV19 &p_other);
    ModelMeshDataV19 &operator=(const ModelMeshDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV19 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV19();
    ModelTransformDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV19(const ModelTransformDataV19 &p_other);
    ModelTransformDataV19 &operator=(const ModelTransformDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV19 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV19 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV19();
    ModelBoneDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV19(const ModelBoneDataV19 &p_other);
    ModelBoneDataV19 &operator=(const ModelBoneDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV19 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV19> Bones;
    dword LODType;

public:
    ModelSkeletonDataV19();
    ModelSkeletonDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV19(const ModelSkeletonDataV19 &p_other);
    ModelSkeletonDataV19 &operator=(const ModelSkeletonDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV19 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV19();
    ModelMeshBindingDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV19(const ModelMeshBindingDataV19 &p_other);
    ModelMeshBindingDataV19 &operator=(const ModelMeshBindingDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV19 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV19();
    ModelTrackMaskV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV19(const ModelTrackMaskV19 &p_other);
    ModelTrackMaskV19 &operator=(const ModelTrackMaskV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV19 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV19> Skeleton;
    ModelTransformDataV19 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV19> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<ModelTrackMaskV19> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV19();
    ModelModelDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV19(const ModelModelDataV19 &p_other);
    ModelModelDataV19 &operator=(const ModelModelDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV19 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV19();
    ModelFloatPropertyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV19(const ModelFloatPropertyDataV19 &p_other);
    ModelFloatPropertyDataV19 &operator=(const ModelFloatPropertyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV19 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV19> floatValues;

public:
    ModelPropertyDataV19();
    ModelPropertyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV19(const ModelPropertyDataV19 &p_other);
    ModelPropertyDataV19 &operator=(const ModelPropertyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV19 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV19();
    ModelParticleCloudV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV19(const ModelParticleCloudV19 &p_other);
    ModelParticleCloudV19 &operator=(const ModelParticleCloudV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV19 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV19();
    ModelParticleCurveV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV19(const ModelParticleCurveV19 &p_other);
    ModelParticleCurveV19 &operator=(const ModelParticleCurveV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV19 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV19();
    ModelParticleFlipbookV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV19(const ModelParticleFlipbookV19 &p_other);
    ModelParticleFlipbookV19 &operator=(const ModelParticleFlipbookV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV19 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV19> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV19> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV19> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV19();
    ModelParticleEmitterV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV19(const ModelParticleEmitterV19 &p_other);
    ModelParticleEmitterV19 &operator=(const ModelParticleEmitterV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV19 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV19();
    ModelParticleObstacleV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV19(const ModelParticleObstacleV19 &p_other);
    ModelParticleObstacleV19 &operator=(const ModelParticleObstacleV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV19 {
    helpers::Array<ModelParticleCloudV19> clouds;
    helpers::Array<ModelParticleEmitterV19> emitters;
    helpers::Array<ModelParticleObstacleV19> obstacles;

public:
    ModelCloudDataV19();
    ModelCloudDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV19(const ModelCloudDataV19 &p_other);
    ModelCloudDataV19 &operator=(const ModelCloudDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV19 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV19();
    ModelStreakV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV19(const ModelStreakV19 &p_other);
    ModelStreakV19 &operator=(const ModelStreakV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV19 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV19();
    ModelStreakAnchorV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV19(const ModelStreakAnchorV19 &p_other);
    ModelStreakAnchorV19 &operator=(const ModelStreakAnchorV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV19 {
    helpers::Array<ModelStreakV19> streaks;
    helpers::Array<ModelStreakAnchorV19> anchors;

public:
    ModelStreakDataV19();
    ModelStreakDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV19(const ModelStreakDataV19 &p_other);
    ModelStreakDataV19 &operator=(const ModelStreakDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV19 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV19();
    ModelEffectLightV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV19(const ModelEffectLightV19 &p_other);
    ModelEffectLightV19 &operator=(const ModelEffectLightV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV19 {
    helpers::Array<ModelEffectLightV19> effectLights;

public:
    ModelLightDataV19();
    ModelLightDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV19(const ModelLightDataV19 &p_other);
    ModelLightDataV19 &operator=(const ModelLightDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothBoneWeightV19 {
    word index;
    byte weight;

public:
    ModelClothBoneWeightV19();
    ModelClothBoneWeightV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothBoneWeightV19(const ModelClothBoneWeightV19 &p_other);
    ModelClothBoneWeightV19 &operator=(const ModelClothBoneWeightV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothMeshGroupV19 {
    helpers::Array<ModelClothBoneWeightV19> weights;

public:
    ModelClothMeshGroupV19();
    ModelClothMeshGroupV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothMeshGroupV19(const ModelClothMeshGroupV19 &p_other);
    ModelClothMeshGroupV19 &operator=(const ModelClothMeshGroupV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothConstraintV19 {
    word vertIndexA;
    word vertIndexB;
    float distance;

public:
    ModelClothConstraintV19();
    ModelClothConstraintV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothConstraintV19(const ModelClothConstraintV19 &p_other);
    ModelClothConstraintV19 &operator=(const ModelClothConstraintV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelClothDataV19 {
    dword materialIndex;
    byte flags;
    float gravity;
    float weight;
    float wind;
    byte rigidness;
    PackVertexType mesh;
    helpers::Array<word> indices;
    word lockCount;
    helpers::Array<ModelClothMeshGroupV19> groups;
    helpers::Array<byte> softLocks;
    helpers::Array<ModelClothConstraintV19> lod0Constraints;
    helpers::Array<ModelClothConstraintV19> lod1Constraints;
    word lod1VertexCount;
    helpers::Array<word> lod1Indices;
    helpers::Array<float3> barycentricCoords;
    helpers::Array<word> barycentricIndices;

public:
    ModelClothDataV19();
    ModelClothDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelClothDataV19(const ModelClothDataV19 &p_other);
    ModelClothDataV19 &operator=(const ModelClothDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV19 {
    helpers::Ptr<ModelMaterialDataV19> materials;
    helpers::Ptr<ModelMeshDataV19> meshes;
    helpers::Ptr<ModelModelDataV19> model;
    helpers::Ptr<ModelPropertyDataV19> properties;
    helpers::Ptr<ModelCloudDataV19> cloudData;
    helpers::Ptr<ModelStreakDataV19> streakData;
    helpers::Ptr<ModelLightDataV19> lightData;
    helpers::Array<ModelClothDataV19> clothData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV19();
    ModelFileDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV19(const ModelFileDataV19 &p_other);
    ModelFileDataV19 &operator=(const ModelFileDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV19 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<18>{
struct ModelTextureDataV18 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV18();
    ModelTextureDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV18(const ModelTextureDataV18 &p_other);
    ModelTextureDataV18 &operator=(const ModelTextureDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV18 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV18();
    ModelConstantDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV18(const ModelConstantDataV18 &p_other);
    ModelConstantDataV18 &operator=(const ModelConstantDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV18 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV18> textures;
    helpers::Array<ModelConstantDataV18> constants;

public:
    ModelMaterialDataV18();
    ModelMaterialDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV18(const ModelMaterialDataV18 &p_other);
    ModelMaterialDataV18 &operator=(const ModelMaterialDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV18 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV18();
    ModelMeshLodDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV18(const ModelMeshLodDataV18 &p_other);
    ModelMeshLodDataV18 &operator=(const ModelMeshLodDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV18 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;
    helpers::String meshName;

public:
    ModelMeshMorphTargetV18();
    ModelMeshMorphTargetV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV18(const ModelMeshMorphTargetV18 &p_other);
    ModelMeshMorphTargetV18 &operator=(const ModelMeshMorphTargetV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV18 {
    helpers::Array<ModelMeshLodDataV18> lods;
    helpers::Array<ModelMeshMorphTargetV18> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV18();
    ModelMeshDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV18(const ModelMeshDataV18 &p_other);
    ModelMeshDataV18 &operator=(const ModelMeshDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV18 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV18();
    ModelTransformDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV18(const ModelTransformDataV18 &p_other);
    ModelTransformDataV18 &operator=(const ModelTransformDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV18 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV18 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV18();
    ModelBoneDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV18(const ModelBoneDataV18 &p_other);
    ModelBoneDataV18 &operator=(const ModelBoneDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV18 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV18> Bones;
    dword LODType;

public:
    ModelSkeletonDataV18();
    ModelSkeletonDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV18(const ModelSkeletonDataV18 &p_other);
    ModelSkeletonDataV18 &operator=(const ModelSkeletonDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV18 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV18();
    ModelMeshBindingDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV18(const ModelMeshBindingDataV18 &p_other);
    ModelMeshBindingDataV18 &operator=(const ModelMeshBindingDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV18 {
    PackGrannyTrackMaskType trackMask;
    qword token;

public:
    ModelTrackMaskV18();
    ModelTrackMaskV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV18(const ModelTrackMaskV18 &p_other);
    ModelTrackMaskV18 &operator=(const ModelTrackMaskV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV18 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV18> Skeleton;
    ModelTransformDataV18 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV18> MeshBindings;
    helpers::Array<dword> boneFlags;
    helpers::Array<ModelTrackMaskV18> trackMasks;
    helpers::Array<byte> skeletonHash;

public:
    ModelModelDataV18();
    ModelModelDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV18(const ModelModelDataV18 &p_other);
    ModelModelDataV18 &operator=(const ModelModelDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV18 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV18();
    ModelFloatPropertyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV18(const ModelFloatPropertyDataV18 &p_other);
    ModelFloatPropertyDataV18 &operator=(const ModelFloatPropertyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV18 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV18> floatValues;

public:
    ModelPropertyDataV18();
    ModelPropertyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV18(const ModelPropertyDataV18 &p_other);
    ModelPropertyDataV18 &operator=(const ModelPropertyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV18 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV18();
    ModelParticleCloudV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV18(const ModelParticleCloudV18 &p_other);
    ModelParticleCloudV18 &operator=(const ModelParticleCloudV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV18 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV18();
    ModelParticleCurveV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV18(const ModelParticleCurveV18 &p_other);
    ModelParticleCurveV18 &operator=(const ModelParticleCurveV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV18 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV18();
    ModelParticleFlipbookV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV18(const ModelParticleFlipbookV18 &p_other);
    ModelParticleFlipbookV18 &operator=(const ModelParticleFlipbookV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV18 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV18> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV18> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV18> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV18();
    ModelParticleEmitterV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV18(const ModelParticleEmitterV18 &p_other);
    ModelParticleEmitterV18 &operator=(const ModelParticleEmitterV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV18 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV18();
    ModelParticleObstacleV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV18(const ModelParticleObstacleV18 &p_other);
    ModelParticleObstacleV18 &operator=(const ModelParticleObstacleV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV18 {
    helpers::Array<ModelParticleCloudV18> clouds;
    helpers::Array<ModelParticleEmitterV18> emitters;
    helpers::Array<ModelParticleObstacleV18> obstacles;

public:
    ModelCloudDataV18();
    ModelCloudDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV18(const ModelCloudDataV18 &p_other);
    ModelCloudDataV18 &operator=(const ModelCloudDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV18 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV18();
    ModelStreakV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV18(const ModelStreakV18 &p_other);
    ModelStreakV18 &operator=(const ModelStreakV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV18 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV18();
    ModelStreakAnchorV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV18(const ModelStreakAnchorV18 &p_other);
    ModelStreakAnchorV18 &operator=(const ModelStreakAnchorV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV18 {
    helpers::Array<ModelStreakV18> streaks;
    helpers::Array<ModelStreakAnchorV18> anchors;

public:
    ModelStreakDataV18();
    ModelStreakDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV18(const ModelStreakDataV18 &p_other);
    ModelStreakDataV18 &operator=(const ModelStreakDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV18 {
    qword bone;
    byte color[3];
    float farDistance;
    float intensity;
    float nearDistance;
    dword visBoneIndex;

public:
    ModelEffectLightV18();
    ModelEffectLightV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV18(const ModelEffectLightV18 &p_other);
    ModelEffectLightV18 &operator=(const ModelEffectLightV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV18 {
    helpers::Array<ModelEffectLightV18> effectLights;

public:
    ModelLightDataV18();
    ModelLightDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV18(const ModelLightDataV18 &p_other);
    ModelLightDataV18 &operator=(const ModelLightDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV18 {
    helpers::Ptr<ModelMaterialDataV18> materials;
    helpers::Ptr<ModelMeshDataV18> meshes;
    helpers::Ptr<ModelModelDataV18> model;
    helpers::Ptr<ModelPropertyDataV18> properties;
    helpers::Ptr<ModelCloudDataV18> cloudData;
    helpers::Ptr<ModelStreakDataV18> streakData;
    helpers::Ptr<ModelLightDataV18> lightData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV18();
    ModelFileDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV18(const ModelFileDataV18 &p_other);
    ModelFileDataV18 &operator=(const ModelFileDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<17>{
struct ModelTextureDataV17 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV17();
    ModelTextureDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV17(const ModelTextureDataV17 &p_other);
    ModelTextureDataV17 &operator=(const ModelTextureDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV17 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV17();
    ModelConstantDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV17(const ModelConstantDataV17 &p_other);
    ModelConstantDataV17 &operator=(const ModelConstantDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV17 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV17> textures;
    helpers::Array<ModelConstantDataV17> constants;

public:
    ModelMaterialDataV17();
    ModelMaterialDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV17(const ModelMaterialDataV17 &p_other);
    ModelMaterialDataV17 &operator=(const ModelMaterialDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV17 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV17();
    ModelMeshLodDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV17(const ModelMeshLodDataV17 &p_other);
    ModelMeshLodDataV17 &operator=(const ModelMeshLodDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV17 {
    helpers::Array<word> positionIndices;
    helpers::Array<float3> positions;
    helpers::Array<word> normalIndices;
    helpers::Array<float3> normals;

public:
    ModelMeshMorphTargetV17();
    ModelMeshMorphTargetV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV17(const ModelMeshMorphTargetV17 &p_other);
    ModelMeshMorphTargetV17 &operator=(const ModelMeshMorphTargetV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV17 {
    helpers::Array<ModelMeshLodDataV17> lods;
    helpers::Array<ModelMeshMorphTargetV17> morphTargets;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV17();
    ModelMeshDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV17(const ModelMeshDataV17 &p_other);
    ModelMeshDataV17 &operator=(const ModelMeshDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV17 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV17();
    ModelTransformDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV17(const ModelTransformDataV17 &p_other);
    ModelTransformDataV17 &operator=(const ModelTransformDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV17 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV17 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV17();
    ModelBoneDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV17(const ModelBoneDataV17 &p_other);
    ModelBoneDataV17 &operator=(const ModelBoneDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV17 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV17> Bones;
    dword LODType;

public:
    ModelSkeletonDataV17();
    ModelSkeletonDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV17(const ModelSkeletonDataV17 &p_other);
    ModelSkeletonDataV17 &operator=(const ModelSkeletonDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV17 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV17();
    ModelMeshBindingDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV17(const ModelMeshBindingDataV17 &p_other);
    ModelMeshBindingDataV17 &operator=(const ModelMeshBindingDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV17 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV17> Skeleton;
    ModelTransformDataV17 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV17> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV17();
    ModelModelDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV17(const ModelModelDataV17 &p_other);
    ModelModelDataV17 &operator=(const ModelModelDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV17 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV17();
    ModelFloatPropertyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV17(const ModelFloatPropertyDataV17 &p_other);
    ModelFloatPropertyDataV17 &operator=(const ModelFloatPropertyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV17 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV17> floatValues;

public:
    ModelPropertyDataV17();
    ModelPropertyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV17(const ModelPropertyDataV17 &p_other);
    ModelPropertyDataV17 &operator=(const ModelPropertyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV17 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV17();
    ModelParticleCloudV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV17(const ModelParticleCloudV17 &p_other);
    ModelParticleCloudV17 &operator=(const ModelParticleCloudV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV17 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV17();
    ModelParticleCurveV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV17(const ModelParticleCurveV17 &p_other);
    ModelParticleCurveV17 &operator=(const ModelParticleCurveV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV17 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV17();
    ModelParticleFlipbookV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV17(const ModelParticleFlipbookV17 &p_other);
    ModelParticleFlipbookV17 &operator=(const ModelParticleFlipbookV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV17 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV17> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV17> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV17> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV17();
    ModelParticleEmitterV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV17(const ModelParticleEmitterV17 &p_other);
    ModelParticleEmitterV17 &operator=(const ModelParticleEmitterV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV17 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV17();
    ModelParticleObstacleV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV17(const ModelParticleObstacleV17 &p_other);
    ModelParticleObstacleV17 &operator=(const ModelParticleObstacleV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV17 {
    helpers::Array<ModelParticleCloudV17> clouds;
    helpers::Array<ModelParticleEmitterV17> emitters;
    helpers::Array<ModelParticleObstacleV17> obstacles;

public:
    ModelCloudDataV17();
    ModelCloudDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV17(const ModelCloudDataV17 &p_other);
    ModelCloudDataV17 &operator=(const ModelCloudDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV17 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV17();
    ModelStreakV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV17(const ModelStreakV17 &p_other);
    ModelStreakV17 &operator=(const ModelStreakV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV17 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV17();
    ModelStreakAnchorV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV17(const ModelStreakAnchorV17 &p_other);
    ModelStreakAnchorV17 &operator=(const ModelStreakAnchorV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV17 {
    helpers::Array<ModelStreakV17> streaks;
    helpers::Array<ModelStreakAnchorV17> anchors;

public:
    ModelStreakDataV17();
    ModelStreakDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV17(const ModelStreakDataV17 &p_other);
    ModelStreakDataV17 &operator=(const ModelStreakDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV17 {
    qword bone;
    byte color[4];
    float2 ranges;

public:
    ModelEffectLightV17();
    ModelEffectLightV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV17(const ModelEffectLightV17 &p_other);
    ModelEffectLightV17 &operator=(const ModelEffectLightV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV17 {
    helpers::Array<ModelEffectLightV17> effectLights;

public:
    ModelLightDataV17();
    ModelLightDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV17(const ModelLightDataV17 &p_other);
    ModelLightDataV17 &operator=(const ModelLightDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV17 {
    helpers::Ptr<ModelMaterialDataV17> materials;
    helpers::Ptr<ModelMeshDataV17> meshes;
    helpers::Ptr<ModelModelDataV17> model;
    helpers::Ptr<ModelPropertyDataV17> properties;
    helpers::Ptr<ModelCloudDataV17> cloudData;
    helpers::Ptr<ModelStreakDataV17> streakData;
    helpers::Ptr<ModelLightDataV17> lightData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];
    helpers::FileName soundScript;

public:
    ModelFileDataV17();
    ModelFileDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV17(const ModelFileDataV17 &p_other);
    ModelFileDataV17 &operator=(const ModelFileDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<16>{
struct ModelTextureDataV16 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV16();
    ModelTextureDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV16(const ModelTextureDataV16 &p_other);
    ModelTextureDataV16 &operator=(const ModelTextureDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV16 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV16();
    ModelConstantDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV16(const ModelConstantDataV16 &p_other);
    ModelConstantDataV16 &operator=(const ModelConstantDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV16 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV16> textures;
    helpers::Array<ModelConstantDataV16> constants;

public:
    ModelMaterialDataV16();
    ModelMaterialDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV16(const ModelMaterialDataV16 &p_other);
    ModelMaterialDataV16 &operator=(const ModelMaterialDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV16 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV16();
    ModelMeshLodDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV16(const ModelMeshLodDataV16 &p_other);
    ModelMeshLodDataV16 &operator=(const ModelMeshLodDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV16 {
    helpers::Array<ModelMeshLodDataV16> lods;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV16();
    ModelMeshDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV16(const ModelMeshDataV16 &p_other);
    ModelMeshDataV16 &operator=(const ModelMeshDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV16 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV16();
    ModelTransformDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV16(const ModelTransformDataV16 &p_other);
    ModelTransformDataV16 &operator=(const ModelTransformDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV16 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV16 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV16();
    ModelBoneDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV16(const ModelBoneDataV16 &p_other);
    ModelBoneDataV16 &operator=(const ModelBoneDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV16 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV16> Bones;
    dword LODType;

public:
    ModelSkeletonDataV16();
    ModelSkeletonDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV16(const ModelSkeletonDataV16 &p_other);
    ModelSkeletonDataV16 &operator=(const ModelSkeletonDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV16 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV16();
    ModelMeshBindingDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV16(const ModelMeshBindingDataV16 &p_other);
    ModelMeshBindingDataV16 &operator=(const ModelMeshBindingDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV16 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV16> Skeleton;
    ModelTransformDataV16 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV16> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV16();
    ModelModelDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV16(const ModelModelDataV16 &p_other);
    ModelModelDataV16 &operator=(const ModelModelDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV16 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV16();
    ModelFloatPropertyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV16(const ModelFloatPropertyDataV16 &p_other);
    ModelFloatPropertyDataV16 &operator=(const ModelFloatPropertyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV16 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV16> floatValues;

public:
    ModelPropertyDataV16();
    ModelPropertyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV16(const ModelPropertyDataV16 &p_other);
    ModelPropertyDataV16 &operator=(const ModelPropertyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV16 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV16();
    ModelParticleCloudV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV16(const ModelParticleCloudV16 &p_other);
    ModelParticleCloudV16 &operator=(const ModelParticleCloudV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV16 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV16();
    ModelParticleCurveV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV16(const ModelParticleCurveV16 &p_other);
    ModelParticleCurveV16 &operator=(const ModelParticleCurveV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV16 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV16();
    ModelParticleFlipbookV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV16(const ModelParticleFlipbookV16 &p_other);
    ModelParticleFlipbookV16 &operator=(const ModelParticleFlipbookV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV16 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV16> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV16> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV16> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV16();
    ModelParticleEmitterV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV16(const ModelParticleEmitterV16 &p_other);
    ModelParticleEmitterV16 &operator=(const ModelParticleEmitterV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV16 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV16();
    ModelParticleObstacleV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV16(const ModelParticleObstacleV16 &p_other);
    ModelParticleObstacleV16 &operator=(const ModelParticleObstacleV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV16 {
    helpers::Array<ModelParticleCloudV16> clouds;
    helpers::Array<ModelParticleEmitterV16> emitters;
    helpers::Array<ModelParticleObstacleV16> obstacles;

public:
    ModelCloudDataV16();
    ModelCloudDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV16(const ModelCloudDataV16 &p_other);
    ModelCloudDataV16 &operator=(const ModelCloudDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV16 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV16();
    ModelStreakV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV16(const ModelStreakV16 &p_other);
    ModelStreakV16 &operator=(const ModelStreakV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV16 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV16();
    ModelStreakAnchorV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV16(const ModelStreakAnchorV16 &p_other);
    ModelStreakAnchorV16 &operator=(const ModelStreakAnchorV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV16 {
    helpers::Array<ModelStreakV16> streaks;
    helpers::Array<ModelStreakAnchorV16> anchors;

public:
    ModelStreakDataV16();
    ModelStreakDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV16(const ModelStreakDataV16 &p_other);
    ModelStreakDataV16 &operator=(const ModelStreakDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV16 {
    qword bone;
    byte color[4];
    float2 ranges;

public:
    ModelEffectLightV16();
    ModelEffectLightV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV16(const ModelEffectLightV16 &p_other);
    ModelEffectLightV16 &operator=(const ModelEffectLightV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV16 {
    helpers::Array<ModelEffectLightV16> effectLights;

public:
    ModelLightDataV16();
    ModelLightDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV16(const ModelLightDataV16 &p_other);
    ModelLightDataV16 &operator=(const ModelLightDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV16 {
    helpers::Ptr<ModelMaterialDataV16> materials;
    helpers::Ptr<ModelMeshDataV16> meshes;
    helpers::Ptr<ModelModelDataV16> model;
    helpers::Ptr<ModelPropertyDataV16> properties;
    helpers::Ptr<ModelCloudDataV16> cloudData;
    helpers::Ptr<ModelStreakDataV16> streakData;
    helpers::Ptr<ModelLightDataV16> lightData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;
    float lodOverride[2];

public:
    ModelFileDataV16();
    ModelFileDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV16(const ModelFileDataV16 &p_other);
    ModelFileDataV16 &operator=(const ModelFileDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<15>{
struct ModelTextureDataV15 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV15();
    ModelTextureDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV15(const ModelTextureDataV15 &p_other);
    ModelTextureDataV15 &operator=(const ModelTextureDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV15 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV15();
    ModelConstantDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV15(const ModelConstantDataV15 &p_other);
    ModelConstantDataV15 &operator=(const ModelConstantDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV15 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV15> textures;
    helpers::Array<ModelConstantDataV15> constants;

public:
    ModelMaterialDataV15();
    ModelMaterialDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV15(const ModelMaterialDataV15 &p_other);
    ModelMaterialDataV15 &operator=(const ModelMaterialDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshLodDataV15 {
    helpers::Array<word> indices;

public:
    ModelMeshLodDataV15();
    ModelMeshLodDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshLodDataV15(const ModelMeshLodDataV15 &p_other);
    ModelMeshLodDataV15 &operator=(const ModelMeshLodDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV15 {
    helpers::Array<ModelMeshLodDataV15> lods;
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV15();
    ModelMeshDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV15(const ModelMeshDataV15 &p_other);
    ModelMeshDataV15 &operator=(const ModelMeshDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV15 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV15();
    ModelTransformDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV15(const ModelTransformDataV15 &p_other);
    ModelTransformDataV15 &operator=(const ModelTransformDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV15 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV15 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV15();
    ModelBoneDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV15(const ModelBoneDataV15 &p_other);
    ModelBoneDataV15 &operator=(const ModelBoneDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV15 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV15> Bones;
    dword LODType;

public:
    ModelSkeletonDataV15();
    ModelSkeletonDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV15(const ModelSkeletonDataV15 &p_other);
    ModelSkeletonDataV15 &operator=(const ModelSkeletonDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV15 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV15();
    ModelMeshBindingDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV15(const ModelMeshBindingDataV15 &p_other);
    ModelMeshBindingDataV15 &operator=(const ModelMeshBindingDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV15 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV15> Skeleton;
    ModelTransformDataV15 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV15> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV15();
    ModelModelDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV15(const ModelModelDataV15 &p_other);
    ModelModelDataV15 &operator=(const ModelModelDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV15 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV15();
    ModelFloatPropertyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV15(const ModelFloatPropertyDataV15 &p_other);
    ModelFloatPropertyDataV15 &operator=(const ModelFloatPropertyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV15 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV15> floatValues;

public:
    ModelPropertyDataV15();
    ModelPropertyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV15(const ModelPropertyDataV15 &p_other);
    ModelPropertyDataV15 &operator=(const ModelPropertyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV15 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV15();
    ModelParticleCloudV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV15(const ModelParticleCloudV15 &p_other);
    ModelParticleCloudV15 &operator=(const ModelParticleCloudV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV15 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV15();
    ModelParticleCurveV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV15(const ModelParticleCurveV15 &p_other);
    ModelParticleCurveV15 &operator=(const ModelParticleCurveV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV15 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV15();
    ModelParticleFlipbookV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV15(const ModelParticleFlipbookV15 &p_other);
    ModelParticleFlipbookV15 &operator=(const ModelParticleFlipbookV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV15 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV15> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV15> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV15> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV15();
    ModelParticleEmitterV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV15(const ModelParticleEmitterV15 &p_other);
    ModelParticleEmitterV15 &operator=(const ModelParticleEmitterV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV15 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV15();
    ModelParticleObstacleV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV15(const ModelParticleObstacleV15 &p_other);
    ModelParticleObstacleV15 &operator=(const ModelParticleObstacleV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV15 {
    helpers::Array<ModelParticleCloudV15> clouds;
    helpers::Array<ModelParticleEmitterV15> emitters;
    helpers::Array<ModelParticleObstacleV15> obstacles;

public:
    ModelCloudDataV15();
    ModelCloudDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV15(const ModelCloudDataV15 &p_other);
    ModelCloudDataV15 &operator=(const ModelCloudDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV15 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV15();
    ModelStreakV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV15(const ModelStreakV15 &p_other);
    ModelStreakV15 &operator=(const ModelStreakV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV15 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV15();
    ModelStreakAnchorV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV15(const ModelStreakAnchorV15 &p_other);
    ModelStreakAnchorV15 &operator=(const ModelStreakAnchorV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV15 {
    helpers::Array<ModelStreakV15> streaks;
    helpers::Array<ModelStreakAnchorV15> anchors;

public:
    ModelStreakDataV15();
    ModelStreakDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV15(const ModelStreakDataV15 &p_other);
    ModelStreakDataV15 &operator=(const ModelStreakDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelEffectLightV15 {
    qword bone;
    byte color[4];
    float2 ranges;

public:
    ModelEffectLightV15();
    ModelEffectLightV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelEffectLightV15(const ModelEffectLightV15 &p_other);
    ModelEffectLightV15 &operator=(const ModelEffectLightV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightDataV15 {
    helpers::Array<ModelEffectLightV15> effectLights;

public:
    ModelLightDataV15();
    ModelLightDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightDataV15(const ModelLightDataV15 &p_other);
    ModelLightDataV15 &operator=(const ModelLightDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV15 {
    helpers::Ptr<ModelMaterialDataV15> materials;
    helpers::Ptr<ModelMeshDataV15> meshes;
    helpers::Ptr<ModelModelDataV15> model;
    helpers::Ptr<ModelPropertyDataV15> properties;
    helpers::Ptr<ModelCloudDataV15> cloudData;
    helpers::Ptr<ModelStreakDataV15> streakData;
    helpers::Ptr<ModelLightDataV15> lightData;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;

public:
    ModelFileDataV15();
    ModelFileDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV15(const ModelFileDataV15 &p_other);
    ModelFileDataV15 &operator=(const ModelFileDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<14>{
struct ModelTextureDataV14 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV14();
    ModelTextureDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV14(const ModelTextureDataV14 &p_other);
    ModelTextureDataV14 &operator=(const ModelTextureDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV14 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV14();
    ModelConstantDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV14(const ModelConstantDataV14 &p_other);
    ModelConstantDataV14 &operator=(const ModelConstantDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV14 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV14> textures;
    helpers::Array<ModelConstantDataV14> constants;

public:
    ModelMaterialDataV14();
    ModelMaterialDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV14(const ModelMaterialDataV14 &p_other);
    ModelMaterialDataV14 &operator=(const ModelMaterialDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV14 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;
    helpers::Array<qword> actionOffsetNames;
    helpers::Array<float3> actionOffsets;

public:
    ModelMeshDataV14();
    ModelMeshDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV14(const ModelMeshDataV14 &p_other);
    ModelMeshDataV14 &operator=(const ModelMeshDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV14 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV14();
    ModelTransformDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV14(const ModelTransformDataV14 &p_other);
    ModelTransformDataV14 &operator=(const ModelTransformDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV14 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV14 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV14();
    ModelBoneDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV14(const ModelBoneDataV14 &p_other);
    ModelBoneDataV14 &operator=(const ModelBoneDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV14 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV14> Bones;
    dword LODType;

public:
    ModelSkeletonDataV14();
    ModelSkeletonDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV14(const ModelSkeletonDataV14 &p_other);
    ModelSkeletonDataV14 &operator=(const ModelSkeletonDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV14 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV14();
    ModelMeshBindingDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV14(const ModelMeshBindingDataV14 &p_other);
    ModelMeshBindingDataV14 &operator=(const ModelMeshBindingDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV14 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV14> Skeleton;
    ModelTransformDataV14 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV14> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV14();
    ModelModelDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV14(const ModelModelDataV14 &p_other);
    ModelModelDataV14 &operator=(const ModelModelDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV14 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV14();
    ModelFloatPropertyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV14(const ModelFloatPropertyDataV14 &p_other);
    ModelFloatPropertyDataV14 &operator=(const ModelFloatPropertyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV14 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV14> floatValues;

public:
    ModelPropertyDataV14();
    ModelPropertyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV14(const ModelPropertyDataV14 &p_other);
    ModelPropertyDataV14 &operator=(const ModelPropertyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV14 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV14();
    ModelParticleCloudV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV14(const ModelParticleCloudV14 &p_other);
    ModelParticleCloudV14 &operator=(const ModelParticleCloudV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV14 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV14();
    ModelParticleCurveV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV14(const ModelParticleCurveV14 &p_other);
    ModelParticleCurveV14 &operator=(const ModelParticleCurveV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV14 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV14();
    ModelParticleFlipbookV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV14(const ModelParticleFlipbookV14 &p_other);
    ModelParticleFlipbookV14 &operator=(const ModelParticleFlipbookV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV14 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV14> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV14> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV14> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV14();
    ModelParticleEmitterV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV14(const ModelParticleEmitterV14 &p_other);
    ModelParticleEmitterV14 &operator=(const ModelParticleEmitterV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV14 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV14();
    ModelParticleObstacleV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV14(const ModelParticleObstacleV14 &p_other);
    ModelParticleObstacleV14 &operator=(const ModelParticleObstacleV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV14 {
    helpers::Array<ModelParticleCloudV14> clouds;
    helpers::Array<ModelParticleEmitterV14> emitters;
    helpers::Array<ModelParticleObstacleV14> obstacles;

public:
    ModelCloudDataV14();
    ModelCloudDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV14(const ModelCloudDataV14 &p_other);
    ModelCloudDataV14 &operator=(const ModelCloudDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV14 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV14();
    ModelStreakV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV14(const ModelStreakV14 &p_other);
    ModelStreakV14 &operator=(const ModelStreakV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV14 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV14();
    ModelStreakAnchorV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV14(const ModelStreakAnchorV14 &p_other);
    ModelStreakAnchorV14 &operator=(const ModelStreakAnchorV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV14 {
    helpers::Array<ModelStreakV14> streaks;
    helpers::Array<ModelStreakAnchorV14> anchors;

public:
    ModelStreakDataV14();
    ModelStreakDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV14(const ModelStreakDataV14 &p_other);
    ModelStreakDataV14 &operator=(const ModelStreakDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV14 {
    helpers::Ptr<ModelMaterialDataV14> materials;
    helpers::Ptr<ModelMeshDataV14> meshes;
    helpers::Ptr<ModelModelDataV14> model;
    helpers::Ptr<ModelPropertyDataV14> properties;
    helpers::Ptr<ModelCloudDataV14> cloudData;
    helpers::Ptr<ModelStreakDataV14> streakData;

public:
    ModelFileDataV14();
    ModelFileDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV14(const ModelFileDataV14 &p_other);
    ModelFileDataV14 &operator=(const ModelFileDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<13>{
struct ModelTextureDataV13 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV13();
    ModelTextureDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV13(const ModelTextureDataV13 &p_other);
    ModelTextureDataV13 &operator=(const ModelTextureDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV13 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV13();
    ModelConstantDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV13(const ModelConstantDataV13 &p_other);
    ModelConstantDataV13 &operator=(const ModelConstantDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV13 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV13> textures;
    helpers::Array<ModelConstantDataV13> constants;

public:
    ModelMaterialDataV13();
    ModelMaterialDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV13(const ModelMaterialDataV13 &p_other);
    ModelMaterialDataV13 &operator=(const ModelMaterialDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV13 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV13();
    ModelMeshDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV13(const ModelMeshDataV13 &p_other);
    ModelMeshDataV13 &operator=(const ModelMeshDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV13 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV13();
    ModelTransformDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV13(const ModelTransformDataV13 &p_other);
    ModelTransformDataV13 &operator=(const ModelTransformDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV13 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV13 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV13();
    ModelBoneDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV13(const ModelBoneDataV13 &p_other);
    ModelBoneDataV13 &operator=(const ModelBoneDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV13 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV13> Bones;
    dword LODType;

public:
    ModelSkeletonDataV13();
    ModelSkeletonDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV13(const ModelSkeletonDataV13 &p_other);
    ModelSkeletonDataV13 &operator=(const ModelSkeletonDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV13 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV13();
    ModelMeshBindingDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV13(const ModelMeshBindingDataV13 &p_other);
    ModelMeshBindingDataV13 &operator=(const ModelMeshBindingDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV13 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV13> Skeleton;
    ModelTransformDataV13 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV13> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV13();
    ModelModelDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV13(const ModelModelDataV13 &p_other);
    ModelModelDataV13 &operator=(const ModelModelDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV13 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV13();
    ModelFloatPropertyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV13(const ModelFloatPropertyDataV13 &p_other);
    ModelFloatPropertyDataV13 &operator=(const ModelFloatPropertyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV13 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV13> floatValues;

public:
    ModelPropertyDataV13();
    ModelPropertyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV13(const ModelPropertyDataV13 &p_other);
    ModelPropertyDataV13 &operator=(const ModelPropertyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV13 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV13();
    ModelParticleCloudV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV13(const ModelParticleCloudV13 &p_other);
    ModelParticleCloudV13 &operator=(const ModelParticleCloudV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV13 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV13();
    ModelParticleCurveV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV13(const ModelParticleCurveV13 &p_other);
    ModelParticleCurveV13 &operator=(const ModelParticleCurveV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV13 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV13();
    ModelParticleFlipbookV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV13(const ModelParticleFlipbookV13 &p_other);
    ModelParticleFlipbookV13 &operator=(const ModelParticleFlipbookV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV13 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV13> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV13> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV13> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV13();
    ModelParticleEmitterV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV13(const ModelParticleEmitterV13 &p_other);
    ModelParticleEmitterV13 &operator=(const ModelParticleEmitterV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV13 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV13();
    ModelParticleObstacleV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV13(const ModelParticleObstacleV13 &p_other);
    ModelParticleObstacleV13 &operator=(const ModelParticleObstacleV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV13 {
    helpers::Array<ModelParticleCloudV13> clouds;
    helpers::Array<ModelParticleEmitterV13> emitters;
    helpers::Array<ModelParticleObstacleV13> obstacles;

public:
    ModelCloudDataV13();
    ModelCloudDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV13(const ModelCloudDataV13 &p_other);
    ModelCloudDataV13 &operator=(const ModelCloudDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV13 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV13();
    ModelStreakV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV13(const ModelStreakV13 &p_other);
    ModelStreakV13 &operator=(const ModelStreakV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV13 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV13();
    ModelStreakAnchorV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV13(const ModelStreakAnchorV13 &p_other);
    ModelStreakAnchorV13 &operator=(const ModelStreakAnchorV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV13 {
    helpers::Array<ModelStreakV13> streaks;
    helpers::Array<ModelStreakAnchorV13> anchors;

public:
    ModelStreakDataV13();
    ModelStreakDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV13(const ModelStreakDataV13 &p_other);
    ModelStreakDataV13 &operator=(const ModelStreakDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV13 {
    helpers::Ptr<ModelMaterialDataV13> materials;
    helpers::Ptr<ModelMeshDataV13> meshes;
    helpers::Ptr<ModelModelDataV13> model;
    helpers::Ptr<ModelPropertyDataV13> properties;
    helpers::Ptr<ModelCloudDataV13> cloudData;
    helpers::Ptr<ModelStreakDataV13> streakData;

public:
    ModelFileDataV13();
    ModelFileDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV13(const ModelFileDataV13 &p_other);
    ModelFileDataV13 &operator=(const ModelFileDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<12>{
struct ModelTextureDataV12 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV12();
    ModelTextureDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV12(const ModelTextureDataV12 &p_other);
    ModelTextureDataV12 &operator=(const ModelTextureDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV12 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV12();
    ModelConstantDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV12(const ModelConstantDataV12 &p_other);
    ModelConstantDataV12 &operator=(const ModelConstantDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV12 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV12> textures;
    helpers::Array<ModelConstantDataV12> constants;

public:
    ModelMaterialDataV12();
    ModelMaterialDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV12(const ModelMaterialDataV12 &p_other);
    ModelMaterialDataV12 &operator=(const ModelMaterialDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV12 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;
    helpers::Array<dword> seamVertIndices;

public:
    ModelMeshDataV12();
    ModelMeshDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV12(const ModelMeshDataV12 &p_other);
    ModelMeshDataV12 &operator=(const ModelMeshDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV12 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV12();
    ModelTransformDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV12(const ModelTransformDataV12 &p_other);
    ModelTransformDataV12 &operator=(const ModelTransformDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV12 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV12 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV12();
    ModelBoneDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV12(const ModelBoneDataV12 &p_other);
    ModelBoneDataV12 &operator=(const ModelBoneDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV12 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV12> Bones;
    dword LODType;

public:
    ModelSkeletonDataV12();
    ModelSkeletonDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV12(const ModelSkeletonDataV12 &p_other);
    ModelSkeletonDataV12 &operator=(const ModelSkeletonDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV12 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV12();
    ModelMeshBindingDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV12(const ModelMeshBindingDataV12 &p_other);
    ModelMeshBindingDataV12 &operator=(const ModelMeshBindingDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV12 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV12> Skeleton;
    ModelTransformDataV12 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV12> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV12();
    ModelModelDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV12(const ModelModelDataV12 &p_other);
    ModelModelDataV12 &operator=(const ModelModelDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV12 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV12();
    ModelFloatPropertyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV12(const ModelFloatPropertyDataV12 &p_other);
    ModelFloatPropertyDataV12 &operator=(const ModelFloatPropertyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV12 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV12> floatValues;

public:
    ModelPropertyDataV12();
    ModelPropertyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV12(const ModelPropertyDataV12 &p_other);
    ModelPropertyDataV12 &operator=(const ModelPropertyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV12 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV12();
    ModelParticleCloudV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV12(const ModelParticleCloudV12 &p_other);
    ModelParticleCloudV12 &operator=(const ModelParticleCloudV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV12 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV12();
    ModelParticleCurveV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV12(const ModelParticleCurveV12 &p_other);
    ModelParticleCurveV12 &operator=(const ModelParticleCurveV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV12 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV12();
    ModelParticleFlipbookV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV12(const ModelParticleFlipbookV12 &p_other);
    ModelParticleFlipbookV12 &operator=(const ModelParticleFlipbookV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV12 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV12> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV12> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV12> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV12();
    ModelParticleEmitterV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV12(const ModelParticleEmitterV12 &p_other);
    ModelParticleEmitterV12 &operator=(const ModelParticleEmitterV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV12 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV12();
    ModelParticleObstacleV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV12(const ModelParticleObstacleV12 &p_other);
    ModelParticleObstacleV12 &operator=(const ModelParticleObstacleV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV12 {
    helpers::Array<ModelParticleCloudV12> clouds;
    helpers::Array<ModelParticleEmitterV12> emitters;
    helpers::Array<ModelParticleObstacleV12> obstacles;

public:
    ModelCloudDataV12();
    ModelCloudDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV12(const ModelCloudDataV12 &p_other);
    ModelCloudDataV12 &operator=(const ModelCloudDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV12 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV12();
    ModelStreakV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV12(const ModelStreakV12 &p_other);
    ModelStreakV12 &operator=(const ModelStreakV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV12 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV12();
    ModelStreakAnchorV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV12(const ModelStreakAnchorV12 &p_other);
    ModelStreakAnchorV12 &operator=(const ModelStreakAnchorV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV12 {
    helpers::Array<ModelStreakV12> streaks;
    helpers::Array<ModelStreakAnchorV12> anchors;

public:
    ModelStreakDataV12();
    ModelStreakDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV12(const ModelStreakDataV12 &p_other);
    ModelStreakDataV12 &operator=(const ModelStreakDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV12 {
    helpers::Ptr<ModelMaterialDataV12> materials;
    helpers::Ptr<ModelMeshDataV12> meshes;
    helpers::Ptr<ModelModelDataV12> model;
    helpers::Ptr<ModelPropertyDataV12> properties;
    helpers::Ptr<ModelCloudDataV12> cloudData;
    helpers::Ptr<ModelStreakDataV12> streakData;

public:
    ModelFileDataV12();
    ModelFileDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV12(const ModelFileDataV12 &p_other);
    ModelFileDataV12 &operator=(const ModelFileDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x410D8B5000000001 */

template <>
struct Gw2StructMODL<11>{
struct ModelTextureDataV11 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV11();
    ModelTextureDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV11(const ModelTextureDataV11 &p_other);
    ModelTextureDataV11 &operator=(const ModelTextureDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV11 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV11();
    ModelConstantDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV11(const ModelConstantDataV11 &p_other);
    ModelConstantDataV11 &operator=(const ModelConstantDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV11 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV11> textures;
    helpers::Array<ModelConstantDataV11> constants;

public:
    ModelMaterialDataV11();
    ModelMaterialDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV11(const ModelMaterialDataV11 &p_other);
    ModelMaterialDataV11 &operator=(const ModelMaterialDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV11 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV11();
    ModelMeshDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV11(const ModelMeshDataV11 &p_other);
    ModelMeshDataV11 &operator=(const ModelMeshDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV11 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV11();
    ModelTransformDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV11(const ModelTransformDataV11 &p_other);
    ModelTransformDataV11 &operator=(const ModelTransformDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV11 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV11 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV11();
    ModelBoneDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV11(const ModelBoneDataV11 &p_other);
    ModelBoneDataV11 &operator=(const ModelBoneDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV11 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV11> Bones;
    dword LODType;

public:
    ModelSkeletonDataV11();
    ModelSkeletonDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV11(const ModelSkeletonDataV11 &p_other);
    ModelSkeletonDataV11 &operator=(const ModelSkeletonDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV11 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV11();
    ModelMeshBindingDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV11(const ModelMeshBindingDataV11 &p_other);
    ModelMeshBindingDataV11 &operator=(const ModelMeshBindingDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV11 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV11> Skeleton;
    ModelTransformDataV11 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV11> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV11();
    ModelModelDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV11(const ModelModelDataV11 &p_other);
    ModelModelDataV11 &operator=(const ModelModelDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV11 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV11();
    ModelFloatPropertyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV11(const ModelFloatPropertyDataV11 &p_other);
    ModelFloatPropertyDataV11 &operator=(const ModelFloatPropertyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV11 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV11> floatValues;

public:
    ModelPropertyDataV11();
    ModelPropertyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV11(const ModelPropertyDataV11 &p_other);
    ModelPropertyDataV11 &operator=(const ModelPropertyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV11 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;

public:
    ModelParticleCloudV11();
    ModelParticleCloudV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV11(const ModelParticleCloudV11 &p_other);
    ModelParticleCloudV11 &operator=(const ModelParticleCloudV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCurveV11 {
    byte curveType;
    helpers::Array<float2> keys;

public:
    ModelParticleCurveV11();
    ModelParticleCurveV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCurveV11(const ModelParticleCurveV11 &p_other);
    ModelParticleCurveV11 &operator=(const ModelParticleCurveV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV11 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV11();
    ModelParticleFlipbookV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV11(const ModelParticleFlipbookV11 &p_other);
    ModelParticleFlipbookV11 &operator=(const ModelParticleFlipbookV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV11 {
    float2 acceleration[4];
    float2 accelerationDistRange;
    float2 accelerationDistSpeed;
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    float colorFalloff;
    float drag;
    helpers::Ptr<ModelParticleCurveV11> opacityCurve;
    dword opacityCurvePreset;
    dword flags;
    helpers::Ptr<ModelParticleFlipbookV11> flipbook;
    float2 lifetime;
    float2 rotationChange;
    float rotationDrag;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    helpers::Ptr<ModelParticleCurveV11> scaleCurve;
    dword scaleCurvePreset;
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    float2 spawnWindEmit;
    float2 spawnWindSpeed;
    float4 texCoordRect;
    dword visBoneIndex;

public:
    ModelParticleEmitterV11();
    ModelParticleEmitterV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV11(const ModelParticleEmitterV11 &p_other);
    ModelParticleEmitterV11 &operator=(const ModelParticleEmitterV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV11 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV11();
    ModelParticleObstacleV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV11(const ModelParticleObstacleV11 &p_other);
    ModelParticleObstacleV11 &operator=(const ModelParticleObstacleV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV11 {
    helpers::Array<ModelParticleCloudV11> clouds;
    helpers::Array<ModelParticleEmitterV11> emitters;
    helpers::Array<ModelParticleObstacleV11> obstacles;

public:
    ModelCloudDataV11();
    ModelCloudDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV11(const ModelCloudDataV11 &p_other);
    ModelCloudDataV11 &operator=(const ModelCloudDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV11 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV11();
    ModelStreakV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV11(const ModelStreakV11 &p_other);
    ModelStreakV11 &operator=(const ModelStreakV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV11 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV11();
    ModelStreakAnchorV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV11(const ModelStreakAnchorV11 &p_other);
    ModelStreakAnchorV11 &operator=(const ModelStreakAnchorV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV11 {
    helpers::Array<ModelStreakV11> streaks;
    helpers::Array<ModelStreakAnchorV11> anchors;

public:
    ModelStreakDataV11();
    ModelStreakDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV11(const ModelStreakDataV11 &p_other);
    ModelStreakDataV11 &operator=(const ModelStreakDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV11 {
    helpers::Ptr<ModelMaterialDataV11> materials;
    helpers::Ptr<ModelMeshDataV11> meshes;
    helpers::Ptr<ModelModelDataV11> model;
    helpers::Ptr<ModelPropertyDataV11> properties;
    helpers::Ptr<ModelCloudDataV11> cloudData;
    helpers::Ptr<ModelStreakDataV11> streakData;

public:
    ModelFileDataV11();
    ModelFileDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV11(const ModelFileDataV11 &p_other);
    ModelFileDataV11 &operator=(const ModelFileDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<10>{
struct ModelTextureDataV10 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV10();
    ModelTextureDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV10(const ModelTextureDataV10 &p_other);
    ModelTextureDataV10 &operator=(const ModelTextureDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV10 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV10();
    ModelConstantDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV10(const ModelConstantDataV10 &p_other);
    ModelConstantDataV10 &operator=(const ModelConstantDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV10 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV10> textures;
    helpers::Array<ModelConstantDataV10> constants;

public:
    ModelMaterialDataV10();
    ModelMaterialDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV10(const ModelMaterialDataV10 &p_other);
    ModelMaterialDataV10 &operator=(const ModelMaterialDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV10 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV10();
    ModelMeshDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV10(const ModelMeshDataV10 &p_other);
    ModelMeshDataV10 &operator=(const ModelMeshDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV10 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV10();
    ModelTransformDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV10(const ModelTransformDataV10 &p_other);
    ModelTransformDataV10 &operator=(const ModelTransformDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV10 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV10 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV10();
    ModelBoneDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV10(const ModelBoneDataV10 &p_other);
    ModelBoneDataV10 &operator=(const ModelBoneDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV10 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV10> Bones;
    dword LODType;

public:
    ModelSkeletonDataV10();
    ModelSkeletonDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV10(const ModelSkeletonDataV10 &p_other);
    ModelSkeletonDataV10 &operator=(const ModelSkeletonDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV10 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV10();
    ModelMeshBindingDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV10(const ModelMeshBindingDataV10 &p_other);
    ModelMeshBindingDataV10 &operator=(const ModelMeshBindingDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV10 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV10> Skeleton;
    ModelTransformDataV10 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV10> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV10();
    ModelModelDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV10(const ModelModelDataV10 &p_other);
    ModelModelDataV10 &operator=(const ModelModelDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV10 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV10();
    ModelFloatPropertyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV10(const ModelFloatPropertyDataV10 &p_other);
    ModelFloatPropertyDataV10 &operator=(const ModelFloatPropertyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV10 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV10> floatValues;

public:
    ModelPropertyDataV10();
    ModelPropertyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV10(const ModelPropertyDataV10 &p_other);
    ModelPropertyDataV10 &operator=(const ModelPropertyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV10 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV10();
    ModelParticleFlipbookV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV10(const ModelParticleFlipbookV10 &p_other);
    ModelParticleFlipbookV10 &operator=(const ModelParticleFlipbookV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV10 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV10> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV10();
    ModelParticleCloudV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV10(const ModelParticleCloudV10 &p_other);
    ModelParticleCloudV10 &operator=(const ModelParticleCloudV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV10 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    dword visBoneIndex;

public:
    ModelParticleEmitterV10();
    ModelParticleEmitterV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV10(const ModelParticleEmitterV10 &p_other);
    ModelParticleEmitterV10 &operator=(const ModelParticleEmitterV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV10 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV10();
    ModelParticleObstacleV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV10(const ModelParticleObstacleV10 &p_other);
    ModelParticleObstacleV10 &operator=(const ModelParticleObstacleV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV10 {
    helpers::Array<ModelParticleCloudV10> clouds;
    helpers::Array<ModelParticleEmitterV10> emitters;
    helpers::Array<ModelParticleObstacleV10> obstacles;

public:
    ModelCloudDataV10();
    ModelCloudDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV10(const ModelCloudDataV10 &p_other);
    ModelCloudDataV10 &operator=(const ModelCloudDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakV10 {
    helpers::Array<dword> anchorIndices;
    qword bone;
    dword flags;
    dword materialIndex;
    float spawnFreq;
    float stretchDist;
    float texScale;
    dword visBoneIndex;

public:
    ModelStreakV10();
    ModelStreakV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakV10(const ModelStreakV10 &p_other);
    ModelStreakV10 &operator=(const ModelStreakV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnchorV10 {
    qword bone;
    dword color;
    float falloff;
    float lifetime;

public:
    ModelStreakAnchorV10();
    ModelStreakAnchorV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnchorV10(const ModelStreakAnchorV10 &p_other);
    ModelStreakAnchorV10 &operator=(const ModelStreakAnchorV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakDataV10 {
    helpers::Array<ModelStreakV10> streaks;
    helpers::Array<ModelStreakAnchorV10> anchors;

public:
    ModelStreakDataV10();
    ModelStreakDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakDataV10(const ModelStreakDataV10 &p_other);
    ModelStreakDataV10 &operator=(const ModelStreakDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV10 {
    helpers::Ptr<ModelMaterialDataV10> materials;
    helpers::Ptr<ModelMeshDataV10> meshes;
    helpers::Ptr<ModelModelDataV10> model;
    helpers::Ptr<ModelPropertyDataV10> properties;
    helpers::Ptr<ModelCloudDataV10> cloudData;
    helpers::Ptr<ModelStreakDataV10> streakData;

public:
    ModelFileDataV10();
    ModelFileDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV10(const ModelFileDataV10 &p_other);
    ModelFileDataV10 &operator=(const ModelFileDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<9>{
struct ModelTextureDataV9 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV9();
    ModelTextureDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV9(const ModelTextureDataV9 &p_other);
    ModelTextureDataV9 &operator=(const ModelTextureDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV9 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV9();
    ModelConstantDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV9(const ModelConstantDataV9 &p_other);
    ModelConstantDataV9 &operator=(const ModelConstantDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV9 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    byte texCoordCount;
    helpers::Array<ModelTextureDataV9> textures;
    helpers::Array<ModelConstantDataV9> constants;

public:
    ModelMaterialDataV9();
    ModelMaterialDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV9(const ModelMaterialDataV9 &p_other);
    ModelMaterialDataV9 &operator=(const ModelMaterialDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV9 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV9();
    ModelMeshDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV9(const ModelMeshDataV9 &p_other);
    ModelMeshDataV9 &operator=(const ModelMeshDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV9 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV9();
    ModelTransformDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV9(const ModelTransformDataV9 &p_other);
    ModelTransformDataV9 &operator=(const ModelTransformDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV9 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV9 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV9();
    ModelBoneDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV9(const ModelBoneDataV9 &p_other);
    ModelBoneDataV9 &operator=(const ModelBoneDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV9 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV9> Bones;
    dword LODType;

public:
    ModelSkeletonDataV9();
    ModelSkeletonDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV9(const ModelSkeletonDataV9 &p_other);
    ModelSkeletonDataV9 &operator=(const ModelSkeletonDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV9 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV9();
    ModelMeshBindingDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV9(const ModelMeshBindingDataV9 &p_other);
    ModelMeshBindingDataV9 &operator=(const ModelMeshBindingDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV9 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV9> Skeleton;
    ModelTransformDataV9 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV9> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV9();
    ModelModelDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV9(const ModelModelDataV9 &p_other);
    ModelModelDataV9 &operator=(const ModelModelDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV9 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV9();
    ModelFloatPropertyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV9(const ModelFloatPropertyDataV9 &p_other);
    ModelFloatPropertyDataV9 &operator=(const ModelFloatPropertyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV9 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV9> floatValues;

public:
    ModelPropertyDataV9();
    ModelPropertyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV9(const ModelPropertyDataV9 &p_other);
    ModelPropertyDataV9 &operator=(const ModelPropertyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV9 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV9();
    ModelParticleFlipbookV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV9(const ModelParticleFlipbookV9 &p_other);
    ModelParticleFlipbookV9 &operator=(const ModelParticleFlipbookV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV9 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV9> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV9();
    ModelParticleCloudV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV9(const ModelParticleCloudV9 &p_other);
    ModelParticleCloudV9 &operator=(const ModelParticleCloudV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV9 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    dword visBoneIndex;

public:
    ModelParticleEmitterV9();
    ModelParticleEmitterV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV9(const ModelParticleEmitterV9 &p_other);
    ModelParticleEmitterV9 &operator=(const ModelParticleEmitterV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV9 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV9();
    ModelParticleObstacleV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV9(const ModelParticleObstacleV9 &p_other);
    ModelParticleObstacleV9 &operator=(const ModelParticleObstacleV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV9 {
    helpers::Array<ModelParticleCloudV9> clouds;
    helpers::Array<ModelParticleEmitterV9> emitters;
    helpers::Array<ModelParticleObstacleV9> obstacles;

public:
    ModelCloudDataV9();
    ModelCloudDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV9(const ModelCloudDataV9 &p_other);
    ModelCloudDataV9 &operator=(const ModelCloudDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV9 {
    helpers::Ptr<ModelMaterialDataV9> materials;
    helpers::Ptr<ModelMeshDataV9> meshes;
    helpers::Ptr<ModelModelDataV9> model;
    helpers::Ptr<ModelPropertyDataV9> properties;
    helpers::Ptr<ModelCloudDataV9> cloudData;

public:
    ModelFileDataV9();
    ModelFileDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV9(const ModelFileDataV9 &p_other);
    ModelFileDataV9 &operator=(const ModelFileDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x410DC77000000001 */

template <>
struct Gw2StructMODL<8>{
struct ModelTextureDataV8 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;
    byte uvAnimId;
    byte uvPSInputIndex;

public:
    ModelTextureDataV8();
    ModelTextureDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV8(const ModelTextureDataV8 &p_other);
    ModelTextureDataV8 &operator=(const ModelTextureDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV8 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV8();
    ModelConstantDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV8(const ModelConstantDataV8 &p_other);
    ModelConstantDataV8 &operator=(const ModelConstantDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV8 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV8> textures;
    helpers::Array<ModelConstantDataV8> constants;

public:
    ModelMaterialDataV8();
    ModelMaterialDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV8(const ModelMaterialDataV8 &p_other);
    ModelMaterialDataV8 &operator=(const ModelMaterialDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV8 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV8();
    ModelMeshDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV8(const ModelMeshDataV8 &p_other);
    ModelMeshDataV8 &operator=(const ModelMeshDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV8 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV8();
    ModelTransformDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV8(const ModelTransformDataV8 &p_other);
    ModelTransformDataV8 &operator=(const ModelTransformDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV8 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV8 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV8();
    ModelBoneDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV8(const ModelBoneDataV8 &p_other);
    ModelBoneDataV8 &operator=(const ModelBoneDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV8 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV8> Bones;
    dword LODType;

public:
    ModelSkeletonDataV8();
    ModelSkeletonDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV8(const ModelSkeletonDataV8 &p_other);
    ModelSkeletonDataV8 &operator=(const ModelSkeletonDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV8 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV8();
    ModelMeshBindingDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV8(const ModelMeshBindingDataV8 &p_other);
    ModelMeshBindingDataV8 &operator=(const ModelMeshBindingDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV8 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV8> Skeleton;
    ModelTransformDataV8 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV8> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV8();
    ModelModelDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV8(const ModelModelDataV8 &p_other);
    ModelModelDataV8 &operator=(const ModelModelDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV8 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV8();
    ModelFloatPropertyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV8(const ModelFloatPropertyDataV8 &p_other);
    ModelFloatPropertyDataV8 &operator=(const ModelFloatPropertyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV8 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV8> floatValues;

public:
    ModelPropertyDataV8();
    ModelPropertyDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV8(const ModelPropertyDataV8 &p_other);
    ModelPropertyDataV8 &operator=(const ModelPropertyDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV8 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV8();
    ModelParticleFlipbookV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV8(const ModelParticleFlipbookV8 &p_other);
    ModelParticleFlipbookV8 &operator=(const ModelParticleFlipbookV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV8 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV8> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV8();
    ModelParticleCloudV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV8(const ModelParticleCloudV8 &p_other);
    ModelParticleCloudV8 &operator=(const ModelParticleCloudV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV8 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    dword visBoneIndex;

public:
    ModelParticleEmitterV8();
    ModelParticleEmitterV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV8(const ModelParticleEmitterV8 &p_other);
    ModelParticleEmitterV8 &operator=(const ModelParticleEmitterV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV8 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV8();
    ModelParticleObstacleV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV8(const ModelParticleObstacleV8 &p_other);
    ModelParticleObstacleV8 &operator=(const ModelParticleObstacleV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV8 {
    helpers::Array<ModelParticleCloudV8> clouds;
    helpers::Array<ModelParticleEmitterV8> emitters;
    helpers::Array<ModelParticleObstacleV8> obstacles;

public:
    ModelCloudDataV8();
    ModelCloudDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV8(const ModelCloudDataV8 &p_other);
    ModelCloudDataV8 &operator=(const ModelCloudDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV8 {
    helpers::Ptr<ModelMaterialDataV8> materials;
    helpers::Ptr<ModelMeshDataV8> meshes;
    helpers::Ptr<ModelModelDataV8> model;
    helpers::Ptr<ModelPropertyDataV8> properties;
    helpers::Ptr<ModelCloudDataV8> cloudData;

public:
    ModelFileDataV8();
    ModelFileDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV8(const ModelFileDataV8 &p_other);
    ModelFileDataV8 &operator=(const ModelFileDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<7>{
struct ModelTextureDataV7 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV7();
    ModelTextureDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV7(const ModelTextureDataV7 &p_other);
    ModelTextureDataV7 &operator=(const ModelTextureDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV7 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV7();
    ModelConstantDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV7(const ModelConstantDataV7 &p_other);
    ModelConstantDataV7 &operator=(const ModelConstantDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV7 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV7> textures;
    helpers::Array<ModelConstantDataV7> constants;

public:
    ModelMaterialDataV7();
    ModelMaterialDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV7(const ModelMaterialDataV7 &p_other);
    ModelMaterialDataV7 &operator=(const ModelMaterialDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV7 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV7();
    ModelMeshDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV7(const ModelMeshDataV7 &p_other);
    ModelMeshDataV7 &operator=(const ModelMeshDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV7 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV7();
    ModelVisTrackDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV7(const ModelVisTrackDataV7 &p_other);
    ModelVisTrackDataV7 &operator=(const ModelVisTrackDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV7 {
    qword token;
    PackGrannyAnimationTypeV0 animation;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV7> visTrackData;

public:
    ModelAnimationDataV7();
    ModelAnimationDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV7(const ModelAnimationDataV7 &p_other);
    ModelAnimationDataV7 &operator=(const ModelAnimationDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV7 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV7();
    ModelAnimationImportDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV7(const ModelAnimationImportDataV7 &p_other);
    ModelAnimationImportDataV7 &operator=(const ModelAnimationImportDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV7 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV7();
    ModelTransformDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV7(const ModelTransformDataV7 &p_other);
    ModelTransformDataV7 &operator=(const ModelTransformDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV7 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV7 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV7();
    ModelBoneDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV7(const ModelBoneDataV7 &p_other);
    ModelBoneDataV7 &operator=(const ModelBoneDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV7 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV7> Bones;
    dword LODType;

public:
    ModelSkeletonDataV7();
    ModelSkeletonDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV7(const ModelSkeletonDataV7 &p_other);
    ModelSkeletonDataV7 &operator=(const ModelSkeletonDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV7 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV7();
    ModelMeshBindingDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV7(const ModelMeshBindingDataV7 &p_other);
    ModelMeshBindingDataV7 &operator=(const ModelMeshBindingDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV7 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV7> Skeleton;
    ModelTransformDataV7 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV7> MeshBindings;
    helpers::Array<dword> boneFlags;

public:
    ModelModelDataV7();
    ModelModelDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV7(const ModelModelDataV7 &p_other);
    ModelModelDataV7 &operator=(const ModelModelDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV7 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV7();
    ModelFloatPropertyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV7(const ModelFloatPropertyDataV7 &p_other);
    ModelFloatPropertyDataV7 &operator=(const ModelFloatPropertyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV7 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV7> floatValues;

public:
    ModelPropertyDataV7();
    ModelPropertyDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV7(const ModelPropertyDataV7 &p_other);
    ModelPropertyDataV7 &operator=(const ModelPropertyDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV7 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV7();
    ModelCollisionMeshV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV7(const ModelCollisionMeshV7 &p_other);
    ModelCollisionMeshV7 &operator=(const ModelCollisionMeshV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV7 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV7();
    ModelCollisionCloudV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV7(const ModelCollisionCloudV7 &p_other);
    ModelCollisionCloudV7 &operator=(const ModelCollisionCloudV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV7 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV7();
    ModelCollisionCubeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV7(const ModelCollisionCubeV7 &p_other);
    ModelCollisionCubeV7 &operator=(const ModelCollisionCubeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV7 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV7();
    ModelCollisionSphereV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV7(const ModelCollisionSphereV7 &p_other);
    ModelCollisionSphereV7 &operator=(const ModelCollisionSphereV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV7 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV7();
    ModelCollisionSurfaceV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV7(const ModelCollisionSurfaceV7 &p_other);
    ModelCollisionSurfaceV7 &operator=(const ModelCollisionSurfaceV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV7 {
    helpers::Array<ModelCollisionMeshV7> meshes;
    helpers::Array<ModelCollisionCloudV7> clouds;
    helpers::Array<ModelCollisionCubeV7> cubes;
    helpers::Array<ModelCollisionSphereV7> spheres;
    helpers::Array<ModelCollisionSurfaceV7> surfaces;

public:
    ModelCollisionDataV7();
    ModelCollisionDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV7(const ModelCollisionDataV7 &p_other);
    ModelCollisionDataV7 &operator=(const ModelCollisionDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV7 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV7();
    ModelParticleFlipbookV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV7(const ModelParticleFlipbookV7 &p_other);
    ModelParticleFlipbookV7 &operator=(const ModelParticleFlipbookV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV7 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV7> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV7();
    ModelParticleCloudV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV7(const ModelParticleCloudV7 &p_other);
    ModelParticleCloudV7 &operator=(const ModelParticleCloudV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV7 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    dword visBoneIndex;

public:
    ModelParticleEmitterV7();
    ModelParticleEmitterV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV7(const ModelParticleEmitterV7 &p_other);
    ModelParticleEmitterV7 &operator=(const ModelParticleEmitterV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV7 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV7();
    ModelParticleObstacleV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV7(const ModelParticleObstacleV7 &p_other);
    ModelParticleObstacleV7 &operator=(const ModelParticleObstacleV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV7 {
    helpers::Array<ModelParticleCloudV7> clouds;
    helpers::Array<ModelParticleEmitterV7> emitters;
    helpers::Array<ModelParticleObstacleV7> obstacles;

public:
    ModelCloudDataV7();
    ModelCloudDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV7(const ModelCloudDataV7 &p_other);
    ModelCloudDataV7 &operator=(const ModelCloudDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV7 {
    helpers::Ptr<ModelMaterialDataV7> materials;
    helpers::Ptr<ModelMeshDataV7> meshes;
    helpers::Ptr<ModelAnimationDataV7> animations;
    helpers::Array<qword> animationFallbacks;
    helpers::Array<ModelAnimationImportDataV7> animationImports;
    helpers::Ptr<ModelModelDataV7> model;
    helpers::Ptr<ModelPropertyDataV7> properties;
    helpers::Ptr<ModelCollisionDataV7> collisionData;
    helpers::Ptr<ModelCloudDataV7> cloudData;

public:
    ModelFileDataV7();
    ModelFileDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV7(const ModelFileDataV7 &p_other);
    ModelFileDataV7 &operator=(const ModelFileDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x410DB9A000000001 */

template <>
struct Gw2StructMODL<6>{
struct ModelTextureDataV6 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV6();
    ModelTextureDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV6(const ModelTextureDataV6 &p_other);
    ModelTextureDataV6 &operator=(const ModelTextureDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV6 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV6();
    ModelConstantDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV6(const ModelConstantDataV6 &p_other);
    ModelConstantDataV6 &operator=(const ModelConstantDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV6 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV6> textures;
    helpers::Array<ModelConstantDataV6> constants;

public:
    ModelMaterialDataV6();
    ModelMaterialDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV6(const ModelMaterialDataV6 &p_other);
    ModelMaterialDataV6 &operator=(const ModelMaterialDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV6 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<dword> visBoneIndices;

public:
    ModelMeshDataV6();
    ModelMeshDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV6(const ModelMeshDataV6 &p_other);
    ModelMeshDataV6 &operator=(const ModelMeshDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV6 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV6();
    ModelVisTrackDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV6(const ModelVisTrackDataV6 &p_other);
    ModelVisTrackDataV6 &operator=(const ModelVisTrackDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV6 {
    qword token;
    PackGrannyAnimationTypeV0 animation;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV6> visTrackData;

public:
    ModelAnimationDataV6();
    ModelAnimationDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV6(const ModelAnimationDataV6 &p_other);
    ModelAnimationDataV6 &operator=(const ModelAnimationDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV6 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV6();
    ModelAnimationImportDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV6(const ModelAnimationImportDataV6 &p_other);
    ModelAnimationImportDataV6 &operator=(const ModelAnimationImportDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV6 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV6();
    ModelTransformDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV6(const ModelTransformDataV6 &p_other);
    ModelTransformDataV6 &operator=(const ModelTransformDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV6 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV6 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV6();
    ModelBoneDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV6(const ModelBoneDataV6 &p_other);
    ModelBoneDataV6 &operator=(const ModelBoneDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV6 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV6> Bones;
    dword LODType;

public:
    ModelSkeletonDataV6();
    ModelSkeletonDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV6(const ModelSkeletonDataV6 &p_other);
    ModelSkeletonDataV6 &operator=(const ModelSkeletonDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV6 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV6();
    ModelMeshBindingDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV6(const ModelMeshBindingDataV6 &p_other);
    ModelMeshBindingDataV6 &operator=(const ModelMeshBindingDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV6 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV6> Skeleton;
    ModelTransformDataV6 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV6> MeshBindings;

public:
    ModelModelDataV6();
    ModelModelDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV6(const ModelModelDataV6 &p_other);
    ModelModelDataV6 &operator=(const ModelModelDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV6 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV6();
    ModelFloatPropertyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV6(const ModelFloatPropertyDataV6 &p_other);
    ModelFloatPropertyDataV6 &operator=(const ModelFloatPropertyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV6 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV6> floatValues;

public:
    ModelPropertyDataV6();
    ModelPropertyDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV6(const ModelPropertyDataV6 &p_other);
    ModelPropertyDataV6 &operator=(const ModelPropertyDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV6 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV6();
    ModelCollisionMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV6(const ModelCollisionMeshV6 &p_other);
    ModelCollisionMeshV6 &operator=(const ModelCollisionMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV6 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV6();
    ModelCollisionCloudV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV6(const ModelCollisionCloudV6 &p_other);
    ModelCollisionCloudV6 &operator=(const ModelCollisionCloudV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV6 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV6();
    ModelCollisionCubeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV6(const ModelCollisionCubeV6 &p_other);
    ModelCollisionCubeV6 &operator=(const ModelCollisionCubeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV6 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV6();
    ModelCollisionSphereV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV6(const ModelCollisionSphereV6 &p_other);
    ModelCollisionSphereV6 &operator=(const ModelCollisionSphereV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV6();
    ModelCollisionSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV6(const ModelCollisionSurfaceV6 &p_other);
    ModelCollisionSurfaceV6 &operator=(const ModelCollisionSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV6 {
    helpers::Array<ModelCollisionMeshV6> meshes;
    helpers::Array<ModelCollisionCloudV6> clouds;
    helpers::Array<ModelCollisionCubeV6> cubes;
    helpers::Array<ModelCollisionSphereV6> spheres;
    helpers::Array<ModelCollisionSurfaceV6> surfaces;

public:
    ModelCollisionDataV6();
    ModelCollisionDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV6(const ModelCollisionDataV6 &p_other);
    ModelCollisionDataV6 &operator=(const ModelCollisionDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV6 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV6();
    ModelParticleFlipbookV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV6(const ModelParticleFlipbookV6 &p_other);
    ModelParticleFlipbookV6 &operator=(const ModelParticleFlipbookV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV6 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV6> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV6();
    ModelParticleCloudV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV6(const ModelParticleCloudV6 &p_other);
    ModelParticleCloudV6 &operator=(const ModelParticleCloudV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV6 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;
    dword visBoneIndex;

public:
    ModelParticleEmitterV6();
    ModelParticleEmitterV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV6(const ModelParticleEmitterV6 &p_other);
    ModelParticleEmitterV6 &operator=(const ModelParticleEmitterV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV6 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;
    dword visBoneIndex;

public:
    ModelParticleObstacleV6();
    ModelParticleObstacleV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV6(const ModelParticleObstacleV6 &p_other);
    ModelParticleObstacleV6 &operator=(const ModelParticleObstacleV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV6 {
    helpers::Array<ModelParticleCloudV6> clouds;
    helpers::Array<ModelParticleEmitterV6> emitters;
    helpers::Array<ModelParticleObstacleV6> obstacles;

public:
    ModelCloudDataV6();
    ModelCloudDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV6(const ModelCloudDataV6 &p_other);
    ModelCloudDataV6 &operator=(const ModelCloudDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV6 {
    helpers::Ptr<ModelMaterialDataV6> materials;
    helpers::Ptr<ModelMeshDataV6> meshes;
    helpers::Ptr<ModelAnimationDataV6> animations;
    helpers::Array<qword> animationFallbacks;
    helpers::Array<ModelAnimationImportDataV6> animationImports;
    helpers::Ptr<ModelModelDataV6> model;
    helpers::Ptr<ModelPropertyDataV6> properties;
    helpers::Ptr<ModelCollisionDataV6> collisionData;
    helpers::Ptr<ModelCloudDataV6> cloudData;

public:
    ModelFileDataV6();
    ModelFileDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV6(const ModelFileDataV6 &p_other);
    ModelFileDataV6 &operator=(const ModelFileDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<5>{
struct ModelTextureDataV5 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV5();
    ModelTextureDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV5(const ModelTextureDataV5 &p_other);
    ModelTextureDataV5 &operator=(const ModelTextureDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV5 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV5();
    ModelConstantDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV5(const ModelConstantDataV5 &p_other);
    ModelConstantDataV5 &operator=(const ModelConstantDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV5 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV5> textures;
    helpers::Array<ModelConstantDataV5> constants;

public:
    ModelMaterialDataV5();
    ModelMaterialDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV5(const ModelMaterialDataV5 &p_other);
    ModelMaterialDataV5 &operator=(const ModelMaterialDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV5 {
    PackGrannyMeshType mesh;
    dword flags;
    helpers::Array<qword> visTokens;

public:
    ModelMeshDataV5();
    ModelMeshDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV5(const ModelMeshDataV5 &p_other);
    ModelMeshDataV5 &operator=(const ModelMeshDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV5 {
    qword token;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV5();
    ModelVisTrackDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV5(const ModelVisTrackDataV5 &p_other);
    ModelVisTrackDataV5 &operator=(const ModelVisTrackDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV5 {
    qword token;
    PackGrannyAnimationTypeV0 animation;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV5> visTrackData;

public:
    ModelAnimationDataV5();
    ModelAnimationDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV5(const ModelAnimationDataV5 &p_other);
    ModelAnimationDataV5 &operator=(const ModelAnimationDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV5 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV5();
    ModelTransformDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV5(const ModelTransformDataV5 &p_other);
    ModelTransformDataV5 &operator=(const ModelTransformDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV5 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV5 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV5();
    ModelBoneDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV5(const ModelBoneDataV5 &p_other);
    ModelBoneDataV5 &operator=(const ModelBoneDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV5 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV5> Bones;
    dword LODType;

public:
    ModelSkeletonDataV5();
    ModelSkeletonDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV5(const ModelSkeletonDataV5 &p_other);
    ModelSkeletonDataV5 &operator=(const ModelSkeletonDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV5 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV5();
    ModelMeshBindingDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV5(const ModelMeshBindingDataV5 &p_other);
    ModelMeshBindingDataV5 &operator=(const ModelMeshBindingDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV5 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV5> Skeleton;
    ModelTransformDataV5 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV5> MeshBindings;

public:
    ModelModelDataV5();
    ModelModelDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV5(const ModelModelDataV5 &p_other);
    ModelModelDataV5 &operator=(const ModelModelDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV5 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV5();
    ModelFloatPropertyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV5(const ModelFloatPropertyDataV5 &p_other);
    ModelFloatPropertyDataV5 &operator=(const ModelFloatPropertyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV5 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV5> floatValues;

public:
    ModelPropertyDataV5();
    ModelPropertyDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV5(const ModelPropertyDataV5 &p_other);
    ModelPropertyDataV5 &operator=(const ModelPropertyDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV5 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV5();
    ModelCollisionMeshV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV5(const ModelCollisionMeshV5 &p_other);
    ModelCollisionMeshV5 &operator=(const ModelCollisionMeshV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV5 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV5();
    ModelCollisionCloudV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV5(const ModelCollisionCloudV5 &p_other);
    ModelCollisionCloudV5 &operator=(const ModelCollisionCloudV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV5 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV5();
    ModelCollisionCubeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV5(const ModelCollisionCubeV5 &p_other);
    ModelCollisionCubeV5 &operator=(const ModelCollisionCubeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV5 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV5();
    ModelCollisionSphereV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV5(const ModelCollisionSphereV5 &p_other);
    ModelCollisionSphereV5 &operator=(const ModelCollisionSphereV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV5 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV5();
    ModelCollisionSurfaceV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV5(const ModelCollisionSurfaceV5 &p_other);
    ModelCollisionSurfaceV5 &operator=(const ModelCollisionSurfaceV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV5 {
    helpers::Array<ModelCollisionMeshV5> meshes;
    helpers::Array<ModelCollisionCloudV5> clouds;
    helpers::Array<ModelCollisionCubeV5> cubes;
    helpers::Array<ModelCollisionSphereV5> spheres;
    helpers::Array<ModelCollisionSurfaceV5> surfaces;

public:
    ModelCollisionDataV5();
    ModelCollisionDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV5(const ModelCollisionDataV5 &p_other);
    ModelCollisionDataV5 &operator=(const ModelCollisionDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV5 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV5();
    ModelParticleFlipbookV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV5(const ModelParticleFlipbookV5 &p_other);
    ModelParticleFlipbookV5 &operator=(const ModelParticleFlipbookV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV5 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    dword flags;
    helpers::Array<ModelParticleFlipbookV5> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV5();
    ModelParticleCloudV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV5(const ModelParticleCloudV5 &p_other);
    ModelParticleCloudV5 &operator=(const ModelParticleCloudV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV5 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;

public:
    ModelParticleEmitterV5();
    ModelParticleEmitterV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV5(const ModelParticleEmitterV5 &p_other);
    ModelParticleEmitterV5 &operator=(const ModelParticleEmitterV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV5 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelParticleObstacleV5();
    ModelParticleObstacleV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV5(const ModelParticleObstacleV5 &p_other);
    ModelParticleObstacleV5 &operator=(const ModelParticleObstacleV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV5 {
    helpers::Array<ModelParticleCloudV5> clouds;
    helpers::Array<ModelParticleEmitterV5> emitters;
    helpers::Array<ModelParticleObstacleV5> obstacles;

public:
    ModelCloudDataV5();
    ModelCloudDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV5(const ModelCloudDataV5 &p_other);
    ModelCloudDataV5 &operator=(const ModelCloudDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV5 {
    helpers::Ptr<ModelMaterialDataV5> materials;
    helpers::Ptr<ModelMeshDataV5> meshes;
    helpers::Ptr<ModelAnimationDataV5> animations;
    helpers::Ptr<ModelModelDataV5> model;
    helpers::Ptr<ModelPropertyDataV5> properties;
    helpers::Ptr<ModelCollisionDataV5> collisionData;
    helpers::Ptr<ModelCloudDataV5> cloudData;

public:
    ModelFileDataV5();
    ModelFileDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV5(const ModelFileDataV5 &p_other);
    ModelFileDataV5 &operator=(const ModelFileDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<4>{
struct ModelTextureDataV4 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV4();
    ModelTextureDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV4(const ModelTextureDataV4 &p_other);
    ModelTextureDataV4 &operator=(const ModelTextureDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV4 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV4();
    ModelConstantDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV4(const ModelConstantDataV4 &p_other);
    ModelConstantDataV4 &operator=(const ModelConstantDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV4 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV4> textures;
    helpers::Array<ModelConstantDataV4> constants;

public:
    ModelMaterialDataV4();
    ModelMaterialDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV4(const ModelMaterialDataV4 &p_other);
    ModelMaterialDataV4 &operator=(const ModelMaterialDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV4 {
    PackGrannyMeshType mesh;
    helpers::Array<qword> visTokens;

public:
    ModelMeshDataV4();
    ModelMeshDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV4(const ModelMeshDataV4 &p_other);
    ModelMeshDataV4 &operator=(const ModelMeshDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV4 {
    qword token;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV4();
    ModelVisTrackDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV4(const ModelVisTrackDataV4 &p_other);
    ModelVisTrackDataV4 &operator=(const ModelVisTrackDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV4 {
    qword token;
    PackGrannyAnimationTypeV0 animation;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV4> visTrackData;

public:
    ModelAnimationDataV4();
    ModelAnimationDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV4(const ModelAnimationDataV4 &p_other);
    ModelAnimationDataV4 &operator=(const ModelAnimationDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV4 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV4();
    ModelTransformDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV4(const ModelTransformDataV4 &p_other);
    ModelTransformDataV4 &operator=(const ModelTransformDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV4 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV4 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV4();
    ModelBoneDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV4(const ModelBoneDataV4 &p_other);
    ModelBoneDataV4 &operator=(const ModelBoneDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV4 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV4> Bones;
    dword LODType;

public:
    ModelSkeletonDataV4();
    ModelSkeletonDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV4(const ModelSkeletonDataV4 &p_other);
    ModelSkeletonDataV4 &operator=(const ModelSkeletonDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV4 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV4();
    ModelMeshBindingDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV4(const ModelMeshBindingDataV4 &p_other);
    ModelMeshBindingDataV4 &operator=(const ModelMeshBindingDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV4 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV4> Skeleton;
    ModelTransformDataV4 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV4> MeshBindings;

public:
    ModelModelDataV4();
    ModelModelDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV4(const ModelModelDataV4 &p_other);
    ModelModelDataV4 &operator=(const ModelModelDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV4 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV4();
    ModelFloatPropertyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV4(const ModelFloatPropertyDataV4 &p_other);
    ModelFloatPropertyDataV4 &operator=(const ModelFloatPropertyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV4 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV4> floatValues;

public:
    ModelPropertyDataV4();
    ModelPropertyDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV4(const ModelPropertyDataV4 &p_other);
    ModelPropertyDataV4 &operator=(const ModelPropertyDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV4 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV4();
    ModelCollisionMeshV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV4(const ModelCollisionMeshV4 &p_other);
    ModelCollisionMeshV4 &operator=(const ModelCollisionMeshV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV4 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV4();
    ModelCollisionCloudV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV4(const ModelCollisionCloudV4 &p_other);
    ModelCollisionCloudV4 &operator=(const ModelCollisionCloudV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV4 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV4();
    ModelCollisionCubeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV4(const ModelCollisionCubeV4 &p_other);
    ModelCollisionCubeV4 &operator=(const ModelCollisionCubeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV4 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV4();
    ModelCollisionSphereV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV4(const ModelCollisionSphereV4 &p_other);
    ModelCollisionSphereV4 &operator=(const ModelCollisionSphereV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV4 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV4();
    ModelCollisionSurfaceV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV4(const ModelCollisionSurfaceV4 &p_other);
    ModelCollisionSurfaceV4 &operator=(const ModelCollisionSurfaceV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV4 {
    helpers::Array<ModelCollisionMeshV4> meshes;
    helpers::Array<ModelCollisionCloudV4> clouds;
    helpers::Array<ModelCollisionCubeV4> cubes;
    helpers::Array<ModelCollisionSphereV4> spheres;
    helpers::Array<ModelCollisionSurfaceV4> surfaces;

public:
    ModelCollisionDataV4();
    ModelCollisionDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV4(const ModelCollisionDataV4 &p_other);
    ModelCollisionDataV4 &operator=(const ModelCollisionDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV4 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV4();
    ModelParticleFlipbookV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV4(const ModelParticleFlipbookV4 &p_other);
    ModelParticleFlipbookV4 &operator=(const ModelParticleFlipbookV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV4 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    helpers::Array<ModelParticleFlipbookV4> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV4();
    ModelParticleCloudV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV4(const ModelParticleCloudV4 &p_other);
    ModelParticleCloudV4 &operator=(const ModelParticleCloudV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV4 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;

public:
    ModelParticleEmitterV4();
    ModelParticleEmitterV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV4(const ModelParticleEmitterV4 &p_other);
    ModelParticleEmitterV4 &operator=(const ModelParticleEmitterV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV4 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelParticleObstacleV4();
    ModelParticleObstacleV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV4(const ModelParticleObstacleV4 &p_other);
    ModelParticleObstacleV4 &operator=(const ModelParticleObstacleV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV4 {
    helpers::Array<ModelParticleCloudV4> clouds;
    helpers::Array<ModelParticleEmitterV4> emitters;
    helpers::Array<ModelParticleObstacleV4> obstacles;

public:
    ModelCloudDataV4();
    ModelCloudDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV4(const ModelCloudDataV4 &p_other);
    ModelCloudDataV4 &operator=(const ModelCloudDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV4 {
    helpers::Ptr<ModelMaterialDataV4> materials;
    helpers::Ptr<ModelMeshDataV4> meshes;
    helpers::Ptr<ModelAnimationDataV4> animations;
    helpers::Ptr<ModelModelDataV4> model;
    helpers::Ptr<ModelPropertyDataV4> properties;
    helpers::Ptr<ModelCollisionDataV4> collisionData;
    helpers::Ptr<ModelCloudDataV4> cloudData;

public:
    ModelFileDataV4();
    ModelFileDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV4(const ModelFileDataV4 &p_other);
    ModelFileDataV4 &operator=(const ModelFileDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<3>{
struct ModelTextureDataV3 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV3();
    ModelTextureDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV3(const ModelTextureDataV3 &p_other);
    ModelTextureDataV3 &operator=(const ModelTextureDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV3 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV3();
    ModelConstantDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV3(const ModelConstantDataV3 &p_other);
    ModelConstantDataV3 &operator=(const ModelConstantDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV3 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV3> textures;
    helpers::Array<ModelConstantDataV3> constants;

public:
    ModelMaterialDataV3();
    ModelMaterialDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV3(const ModelMaterialDataV3 &p_other);
    ModelMaterialDataV3 &operator=(const ModelMaterialDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV3 {
    PackGrannyMeshType mesh;

public:
    ModelMeshDataV3();
    ModelMeshDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV3(const ModelMeshDataV3 &p_other);
    ModelMeshDataV3 &operator=(const ModelMeshDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV3 {
    qword token;
    PackGrannyAnimationTypeV0 animation;

public:
    ModelAnimationDataV3();
    ModelAnimationDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV3(const ModelAnimationDataV3 &p_other);
    ModelAnimationDataV3 &operator=(const ModelAnimationDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV3 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV3();
    ModelTransformDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV3(const ModelTransformDataV3 &p_other);
    ModelTransformDataV3 &operator=(const ModelTransformDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV3 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV3 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV3();
    ModelBoneDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV3(const ModelBoneDataV3 &p_other);
    ModelBoneDataV3 &operator=(const ModelBoneDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV3 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV3> Bones;
    dword LODType;

public:
    ModelSkeletonDataV3();
    ModelSkeletonDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV3(const ModelSkeletonDataV3 &p_other);
    ModelSkeletonDataV3 &operator=(const ModelSkeletonDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV3 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV3();
    ModelMeshBindingDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV3(const ModelMeshBindingDataV3 &p_other);
    ModelMeshBindingDataV3 &operator=(const ModelMeshBindingDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV3 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV3> Skeleton;
    ModelTransformDataV3 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV3> MeshBindings;

public:
    ModelModelDataV3();
    ModelModelDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV3(const ModelModelDataV3 &p_other);
    ModelModelDataV3 &operator=(const ModelModelDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV3 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV3();
    ModelFloatPropertyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV3(const ModelFloatPropertyDataV3 &p_other);
    ModelFloatPropertyDataV3 &operator=(const ModelFloatPropertyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV3 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV3> floatValues;

public:
    ModelPropertyDataV3();
    ModelPropertyDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV3(const ModelPropertyDataV3 &p_other);
    ModelPropertyDataV3 &operator=(const ModelPropertyDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV3 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV3();
    ModelCollisionMeshV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV3(const ModelCollisionMeshV3 &p_other);
    ModelCollisionMeshV3 &operator=(const ModelCollisionMeshV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV3 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV3();
    ModelCollisionCloudV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV3(const ModelCollisionCloudV3 &p_other);
    ModelCollisionCloudV3 &operator=(const ModelCollisionCloudV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV3 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV3();
    ModelCollisionCubeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV3(const ModelCollisionCubeV3 &p_other);
    ModelCollisionCubeV3 &operator=(const ModelCollisionCubeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV3 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV3();
    ModelCollisionSphereV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV3(const ModelCollisionSphereV3 &p_other);
    ModelCollisionSphereV3 &operator=(const ModelCollisionSphereV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV3 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV3();
    ModelCollisionSurfaceV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV3(const ModelCollisionSurfaceV3 &p_other);
    ModelCollisionSurfaceV3 &operator=(const ModelCollisionSurfaceV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV3 {
    helpers::Array<ModelCollisionMeshV3> meshes;
    helpers::Array<ModelCollisionCloudV3> clouds;
    helpers::Array<ModelCollisionCubeV3> cubes;
    helpers::Array<ModelCollisionSphereV3> spheres;
    helpers::Array<ModelCollisionSurfaceV3> surfaces;

public:
    ModelCollisionDataV3();
    ModelCollisionDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV3(const ModelCollisionDataV3 &p_other);
    ModelCollisionDataV3 &operator=(const ModelCollisionDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV3 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV3();
    ModelParticleFlipbookV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV3(const ModelParticleFlipbookV3 &p_other);
    ModelParticleFlipbookV3 &operator=(const ModelParticleFlipbookV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV3 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    helpers::Array<ModelParticleFlipbookV3> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV3();
    ModelParticleCloudV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV3(const ModelParticleCloudV3 &p_other);
    ModelParticleCloudV3 &operator=(const ModelParticleCloudV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV3 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;

public:
    ModelParticleEmitterV3();
    ModelParticleEmitterV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV3(const ModelParticleEmitterV3 &p_other);
    ModelParticleEmitterV3 &operator=(const ModelParticleEmitterV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV3 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelParticleObstacleV3();
    ModelParticleObstacleV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV3(const ModelParticleObstacleV3 &p_other);
    ModelParticleObstacleV3 &operator=(const ModelParticleObstacleV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV3 {
    helpers::Array<ModelParticleCloudV3> clouds;
    helpers::Array<ModelParticleEmitterV3> emitters;
    helpers::Array<ModelParticleObstacleV3> obstacles;

public:
    ModelCloudDataV3();
    ModelCloudDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV3(const ModelCloudDataV3 &p_other);
    ModelCloudDataV3 &operator=(const ModelCloudDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV3 {
    helpers::Ptr<ModelMaterialDataV3> materials;
    helpers::Ptr<ModelMeshDataV3> meshes;
    helpers::Ptr<ModelAnimationDataV3> animations;
    helpers::Ptr<ModelModelDataV3> model;
    helpers::Ptr<ModelPropertyDataV3> properties;
    helpers::Ptr<ModelCollisionDataV3> collisionData;
    helpers::Ptr<ModelCloudDataV3> cloudData;

public:
    ModelFileDataV3();
    ModelFileDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV3(const ModelFileDataV3 &p_other);
    ModelFileDataV3 &operator=(const ModelFileDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<2>{
struct ModelTextureDataV2 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV2();
    ModelTextureDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV2(const ModelTextureDataV2 &p_other);
    ModelTextureDataV2 &operator=(const ModelTextureDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV2 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV2();
    ModelConstantDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV2(const ModelConstantDataV2 &p_other);
    ModelConstantDataV2 &operator=(const ModelConstantDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV2 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV2> textures;
    helpers::Array<ModelConstantDataV2> constants;

public:
    ModelMaterialDataV2();
    ModelMaterialDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV2(const ModelMaterialDataV2 &p_other);
    ModelMaterialDataV2 &operator=(const ModelMaterialDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV2 {
    PackGrannyMeshType mesh;

public:
    ModelMeshDataV2();
    ModelMeshDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV2(const ModelMeshDataV2 &p_other);
    ModelMeshDataV2 &operator=(const ModelMeshDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV2 {
    qword token;
    PackGrannyAnimationTypeV0 animation;

public:
    ModelAnimationDataV2();
    ModelAnimationDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV2(const ModelAnimationDataV2 &p_other);
    ModelAnimationDataV2 &operator=(const ModelAnimationDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV2 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV2();
    ModelTransformDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV2(const ModelTransformDataV2 &p_other);
    ModelTransformDataV2 &operator=(const ModelTransformDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV2 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV2 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV2();
    ModelBoneDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV2(const ModelBoneDataV2 &p_other);
    ModelBoneDataV2 &operator=(const ModelBoneDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV2 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV2> Bones;
    dword LODType;

public:
    ModelSkeletonDataV2();
    ModelSkeletonDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV2(const ModelSkeletonDataV2 &p_other);
    ModelSkeletonDataV2 &operator=(const ModelSkeletonDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV2 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV2();
    ModelMeshBindingDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV2(const ModelMeshBindingDataV2 &p_other);
    ModelMeshBindingDataV2 &operator=(const ModelMeshBindingDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV2 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV2> Skeleton;
    ModelTransformDataV2 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV2> MeshBindings;

public:
    ModelModelDataV2();
    ModelModelDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV2(const ModelModelDataV2 &p_other);
    ModelModelDataV2 &operator=(const ModelModelDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV2 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV2();
    ModelFloatPropertyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV2(const ModelFloatPropertyDataV2 &p_other);
    ModelFloatPropertyDataV2 &operator=(const ModelFloatPropertyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV2 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV2> floatValues;

public:
    ModelPropertyDataV2();
    ModelPropertyDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV2(const ModelPropertyDataV2 &p_other);
    ModelPropertyDataV2 &operator=(const ModelPropertyDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV2 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV2();
    ModelCollisionMeshV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV2(const ModelCollisionMeshV2 &p_other);
    ModelCollisionMeshV2 &operator=(const ModelCollisionMeshV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV2 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV2();
    ModelCollisionCloudV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV2(const ModelCollisionCloudV2 &p_other);
    ModelCollisionCloudV2 &operator=(const ModelCollisionCloudV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV2 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV2();
    ModelCollisionSurfaceV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV2(const ModelCollisionSurfaceV2 &p_other);
    ModelCollisionSurfaceV2 &operator=(const ModelCollisionSurfaceV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionDataV2 {
    helpers::Array<ModelCollisionMeshV2> meshes;
    helpers::Array<ModelCollisionCloudV2> clouds;
    helpers::Array<ModelCollisionSurfaceV2> surfaces;

public:
    ModelCollisionDataV2();
    ModelCollisionDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionDataV2(const ModelCollisionDataV2 &p_other);
    ModelCollisionDataV2 &operator=(const ModelCollisionDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleFlipbookV2 {
    byte columns;
    byte count;
    byte flags;
    dword fps;
    byte rows;
    byte start;

public:
    ModelParticleFlipbookV2();
    ModelParticleFlipbookV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleFlipbookV2(const ModelParticleFlipbookV2 &p_other);
    ModelParticleFlipbookV2 &operator=(const ModelParticleFlipbookV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleCloudV2 {
    float3 acceleration;
    qword bone;
    float drag;
    helpers::Array<dword> emitterIndices;
    helpers::Array<ModelParticleFlipbookV2> flipbook;
    dword materialIndex;
    helpers::Array<dword> obstacleIndices;
    byte opacityCurveType;
    helpers::Array<float2> opacityKeys;
    byte scaleCurveType;
    helpers::Array<float2> scaleKeys;

public:
    ModelParticleCloudV2();
    ModelParticleCloudV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleCloudV2(const ModelParticleCloudV2 &p_other);
    ModelParticleCloudV2 &operator=(const ModelParticleCloudV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleEmitterV2 {
    float2 acceleration[4];
    qword bone;
    float4 colorBegin;
    float4 colorEnd;
    float2 colorPeriod;
    dword flags;
    float2 lifetime;
    float2 rotationChange;
    float2 rotationInitial;
    float2 scaleChange[2];
    float2 scaleInitial[2];
    float2 velocity[4];
    float2 velocityDistRange;
    float2 velocityDistSpeed;
    float2 spawnGroupSize;
    float spawnPeriod;
    float spawnProbability;
    float2 spawnRadius;
    byte spawnShape;

public:
    ModelParticleEmitterV2();
    ModelParticleEmitterV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleEmitterV2(const ModelParticleEmitterV2 &p_other);
    ModelParticleEmitterV2 &operator=(const ModelParticleEmitterV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelParticleObstacleV2 {
    qword bone;
    float dragCoef;
    dword flags;
    float3 geoData;
    float gravityCoef;
    byte response;
    byte type;

public:
    ModelParticleObstacleV2();
    ModelParticleObstacleV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelParticleObstacleV2(const ModelParticleObstacleV2 &p_other);
    ModelParticleObstacleV2 &operator=(const ModelParticleObstacleV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudDataV2 {
    helpers::Array<ModelParticleCloudV2> clouds;
    helpers::Array<ModelParticleEmitterV2> emitters;
    helpers::Array<ModelParticleObstacleV2> obstacles;

public:
    ModelCloudDataV2();
    ModelCloudDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudDataV2(const ModelCloudDataV2 &p_other);
    ModelCloudDataV2 &operator=(const ModelCloudDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV2 {
    helpers::Ptr<ModelMaterialDataV2> materials;
    helpers::Ptr<ModelMeshDataV2> meshes;
    helpers::Ptr<ModelAnimationDataV2> animations;
    helpers::Ptr<ModelModelDataV2> model;
    helpers::Ptr<ModelPropertyDataV2> properties;
    helpers::Ptr<ModelCollisionDataV2> collisionData;
    helpers::Ptr<ModelCloudDataV2> cloudData;

public:
    ModelFileDataV2();
    ModelFileDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV2(const ModelFileDataV2 &p_other);
    ModelFileDataV2 &operator=(const ModelFileDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<1>{
struct ModelTextureDataV1 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV1();
    ModelTextureDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV1(const ModelTextureDataV1 &p_other);
    ModelTextureDataV1 &operator=(const ModelTextureDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV1 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV1();
    ModelConstantDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV1(const ModelConstantDataV1 &p_other);
    ModelConstantDataV1 &operator=(const ModelConstantDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV1 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV1> textures;
    helpers::Array<ModelConstantDataV1> constants;

public:
    ModelMaterialDataV1();
    ModelMaterialDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV1(const ModelMaterialDataV1 &p_other);
    ModelMaterialDataV1 &operator=(const ModelMaterialDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV1 {
    PackGrannyMeshType mesh;

public:
    ModelMeshDataV1();
    ModelMeshDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV1(const ModelMeshDataV1 &p_other);
    ModelMeshDataV1 &operator=(const ModelMeshDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV1 {
    qword token;
    PackGrannyAnimationTypeV0 animation;

public:
    ModelAnimationDataV1();
    ModelAnimationDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV1(const ModelAnimationDataV1 &p_other);
    ModelAnimationDataV1 &operator=(const ModelAnimationDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV1 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV1();
    ModelTransformDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV1(const ModelTransformDataV1 &p_other);
    ModelTransformDataV1 &operator=(const ModelTransformDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV1 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV1 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV1();
    ModelBoneDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV1(const ModelBoneDataV1 &p_other);
    ModelBoneDataV1 &operator=(const ModelBoneDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV1 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV1> Bones;
    dword LODType;

public:
    ModelSkeletonDataV1();
    ModelSkeletonDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV1(const ModelSkeletonDataV1 &p_other);
    ModelSkeletonDataV1 &operator=(const ModelSkeletonDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV1 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV1();
    ModelMeshBindingDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV1(const ModelMeshBindingDataV1 &p_other);
    ModelMeshBindingDataV1 &operator=(const ModelMeshBindingDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV1 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV1> Skeleton;
    ModelTransformDataV1 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV1> MeshBindings;

public:
    ModelModelDataV1();
    ModelModelDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV1(const ModelModelDataV1 &p_other);
    ModelModelDataV1 &operator=(const ModelModelDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV1 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV1();
    ModelFloatPropertyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV1(const ModelFloatPropertyDataV1 &p_other);
    ModelFloatPropertyDataV1 &operator=(const ModelFloatPropertyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV1 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV1> floatValues;

public:
    ModelPropertyDataV1();
    ModelPropertyDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV1(const ModelPropertyDataV1 &p_other);
    ModelPropertyDataV1 &operator=(const ModelPropertyDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelChunkCollisionMeshV1 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelChunkCollisionMeshV1();
    ModelChunkCollisionMeshV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelChunkCollisionMeshV1(const ModelChunkCollisionMeshV1 &p_other);
    ModelChunkCollisionMeshV1 &operator=(const ModelChunkCollisionMeshV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelChunkCollisionCloudV1 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelChunkCollisionCloudV1();
    ModelChunkCollisionCloudV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelChunkCollisionCloudV1(const ModelChunkCollisionCloudV1 &p_other);
    ModelChunkCollisionCloudV1 &operator=(const ModelChunkCollisionCloudV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelChunkCollisionSurfaceV1 {
    helpers::Array<qword> tokens;

public:
    ModelChunkCollisionSurfaceV1();
    ModelChunkCollisionSurfaceV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelChunkCollisionSurfaceV1(const ModelChunkCollisionSurfaceV1 &p_other);
    ModelChunkCollisionSurfaceV1 &operator=(const ModelChunkCollisionSurfaceV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelChunkCollisionDataV1 {
    helpers::Array<ModelChunkCollisionMeshV1> meshes;
    helpers::Array<ModelChunkCollisionCloudV1> clouds;
    helpers::Array<ModelChunkCollisionSurfaceV1> surfaces;

public:
    ModelChunkCollisionDataV1();
    ModelChunkCollisionDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelChunkCollisionDataV1(const ModelChunkCollisionDataV1 &p_other);
    ModelChunkCollisionDataV1 &operator=(const ModelChunkCollisionDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV1 {
    helpers::Ptr<ModelMaterialDataV1> materials;
    helpers::Ptr<ModelMeshDataV1> meshes;
    helpers::Ptr<ModelAnimationDataV1> animations;
    helpers::Ptr<ModelModelDataV1> model;
    helpers::Ptr<ModelPropertyDataV1> properties;
    helpers::Ptr<ModelChunkCollisionDataV1> collisionData;

public:
    ModelFileDataV1();
    ModelFileDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV1(const ModelFileDataV1 &p_other);
    ModelFileDataV1 &operator=(const ModelFileDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMODL<0>{
struct ModelTextureDataV0 {
    helpers::FileName filename;
    dword textureFlags;
    qword token;
    qword blitId;

public:
    ModelTextureDataV0();
    ModelTextureDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTextureDataV0(const ModelTextureDataV0 &p_other);
    ModelTextureDataV0 &operator=(const ModelTextureDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelConstantDataV0 {
    dword name;
    float4 value;
    dword constantFlags;

public:
    ModelConstantDataV0();
    ModelConstantDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelConstantDataV0(const ModelConstantDataV0 &p_other);
    ModelConstantDataV0 &operator=(const ModelConstantDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMaterialDataV0 {
    helpers::FileName filename;
    dword materialFlags;
    dword sortOrder;
    helpers::Array<ModelTextureDataV0> textures;
    helpers::Array<ModelConstantDataV0> constants;

public:
    ModelMaterialDataV0();
    ModelMaterialDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMaterialDataV0(const ModelMaterialDataV0 &p_other);
    ModelMaterialDataV0 &operator=(const ModelMaterialDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMeshType {
    helpers::Array<byte> mesh;

public:
    PackGrannyMeshType();
    PackGrannyMeshType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMeshType(const PackGrannyMeshType &p_other);
    PackGrannyMeshType &operator=(const PackGrannyMeshType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV0 {
    PackGrannyMeshType mesh;

public:
    ModelMeshDataV0();
    ModelMeshDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV0(const ModelMeshDataV0 &p_other);
    ModelMeshDataV0 &operator=(const ModelMeshDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV0 {
    qword token;
    PackGrannyAnimationTypeV0 animation;

public:
    ModelAnimationDataV0();
    ModelAnimationDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV0(const ModelAnimationDataV0 &p_other);
    ModelAnimationDataV0 &operator=(const ModelAnimationDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTransformDataV0 {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformDataV0();
    ModelTransformDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformDataV0(const ModelTransformDataV0 &p_other);
    ModelTransformDataV0 &operator=(const ModelTransformDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneDataV0 {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformDataV0 LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneDataV0();
    ModelBoneDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneDataV0(const ModelBoneDataV0 &p_other);
    ModelBoneDataV0 &operator=(const ModelBoneDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV0 {
    helpers::String Name;
    helpers::Array<ModelBoneDataV0> Bones;
    dword LODType;

public:
    ModelSkeletonDataV0();
    ModelSkeletonDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV0(const ModelSkeletonDataV0 &p_other);
    ModelSkeletonDataV0 &operator=(const ModelSkeletonDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingDataV0 {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingDataV0();
    ModelMeshBindingDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingDataV0(const ModelMeshBindingDataV0 &p_other);
    ModelMeshBindingDataV0 &operator=(const ModelMeshBindingDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelModelDataV0 {
    helpers::String Name;
    helpers::Ptr<ModelSkeletonDataV0> Skeleton;
    ModelTransformDataV0 InitialPlacement;
    helpers::Array<ModelMeshBindingDataV0> MeshBindings;

public:
    ModelModelDataV0();
    ModelModelDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelModelDataV0(const ModelModelDataV0 &p_other);
    ModelModelDataV0 &operator=(const ModelModelDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFloatPropertyDataV0 {
    qword token;
    float value;

public:
    ModelFloatPropertyDataV0();
    ModelFloatPropertyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFloatPropertyDataV0(const ModelFloatPropertyDataV0 &p_other);
    ModelFloatPropertyDataV0 &operator=(const ModelFloatPropertyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyDataV0 {
    helpers::Array<qword> boolTokens;
    helpers::Array<ModelFloatPropertyDataV0> floatValues;

public:
    ModelPropertyDataV0();
    ModelPropertyDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyDataV0(const ModelPropertyDataV0 &p_other);
    ModelPropertyDataV0 &operator=(const ModelPropertyDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileDataV0 {
    helpers::Ptr<ModelMaterialDataV0> materials;
    helpers::Ptr<ModelMeshDataV0> meshes;
    helpers::Ptr<ModelAnimationDataV0> animations;
    helpers::Ptr<ModelModelDataV0> model;
    helpers::Ptr<ModelPropertyDataV0> properties;

public:
    ModelFileDataV0();
    ModelFileDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileDataV0(const ModelFileDataV0 &p_other);
    ModelFileDataV0 &operator=(const ModelFileDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileDataV0 Gw2Struct;
};


/* ===============================================
 * Chunk: ANIM, versions: 26, strucTab: 0x14218F750
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructANIM;

/* Version: 25, ReferencedFunction: 0x410D63C000000001 */

template <>
struct Gw2StructANIM<25>{
struct PackGrannyAnimationTypeV1 {
    helpers::Array<byte> animation;
    helpers::Array<dword> pointers;

public:
    PackGrannyAnimationTypeV1();
    PackGrannyAnimationTypeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV1(const PackGrannyAnimationTypeV1 &p_other);
    PackGrannyAnimationTypeV1 &operator=(const PackGrannyAnimationTypeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationLodV25 {
    PackGrannyAnimationTypeV1 data;
    helpers::FileName fileFull;

public:
    ModelAnimationLodV25();
    ModelAnimationLodV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationLodV25(const ModelAnimationLodV25 &p_other);
    ModelAnimationLodV25 &operator=(const ModelAnimationLodV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV33 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV33();
    ModelVisTrackDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV33(const ModelVisTrackDataV33 &p_other);
    ModelVisTrackDataV33 &operator=(const ModelVisTrackDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV25 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV25();
    ModelTrackTypeDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV25(const ModelTrackTypeDataV25 &p_other);
    ModelTrackTypeDataV25 &operator=(const ModelTrackTypeDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV25 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV25> uvTransformData;

public:
    ModelUVAnimationV25();
    ModelUVAnimationV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV25(const ModelUVAnimationV25 &p_other);
    ModelUVAnimationV25 &operator=(const ModelUVAnimationV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> cloudTrackData;

public:
    ModelCloudAnimV25();
    ModelCloudAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV25(const ModelCloudAnimV25 &p_other);
    ModelCloudAnimV25 &operator=(const ModelCloudAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV25 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV25();
    ModelMatConstAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV25(const ModelMatConstAnimV25 &p_other);
    ModelMatConstAnimV25 &operator=(const ModelMatConstAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> lightTrackData;

public:
    ModelLightAnimationV25();
    ModelLightAnimationV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV25(const ModelLightAnimationV25 &p_other);
    ModelLightAnimationV25 &operator=(const ModelLightAnimationV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV25 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV25();
    ModelAnimPropertyDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV25(const ModelAnimPropertyDataV25 &p_other);
    ModelAnimPropertyDataV25 &operator=(const ModelAnimPropertyDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV25 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV25();
    ModelTokenMapAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV25(const ModelTokenMapAnimV25 &p_other);
    ModelTokenMapAnimV25 &operator=(const ModelTokenMapAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> bcTrackData;

public:
    ModelBoneConstraintAnimV25();
    ModelBoneConstraintAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV25(const ModelBoneConstraintAnimV25 &p_other);
    ModelBoneConstraintAnimV25 &operator=(const ModelBoneConstraintAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> anchorTrackData;

public:
    ModelAnchorAnimV25();
    ModelAnchorAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV25(const ModelAnchorAnimV25 &p_other);
    ModelAnchorAnimV25 &operator=(const ModelAnchorAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV25 {
    qword bone;
    helpers::Array<ModelAnchorAnimV25> anchorAnim;

public:
    ModelStreakAnimV25();
    ModelStreakAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV25(const ModelStreakAnimV25 &p_other);
    ModelStreakAnimV25 &operator=(const ModelStreakAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> lightningTrackData;

public:
    ModelLightningAnimV25();
    ModelLightningAnimV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV25(const ModelLightningAnimV25 &p_other);
    ModelLightningAnimV25 &operator=(const ModelLightningAnimV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindAnimationV25 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV25> windTrackData;

public:
    ModelWindAnimationV25();
    ModelWindAnimationV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindAnimationV25(const ModelWindAnimationV25 &p_other);
    ModelWindAnimationV25 &operator=(const ModelWindAnimationV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV33 {
    qword token;
    PackGrannyAnimationTypeV1 data;
    helpers::Ptr<ModelAnimationLodV25> animLod;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV33> visTrackData;
    helpers::Array<ModelUVAnimationV25> uvAnimData;
    helpers::Array<ModelCloudAnimV25> cloudAnim;
    helpers::Array<ModelMatConstAnimV25> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV25> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV25> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV25> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV25> bcAnim;
    helpers::Array<ModelStreakAnimV25> streakAnim;
    helpers::Array<ModelLightningAnimV25> lightningAnim;
    helpers::Array<ModelWindAnimationV25> windAnimData;

public:
    ModelAnimationDataV33();
    ModelAnimationDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV33(const ModelAnimationDataV33 &p_other);
    ModelAnimationDataV33 &operator=(const ModelAnimationDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV25 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV25();
    ModelCompoundAnimationDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV25(const ModelCompoundAnimationDataV25 &p_other);
    ModelCompoundAnimationDataV25 &operator=(const ModelCompoundAnimationDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV25 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV25();
    ModelAnimationImportSequenceV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV25(const ModelAnimationImportSequenceV25 &p_other);
    ModelAnimationImportSequenceV25 &operator=(const ModelAnimationImportSequenceV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV33 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV25> sequences;

public:
    ModelAnimationImportDataV33();
    ModelAnimationImportDataV33(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV33(const ModelAnimationImportDataV33 &p_other);
    ModelAnimationImportDataV33 &operator=(const ModelAnimationImportDataV33 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV25 {
    helpers::Ptr<ModelAnimationDataV33> animations;
    helpers::Array<ModelCompoundAnimationDataV25> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV33> imports;

public:
    ModelFileAnimationBankV25();
    ModelFileAnimationBankV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV25(const ModelFileAnimationBankV25 &p_other);
    ModelFileAnimationBankV25 &operator=(const ModelFileAnimationBankV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationV25 {
    helpers::Ptr<ModelFileAnimationBankV25> bank;
    PackGrannyAnimationTypeV1 anim;

public:
    ModelFileAnimationV25();
    ModelFileAnimationV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationV25(const ModelFileAnimationV25 &p_other);
    ModelFileAnimationV25 &operator=(const ModelFileAnimationV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationV25 Gw2Struct;
};

/* Version: 24, ReferencedFunction: 0x410D614000000001 */

template <>
struct Gw2StructANIM<24>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationLodV24 {
    PackGrannyAnimationTypeV0 data;
    helpers::FileName fileFull;

public:
    ModelAnimationLodV24();
    ModelAnimationLodV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationLodV24(const ModelAnimationLodV24 &p_other);
    ModelAnimationLodV24 &operator=(const ModelAnimationLodV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV32 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV32();
    ModelVisTrackDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV32(const ModelVisTrackDataV32 &p_other);
    ModelVisTrackDataV32 &operator=(const ModelVisTrackDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV24 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV24();
    ModelTrackTypeDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV24(const ModelTrackTypeDataV24 &p_other);
    ModelTrackTypeDataV24 &operator=(const ModelTrackTypeDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV24 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV24> uvTransformData;

public:
    ModelUVAnimationV24();
    ModelUVAnimationV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV24(const ModelUVAnimationV24 &p_other);
    ModelUVAnimationV24 &operator=(const ModelUVAnimationV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> cloudTrackData;

public:
    ModelCloudAnimV24();
    ModelCloudAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV24(const ModelCloudAnimV24 &p_other);
    ModelCloudAnimV24 &operator=(const ModelCloudAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV24 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV24();
    ModelMatConstAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV24(const ModelMatConstAnimV24 &p_other);
    ModelMatConstAnimV24 &operator=(const ModelMatConstAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> lightTrackData;

public:
    ModelLightAnimationV24();
    ModelLightAnimationV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV24(const ModelLightAnimationV24 &p_other);
    ModelLightAnimationV24 &operator=(const ModelLightAnimationV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV24 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV24();
    ModelAnimPropertyDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV24(const ModelAnimPropertyDataV24 &p_other);
    ModelAnimPropertyDataV24 &operator=(const ModelAnimPropertyDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV24 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV24();
    ModelTokenMapAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV24(const ModelTokenMapAnimV24 &p_other);
    ModelTokenMapAnimV24 &operator=(const ModelTokenMapAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> bcTrackData;

public:
    ModelBoneConstraintAnimV24();
    ModelBoneConstraintAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV24(const ModelBoneConstraintAnimV24 &p_other);
    ModelBoneConstraintAnimV24 &operator=(const ModelBoneConstraintAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> anchorTrackData;

public:
    ModelAnchorAnimV24();
    ModelAnchorAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV24(const ModelAnchorAnimV24 &p_other);
    ModelAnchorAnimV24 &operator=(const ModelAnchorAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV24 {
    qword bone;
    helpers::Array<ModelAnchorAnimV24> anchorAnim;

public:
    ModelStreakAnimV24();
    ModelStreakAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV24(const ModelStreakAnimV24 &p_other);
    ModelStreakAnimV24 &operator=(const ModelStreakAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> lightningTrackData;

public:
    ModelLightningAnimV24();
    ModelLightningAnimV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV24(const ModelLightningAnimV24 &p_other);
    ModelLightningAnimV24 &operator=(const ModelLightningAnimV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindAnimationV24 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV24> windTrackData;

public:
    ModelWindAnimationV24();
    ModelWindAnimationV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindAnimationV24(const ModelWindAnimationV24 &p_other);
    ModelWindAnimationV24 &operator=(const ModelWindAnimationV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV32 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    helpers::Ptr<ModelAnimationLodV24> animLod;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV32> visTrackData;
    helpers::Array<ModelUVAnimationV24> uvAnimData;
    helpers::Array<ModelCloudAnimV24> cloudAnim;
    helpers::Array<ModelMatConstAnimV24> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV24> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV24> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV24> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV24> bcAnim;
    helpers::Array<ModelStreakAnimV24> streakAnim;
    helpers::Array<ModelLightningAnimV24> lightningAnim;
    helpers::Array<ModelWindAnimationV24> windAnimData;

public:
    ModelAnimationDataV32();
    ModelAnimationDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV32(const ModelAnimationDataV32 &p_other);
    ModelAnimationDataV32 &operator=(const ModelAnimationDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV24 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV24();
    ModelCompoundAnimationDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV24(const ModelCompoundAnimationDataV24 &p_other);
    ModelCompoundAnimationDataV24 &operator=(const ModelCompoundAnimationDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV24 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV24();
    ModelAnimationImportSequenceV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV24(const ModelAnimationImportSequenceV24 &p_other);
    ModelAnimationImportSequenceV24 &operator=(const ModelAnimationImportSequenceV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV32 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV24> sequences;

public:
    ModelAnimationImportDataV32();
    ModelAnimationImportDataV32(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV32(const ModelAnimationImportDataV32 &p_other);
    ModelAnimationImportDataV32 &operator=(const ModelAnimationImportDataV32 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV24 {
    helpers::Ptr<ModelAnimationDataV32> animations;
    helpers::Array<ModelCompoundAnimationDataV24> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV32> imports;

public:
    ModelFileAnimationBankV24();
    ModelFileAnimationBankV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV24(const ModelFileAnimationBankV24 &p_other);
    ModelFileAnimationBankV24 &operator=(const ModelFileAnimationBankV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationV24 {
    helpers::Ptr<ModelFileAnimationBankV24> bank;
    PackGrannyAnimationTypeV0 anim;

public:
    ModelFileAnimationV24();
    ModelFileAnimationV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationV24(const ModelFileAnimationV24 &p_other);
    ModelFileAnimationV24 &operator=(const ModelFileAnimationV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationV24 Gw2Struct;
};

/* Version: 23, ReferencedFunction: 0x410D5F0000000001 */

template <>
struct Gw2StructANIM<23>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV31 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV31();
    ModelVisTrackDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV31(const ModelVisTrackDataV31 &p_other);
    ModelVisTrackDataV31 &operator=(const ModelVisTrackDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV23 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV23();
    ModelTrackTypeDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV23(const ModelTrackTypeDataV23 &p_other);
    ModelTrackTypeDataV23 &operator=(const ModelTrackTypeDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV23 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV23> uvTransformData;

public:
    ModelUVAnimationV23();
    ModelUVAnimationV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV23(const ModelUVAnimationV23 &p_other);
    ModelUVAnimationV23 &operator=(const ModelUVAnimationV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> cloudTrackData;

public:
    ModelCloudAnimV23();
    ModelCloudAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV23(const ModelCloudAnimV23 &p_other);
    ModelCloudAnimV23 &operator=(const ModelCloudAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV23 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV23();
    ModelMatConstAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV23(const ModelMatConstAnimV23 &p_other);
    ModelMatConstAnimV23 &operator=(const ModelMatConstAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> lightTrackData;

public:
    ModelLightAnimationV23();
    ModelLightAnimationV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV23(const ModelLightAnimationV23 &p_other);
    ModelLightAnimationV23 &operator=(const ModelLightAnimationV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV23 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV23();
    ModelAnimPropertyDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV23(const ModelAnimPropertyDataV23 &p_other);
    ModelAnimPropertyDataV23 &operator=(const ModelAnimPropertyDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV23 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV23();
    ModelTokenMapAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV23(const ModelTokenMapAnimV23 &p_other);
    ModelTokenMapAnimV23 &operator=(const ModelTokenMapAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> bcTrackData;

public:
    ModelBoneConstraintAnimV23();
    ModelBoneConstraintAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV23(const ModelBoneConstraintAnimV23 &p_other);
    ModelBoneConstraintAnimV23 &operator=(const ModelBoneConstraintAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> anchorTrackData;

public:
    ModelAnchorAnimV23();
    ModelAnchorAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV23(const ModelAnchorAnimV23 &p_other);
    ModelAnchorAnimV23 &operator=(const ModelAnchorAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV23 {
    qword bone;
    helpers::Array<ModelAnchorAnimV23> anchorAnim;

public:
    ModelStreakAnimV23();
    ModelStreakAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV23(const ModelStreakAnimV23 &p_other);
    ModelStreakAnimV23 &operator=(const ModelStreakAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> lightningTrackData;

public:
    ModelLightningAnimV23();
    ModelLightningAnimV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV23(const ModelLightningAnimV23 &p_other);
    ModelLightningAnimV23 &operator=(const ModelLightningAnimV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindAnimationV23 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV23> windTrackData;

public:
    ModelWindAnimationV23();
    ModelWindAnimationV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindAnimationV23(const ModelWindAnimationV23 &p_other);
    ModelWindAnimationV23 &operator=(const ModelWindAnimationV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV31 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV31> visTrackData;
    helpers::Array<ModelUVAnimationV23> uvAnimData;
    helpers::Array<ModelCloudAnimV23> cloudAnim;
    helpers::Array<ModelMatConstAnimV23> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV23> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV23> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV23> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV23> bcAnim;
    helpers::Array<ModelStreakAnimV23> streakAnim;
    helpers::Array<ModelLightningAnimV23> lightningAnim;
    helpers::Array<ModelWindAnimationV23> windAnimData;

public:
    ModelAnimationDataV31();
    ModelAnimationDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV31(const ModelAnimationDataV31 &p_other);
    ModelAnimationDataV31 &operator=(const ModelAnimationDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV23 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV23();
    ModelCompoundAnimationDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV23(const ModelCompoundAnimationDataV23 &p_other);
    ModelCompoundAnimationDataV23 &operator=(const ModelCompoundAnimationDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV23 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV23();
    ModelAnimationImportSequenceV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV23(const ModelAnimationImportSequenceV23 &p_other);
    ModelAnimationImportSequenceV23 &operator=(const ModelAnimationImportSequenceV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV31 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV23> sequences;

public:
    ModelAnimationImportDataV31();
    ModelAnimationImportDataV31(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV31(const ModelAnimationImportDataV31 &p_other);
    ModelAnimationImportDataV31 &operator=(const ModelAnimationImportDataV31 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV23 {
    helpers::Ptr<ModelAnimationDataV31> animations;
    helpers::Array<ModelCompoundAnimationDataV23> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV31> imports;

public:
    ModelFileAnimationBankV23();
    ModelFileAnimationBankV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV23(const ModelFileAnimationBankV23 &p_other);
    ModelFileAnimationBankV23 &operator=(const ModelFileAnimationBankV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV23 Gw2Struct;
};

/* Version: 22, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<22>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV30 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV30();
    ModelVisTrackDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV30(const ModelVisTrackDataV30 &p_other);
    ModelVisTrackDataV30 &operator=(const ModelVisTrackDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV22 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV22();
    ModelTrackTypeDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV22(const ModelTrackTypeDataV22 &p_other);
    ModelTrackTypeDataV22 &operator=(const ModelTrackTypeDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV22 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV22> uvTransformData;

public:
    ModelUVAnimationV22();
    ModelUVAnimationV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV22(const ModelUVAnimationV22 &p_other);
    ModelUVAnimationV22 &operator=(const ModelUVAnimationV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> cloudTrackData;

public:
    ModelCloudAnimV22();
    ModelCloudAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV22(const ModelCloudAnimV22 &p_other);
    ModelCloudAnimV22 &operator=(const ModelCloudAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV22 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV22();
    ModelMatConstAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV22(const ModelMatConstAnimV22 &p_other);
    ModelMatConstAnimV22 &operator=(const ModelMatConstAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> lightTrackData;

public:
    ModelLightAnimationV22();
    ModelLightAnimationV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV22(const ModelLightAnimationV22 &p_other);
    ModelLightAnimationV22 &operator=(const ModelLightAnimationV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV22 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV22();
    ModelAnimPropertyDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV22(const ModelAnimPropertyDataV22 &p_other);
    ModelAnimPropertyDataV22 &operator=(const ModelAnimPropertyDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV22 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV22();
    ModelTokenMapAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV22(const ModelTokenMapAnimV22 &p_other);
    ModelTokenMapAnimV22 &operator=(const ModelTokenMapAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> bcTrackData;

public:
    ModelBoneConstraintAnimV22();
    ModelBoneConstraintAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV22(const ModelBoneConstraintAnimV22 &p_other);
    ModelBoneConstraintAnimV22 &operator=(const ModelBoneConstraintAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> anchorTrackData;

public:
    ModelAnchorAnimV22();
    ModelAnchorAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV22(const ModelAnchorAnimV22 &p_other);
    ModelAnchorAnimV22 &operator=(const ModelAnchorAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV22 {
    qword bone;
    helpers::Array<ModelAnchorAnimV22> anchorAnim;

public:
    ModelStreakAnimV22();
    ModelStreakAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV22(const ModelStreakAnimV22 &p_other);
    ModelStreakAnimV22 &operator=(const ModelStreakAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> lightningTrackData;

public:
    ModelLightningAnimV22();
    ModelLightningAnimV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV22(const ModelLightningAnimV22 &p_other);
    ModelLightningAnimV22 &operator=(const ModelLightningAnimV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindAnimationV22 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV22> windTrackData;

public:
    ModelWindAnimationV22();
    ModelWindAnimationV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindAnimationV22(const ModelWindAnimationV22 &p_other);
    ModelWindAnimationV22 &operator=(const ModelWindAnimationV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV30 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV30> visTrackData;
    helpers::Array<ModelUVAnimationV22> uvAnimData;
    helpers::Array<ModelCloudAnimV22> cloudAnim;
    helpers::Array<ModelMatConstAnimV22> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV22> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV22> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV22> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV22> bcAnim;
    helpers::Array<ModelStreakAnimV22> streakAnim;
    helpers::Array<ModelLightningAnimV22> lightningAnim;
    helpers::Array<ModelWindAnimationV22> windAnimData;

public:
    ModelAnimationDataV30();
    ModelAnimationDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV30(const ModelAnimationDataV30 &p_other);
    ModelAnimationDataV30 &operator=(const ModelAnimationDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV22 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV22();
    ModelCompoundAnimationDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV22(const ModelCompoundAnimationDataV22 &p_other);
    ModelCompoundAnimationDataV22 &operator=(const ModelCompoundAnimationDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV22 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV22();
    ModelAnimationImportSequenceV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV22(const ModelAnimationImportSequenceV22 &p_other);
    ModelAnimationImportSequenceV22 &operator=(const ModelAnimationImportSequenceV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV30 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV22> sequences;

public:
    ModelAnimationImportDataV30();
    ModelAnimationImportDataV30(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV30(const ModelAnimationImportDataV30 &p_other);
    ModelAnimationImportDataV30 &operator=(const ModelAnimationImportDataV30 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV22 {
    helpers::Ptr<ModelAnimationDataV30> animations;
    helpers::Array<ModelCompoundAnimationDataV22> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV30> imports;

public:
    ModelFileAnimationBankV22();
    ModelFileAnimationBankV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV22(const ModelFileAnimationBankV22 &p_other);
    ModelFileAnimationBankV22 &operator=(const ModelFileAnimationBankV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV22 Gw2Struct;
};

/* Version: 21, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<21>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV29 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV29();
    ModelVisTrackDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV29(const ModelVisTrackDataV29 &p_other);
    ModelVisTrackDataV29 &operator=(const ModelVisTrackDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV21 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV21();
    ModelTrackTypeDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV21(const ModelTrackTypeDataV21 &p_other);
    ModelTrackTypeDataV21 &operator=(const ModelTrackTypeDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV21 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV21> uvTransformData;

public:
    ModelUVAnimationV21();
    ModelUVAnimationV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV21(const ModelUVAnimationV21 &p_other);
    ModelUVAnimationV21 &operator=(const ModelUVAnimationV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> cloudTrackData;

public:
    ModelCloudAnimV21();
    ModelCloudAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV21(const ModelCloudAnimV21 &p_other);
    ModelCloudAnimV21 &operator=(const ModelCloudAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV21 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV21();
    ModelMatConstAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV21(const ModelMatConstAnimV21 &p_other);
    ModelMatConstAnimV21 &operator=(const ModelMatConstAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> lightTrackData;

public:
    ModelLightAnimationV21();
    ModelLightAnimationV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV21(const ModelLightAnimationV21 &p_other);
    ModelLightAnimationV21 &operator=(const ModelLightAnimationV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV21 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV21();
    ModelAnimPropertyDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV21(const ModelAnimPropertyDataV21 &p_other);
    ModelAnimPropertyDataV21 &operator=(const ModelAnimPropertyDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV21 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV21();
    ModelTokenMapAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV21(const ModelTokenMapAnimV21 &p_other);
    ModelTokenMapAnimV21 &operator=(const ModelTokenMapAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> bcTrackData;

public:
    ModelBoneConstraintAnimV21();
    ModelBoneConstraintAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV21(const ModelBoneConstraintAnimV21 &p_other);
    ModelBoneConstraintAnimV21 &operator=(const ModelBoneConstraintAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> anchorTrackData;

public:
    ModelAnchorAnimV21();
    ModelAnchorAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV21(const ModelAnchorAnimV21 &p_other);
    ModelAnchorAnimV21 &operator=(const ModelAnchorAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV21 {
    qword bone;
    helpers::Array<ModelAnchorAnimV21> anchorAnim;

public:
    ModelStreakAnimV21();
    ModelStreakAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV21(const ModelStreakAnimV21 &p_other);
    ModelStreakAnimV21 &operator=(const ModelStreakAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> lightningTrackData;

public:
    ModelLightningAnimV21();
    ModelLightningAnimV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV21(const ModelLightningAnimV21 &p_other);
    ModelLightningAnimV21 &operator=(const ModelLightningAnimV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelWindAnimationV21 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV21> windTrackData;

public:
    ModelWindAnimationV21();
    ModelWindAnimationV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelWindAnimationV21(const ModelWindAnimationV21 &p_other);
    ModelWindAnimationV21 &operator=(const ModelWindAnimationV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV29 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV29> visTrackData;
    helpers::Array<ModelUVAnimationV21> uvAnimData;
    helpers::Array<ModelCloudAnimV21> cloudAnim;
    helpers::Array<ModelMatConstAnimV21> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV21> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV21> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV21> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV21> bcAnim;
    helpers::Array<ModelStreakAnimV21> streakAnim;
    helpers::Array<ModelLightningAnimV21> lightningAnim;
    helpers::Array<ModelWindAnimationV21> windAnimData;

public:
    ModelAnimationDataV29();
    ModelAnimationDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV29(const ModelAnimationDataV29 &p_other);
    ModelAnimationDataV29 &operator=(const ModelAnimationDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV21 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV21();
    ModelCompoundAnimationDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV21(const ModelCompoundAnimationDataV21 &p_other);
    ModelCompoundAnimationDataV21 &operator=(const ModelCompoundAnimationDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV21 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV21();
    ModelAnimationImportSequenceV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV21(const ModelAnimationImportSequenceV21 &p_other);
    ModelAnimationImportSequenceV21 &operator=(const ModelAnimationImportSequenceV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV29 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV21> sequences;

public:
    ModelAnimationImportDataV29();
    ModelAnimationImportDataV29(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV29(const ModelAnimationImportDataV29 &p_other);
    ModelAnimationImportDataV29 &operator=(const ModelAnimationImportDataV29 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV21 {
    helpers::Ptr<ModelAnimationDataV29> animations;
    helpers::Array<ModelCompoundAnimationDataV21> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV29> imports;
    helpers::FileName modelReference;

public:
    ModelFileAnimationBankV21();
    ModelFileAnimationBankV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV21(const ModelFileAnimationBankV21 &p_other);
    ModelFileAnimationBankV21 &operator=(const ModelFileAnimationBankV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV21 Gw2Struct;
};

/* Version: 20, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<20>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV28 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV28();
    ModelVisTrackDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV28(const ModelVisTrackDataV28 &p_other);
    ModelVisTrackDataV28 &operator=(const ModelVisTrackDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV20 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV20();
    ModelTrackTypeDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV20(const ModelTrackTypeDataV20 &p_other);
    ModelTrackTypeDataV20 &operator=(const ModelTrackTypeDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV20 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV20> uvTransformData;

public:
    ModelUVAnimationV20();
    ModelUVAnimationV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV20(const ModelUVAnimationV20 &p_other);
    ModelUVAnimationV20 &operator=(const ModelUVAnimationV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV20 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV20> cloudTrackData;

public:
    ModelCloudAnimV20();
    ModelCloudAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV20(const ModelCloudAnimV20 &p_other);
    ModelCloudAnimV20 &operator=(const ModelCloudAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV20 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV20();
    ModelMatConstAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV20(const ModelMatConstAnimV20 &p_other);
    ModelMatConstAnimV20 &operator=(const ModelMatConstAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV20 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV20> lightTrackData;

public:
    ModelLightAnimationV20();
    ModelLightAnimationV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV20(const ModelLightAnimationV20 &p_other);
    ModelLightAnimationV20 &operator=(const ModelLightAnimationV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV20 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV20();
    ModelAnimPropertyDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV20(const ModelAnimPropertyDataV20 &p_other);
    ModelAnimPropertyDataV20 &operator=(const ModelAnimPropertyDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV20 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV20();
    ModelTokenMapAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV20(const ModelTokenMapAnimV20 &p_other);
    ModelTokenMapAnimV20 &operator=(const ModelTokenMapAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV20 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV20> bcTrackData;

public:
    ModelBoneConstraintAnimV20();
    ModelBoneConstraintAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV20(const ModelBoneConstraintAnimV20 &p_other);
    ModelBoneConstraintAnimV20 &operator=(const ModelBoneConstraintAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV20 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV20> anchorTrackData;

public:
    ModelAnchorAnimV20();
    ModelAnchorAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV20(const ModelAnchorAnimV20 &p_other);
    ModelAnchorAnimV20 &operator=(const ModelAnchorAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV20 {
    qword bone;
    helpers::Array<ModelAnchorAnimV20> anchorAnim;

public:
    ModelStreakAnimV20();
    ModelStreakAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV20(const ModelStreakAnimV20 &p_other);
    ModelStreakAnimV20 &operator=(const ModelStreakAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightningAnimV20 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV20> lightningTrackData;

public:
    ModelLightningAnimV20();
    ModelLightningAnimV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightningAnimV20(const ModelLightningAnimV20 &p_other);
    ModelLightningAnimV20 &operator=(const ModelLightningAnimV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV28 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV28> visTrackData;
    helpers::Array<ModelUVAnimationV20> uvAnimData;
    helpers::Array<ModelCloudAnimV20> cloudAnim;
    helpers::Array<ModelMatConstAnimV20> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV20> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV20> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV20> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV20> bcAnim;
    helpers::Array<ModelStreakAnimV20> streakAnim;
    helpers::Array<ModelLightningAnimV20> lightningAnim;

public:
    ModelAnimationDataV28();
    ModelAnimationDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV28(const ModelAnimationDataV28 &p_other);
    ModelAnimationDataV28 &operator=(const ModelAnimationDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV20 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV20();
    ModelCompoundAnimationDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV20(const ModelCompoundAnimationDataV20 &p_other);
    ModelCompoundAnimationDataV20 &operator=(const ModelCompoundAnimationDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV20 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV20();
    ModelAnimationImportSequenceV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV20(const ModelAnimationImportSequenceV20 &p_other);
    ModelAnimationImportSequenceV20 &operator=(const ModelAnimationImportSequenceV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV28 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV20> sequences;

public:
    ModelAnimationImportDataV28();
    ModelAnimationImportDataV28(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV28(const ModelAnimationImportDataV28 &p_other);
    ModelAnimationImportDataV28 &operator=(const ModelAnimationImportDataV28 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV20 {
    helpers::Ptr<ModelAnimationDataV28> animations;
    helpers::Array<ModelCompoundAnimationDataV20> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV28> imports;
    helpers::FileName modelReference;

public:
    ModelFileAnimationBankV20();
    ModelFileAnimationBankV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV20(const ModelFileAnimationBankV20 &p_other);
    ModelFileAnimationBankV20 &operator=(const ModelFileAnimationBankV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV20 Gw2Struct;
};

/* Version: 19, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<19>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV27 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV27();
    ModelVisTrackDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV27(const ModelVisTrackDataV27 &p_other);
    ModelVisTrackDataV27 &operator=(const ModelVisTrackDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV19 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV19();
    ModelTrackTypeDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV19(const ModelTrackTypeDataV19 &p_other);
    ModelTrackTypeDataV19 &operator=(const ModelTrackTypeDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV19 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV19> uvTransformData;

public:
    ModelUVAnimationV19();
    ModelUVAnimationV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV19(const ModelUVAnimationV19 &p_other);
    ModelUVAnimationV19 &operator=(const ModelUVAnimationV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV19 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV19> cloudTrackData;

public:
    ModelCloudAnimV19();
    ModelCloudAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV19(const ModelCloudAnimV19 &p_other);
    ModelCloudAnimV19 &operator=(const ModelCloudAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV19 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV19();
    ModelMatConstAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV19(const ModelMatConstAnimV19 &p_other);
    ModelMatConstAnimV19 &operator=(const ModelMatConstAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV19 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV19> lightTrackData;

public:
    ModelLightAnimationV19();
    ModelLightAnimationV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV19(const ModelLightAnimationV19 &p_other);
    ModelLightAnimationV19 &operator=(const ModelLightAnimationV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV19 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV19();
    ModelAnimPropertyDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV19(const ModelAnimPropertyDataV19 &p_other);
    ModelAnimPropertyDataV19 &operator=(const ModelAnimPropertyDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV19 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV19();
    ModelTokenMapAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV19(const ModelTokenMapAnimV19 &p_other);
    ModelTokenMapAnimV19 &operator=(const ModelTokenMapAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV19 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV19> bcTrackData;

public:
    ModelBoneConstraintAnimV19();
    ModelBoneConstraintAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV19(const ModelBoneConstraintAnimV19 &p_other);
    ModelBoneConstraintAnimV19 &operator=(const ModelBoneConstraintAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV19 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV19> anchorTrackData;

public:
    ModelAnchorAnimV19();
    ModelAnchorAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV19(const ModelAnchorAnimV19 &p_other);
    ModelAnchorAnimV19 &operator=(const ModelAnchorAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV19 {
    qword bone;
    helpers::Array<ModelAnchorAnimV19> anchorAnim;

public:
    ModelStreakAnimV19();
    ModelStreakAnimV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV19(const ModelStreakAnimV19 &p_other);
    ModelStreakAnimV19 &operator=(const ModelStreakAnimV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV27 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV27> visTrackData;
    helpers::Array<ModelUVAnimationV19> uvAnimData;
    helpers::Array<ModelCloudAnimV19> cloudAnim;
    helpers::Array<ModelMatConstAnimV19> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV19> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV19> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV19> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV19> bcAnim;
    helpers::Array<ModelStreakAnimV19> streakAnim;

public:
    ModelAnimationDataV27();
    ModelAnimationDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV27(const ModelAnimationDataV27 &p_other);
    ModelAnimationDataV27 &operator=(const ModelAnimationDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV19 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV19();
    ModelCompoundAnimationDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV19(const ModelCompoundAnimationDataV19 &p_other);
    ModelCompoundAnimationDataV19 &operator=(const ModelCompoundAnimationDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV19 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV19();
    ModelAnimationImportSequenceV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV19(const ModelAnimationImportSequenceV19 &p_other);
    ModelAnimationImportSequenceV19 &operator=(const ModelAnimationImportSequenceV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV27 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV19> sequences;

public:
    ModelAnimationImportDataV27();
    ModelAnimationImportDataV27(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV27(const ModelAnimationImportDataV27 &p_other);
    ModelAnimationImportDataV27 &operator=(const ModelAnimationImportDataV27 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV19 {
    helpers::Ptr<ModelAnimationDataV27> animations;
    helpers::Array<ModelCompoundAnimationDataV19> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV27> imports;
    helpers::FileName modelReference;

public:
    ModelFileAnimationBankV19();
    ModelFileAnimationBankV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV19(const ModelFileAnimationBankV19 &p_other);
    ModelFileAnimationBankV19 &operator=(const ModelFileAnimationBankV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV19 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x410D5E3000000001 */

template <>
struct Gw2StructANIM<18>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV26 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV26();
    ModelVisTrackDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV26(const ModelVisTrackDataV26 &p_other);
    ModelVisTrackDataV26 &operator=(const ModelVisTrackDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV18 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV18();
    ModelTrackTypeDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV18(const ModelTrackTypeDataV18 &p_other);
    ModelTrackTypeDataV18 &operator=(const ModelTrackTypeDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV18 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV18> uvTransformData;

public:
    ModelUVAnimationV18();
    ModelUVAnimationV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV18(const ModelUVAnimationV18 &p_other);
    ModelUVAnimationV18 &operator=(const ModelUVAnimationV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV18 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV18> cloudTrackData;

public:
    ModelCloudAnimV18();
    ModelCloudAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV18(const ModelCloudAnimV18 &p_other);
    ModelCloudAnimV18 &operator=(const ModelCloudAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV18 {
    dword materialId;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV18();
    ModelMatConstAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV18(const ModelMatConstAnimV18 &p_other);
    ModelMatConstAnimV18 &operator=(const ModelMatConstAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV18 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV18> lightTrackData;

public:
    ModelLightAnimationV18();
    ModelLightAnimationV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV18(const ModelLightAnimationV18 &p_other);
    ModelLightAnimationV18 &operator=(const ModelLightAnimationV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV18 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV18();
    ModelAnimPropertyDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV18(const ModelAnimPropertyDataV18 &p_other);
    ModelAnimPropertyDataV18 &operator=(const ModelAnimPropertyDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV18 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV18();
    ModelTokenMapAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV18(const ModelTokenMapAnimV18 &p_other);
    ModelTokenMapAnimV18 &operator=(const ModelTokenMapAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV18 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV18> bcTrackData;

public:
    ModelBoneConstraintAnimV18();
    ModelBoneConstraintAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV18(const ModelBoneConstraintAnimV18 &p_other);
    ModelBoneConstraintAnimV18 &operator=(const ModelBoneConstraintAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV18 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV18> anchorTrackData;

public:
    ModelAnchorAnimV18();
    ModelAnchorAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV18(const ModelAnchorAnimV18 &p_other);
    ModelAnchorAnimV18 &operator=(const ModelAnchorAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV18 {
    qword bone;
    helpers::Array<ModelAnchorAnimV18> anchorAnim;

public:
    ModelStreakAnimV18();
    ModelStreakAnimV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV18(const ModelStreakAnimV18 &p_other);
    ModelStreakAnimV18 &operator=(const ModelStreakAnimV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV26 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV26> visTrackData;
    helpers::Array<ModelUVAnimationV18> uvAnimData;
    helpers::Array<ModelCloudAnimV18> cloudAnim;
    helpers::Array<ModelMatConstAnimV18> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV18> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV18> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV18> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV18> bcAnim;
    helpers::Array<ModelStreakAnimV18> streakAnim;

public:
    ModelAnimationDataV26();
    ModelAnimationDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV26(const ModelAnimationDataV26 &p_other);
    ModelAnimationDataV26 &operator=(const ModelAnimationDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV18 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV18();
    ModelCompoundAnimationDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV18(const ModelCompoundAnimationDataV18 &p_other);
    ModelCompoundAnimationDataV18 &operator=(const ModelCompoundAnimationDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV18 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV18();
    ModelAnimationImportSequenceV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV18(const ModelAnimationImportSequenceV18 &p_other);
    ModelAnimationImportSequenceV18 &operator=(const ModelAnimationImportSequenceV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV26 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV18> sequences;

public:
    ModelAnimationImportDataV26();
    ModelAnimationImportDataV26(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV26(const ModelAnimationImportDataV26 &p_other);
    ModelAnimationImportDataV26 &operator=(const ModelAnimationImportDataV26 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV18 {
    helpers::Ptr<ModelAnimationDataV26> animations;
    helpers::Array<ModelCompoundAnimationDataV18> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV26> imports;

public:
    ModelFileAnimationBankV18();
    ModelFileAnimationBankV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV18(const ModelFileAnimationBankV18 &p_other);
    ModelFileAnimationBankV18 &operator=(const ModelFileAnimationBankV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x410D58D000000001 */

template <>
struct Gw2StructANIM<17>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV25 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV25();
    ModelVisTrackDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV25(const ModelVisTrackDataV25 &p_other);
    ModelVisTrackDataV25 &operator=(const ModelVisTrackDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV17 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV17();
    ModelTrackTypeDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV17(const ModelTrackTypeDataV17 &p_other);
    ModelTrackTypeDataV17 &operator=(const ModelTrackTypeDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV17 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV17> uvTransformData;

public:
    ModelUVAnimationV17();
    ModelUVAnimationV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV17(const ModelUVAnimationV17 &p_other);
    ModelUVAnimationV17 &operator=(const ModelUVAnimationV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV17 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV17> cloudTrackData;

public:
    ModelCloudAnimV17();
    ModelCloudAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV17(const ModelCloudAnimV17 &p_other);
    ModelCloudAnimV17 &operator=(const ModelCloudAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV17 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV17();
    ModelMatConstAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV17(const ModelMatConstAnimV17 &p_other);
    ModelMatConstAnimV17 &operator=(const ModelMatConstAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV17 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV17> lightTrackData;

public:
    ModelLightAnimationV17();
    ModelLightAnimationV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV17(const ModelLightAnimationV17 &p_other);
    ModelLightAnimationV17 &operator=(const ModelLightAnimationV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV17 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV17();
    ModelAnimPropertyDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV17(const ModelAnimPropertyDataV17 &p_other);
    ModelAnimPropertyDataV17 &operator=(const ModelAnimPropertyDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV17 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV17();
    ModelTokenMapAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV17(const ModelTokenMapAnimV17 &p_other);
    ModelTokenMapAnimV17 &operator=(const ModelTokenMapAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV17 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV17> bcTrackData;

public:
    ModelBoneConstraintAnimV17();
    ModelBoneConstraintAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV17(const ModelBoneConstraintAnimV17 &p_other);
    ModelBoneConstraintAnimV17 &operator=(const ModelBoneConstraintAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV17 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV17> anchorTrackData;

public:
    ModelAnchorAnimV17();
    ModelAnchorAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV17(const ModelAnchorAnimV17 &p_other);
    ModelAnchorAnimV17 &operator=(const ModelAnchorAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV17 {
    qword bone;
    helpers::Array<ModelAnchorAnimV17> anchorAnim;

public:
    ModelStreakAnimV17();
    ModelStreakAnimV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV17(const ModelStreakAnimV17 &p_other);
    ModelStreakAnimV17 &operator=(const ModelStreakAnimV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV25 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV25> visTrackData;
    helpers::Array<ModelUVAnimationV17> uvAnimData;
    helpers::Array<ModelCloudAnimV17> cloudAnim;
    helpers::Array<ModelMatConstAnimV17> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV17> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV17> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV17> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV17> bcAnim;
    helpers::Array<ModelStreakAnimV17> streakAnim;

public:
    ModelAnimationDataV25();
    ModelAnimationDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV25(const ModelAnimationDataV25 &p_other);
    ModelAnimationDataV25 &operator=(const ModelAnimationDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV17 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV17();
    ModelCompoundAnimationDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV17(const ModelCompoundAnimationDataV17 &p_other);
    ModelCompoundAnimationDataV17 &operator=(const ModelCompoundAnimationDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportSequenceV17 {
    qword name;
    float duration;

public:
    ModelAnimationImportSequenceV17();
    ModelAnimationImportSequenceV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportSequenceV17(const ModelAnimationImportSequenceV17 &p_other);
    ModelAnimationImportSequenceV17 &operator=(const ModelAnimationImportSequenceV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV25 {
    helpers::FileName filename;
    helpers::Array<ModelAnimationImportSequenceV17> sequences;

public:
    ModelAnimationImportDataV25();
    ModelAnimationImportDataV25(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV25(const ModelAnimationImportDataV25 &p_other);
    ModelAnimationImportDataV25 &operator=(const ModelAnimationImportDataV25 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV17 {
    helpers::Ptr<ModelAnimationDataV25> animations;
    helpers::Array<ModelCompoundAnimationDataV17> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV25> imports;

public:
    ModelFileAnimationBankV17();
    ModelFileAnimationBankV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV17(const ModelFileAnimationBankV17 &p_other);
    ModelFileAnimationBankV17 &operator=(const ModelFileAnimationBankV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<16>{
struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelVisTrackDataV24 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV24();
    ModelVisTrackDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV24(const ModelVisTrackDataV24 &p_other);
    ModelVisTrackDataV24 &operator=(const ModelVisTrackDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV16 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV16();
    ModelTrackTypeDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV16(const ModelTrackTypeDataV16 &p_other);
    ModelTrackTypeDataV16 &operator=(const ModelTrackTypeDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV16 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV16> uvTransformData;

public:
    ModelUVAnimationV16();
    ModelUVAnimationV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV16(const ModelUVAnimationV16 &p_other);
    ModelUVAnimationV16 &operator=(const ModelUVAnimationV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV16 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV16> cloudTrackData;

public:
    ModelCloudAnimV16();
    ModelCloudAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV16(const ModelCloudAnimV16 &p_other);
    ModelCloudAnimV16 &operator=(const ModelCloudAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV16 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV16();
    ModelMatConstAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV16(const ModelMatConstAnimV16 &p_other);
    ModelMatConstAnimV16 &operator=(const ModelMatConstAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV16 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV16> lightTrackData;

public:
    ModelLightAnimationV16();
    ModelLightAnimationV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV16(const ModelLightAnimationV16 &p_other);
    ModelLightAnimationV16 &operator=(const ModelLightAnimationV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV16 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV16();
    ModelAnimPropertyDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV16(const ModelAnimPropertyDataV16 &p_other);
    ModelAnimPropertyDataV16 &operator=(const ModelAnimPropertyDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV16 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV16();
    ModelTokenMapAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV16(const ModelTokenMapAnimV16 &p_other);
    ModelTokenMapAnimV16 &operator=(const ModelTokenMapAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV16 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV16> bcTrackData;

public:
    ModelBoneConstraintAnimV16();
    ModelBoneConstraintAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV16(const ModelBoneConstraintAnimV16 &p_other);
    ModelBoneConstraintAnimV16 &operator=(const ModelBoneConstraintAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnchorAnimV16 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV16> anchorTrackData;

public:
    ModelAnchorAnimV16();
    ModelAnchorAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnchorAnimV16(const ModelAnchorAnimV16 &p_other);
    ModelAnchorAnimV16 &operator=(const ModelAnchorAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelStreakAnimV16 {
    qword bone;
    helpers::Array<ModelAnchorAnimV16> anchorAnim;

public:
    ModelStreakAnimV16();
    ModelStreakAnimV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelStreakAnimV16(const ModelStreakAnimV16 &p_other);
    ModelStreakAnimV16 &operator=(const ModelStreakAnimV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV24 {
    qword token;
    PackGrannyAnimationTypeV0 data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV24> visTrackData;
    helpers::Array<ModelUVAnimationV16> uvAnimData;
    helpers::Array<ModelCloudAnimV16> cloudAnim;
    helpers::Array<ModelMatConstAnimV16> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV16> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV16> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV16> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV16> bcAnim;
    helpers::Array<ModelStreakAnimV16> streakAnim;

public:
    ModelAnimationDataV24();
    ModelAnimationDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV24(const ModelAnimationDataV24 &p_other);
    ModelAnimationDataV24 &operator=(const ModelAnimationDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV16 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV16();
    ModelCompoundAnimationDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV16(const ModelCompoundAnimationDataV16 &p_other);
    ModelCompoundAnimationDataV16 &operator=(const ModelCompoundAnimationDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV24 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV24();
    ModelAnimationImportDataV24(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV24(const ModelAnimationImportDataV24 &p_other);
    ModelAnimationImportDataV24 &operator=(const ModelAnimationImportDataV24 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV16 {
    helpers::Ptr<ModelAnimationDataV24> animations;
    helpers::Array<ModelCompoundAnimationDataV16> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV24> imports;

public:
    ModelFileAnimationBankV16();
    ModelFileAnimationBankV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV16(const ModelFileAnimationBankV16 &p_other);
    ModelFileAnimationBankV16 &operator=(const ModelFileAnimationBankV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<15>{
struct ModelVisTrackDataV23 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV23();
    ModelVisTrackDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV23(const ModelVisTrackDataV23 &p_other);
    ModelVisTrackDataV23 &operator=(const ModelVisTrackDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV15 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV15();
    ModelTrackTypeDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV15(const ModelTrackTypeDataV15 &p_other);
    ModelTrackTypeDataV15 &operator=(const ModelTrackTypeDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV15 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV15> uvTransformData;

public:
    ModelUVAnimationV15();
    ModelUVAnimationV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV15(const ModelUVAnimationV15 &p_other);
    ModelUVAnimationV15 &operator=(const ModelUVAnimationV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV15 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV15> cloudTrackData;

public:
    ModelCloudAnimV15();
    ModelCloudAnimV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV15(const ModelCloudAnimV15 &p_other);
    ModelCloudAnimV15 &operator=(const ModelCloudAnimV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV15 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV15();
    ModelMatConstAnimV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV15(const ModelMatConstAnimV15 &p_other);
    ModelMatConstAnimV15 &operator=(const ModelMatConstAnimV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV15 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV15> lightTrackData;

public:
    ModelLightAnimationV15();
    ModelLightAnimationV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV15(const ModelLightAnimationV15 &p_other);
    ModelLightAnimationV15 &operator=(const ModelLightAnimationV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV15 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV15();
    ModelAnimPropertyDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV15(const ModelAnimPropertyDataV15 &p_other);
    ModelAnimPropertyDataV15 &operator=(const ModelAnimPropertyDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV15 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV15();
    ModelTokenMapAnimV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV15(const ModelTokenMapAnimV15 &p_other);
    ModelTokenMapAnimV15 &operator=(const ModelTokenMapAnimV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintAnimV15 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV15> bcTrackData;

public:
    ModelBoneConstraintAnimV15();
    ModelBoneConstraintAnimV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintAnimV15(const ModelBoneConstraintAnimV15 &p_other);
    ModelBoneConstraintAnimV15 &operator=(const ModelBoneConstraintAnimV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV23 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV23> visTrackData;
    helpers::Array<ModelUVAnimationV15> uvAnimData;
    helpers::Array<ModelCloudAnimV15> cloudAnim;
    helpers::Array<ModelMatConstAnimV15> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV15> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV15> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV15> tokenMapAnims;
    helpers::Array<ModelBoneConstraintAnimV15> bcAnim;

public:
    ModelAnimationDataV23();
    ModelAnimationDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV23(const ModelAnimationDataV23 &p_other);
    ModelAnimationDataV23 &operator=(const ModelAnimationDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV15 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV15();
    ModelCompoundAnimationDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV15(const ModelCompoundAnimationDataV15 &p_other);
    ModelCompoundAnimationDataV15 &operator=(const ModelCompoundAnimationDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV23 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV23();
    ModelAnimationImportDataV23(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV23(const ModelAnimationImportDataV23 &p_other);
    ModelAnimationImportDataV23 &operator=(const ModelAnimationImportDataV23 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV15 {
    helpers::Ptr<ModelAnimationDataV23> animations;
    helpers::Array<ModelCompoundAnimationDataV15> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV23> imports;

public:
    ModelFileAnimationBankV15();
    ModelFileAnimationBankV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV15(const ModelFileAnimationBankV15 &p_other);
    ModelFileAnimationBankV15 &operator=(const ModelFileAnimationBankV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x410D560000000001 */

template <>
struct Gw2StructANIM<14>{
struct ModelVisTrackDataV22 {
    qword boneToken;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV22();
    ModelVisTrackDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV22(const ModelVisTrackDataV22 &p_other);
    ModelVisTrackDataV22 &operator=(const ModelVisTrackDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV14 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV14();
    ModelTrackTypeDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV14(const ModelTrackTypeDataV14 &p_other);
    ModelTrackTypeDataV14 &operator=(const ModelTrackTypeDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV14 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV14> uvTransformData;

public:
    ModelUVAnimationV14();
    ModelUVAnimationV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV14(const ModelUVAnimationV14 &p_other);
    ModelUVAnimationV14 &operator=(const ModelUVAnimationV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV14 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV14> cloudTrackData;

public:
    ModelCloudAnimV14();
    ModelCloudAnimV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV14(const ModelCloudAnimV14 &p_other);
    ModelCloudAnimV14 &operator=(const ModelCloudAnimV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV14 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV14();
    ModelMatConstAnimV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV14(const ModelMatConstAnimV14 &p_other);
    ModelMatConstAnimV14 &operator=(const ModelMatConstAnimV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV14 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV14> lightTrackData;

public:
    ModelLightAnimationV14();
    ModelLightAnimationV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV14(const ModelLightAnimationV14 &p_other);
    ModelLightAnimationV14 &operator=(const ModelLightAnimationV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV14 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV14();
    ModelAnimPropertyDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV14(const ModelAnimPropertyDataV14 &p_other);
    ModelAnimPropertyDataV14 &operator=(const ModelAnimPropertyDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV14 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV14();
    ModelTokenMapAnimV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV14(const ModelTokenMapAnimV14 &p_other);
    ModelTokenMapAnimV14 &operator=(const ModelTokenMapAnimV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV22 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV22> visTrackData;
    helpers::Array<ModelUVAnimationV14> uvAnimData;
    helpers::Array<ModelCloudAnimV14> cloudAnim;
    helpers::Array<ModelMatConstAnimV14> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV14> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV14> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV14> tokenMapAnims;

public:
    ModelAnimationDataV22();
    ModelAnimationDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV22(const ModelAnimationDataV22 &p_other);
    ModelAnimationDataV22 &operator=(const ModelAnimationDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV14 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV14();
    ModelCompoundAnimationDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV14(const ModelCompoundAnimationDataV14 &p_other);
    ModelCompoundAnimationDataV14 &operator=(const ModelCompoundAnimationDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV22 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV22();
    ModelAnimationImportDataV22(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV22(const ModelAnimationImportDataV22 &p_other);
    ModelAnimationImportDataV22 &operator=(const ModelAnimationImportDataV22 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV14 {
    helpers::Ptr<ModelAnimationDataV22> animations;
    helpers::Array<ModelCompoundAnimationDataV14> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV22> imports;

public:
    ModelFileAnimationBankV14();
    ModelFileAnimationBankV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV14(const ModelFileAnimationBankV14 &p_other);
    ModelFileAnimationBankV14 &operator=(const ModelFileAnimationBankV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<13>{
struct ModelVisTrackDataV21 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV21();
    ModelVisTrackDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV21(const ModelVisTrackDataV21 &p_other);
    ModelVisTrackDataV21 &operator=(const ModelVisTrackDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV13 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV13();
    ModelTrackTypeDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV13(const ModelTrackTypeDataV13 &p_other);
    ModelTrackTypeDataV13 &operator=(const ModelTrackTypeDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV13 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV13> uvTransformData;

public:
    ModelUVAnimationV13();
    ModelUVAnimationV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV13(const ModelUVAnimationV13 &p_other);
    ModelUVAnimationV13 &operator=(const ModelUVAnimationV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV13 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV13> cloudTrackData;

public:
    ModelCloudAnimV13();
    ModelCloudAnimV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV13(const ModelCloudAnimV13 &p_other);
    ModelCloudAnimV13 &operator=(const ModelCloudAnimV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV13 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV13();
    ModelMatConstAnimV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV13(const ModelMatConstAnimV13 &p_other);
    ModelMatConstAnimV13 &operator=(const ModelMatConstAnimV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV13 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV13> lightTrackData;

public:
    ModelLightAnimationV13();
    ModelLightAnimationV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV13(const ModelLightAnimationV13 &p_other);
    ModelLightAnimationV13 &operator=(const ModelLightAnimationV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV13 {
    qword id;
    dword type;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV13();
    ModelAnimPropertyDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV13(const ModelAnimPropertyDataV13 &p_other);
    ModelAnimPropertyDataV13 &operator=(const ModelAnimPropertyDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV13 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV13();
    ModelTokenMapAnimV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV13(const ModelTokenMapAnimV13 &p_other);
    ModelTokenMapAnimV13 &operator=(const ModelTokenMapAnimV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV21 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV21> visTrackData;
    helpers::Array<ModelUVAnimationV13> uvAnimData;
    helpers::Array<ModelCloudAnimV13> cloudAnim;
    helpers::Array<ModelMatConstAnimV13> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV13> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV13> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV13> tokenMapAnims;

public:
    ModelAnimationDataV21();
    ModelAnimationDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV21(const ModelAnimationDataV21 &p_other);
    ModelAnimationDataV21 &operator=(const ModelAnimationDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV13 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV13();
    ModelCompoundAnimationDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV13(const ModelCompoundAnimationDataV13 &p_other);
    ModelCompoundAnimationDataV13 &operator=(const ModelCompoundAnimationDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV21 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV21();
    ModelAnimationImportDataV21(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV21(const ModelAnimationImportDataV21 &p_other);
    ModelAnimationImportDataV21 &operator=(const ModelAnimationImportDataV21 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV13 {
    helpers::Ptr<ModelAnimationDataV21> animations;
    helpers::Array<ModelCompoundAnimationDataV13> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV21> imports;

public:
    ModelFileAnimationBankV13();
    ModelFileAnimationBankV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV13(const ModelFileAnimationBankV13 &p_other);
    ModelFileAnimationBankV13 &operator=(const ModelFileAnimationBankV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x410D552000000001 */

template <>
struct Gw2StructANIM<12>{
struct ModelVisTrackDataV20 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV20();
    ModelVisTrackDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV20(const ModelVisTrackDataV20 &p_other);
    ModelVisTrackDataV20 &operator=(const ModelVisTrackDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV12 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV12();
    ModelTrackTypeDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV12(const ModelTrackTypeDataV12 &p_other);
    ModelTrackTypeDataV12 &operator=(const ModelTrackTypeDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV12 {
    dword uvAnimId;
    helpers::Array<ModelTrackTypeDataV12> uvTransformData;

public:
    ModelUVAnimationV12();
    ModelUVAnimationV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV12(const ModelUVAnimationV12 &p_other);
    ModelUVAnimationV12 &operator=(const ModelUVAnimationV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV12 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV12> cloudTrackData;

public:
    ModelCloudAnimV12();
    ModelCloudAnimV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV12(const ModelCloudAnimV12 &p_other);
    ModelCloudAnimV12 &operator=(const ModelCloudAnimV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV12 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV12();
    ModelMatConstAnimV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV12(const ModelMatConstAnimV12 &p_other);
    ModelMatConstAnimV12 &operator=(const ModelMatConstAnimV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV12 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV12> lightTrackData;

public:
    ModelLightAnimationV12();
    ModelLightAnimationV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV12(const ModelLightAnimationV12 &p_other);
    ModelLightAnimationV12 &operator=(const ModelLightAnimationV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV12 {
    qword id;
    dword type;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV12();
    ModelAnimPropertyDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV12(const ModelAnimPropertyDataV12 &p_other);
    ModelAnimPropertyDataV12 &operator=(const ModelAnimPropertyDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTokenMapAnimV12 {
    qword linkToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTokenMapAnimV12();
    ModelTokenMapAnimV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTokenMapAnimV12(const ModelTokenMapAnimV12 &p_other);
    ModelTokenMapAnimV12 &operator=(const ModelTokenMapAnimV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV20 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV20> visTrackData;
    helpers::Array<ModelUVAnimationV12> uvAnimData;
    helpers::Array<ModelCloudAnimV12> cloudAnim;
    helpers::Array<ModelMatConstAnimV12> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV12> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV12> properties;
    float3 center;
    float radius;
    helpers::Array<ModelTokenMapAnimV12> tokenMapAnims;

public:
    ModelAnimationDataV20();
    ModelAnimationDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV20(const ModelAnimationDataV20 &p_other);
    ModelAnimationDataV20 &operator=(const ModelAnimationDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV12 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV12();
    ModelCompoundAnimationDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV12(const ModelCompoundAnimationDataV12 &p_other);
    ModelCompoundAnimationDataV12 &operator=(const ModelCompoundAnimationDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV20 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV20();
    ModelAnimationImportDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV20(const ModelAnimationImportDataV20 &p_other);
    ModelAnimationImportDataV20 &operator=(const ModelAnimationImportDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV12 {
    helpers::Ptr<ModelAnimationDataV20> animations;
    helpers::Array<ModelCompoundAnimationDataV12> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV20> imports;

public:
    ModelFileAnimationBankV12();
    ModelFileAnimationBankV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV12(const ModelFileAnimationBankV12 &p_other);
    ModelFileAnimationBankV12 &operator=(const ModelFileAnimationBankV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<11>{
struct ModelVisTrackDataV19 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV19();
    ModelVisTrackDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV19(const ModelVisTrackDataV19 &p_other);
    ModelVisTrackDataV19 &operator=(const ModelVisTrackDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV11 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV11();
    ModelTrackTypeDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV11(const ModelTrackTypeDataV11 &p_other);
    ModelTrackTypeDataV11 &operator=(const ModelTrackTypeDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV11 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV11> uvTransformData;

public:
    ModelUVAnimationV11();
    ModelUVAnimationV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV11(const ModelUVAnimationV11 &p_other);
    ModelUVAnimationV11 &operator=(const ModelUVAnimationV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV11 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV11> cloudTrackData;

public:
    ModelCloudAnimV11();
    ModelCloudAnimV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV11(const ModelCloudAnimV11 &p_other);
    ModelCloudAnimV11 &operator=(const ModelCloudAnimV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV11 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV11();
    ModelMatConstAnimV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV11(const ModelMatConstAnimV11 &p_other);
    ModelMatConstAnimV11 &operator=(const ModelMatConstAnimV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV11 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV11> lightTrackData;

public:
    ModelLightAnimationV11();
    ModelLightAnimationV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV11(const ModelLightAnimationV11 &p_other);
    ModelLightAnimationV11 &operator=(const ModelLightAnimationV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV11 {
    qword id;
    dword type;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV11();
    ModelAnimPropertyDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV11(const ModelAnimPropertyDataV11 &p_other);
    ModelAnimPropertyDataV11 &operator=(const ModelAnimPropertyDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV19 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV19> visTrackData;
    helpers::Array<ModelUVAnimationV11> uvAnimData;
    helpers::Array<ModelCloudAnimV11> cloudAnim;
    helpers::Array<ModelMatConstAnimV11> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV11> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV11> properties;
    float3 center;
    float radius;

public:
    ModelAnimationDataV19();
    ModelAnimationDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV19(const ModelAnimationDataV19 &p_other);
    ModelAnimationDataV19 &operator=(const ModelAnimationDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV11 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV11();
    ModelCompoundAnimationDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV11(const ModelCompoundAnimationDataV11 &p_other);
    ModelCompoundAnimationDataV11 &operator=(const ModelCompoundAnimationDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV19 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV19();
    ModelAnimationImportDataV19(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV19(const ModelAnimationImportDataV19 &p_other);
    ModelAnimationImportDataV19 &operator=(const ModelAnimationImportDataV19 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV11 {
    helpers::Ptr<ModelAnimationDataV19> animations;
    helpers::Array<ModelCompoundAnimationDataV11> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV19> imports;

public:
    ModelFileAnimationBankV11();
    ModelFileAnimationBankV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV11(const ModelFileAnimationBankV11 &p_other);
    ModelFileAnimationBankV11 &operator=(const ModelFileAnimationBankV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<10>{
struct ModelVisTrackDataV18 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV18();
    ModelVisTrackDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV18(const ModelVisTrackDataV18 &p_other);
    ModelVisTrackDataV18 &operator=(const ModelVisTrackDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV10 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV10();
    ModelTrackTypeDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV10(const ModelTrackTypeDataV10 &p_other);
    ModelTrackTypeDataV10 &operator=(const ModelTrackTypeDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV10 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV10> uvTransformData;

public:
    ModelUVAnimationV10();
    ModelUVAnimationV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV10(const ModelUVAnimationV10 &p_other);
    ModelUVAnimationV10 &operator=(const ModelUVAnimationV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV10 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV10> cloudTrackData;

public:
    ModelCloudAnimV10();
    ModelCloudAnimV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV10(const ModelCloudAnimV10 &p_other);
    ModelCloudAnimV10 &operator=(const ModelCloudAnimV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV10 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV10();
    ModelMatConstAnimV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV10(const ModelMatConstAnimV10 &p_other);
    ModelMatConstAnimV10 &operator=(const ModelMatConstAnimV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV10 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV10> lightTrackData;

public:
    ModelLightAnimationV10();
    ModelLightAnimationV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV10(const ModelLightAnimationV10 &p_other);
    ModelLightAnimationV10 &operator=(const ModelLightAnimationV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimPropertyDataV10 {
    qword id;
    dword type;
    qword val;
    helpers::FileName strVal;

public:
    ModelAnimPropertyDataV10();
    ModelAnimPropertyDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimPropertyDataV10(const ModelAnimPropertyDataV10 &p_other);
    ModelAnimPropertyDataV10 &operator=(const ModelAnimPropertyDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV18 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV18> visTrackData;
    helpers::Array<ModelUVAnimationV10> uvAnimData;
    helpers::Array<ModelCloudAnimV10> cloudAnim;
    helpers::Array<ModelMatConstAnimV10> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV10> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];
    helpers::Array<ModelAnimPropertyDataV10> properties;

public:
    ModelAnimationDataV18();
    ModelAnimationDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV18(const ModelAnimationDataV18 &p_other);
    ModelAnimationDataV18 &operator=(const ModelAnimationDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV10 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV10();
    ModelCompoundAnimationDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV10(const ModelCompoundAnimationDataV10 &p_other);
    ModelCompoundAnimationDataV10 &operator=(const ModelCompoundAnimationDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV18 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV18();
    ModelAnimationImportDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV18(const ModelAnimationImportDataV18 &p_other);
    ModelAnimationImportDataV18 &operator=(const ModelAnimationImportDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV10 {
    helpers::Ptr<ModelAnimationDataV18> animations;
    helpers::Array<ModelCompoundAnimationDataV10> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV18> imports;

public:
    ModelFileAnimationBankV10();
    ModelFileAnimationBankV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV10(const ModelFileAnimationBankV10 &p_other);
    ModelFileAnimationBankV10 &operator=(const ModelFileAnimationBankV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<9>{
struct ModelVisTrackDataV17 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV17();
    ModelVisTrackDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV17(const ModelVisTrackDataV17 &p_other);
    ModelVisTrackDataV17 &operator=(const ModelVisTrackDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV9 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelTrackTypeDataV9();
    ModelTrackTypeDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV9(const ModelTrackTypeDataV9 &p_other);
    ModelTrackTypeDataV9 &operator=(const ModelTrackTypeDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV9 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV9> uvTransformData;

public:
    ModelUVAnimationV9();
    ModelUVAnimationV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV9(const ModelUVAnimationV9 &p_other);
    ModelUVAnimationV9 &operator=(const ModelUVAnimationV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV9 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV9> cloudTrackData;

public:
    ModelCloudAnimV9();
    ModelCloudAnimV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV9(const ModelCloudAnimV9 &p_other);
    ModelCloudAnimV9 &operator=(const ModelCloudAnimV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV9 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;
    float4 initialValue;

public:
    ModelMatConstAnimV9();
    ModelMatConstAnimV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV9(const ModelMatConstAnimV9 &p_other);
    ModelMatConstAnimV9 &operator=(const ModelMatConstAnimV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV9 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV9> lightTrackData;

public:
    ModelLightAnimationV9();
    ModelLightAnimationV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV9(const ModelLightAnimationV9 &p_other);
    ModelLightAnimationV9 &operator=(const ModelLightAnimationV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV17 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV17> visTrackData;
    helpers::Array<ModelUVAnimationV9> uvAnimData;
    helpers::Array<ModelCloudAnimV9> cloudAnim;
    helpers::Array<ModelMatConstAnimV9> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV9> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];

public:
    ModelAnimationDataV17();
    ModelAnimationDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV17(const ModelAnimationDataV17 &p_other);
    ModelAnimationDataV17 &operator=(const ModelAnimationDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV9 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV9();
    ModelCompoundAnimationDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV9(const ModelCompoundAnimationDataV9 &p_other);
    ModelCompoundAnimationDataV9 &operator=(const ModelCompoundAnimationDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV17 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV17();
    ModelAnimationImportDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV17(const ModelAnimationImportDataV17 &p_other);
    ModelAnimationImportDataV17 &operator=(const ModelAnimationImportDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV9 {
    helpers::Ptr<ModelAnimationDataV17> animations;
    helpers::Array<ModelCompoundAnimationDataV9> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV17> imports;

public:
    ModelFileAnimationBankV9();
    ModelFileAnimationBankV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV9(const ModelFileAnimationBankV9 &p_other);
    ModelFileAnimationBankV9 &operator=(const ModelFileAnimationBankV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<8>{
struct ModelVisTrackDataV16 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV16();
    ModelVisTrackDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV16(const ModelVisTrackDataV16 &p_other);
    ModelVisTrackDataV16 &operator=(const ModelVisTrackDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV8 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV8();
    ModelTrackTypeDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV8(const ModelTrackTypeDataV8 &p_other);
    ModelTrackTypeDataV8 &operator=(const ModelTrackTypeDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV8 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV8> uvTransformData;

public:
    ModelUVAnimationV8();
    ModelUVAnimationV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV8(const ModelUVAnimationV8 &p_other);
    ModelUVAnimationV8 &operator=(const ModelUVAnimationV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV8 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV8> cloudTrackData;

public:
    ModelCloudAnimV8();
    ModelCloudAnimV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV8(const ModelCloudAnimV8 &p_other);
    ModelCloudAnimV8 &operator=(const ModelCloudAnimV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV8 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;

public:
    ModelMatConstAnimV8();
    ModelMatConstAnimV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV8(const ModelMatConstAnimV8 &p_other);
    ModelMatConstAnimV8 &operator=(const ModelMatConstAnimV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV8 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV8> lightTrackData;

public:
    ModelLightAnimationV8();
    ModelLightAnimationV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV8(const ModelLightAnimationV8 &p_other);
    ModelLightAnimationV8 &operator=(const ModelLightAnimationV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV16 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV16> visTrackData;
    helpers::Array<ModelUVAnimationV8> uvAnimData;
    helpers::Array<ModelCloudAnimV8> cloudAnim;
    helpers::Array<ModelMatConstAnimV8> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV8> lightAnimData;
    dword isAdditive;
    dword variantCount;
    dword variantIndices[3];

public:
    ModelAnimationDataV16();
    ModelAnimationDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV16(const ModelAnimationDataV16 &p_other);
    ModelAnimationDataV16 &operator=(const ModelAnimationDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV8 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV8();
    ModelCompoundAnimationDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV8(const ModelCompoundAnimationDataV8 &p_other);
    ModelCompoundAnimationDataV8 &operator=(const ModelCompoundAnimationDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV16 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV16();
    ModelAnimationImportDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV16(const ModelAnimationImportDataV16 &p_other);
    ModelAnimationImportDataV16 &operator=(const ModelAnimationImportDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV8 {
    helpers::Ptr<ModelAnimationDataV16> animations;
    helpers::Array<ModelCompoundAnimationDataV8> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV16> imports;

public:
    ModelFileAnimationBankV8();
    ModelFileAnimationBankV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV8(const ModelFileAnimationBankV8 &p_other);
    ModelFileAnimationBankV8 &operator=(const ModelFileAnimationBankV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<7>{
struct ModelVisTrackDataV15 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV15();
    ModelVisTrackDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV15(const ModelVisTrackDataV15 &p_other);
    ModelVisTrackDataV15 &operator=(const ModelVisTrackDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV7 {
    byte type;
    dword trackGroupIndex;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV7();
    ModelTrackTypeDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV7(const ModelTrackTypeDataV7 &p_other);
    ModelTrackTypeDataV7 &operator=(const ModelTrackTypeDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV7 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV7> uvTransformData;

public:
    ModelUVAnimationV7();
    ModelUVAnimationV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV7(const ModelUVAnimationV7 &p_other);
    ModelUVAnimationV7 &operator=(const ModelUVAnimationV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV7 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV7> cloudTrackData;

public:
    ModelCloudAnimV7();
    ModelCloudAnimV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV7(const ModelCloudAnimV7 &p_other);
    ModelCloudAnimV7 &operator=(const ModelCloudAnimV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV7 {
    dword matIndex;
    dword constToken;
    dword trackGroupIndex;
    dword vectorTrackIndex;

public:
    ModelMatConstAnimV7();
    ModelMatConstAnimV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV7(const ModelMatConstAnimV7 &p_other);
    ModelMatConstAnimV7 &operator=(const ModelMatConstAnimV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV7 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV7> lightTrackData;

public:
    ModelLightAnimationV7();
    ModelLightAnimationV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV7(const ModelLightAnimationV7 &p_other);
    ModelLightAnimationV7 &operator=(const ModelLightAnimationV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV15 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV15> visTrackData;
    helpers::Array<ModelUVAnimationV7> uvAnimData;
    helpers::Array<ModelCloudAnimV7> cloudAnim;
    helpers::Array<ModelMatConstAnimV7> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV7> lightAnimData;
    dword isAdditive;

public:
    ModelAnimationDataV15();
    ModelAnimationDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV15(const ModelAnimationDataV15 &p_other);
    ModelAnimationDataV15 &operator=(const ModelAnimationDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV7 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV7();
    ModelCompoundAnimationDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV7(const ModelCompoundAnimationDataV7 &p_other);
    ModelCompoundAnimationDataV7 &operator=(const ModelCompoundAnimationDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV15 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV15();
    ModelAnimationImportDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV15(const ModelAnimationImportDataV15 &p_other);
    ModelAnimationImportDataV15 &operator=(const ModelAnimationImportDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV7 {
    helpers::Ptr<ModelAnimationDataV15> animations;
    helpers::Array<ModelCompoundAnimationDataV7> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV15> imports;

public:
    ModelFileAnimationBankV7();
    ModelFileAnimationBankV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV7(const ModelFileAnimationBankV7 &p_other);
    ModelFileAnimationBankV7 &operator=(const ModelFileAnimationBankV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<6>{
struct ModelVisTrackDataV14 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV14();
    ModelVisTrackDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV14(const ModelVisTrackDataV14 &p_other);
    ModelVisTrackDataV14 &operator=(const ModelVisTrackDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV6 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV6();
    ModelTrackTypeDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV6(const ModelTrackTypeDataV6 &p_other);
    ModelTrackTypeDataV6 &operator=(const ModelTrackTypeDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV6 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV6> uvTransformData;

public:
    ModelUVAnimationV6();
    ModelUVAnimationV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV6(const ModelUVAnimationV6 &p_other);
    ModelUVAnimationV6 &operator=(const ModelUVAnimationV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCloudAnimV6 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV6> cloudTrackData;

public:
    ModelCloudAnimV6();
    ModelCloudAnimV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCloudAnimV6(const ModelCloudAnimV6 &p_other);
    ModelCloudAnimV6 &operator=(const ModelCloudAnimV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMatConstAnimV6 {
    dword matIndex;
    dword constToken;
    dword vectorTrackIndex;

public:
    ModelMatConstAnimV6();
    ModelMatConstAnimV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMatConstAnimV6(const ModelMatConstAnimV6 &p_other);
    ModelMatConstAnimV6 &operator=(const ModelMatConstAnimV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV6 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV6> lightTrackData;

public:
    ModelLightAnimationV6();
    ModelLightAnimationV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV6(const ModelLightAnimationV6 &p_other);
    ModelLightAnimationV6 &operator=(const ModelLightAnimationV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV14 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV14> visTrackData;
    helpers::Array<ModelUVAnimationV6> uvAnimData;
    helpers::Array<ModelCloudAnimV6> cloudAnim;
    helpers::Array<ModelMatConstAnimV6> matConstAnim;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV6> lightAnimData;
    dword isAdditive;

public:
    ModelAnimationDataV14();
    ModelAnimationDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV14(const ModelAnimationDataV14 &p_other);
    ModelAnimationDataV14 &operator=(const ModelAnimationDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV6 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV6();
    ModelCompoundAnimationDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV6(const ModelCompoundAnimationDataV6 &p_other);
    ModelCompoundAnimationDataV6 &operator=(const ModelCompoundAnimationDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV14 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV14();
    ModelAnimationImportDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV14(const ModelAnimationImportDataV14 &p_other);
    ModelAnimationImportDataV14 &operator=(const ModelAnimationImportDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV6 {
    helpers::Ptr<ModelAnimationDataV14> animations;
    helpers::Array<ModelCompoundAnimationDataV6> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV14> imports;

public:
    ModelFileAnimationBankV6();
    ModelFileAnimationBankV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV6(const ModelFileAnimationBankV6 &p_other);
    ModelFileAnimationBankV6 &operator=(const ModelFileAnimationBankV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<5>{
struct ModelVisTrackDataV13 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV13();
    ModelVisTrackDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV13(const ModelVisTrackDataV13 &p_other);
    ModelVisTrackDataV13 &operator=(const ModelVisTrackDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV5 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV5();
    ModelTrackTypeDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV5(const ModelTrackTypeDataV5 &p_other);
    ModelTrackTypeDataV5 &operator=(const ModelTrackTypeDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV5 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV5> uvTransformData;

public:
    ModelUVAnimationV5();
    ModelUVAnimationV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV5(const ModelUVAnimationV5 &p_other);
    ModelUVAnimationV5 &operator=(const ModelUVAnimationV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV5 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV5> lightTrackData;

public:
    ModelLightAnimationV5();
    ModelLightAnimationV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV5(const ModelLightAnimationV5 &p_other);
    ModelLightAnimationV5 &operator=(const ModelLightAnimationV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV13 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV13> visTrackData;
    helpers::Array<ModelUVAnimationV5> uvAnimData;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV5> lightAnimData;
    dword isAdditive;

public:
    ModelAnimationDataV13();
    ModelAnimationDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV13(const ModelAnimationDataV13 &p_other);
    ModelAnimationDataV13 &operator=(const ModelAnimationDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV5 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV5();
    ModelCompoundAnimationDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV5(const ModelCompoundAnimationDataV5 &p_other);
    ModelCompoundAnimationDataV5 &operator=(const ModelCompoundAnimationDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV13 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV13();
    ModelAnimationImportDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV13(const ModelAnimationImportDataV13 &p_other);
    ModelAnimationImportDataV13 &operator=(const ModelAnimationImportDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV5 {
    helpers::Ptr<ModelAnimationDataV13> animations;
    helpers::Array<ModelCompoundAnimationDataV5> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV13> imports;

public:
    ModelFileAnimationBankV5();
    ModelFileAnimationBankV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV5(const ModelFileAnimationBankV5 &p_other);
    ModelFileAnimationBankV5 &operator=(const ModelFileAnimationBankV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<4>{
struct ModelVisTrackDataV12 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV12();
    ModelVisTrackDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV12(const ModelVisTrackDataV12 &p_other);
    ModelVisTrackDataV12 &operator=(const ModelVisTrackDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV4 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV4();
    ModelTrackTypeDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV4(const ModelTrackTypeDataV4 &p_other);
    ModelTrackTypeDataV4 &operator=(const ModelTrackTypeDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV4 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV4> uvTransformData;

public:
    ModelUVAnimationV4();
    ModelUVAnimationV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV4(const ModelUVAnimationV4 &p_other);
    ModelUVAnimationV4 &operator=(const ModelUVAnimationV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV4 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV4> lightTrackData;

public:
    ModelLightAnimationV4();
    ModelLightAnimationV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV4(const ModelLightAnimationV4 &p_other);
    ModelLightAnimationV4 &operator=(const ModelLightAnimationV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV12 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV12> visTrackData;
    helpers::Array<ModelUVAnimationV4> uvAnimData;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV4> lightAnimData;
    dword isAdditive;

public:
    ModelAnimationDataV12();
    ModelAnimationDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV12(const ModelAnimationDataV12 &p_other);
    ModelAnimationDataV12 &operator=(const ModelAnimationDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV4 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV4();
    ModelCompoundAnimationDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV4(const ModelCompoundAnimationDataV4 &p_other);
    ModelCompoundAnimationDataV4 &operator=(const ModelCompoundAnimationDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV12 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV12();
    ModelAnimationImportDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV12(const ModelAnimationImportDataV12 &p_other);
    ModelAnimationImportDataV12 &operator=(const ModelAnimationImportDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV4 {
    helpers::Ptr<ModelAnimationDataV12> animations;
    helpers::Array<ModelCompoundAnimationDataV4> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV12> imports;

public:
    ModelFileAnimationBankV4();
    ModelFileAnimationBankV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV4(const ModelFileAnimationBankV4 &p_other);
    ModelFileAnimationBankV4 &operator=(const ModelFileAnimationBankV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<3>{
struct ModelVisTrackDataV11 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV11();
    ModelVisTrackDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV11(const ModelVisTrackDataV11 &p_other);
    ModelVisTrackDataV11 &operator=(const ModelVisTrackDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackTypeDataV3 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelTrackTypeDataV3();
    ModelTrackTypeDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackTypeDataV3(const ModelTrackTypeDataV3 &p_other);
    ModelTrackTypeDataV3 &operator=(const ModelTrackTypeDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV3 {
    byte uvAnimId;
    helpers::Array<ModelTrackTypeDataV3> uvTransformData;

public:
    ModelUVAnimationV3();
    ModelUVAnimationV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV3(const ModelUVAnimationV3 &p_other);
    ModelUVAnimationV3 &operator=(const ModelUVAnimationV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelLightAnimationV3 {
    qword bone;
    helpers::Array<ModelTrackTypeDataV3> lightTrackData;

public:
    ModelLightAnimationV3();
    ModelLightAnimationV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelLightAnimationV3(const ModelLightAnimationV3 &p_other);
    ModelLightAnimationV3 &operator=(const ModelLightAnimationV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV11 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV11> visTrackData;
    helpers::Array<ModelUVAnimationV3> uvAnimData;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;
    helpers::Array<ModelLightAnimationV3> lightAnimData;

public:
    ModelAnimationDataV11();
    ModelAnimationDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV11(const ModelAnimationDataV11 &p_other);
    ModelAnimationDataV11 &operator=(const ModelAnimationDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV3 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV3();
    ModelCompoundAnimationDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV3(const ModelCompoundAnimationDataV3 &p_other);
    ModelCompoundAnimationDataV3 &operator=(const ModelCompoundAnimationDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV11 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV11();
    ModelAnimationImportDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV11(const ModelAnimationImportDataV11 &p_other);
    ModelAnimationImportDataV11 &operator=(const ModelAnimationImportDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV3 {
    helpers::Ptr<ModelAnimationDataV11> animations;
    helpers::Array<ModelCompoundAnimationDataV3> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV11> imports;

public:
    ModelFileAnimationBankV3();
    ModelFileAnimationBankV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV3(const ModelFileAnimationBankV3 &p_other);
    ModelFileAnimationBankV3 &operator=(const ModelFileAnimationBankV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<2>{
struct ModelVisTrackDataV10 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV10();
    ModelVisTrackDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV10(const ModelVisTrackDataV10 &p_other);
    ModelVisTrackDataV10 &operator=(const ModelVisTrackDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransformV2 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelUVTransformV2();
    ModelUVTransformV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransformV2(const ModelUVTransformV2 &p_other);
    ModelUVTransformV2 &operator=(const ModelUVTransformV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV2 {
    byte uvAnimId;
    helpers::Array<ModelUVTransformV2> uvTransformData;

public:
    ModelUVAnimationV2();
    ModelUVAnimationV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV2(const ModelUVAnimationV2 &p_other);
    ModelUVAnimationV2 &operator=(const ModelUVAnimationV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV10 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV10> visTrackData;
    helpers::Array<ModelUVAnimationV2> uvAnimData;
    helpers::Array<word> morphTrackGroups;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;

public:
    ModelAnimationDataV10();
    ModelAnimationDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV10(const ModelAnimationDataV10 &p_other);
    ModelAnimationDataV10 &operator=(const ModelAnimationDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV2 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV2();
    ModelCompoundAnimationDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV2(const ModelCompoundAnimationDataV2 &p_other);
    ModelCompoundAnimationDataV2 &operator=(const ModelCompoundAnimationDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV10 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV10();
    ModelAnimationImportDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV10(const ModelAnimationImportDataV10 &p_other);
    ModelAnimationImportDataV10 &operator=(const ModelAnimationImportDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationBankV2 {
    helpers::Ptr<ModelAnimationDataV10> animations;
    helpers::Array<ModelCompoundAnimationDataV2> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV10> imports;

public:
    ModelFileAnimationBankV2();
    ModelFileAnimationBankV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationBankV2(const ModelFileAnimationBankV2 &p_other);
    ModelFileAnimationBankV2 &operator=(const ModelFileAnimationBankV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationBankV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<1>{
struct ModelVisTrackDataV9 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV9();
    ModelVisTrackDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV9(const ModelVisTrackDataV9 &p_other);
    ModelVisTrackDataV9 &operator=(const ModelVisTrackDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransformV1 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelUVTransformV1();
    ModelUVTransformV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransformV1(const ModelUVTransformV1 &p_other);
    ModelUVTransformV1 &operator=(const ModelUVTransformV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV1 {
    byte uvAnimId;
    helpers::Array<ModelUVTransformV1> uvTransformData;

public:
    ModelUVAnimationV1();
    ModelUVAnimationV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV1(const ModelUVAnimationV1 &p_other);
    ModelUVAnimationV1 &operator=(const ModelUVAnimationV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV9 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV9> visTrackData;
    helpers::Array<ModelUVAnimationV1> uvAnimData;
    helpers::Array<float> triggerTimes;
    helpers::Array<qword> triggerTokens;

public:
    ModelAnimationDataV9();
    ModelAnimationDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV9(const ModelAnimationDataV9 &p_other);
    ModelAnimationDataV9 &operator=(const ModelAnimationDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV1 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV1();
    ModelCompoundAnimationDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV1(const ModelCompoundAnimationDataV1 &p_other);
    ModelCompoundAnimationDataV1 &operator=(const ModelCompoundAnimationDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV9 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV9();
    ModelAnimationImportDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV9(const ModelAnimationImportDataV9 &p_other);
    ModelAnimationImportDataV9 &operator=(const ModelAnimationImportDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationV1 {
    helpers::Ptr<ModelAnimationDataV9> animations;
    helpers::Array<ModelCompoundAnimationDataV1> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV9> imports;

public:
    ModelFileAnimationV1();
    ModelFileAnimationV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationV1(const ModelFileAnimationV1 &p_other);
    ModelFileAnimationV1 &operator=(const ModelFileAnimationV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<0>{
struct ModelVisTrackDataV8 {
    dword boneIndex;
    helpers::Array<float> keys;

public:
    ModelVisTrackDataV8();
    ModelVisTrackDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelVisTrackDataV8(const ModelVisTrackDataV8 &p_other);
    ModelVisTrackDataV8 &operator=(const ModelVisTrackDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVTransformV0 {
    byte type;
    dword vectorTrackIndex;

public:
    ModelUVTransformV0();
    ModelUVTransformV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVTransformV0(const ModelUVTransformV0 &p_other);
    ModelUVTransformV0 &operator=(const ModelUVTransformV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelUVAnimationV0 {
    byte uvAnimId;
    helpers::Array<ModelUVTransformV0> uvTransformData;

public:
    ModelUVAnimationV0();
    ModelUVAnimationV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelUVAnimationV0(const ModelUVAnimationV0 &p_other);
    ModelUVAnimationV0 &operator=(const ModelUVAnimationV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationDataV8 {
    qword token;
    helpers::Array<byte> data;
    float moveSpeed;
    helpers::Array<ModelVisTrackDataV8> visTrackData;
    helpers::Array<ModelUVAnimationV0> uvAnimData;

public:
    ModelAnimationDataV8();
    ModelAnimationDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationDataV8(const ModelAnimationDataV8 &p_other);
    ModelAnimationDataV8 &operator=(const ModelAnimationDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCompoundAnimationDataV0 {
    qword token;
    qword start;
    qword loop;
    qword end;

public:
    ModelCompoundAnimationDataV0();
    ModelCompoundAnimationDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCompoundAnimationDataV0(const ModelCompoundAnimationDataV0 &p_other);
    ModelCompoundAnimationDataV0 &operator=(const ModelCompoundAnimationDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelAnimationImportDataV8 {
    helpers::FileName filename;
    helpers::Array<qword> sequenceTokens;

public:
    ModelAnimationImportDataV8();
    ModelAnimationImportDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelAnimationImportDataV8(const ModelAnimationImportDataV8 &p_other);
    ModelAnimationImportDataV8 &operator=(const ModelAnimationImportDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileAnimationV0 {
    helpers::Ptr<ModelAnimationDataV8> animations;
    helpers::Array<ModelCompoundAnimationDataV0> compoundAnimations;
    helpers::Array<qword> fallbacks;
    helpers::Array<ModelAnimationImportDataV8> imports;

public:
    ModelFileAnimationV0();
    ModelFileAnimationV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileAnimationV0(const ModelFileAnimationV0 &p_other);
    ModelFileAnimationV0 &operator=(const ModelFileAnimationV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileAnimationV0 Gw2Struct;
};


/* ===============================================
 * Chunk: COLL, versions: 5, strucTab: 0x14218F9C0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructCOLL;

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCOLL<4>{
struct ModelCollisionKeyFrameV10 {
    float time;
    float3 position;
    float4 orientation;

public:
    ModelCollisionKeyFrameV10();
    ModelCollisionKeyFrameV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionKeyFrameV10(const ModelCollisionKeyFrameV10 &p_other);
    ModelCollisionKeyFrameV10 &operator=(const ModelCollisionKeyFrameV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionAnimatedObjectV10 {
    helpers::Array<dword> shapeIndices;
    helpers::Array<ModelCollisionKeyFrameV10> keyFrames;

public:
    ModelCollisionAnimatedObjectV10();
    ModelCollisionAnimatedObjectV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionAnimatedObjectV10(const ModelCollisionAnimatedObjectV10 &p_other);
    ModelCollisionAnimatedObjectV10 &operator=(const ModelCollisionAnimatedObjectV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionAnimationV10 {
    qword animation;
    helpers::Array<ModelCollisionAnimatedObjectV10> objects;
    helpers::Array<float3> targetPoints;

public:
    ModelCollisionAnimationV10();
    ModelCollisionAnimationV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionAnimationV10(const ModelCollisionAnimationV10 &p_other);
    ModelCollisionAnimationV10 &operator=(const ModelCollisionAnimationV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV10 {
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;
    helpers::Array<float3> navSeedPoints;

public:
    ModelCollisionMeshV10();
    ModelCollisionMeshV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV10(const ModelCollisionMeshV10 &p_other);
    ModelCollisionMeshV10 &operator=(const ModelCollisionMeshV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionBoxV10 {
    float3 dimensions;
    float3 position;
    float4 rotation;
    byte surface;

public:
    ModelCollisionBoxV10();
    ModelCollisionBoxV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionBoxV10(const ModelCollisionBoxV10 &p_other);
    ModelCollisionBoxV10 &operator=(const ModelCollisionBoxV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV10 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV10();
    ModelCollisionSphereV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV10(const ModelCollisionSphereV10 &p_other);
    ModelCollisionSphereV10 &operator=(const ModelCollisionSphereV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCapsuleV10 {
    float3 p0;
    float3 p1;
    float radius;
    byte surface;

public:
    ModelCollisionCapsuleV10();
    ModelCollisionCapsuleV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCapsuleV10(const ModelCollisionCapsuleV10 &p_other);
    ModelCollisionCapsuleV10 &operator=(const ModelCollisionCapsuleV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV10 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV10();
    ModelCollisionSurfaceV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV10(const ModelCollisionSurfaceV10 &p_other);
    ModelCollisionSurfaceV10 &operator=(const ModelCollisionSurfaceV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileCollisionV10 {
    helpers::Array<ModelCollisionAnimationV10> animations;
    helpers::Array<ModelCollisionMeshV10> meshes;
    helpers::Array<ModelCollisionBoxV10> boxes;
    helpers::Array<ModelCollisionSphereV10> spheres;
    helpers::Array<ModelCollisionCapsuleV10> capsules;
    helpers::Array<ModelCollisionSurfaceV10> surfaces;

public:
    ModelFileCollisionV10();
    ModelFileCollisionV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileCollisionV10(const ModelFileCollisionV10 &p_other);
    ModelFileCollisionV10 &operator=(const ModelFileCollisionV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileCollisionV10 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x410D660000000001 */

template <>
struct Gw2StructCOLL<3>{
struct ModelCollisionKeyFrameV9 {
    float time;
    float3 position;
    float4 orientation;

public:
    ModelCollisionKeyFrameV9();
    ModelCollisionKeyFrameV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionKeyFrameV9(const ModelCollisionKeyFrameV9 &p_other);
    ModelCollisionKeyFrameV9 &operator=(const ModelCollisionKeyFrameV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionAnimatedObjectV9 {
    helpers::Array<dword> shapeIndices;
    helpers::Array<ModelCollisionKeyFrameV9> keyFrames;

public:
    ModelCollisionAnimatedObjectV9();
    ModelCollisionAnimatedObjectV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionAnimatedObjectV9(const ModelCollisionAnimatedObjectV9 &p_other);
    ModelCollisionAnimatedObjectV9 &operator=(const ModelCollisionAnimatedObjectV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionAnimationV9 {
    qword animation;
    helpers::Array<ModelCollisionAnimatedObjectV9> objects;

public:
    ModelCollisionAnimationV9();
    ModelCollisionAnimationV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionAnimationV9(const ModelCollisionAnimationV9 &p_other);
    ModelCollisionAnimationV9 &operator=(const ModelCollisionAnimationV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionMeshV9 {
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV9();
    ModelCollisionMeshV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV9(const ModelCollisionMeshV9 &p_other);
    ModelCollisionMeshV9 &operator=(const ModelCollisionMeshV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionBoxV9 {
    float3 dimensions;
    float3 position;
    float4 rotation;
    byte surface;

public:
    ModelCollisionBoxV9();
    ModelCollisionBoxV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionBoxV9(const ModelCollisionBoxV9 &p_other);
    ModelCollisionBoxV9 &operator=(const ModelCollisionBoxV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV9 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV9();
    ModelCollisionSphereV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV9(const ModelCollisionSphereV9 &p_other);
    ModelCollisionSphereV9 &operator=(const ModelCollisionSphereV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCapsuleV9 {
    float3 p0;
    float3 p1;
    float radius;
    byte surface;

public:
    ModelCollisionCapsuleV9();
    ModelCollisionCapsuleV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCapsuleV9(const ModelCollisionCapsuleV9 &p_other);
    ModelCollisionCapsuleV9 &operator=(const ModelCollisionCapsuleV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV9 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV9();
    ModelCollisionSurfaceV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV9(const ModelCollisionSurfaceV9 &p_other);
    ModelCollisionSurfaceV9 &operator=(const ModelCollisionSurfaceV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileCollisionV9 {
    helpers::Array<ModelCollisionAnimationV9> animations;
    helpers::Array<ModelCollisionMeshV9> meshes;
    helpers::Array<ModelCollisionBoxV9> boxes;
    helpers::Array<ModelCollisionSphereV9> spheres;
    helpers::Array<ModelCollisionCapsuleV9> capsules;
    helpers::Array<ModelCollisionSurfaceV9> surfaces;

public:
    ModelFileCollisionV9();
    ModelFileCollisionV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileCollisionV9(const ModelFileCollisionV9 &p_other);
    ModelFileCollisionV9 &operator=(const ModelFileCollisionV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileCollisionV9 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCOLL<2>{
struct ModelCollisionMeshV8 {
    helpers::Array<qword> animationSequences;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV8();
    ModelCollisionMeshV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV8(const ModelCollisionMeshV8 &p_other);
    ModelCollisionMeshV8 &operator=(const ModelCollisionMeshV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV8 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV8();
    ModelCollisionCloudV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV8(const ModelCollisionCloudV8 &p_other);
    ModelCollisionCloudV8 &operator=(const ModelCollisionCloudV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV8 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV8();
    ModelCollisionCubeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV8(const ModelCollisionCubeV8 &p_other);
    ModelCollisionCubeV8 &operator=(const ModelCollisionCubeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV8 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV8();
    ModelCollisionSphereV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV8(const ModelCollisionSphereV8 &p_other);
    ModelCollisionSphereV8 &operator=(const ModelCollisionSphereV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCapsuleV8 {
    float3 p0;
    float3 p1;
    float radius;
    byte surface;

public:
    ModelCollisionCapsuleV8();
    ModelCollisionCapsuleV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCapsuleV8(const ModelCollisionCapsuleV8 &p_other);
    ModelCollisionCapsuleV8 &operator=(const ModelCollisionCapsuleV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV8 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV8();
    ModelCollisionSurfaceV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV8(const ModelCollisionSurfaceV8 &p_other);
    ModelCollisionSurfaceV8 &operator=(const ModelCollisionSurfaceV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileCollisionV8 {
    helpers::Array<ModelCollisionMeshV8> meshes;
    helpers::Array<ModelCollisionCloudV8> clouds;
    helpers::Array<ModelCollisionCubeV8> cubes;
    helpers::Array<ModelCollisionSphereV8> spheres;
    helpers::Array<ModelCollisionCapsuleV8> capsules;
    helpers::Array<ModelCollisionSurfaceV8> surfaces;

public:
    ModelFileCollisionV8();
    ModelFileCollisionV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileCollisionV8(const ModelFileCollisionV8 &p_other);
    ModelFileCollisionV8 &operator=(const ModelFileCollisionV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileCollisionV8 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCOLL<1>{
struct ModelCollisionMeshV1 {
    helpers::Array<qword> animationSequences;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV1();
    ModelCollisionMeshV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV1(const ModelCollisionMeshV1 &p_other);
    ModelCollisionMeshV1 &operator=(const ModelCollisionMeshV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV1 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV1();
    ModelCollisionCloudV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV1(const ModelCollisionCloudV1 &p_other);
    ModelCollisionCloudV1 &operator=(const ModelCollisionCloudV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV1 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV1();
    ModelCollisionCubeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV1(const ModelCollisionCubeV1 &p_other);
    ModelCollisionCubeV1 &operator=(const ModelCollisionCubeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV1 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV1();
    ModelCollisionSphereV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV1(const ModelCollisionSphereV1 &p_other);
    ModelCollisionSphereV1 &operator=(const ModelCollisionSphereV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV1 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV1();
    ModelCollisionSurfaceV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV1(const ModelCollisionSurfaceV1 &p_other);
    ModelCollisionSurfaceV1 &operator=(const ModelCollisionSurfaceV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileCollisionV1 {
    helpers::Array<ModelCollisionMeshV1> meshes;
    helpers::Array<ModelCollisionCloudV1> clouds;
    helpers::Array<ModelCollisionCubeV1> cubes;
    helpers::Array<ModelCollisionSphereV1> spheres;
    helpers::Array<ModelCollisionSurfaceV1> surfaces;

public:
    ModelFileCollisionV1();
    ModelFileCollisionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileCollisionV1(const ModelFileCollisionV1 &p_other);
    ModelFileCollisionV1 &operator=(const ModelFileCollisionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileCollisionV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructCOLL<0>{
struct ModelCollisionMeshV0 {
    qword animationSequence;
    helpers::Array<float3> vertices;
    helpers::Array<word> indices;
    helpers::Array<byte> surfaces;

public:
    ModelCollisionMeshV0();
    ModelCollisionMeshV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionMeshV0(const ModelCollisionMeshV0 &p_other);
    ModelCollisionMeshV0 &operator=(const ModelCollisionMeshV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCloudV0 {
    qword animationSequence;
    helpers::Array<float3> points;
    byte surface;

public:
    ModelCollisionCloudV0();
    ModelCollisionCloudV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCloudV0(const ModelCollisionCloudV0 &p_other);
    ModelCollisionCloudV0 &operator=(const ModelCollisionCloudV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionCubeV0 {
    float4 transform[3];
    byte surface;

public:
    ModelCollisionCubeV0();
    ModelCollisionCubeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionCubeV0(const ModelCollisionCubeV0 &p_other);
    ModelCollisionCubeV0 &operator=(const ModelCollisionCubeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSphereV0 {
    float radius;
    float3 position;
    byte surface;

public:
    ModelCollisionSphereV0();
    ModelCollisionSphereV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSphereV0(const ModelCollisionSphereV0 &p_other);
    ModelCollisionSphereV0 &operator=(const ModelCollisionSphereV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelCollisionSurfaceV0 {
    helpers::Array<qword> tokens;

public:
    ModelCollisionSurfaceV0();
    ModelCollisionSurfaceV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelCollisionSurfaceV0(const ModelCollisionSurfaceV0 &p_other);
    ModelCollisionSurfaceV0 &operator=(const ModelCollisionSurfaceV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileCollisionV0 {
    helpers::Array<ModelCollisionMeshV0> meshes;
    helpers::Array<ModelCollisionCloudV0> clouds;
    helpers::Array<ModelCollisionCubeV0> cubes;
    helpers::Array<ModelCollisionSphereV0> spheres;
    helpers::Array<ModelCollisionSurfaceV0> surfaces;

public:
    ModelFileCollisionV0();
    ModelFileCollisionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileCollisionV0(const ModelFileCollisionV0 &p_other);
    ModelFileCollisionV0 &operator=(const ModelFileCollisionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileCollisionV0 Gw2Struct;
};


/* ===============================================
 * Chunk: GR2S, versions: 5, strucTab: 0x14218FA40
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructGR2S;

/* Version: 4, ReferencedFunction: 0x410D7E4000000001 */

template <>
struct Gw2StructGR2S<4>{
struct ModelGr2DataV4 {
    helpers::WString filename;
    dword flags;
    helpers::Array<byte> data;

public:
    ModelGr2DataV4();
    ModelGr2DataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGr2DataV4(const ModelGr2DataV4 &p_other);
    ModelGr2DataV4 &operator=(const ModelGr2DataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGr2sV4 {
    helpers::Array<ModelGr2DataV4> gr2Data;

public:
    ModelFileGr2sV4();
    ModelFileGr2sV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGr2sV4(const ModelFileGr2sV4 &p_other);
    ModelFileGr2sV4 &operator=(const ModelFileGr2sV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGr2sV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x410D790000000001 */

template <>
struct Gw2StructGR2S<3>{
struct ModelGr2DataV3 {
    helpers::WString filename;
    dword flags;
    helpers::Array<byte> data;

public:
    ModelGr2DataV3();
    ModelGr2DataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGr2DataV3(const ModelGr2DataV3 &p_other);
    ModelGr2DataV3 &operator=(const ModelGr2DataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGr2sV3 {
    helpers::Array<ModelGr2DataV3> gr2Data;

public:
    ModelFileGr2sV3();
    ModelFileGr2sV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGr2sV3(const ModelFileGr2sV3 &p_other);
    ModelFileGr2sV3 &operator=(const ModelFileGr2sV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGr2sV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x410D721000000001 */

template <>
struct Gw2StructGR2S<2>{
struct ModelGr2DataV2 {
    helpers::WString filename;
    dword flags;
    helpers::Array<byte> data;

public:
    ModelGr2DataV2();
    ModelGr2DataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGr2DataV2(const ModelGr2DataV2 &p_other);
    ModelGr2DataV2 &operator=(const ModelGr2DataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGr2sV2 {
    helpers::Array<ModelGr2DataV2> gr2Data;

public:
    ModelFileGr2sV2();
    ModelFileGr2sV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGr2sV2(const ModelFileGr2sV2 &p_other);
    ModelFileGr2sV2 &operator=(const ModelFileGr2sV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGr2sV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGR2S<1>{
struct ModelGr2DataV1 {
    helpers::WString filename;
    dword flags;
    helpers::Array<byte> data;

public:
    ModelGr2DataV1();
    ModelGr2DataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGr2DataV1(const ModelGr2DataV1 &p_other);
    ModelGr2DataV1 &operator=(const ModelGr2DataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGr2sV1 {
    helpers::Array<ModelGr2DataV1> gr2Data;

public:
    ModelFileGr2sV1();
    ModelFileGr2sV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGr2sV1(const ModelFileGr2sV1 &p_other);
    ModelFileGr2sV1 &operator=(const ModelFileGr2sV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGr2sV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGR2S<0>{
struct ModelGr2DataV0 {
    helpers::Array<byte> data;

public:
    ModelGr2DataV0();
    ModelGr2DataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGr2DataV0(const ModelGr2DataV0 &p_other);
    ModelGr2DataV0 &operator=(const ModelGr2DataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGr2sV0 {
    helpers::Array<ModelGr2DataV0> gr2Data;

public:
    ModelFileGr2sV0();
    ModelFileGr2sV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGr2sV0(const ModelFileGr2sV0 &p_other);
    ModelFileGr2sV0 &operator=(const ModelFileGr2sV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGr2sV0 Gw2Struct;
};


/* ===============================================
 * Chunk: TOOL, versions: 17, strucTab: 0x14218FAC0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructTOOL;

/* Version: 16, ReferencedFunction: 0x410D885000000001 */

template <>
struct Gw2StructTOOL<16>{
struct ModelToolCloudV16 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV16();
    ModelToolCloudV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV16(const ModelToolCloudV16 &p_other);
    ModelToolCloudV16 &operator=(const ModelToolCloudV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV16 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV16();
    ModelToolBlitTextureV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV16(const ModelToolBlitTextureV16 &p_other);
    ModelToolBlitTextureV16 &operator=(const ModelToolBlitTextureV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV16 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV16();
    ModelToolStreakV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV16(const ModelToolStreakV16 &p_other);
    ModelToolStreakV16 &operator=(const ModelToolStreakV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV16 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV16();
    ModelToolLightningV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV16(const ModelToolLightningV16 &p_other);
    ModelToolLightningV16 &operator=(const ModelToolLightningV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV1 {
    helpers::Array<byte> animation;
    helpers::Array<dword> pointers;

public:
    PackGrannyAnimationTypeV1();
    PackGrannyAnimationTypeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV1(const PackGrannyAnimationTypeV1 &p_other);
    PackGrannyAnimationTypeV1 &operator=(const PackGrannyAnimationTypeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolAnimationV16 {
    qword name;
    helpers::WString filename;
    PackGrannyAnimationTypeV1 data;

public:
    ModelToolAnimationV16();
    ModelToolAnimationV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolAnimationV16(const ModelToolAnimationV16 &p_other);
    ModelToolAnimationV16 &operator=(const ModelToolAnimationV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSequenceCompressionInfoV16 {
    qword animToken;
    helpers::WString cmpGroup;
    helpers::WString cmpType;

public:
    ModelSequenceCompressionInfoV16();
    ModelSequenceCompressionInfoV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSequenceCompressionInfoV16(const ModelSequenceCompressionInfoV16 &p_other);
    ModelSequenceCompressionInfoV16 &operator=(const ModelSequenceCompressionInfoV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV16 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV16> cloudData;
    helpers::Array<ModelToolBlitTextureV16> blitTextures;
    helpers::Ptr<ModelToolStreakV16> streakData;
    helpers::Ptr<ModelToolLightningV16> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolAnimationV16> highLodAnimations;
    helpers::Array<ModelSequenceCompressionInfoV16> compressionInfos;
    helpers::String region;

public:
    ModelFileToolV16();
    ModelFileToolV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV16(const ModelFileToolV16 &p_other);
    ModelFileToolV16 &operator=(const ModelFileToolV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<15>{
struct ModelToolCloudV15 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV15();
    ModelToolCloudV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV15(const ModelToolCloudV15 &p_other);
    ModelToolCloudV15 &operator=(const ModelToolCloudV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV15 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV15();
    ModelToolBlitTextureV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV15(const ModelToolBlitTextureV15 &p_other);
    ModelToolBlitTextureV15 &operator=(const ModelToolBlitTextureV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV15 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV15();
    ModelToolStreakV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV15(const ModelToolStreakV15 &p_other);
    ModelToolStreakV15 &operator=(const ModelToolStreakV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV15 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV15();
    ModelToolLightningV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV15(const ModelToolLightningV15 &p_other);
    ModelToolLightningV15 &operator=(const ModelToolLightningV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolAnimationV15 {
    qword name;
    helpers::WString filename;
    PackGrannyAnimationTypeV0 data;

public:
    ModelToolAnimationV15();
    ModelToolAnimationV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolAnimationV15(const ModelToolAnimationV15 &p_other);
    ModelToolAnimationV15 &operator=(const ModelToolAnimationV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSequenceCompressionInfoV15 {
    qword animToken;
    helpers::WString cmpGroup;
    helpers::WString cmpType;

public:
    ModelSequenceCompressionInfoV15();
    ModelSequenceCompressionInfoV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSequenceCompressionInfoV15(const ModelSequenceCompressionInfoV15 &p_other);
    ModelSequenceCompressionInfoV15 &operator=(const ModelSequenceCompressionInfoV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV15 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV15> cloudData;
    helpers::Array<ModelToolBlitTextureV15> blitTextures;
    helpers::Ptr<ModelToolStreakV15> streakData;
    helpers::Ptr<ModelToolLightningV15> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolAnimationV15> highLodAnimations;
    helpers::Array<ModelSequenceCompressionInfoV15> compressionInfos;
    helpers::String region;

public:
    ModelFileToolV15();
    ModelFileToolV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV15(const ModelFileToolV15 &p_other);
    ModelFileToolV15 &operator=(const ModelFileToolV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<14>{
struct ModelToolCloudV14 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV14();
    ModelToolCloudV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV14(const ModelToolCloudV14 &p_other);
    ModelToolCloudV14 &operator=(const ModelToolCloudV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV14 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV14();
    ModelToolBlitTextureV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV14(const ModelToolBlitTextureV14 &p_other);
    ModelToolBlitTextureV14 &operator=(const ModelToolBlitTextureV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV14 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV14();
    ModelToolStreakV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV14(const ModelToolStreakV14 &p_other);
    ModelToolStreakV14 &operator=(const ModelToolStreakV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV14 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV14();
    ModelToolLightningV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV14(const ModelToolLightningV14 &p_other);
    ModelToolLightningV14 &operator=(const ModelToolLightningV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolAnimationV14 {
    qword name;
    helpers::WString filename;
    PackGrannyAnimationTypeV0 data;

public:
    ModelToolAnimationV14();
    ModelToolAnimationV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolAnimationV14(const ModelToolAnimationV14 &p_other);
    ModelToolAnimationV14 &operator=(const ModelToolAnimationV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSequenceCompressionInfoV14 {
    qword animToken;
    helpers::WString cmpGroup;
    helpers::WString cmpType;

public:
    ModelSequenceCompressionInfoV14();
    ModelSequenceCompressionInfoV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSequenceCompressionInfoV14(const ModelSequenceCompressionInfoV14 &p_other);
    ModelSequenceCompressionInfoV14 &operator=(const ModelSequenceCompressionInfoV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV14 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV14> cloudData;
    helpers::Array<ModelToolBlitTextureV14> blitTextures;
    helpers::Ptr<ModelToolStreakV14> streakData;
    helpers::Ptr<ModelToolLightningV14> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolAnimationV14> highLodAnimations;
    helpers::Array<ModelSequenceCompressionInfoV14> compressionInfos;

public:
    ModelFileToolV14();
    ModelFileToolV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV14(const ModelFileToolV14 &p_other);
    ModelFileToolV14 &operator=(const ModelFileToolV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<13>{
struct ModelToolCloudV13 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV13();
    ModelToolCloudV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV13(const ModelToolCloudV13 &p_other);
    ModelToolCloudV13 &operator=(const ModelToolCloudV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV13 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV13();
    ModelToolBlitTextureV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV13(const ModelToolBlitTextureV13 &p_other);
    ModelToolBlitTextureV13 &operator=(const ModelToolBlitTextureV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV13 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV13();
    ModelToolStreakV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV13(const ModelToolStreakV13 &p_other);
    ModelToolStreakV13 &operator=(const ModelToolStreakV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV13 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV13();
    ModelToolLightningV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV13(const ModelToolLightningV13 &p_other);
    ModelToolLightningV13 &operator=(const ModelToolLightningV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolAnimationV13 {
    qword name;
    helpers::WString filename;
    PackGrannyAnimationTypeV0 data;

public:
    ModelToolAnimationV13();
    ModelToolAnimationV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolAnimationV13(const ModelToolAnimationV13 &p_other);
    ModelToolAnimationV13 &operator=(const ModelToolAnimationV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV13 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV13> cloudData;
    helpers::Array<ModelToolBlitTextureV13> blitTextures;
    helpers::Ptr<ModelToolStreakV13> streakData;
    helpers::Ptr<ModelToolLightningV13> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolAnimationV13> highLodAnimations;

public:
    ModelFileToolV13();
    ModelFileToolV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV13(const ModelFileToolV13 &p_other);
    ModelFileToolV13 &operator=(const ModelFileToolV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<12>{
struct ModelToolCloudV12 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV12();
    ModelToolCloudV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV12(const ModelToolCloudV12 &p_other);
    ModelToolCloudV12 &operator=(const ModelToolCloudV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV12 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV12();
    ModelToolBlitTextureV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV12(const ModelToolBlitTextureV12 &p_other);
    ModelToolBlitTextureV12 &operator=(const ModelToolBlitTextureV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV12 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV12();
    ModelToolStreakV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV12(const ModelToolStreakV12 &p_other);
    ModelToolStreakV12 &operator=(const ModelToolStreakV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV12 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV12();
    ModelToolLightningV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV12(const ModelToolLightningV12 &p_other);
    ModelToolLightningV12 &operator=(const ModelToolLightningV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyAnimationTypeV0 {
    helpers::Array<byte> animation;

public:
    PackGrannyAnimationTypeV0();
    PackGrannyAnimationTypeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyAnimationTypeV0(const PackGrannyAnimationTypeV0 &p_other);
    PackGrannyAnimationTypeV0 &operator=(const PackGrannyAnimationTypeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolAnimationV12 {
    qword name;
    helpers::WString filename;
    PackGrannyAnimationTypeV0 data;

public:
    ModelToolAnimationV12();
    ModelToolAnimationV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolAnimationV12(const ModelToolAnimationV12 &p_other);
    ModelToolAnimationV12 &operator=(const ModelToolAnimationV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV12 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV12> cloudData;
    helpers::Array<ModelToolBlitTextureV12> blitTextures;
    helpers::Ptr<ModelToolStreakV12> streakData;
    helpers::Ptr<ModelToolLightningV12> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolAnimationV12> highLodAnimations;

public:
    ModelFileToolV12();
    ModelFileToolV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV12(const ModelFileToolV12 &p_other);
    ModelFileToolV12 &operator=(const ModelFileToolV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x410D884000000001 */

template <>
struct Gw2StructTOOL<11>{
struct ModelToolCloudV11 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV11();
    ModelToolCloudV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV11(const ModelToolCloudV11 &p_other);
    ModelToolCloudV11 &operator=(const ModelToolCloudV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV11 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV11();
    ModelToolBlitTextureV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV11(const ModelToolBlitTextureV11 &p_other);
    ModelToolBlitTextureV11 &operator=(const ModelToolBlitTextureV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV11 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV11();
    ModelToolStreakV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV11(const ModelToolStreakV11 &p_other);
    ModelToolStreakV11 &operator=(const ModelToolStreakV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV11 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV11();
    ModelToolLightningV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV11(const ModelToolLightningV11 &p_other);
    ModelToolLightningV11 &operator=(const ModelToolLightningV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV11 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV11> cloudData;
    helpers::Array<ModelToolBlitTextureV11> blitTextures;
    helpers::Ptr<ModelToolStreakV11> streakData;
    helpers::Ptr<ModelToolLightningV11> lightningData;
    helpers::Array<qword> permutationTokens;

public:
    ModelFileToolV11();
    ModelFileToolV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV11(const ModelFileToolV11 &p_other);
    ModelFileToolV11 &operator=(const ModelFileToolV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x410D89F000000001 */

template <>
struct Gw2StructTOOL<10>{
struct ModelToolCloudV10 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV10();
    ModelToolCloudV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV10(const ModelToolCloudV10 &p_other);
    ModelToolCloudV10 &operator=(const ModelToolCloudV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV10 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV10();
    ModelToolBlitTextureV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV10(const ModelToolBlitTextureV10 &p_other);
    ModelToolBlitTextureV10 &operator=(const ModelToolBlitTextureV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV10 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV10();
    ModelToolStreakV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV10(const ModelToolStreakV10 &p_other);
    ModelToolStreakV10 &operator=(const ModelToolStreakV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV10 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV10();
    ModelToolLightningV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV10(const ModelToolLightningV10 &p_other);
    ModelToolLightningV10 &operator=(const ModelToolLightningV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV10 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV10> cloudData;
    helpers::Array<ModelToolBlitTextureV10> blitTextures;
    helpers::Ptr<ModelToolStreakV10> streakData;
    helpers::Ptr<ModelToolLightningV10> lightningData;
    helpers::Array<qword> permutationTokens;

public:
    ModelFileToolV10();
    ModelFileToolV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV10(const ModelFileToolV10 &p_other);
    ModelFileToolV10 &operator=(const ModelFileToolV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<9>{
struct ModelToolCloudV9 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV9();
    ModelToolCloudV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV9(const ModelToolCloudV9 &p_other);
    ModelToolCloudV9 &operator=(const ModelToolCloudV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV9 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV9();
    ModelToolBlitTextureV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV9(const ModelToolBlitTextureV9 &p_other);
    ModelToolBlitTextureV9 &operator=(const ModelToolBlitTextureV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV9 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV9();
    ModelToolStreakV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV9(const ModelToolStreakV9 &p_other);
    ModelToolStreakV9 &operator=(const ModelToolStreakV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV9 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV9();
    ModelToolLightningV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV9(const ModelToolLightningV9 &p_other);
    ModelToolLightningV9 &operator=(const ModelToolLightningV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolPropertyDataV9 {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelToolPropertyDataV9();
    ModelToolPropertyDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolPropertyDataV9(const ModelToolPropertyDataV9 &p_other);
    ModelToolPropertyDataV9 &operator=(const ModelToolPropertyDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV9 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV9> cloudData;
    helpers::Array<ModelToolBlitTextureV9> blitTextures;
    helpers::Ptr<ModelToolStreakV9> streakData;
    helpers::Ptr<ModelToolLightningV9> lightningData;
    helpers::Array<qword> permutationTokens;
    helpers::Array<ModelToolPropertyDataV9> properties;

public:
    ModelFileToolV9();
    ModelFileToolV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV9(const ModelFileToolV9 &p_other);
    ModelFileToolV9 &operator=(const ModelFileToolV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<8>{
struct ModelToolCloudV8 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV8();
    ModelToolCloudV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV8(const ModelToolCloudV8 &p_other);
    ModelToolCloudV8 &operator=(const ModelToolCloudV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV8 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV8();
    ModelToolBlitTextureV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV8(const ModelToolBlitTextureV8 &p_other);
    ModelToolBlitTextureV8 &operator=(const ModelToolBlitTextureV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV8 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV8();
    ModelToolStreakV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV8(const ModelToolStreakV8 &p_other);
    ModelToolStreakV8 &operator=(const ModelToolStreakV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV8 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV8();
    ModelToolLightningV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV8(const ModelToolLightningV8 &p_other);
    ModelToolLightningV8 &operator=(const ModelToolLightningV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV8 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV8> cloudData;
    helpers::Array<ModelToolBlitTextureV8> blitTextures;
    helpers::Ptr<ModelToolStreakV8> streakData;
    helpers::Ptr<ModelToolLightningV8> lightningData;
    helpers::Array<qword> permutationTokens;

public:
    ModelFileToolV8();
    ModelFileToolV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV8(const ModelFileToolV8 &p_other);
    ModelFileToolV8 &operator=(const ModelFileToolV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<7>{
struct ModelToolCloudV7 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV7();
    ModelToolCloudV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV7(const ModelToolCloudV7 &p_other);
    ModelToolCloudV7 &operator=(const ModelToolCloudV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV7 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV7();
    ModelToolBlitTextureV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV7(const ModelToolBlitTextureV7 &p_other);
    ModelToolBlitTextureV7 &operator=(const ModelToolBlitTextureV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV7 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV7();
    ModelToolStreakV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV7(const ModelToolStreakV7 &p_other);
    ModelToolStreakV7 &operator=(const ModelToolStreakV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolLightningV7 {
    helpers::Array<helpers::String> systemNames;
    helpers::Array<helpers::String> boltNames;
    helpers::Array<helpers::String> nodeNames;

public:
    ModelToolLightningV7();
    ModelToolLightningV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolLightningV7(const ModelToolLightningV7 &p_other);
    ModelToolLightningV7 &operator=(const ModelToolLightningV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV7 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV7> cloudData;
    helpers::Array<ModelToolBlitTextureV7> blitTextures;
    helpers::Ptr<ModelToolStreakV7> streakData;
    helpers::Ptr<ModelToolLightningV7> lightningData;

public:
    ModelFileToolV7();
    ModelFileToolV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV7(const ModelFileToolV7 &p_other);
    ModelFileToolV7 &operator=(const ModelFileToolV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x410D899000000001 */

template <>
struct Gw2StructTOOL<6>{
struct ModelToolCloudV6 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV6();
    ModelToolCloudV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV6(const ModelToolCloudV6 &p_other);
    ModelToolCloudV6 &operator=(const ModelToolCloudV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV6 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV6();
    ModelToolBlitTextureV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV6(const ModelToolBlitTextureV6 &p_other);
    ModelToolBlitTextureV6 &operator=(const ModelToolBlitTextureV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV6 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV6();
    ModelToolStreakV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV6(const ModelToolStreakV6 &p_other);
    ModelToolStreakV6 &operator=(const ModelToolStreakV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV6 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV6> cloudData;
    helpers::Array<ModelToolBlitTextureV6> blitTextures;
    helpers::Ptr<ModelToolStreakV6> streakData;

public:
    ModelFileToolV6();
    ModelFileToolV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV6(const ModelFileToolV6 &p_other);
    ModelFileToolV6 &operator=(const ModelFileToolV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x410D896000000001 */

template <>
struct Gw2StructTOOL<5>{
struct ModelToolCloudV5 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;

public:
    ModelToolCloudV5();
    ModelToolCloudV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV5(const ModelToolCloudV5 &p_other);
    ModelToolCloudV5 &operator=(const ModelToolCloudV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolMotionV5 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelToolMotionV5();
    ModelToolMotionV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolMotionV5(const ModelToolMotionV5 &p_other);
    ModelToolMotionV5 &operator=(const ModelToolMotionV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV5 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV5();
    ModelToolBlitTextureV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV5(const ModelToolBlitTextureV5 &p_other);
    ModelToolBlitTextureV5 &operator=(const ModelToolBlitTextureV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV5 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV5();
    ModelToolStreakV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV5(const ModelToolStreakV5 &p_other);
    ModelToolStreakV5 &operator=(const ModelToolStreakV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV5 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Array<helpers::String> obstacleNames;
    helpers::Ptr<ModelToolCloudV5> cloudData;
    helpers::Array<ModelToolMotionV5> motions;
    helpers::Array<ModelToolBlitTextureV5> blitTextures;
    helpers::Ptr<ModelToolStreakV5> streakData;

public:
    ModelFileToolV5();
    ModelFileToolV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV5(const ModelFileToolV5 &p_other);
    ModelFileToolV5 &operator=(const ModelFileToolV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<4>{
struct ModelToolCloudV4 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;
    helpers::Array<helpers::String> obstacleNames;

public:
    ModelToolCloudV4();
    ModelToolCloudV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV4(const ModelToolCloudV4 &p_other);
    ModelToolCloudV4 &operator=(const ModelToolCloudV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolMotionV4 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelToolMotionV4();
    ModelToolMotionV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolMotionV4(const ModelToolMotionV4 &p_other);
    ModelToolMotionV4 &operator=(const ModelToolMotionV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV4 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV4();
    ModelToolBlitTextureV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV4(const ModelToolBlitTextureV4 &p_other);
    ModelToolBlitTextureV4 &operator=(const ModelToolBlitTextureV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolStreakV4 {
    helpers::Array<helpers::String> streakNames;
    helpers::Array<helpers::String> anchorNames;

public:
    ModelToolStreakV4();
    ModelToolStreakV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolStreakV4(const ModelToolStreakV4 &p_other);
    ModelToolStreakV4 &operator=(const ModelToolStreakV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV4 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Ptr<ModelToolCloudV4> cloudData;
    helpers::Array<ModelToolMotionV4> motions;
    helpers::Array<ModelToolBlitTextureV4> blitTextures;
    helpers::Ptr<ModelToolStreakV4> streakData;

public:
    ModelFileToolV4();
    ModelFileToolV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV4(const ModelFileToolV4 &p_other);
    ModelFileToolV4 &operator=(const ModelFileToolV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<3>{
struct ModelToolCloudV3 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;
    helpers::Array<helpers::String> obstacleNames;

public:
    ModelToolCloudV3();
    ModelToolCloudV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV3(const ModelToolCloudV3 &p_other);
    ModelToolCloudV3 &operator=(const ModelToolCloudV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolMotionV3 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelToolMotionV3();
    ModelToolMotionV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolMotionV3(const ModelToolMotionV3 &p_other);
    ModelToolMotionV3 &operator=(const ModelToolMotionV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV3 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV3();
    ModelToolBlitTextureV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV3(const ModelToolBlitTextureV3 &p_other);
    ModelToolBlitTextureV3 &operator=(const ModelToolBlitTextureV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV3 {
    qword modelType;
    helpers::Array<helpers::String> materialNames;
    helpers::Ptr<ModelToolCloudV3> cloudData;
    helpers::Array<ModelToolMotionV3> motions;
    helpers::Array<ModelToolBlitTextureV3> blitTextures;

public:
    ModelFileToolV3();
    ModelFileToolV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV3(const ModelFileToolV3 &p_other);
    ModelFileToolV3 &operator=(const ModelFileToolV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<2>{
struct ModelToolCloudV2 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;
    helpers::Array<helpers::String> obstacleNames;

public:
    ModelToolCloudV2();
    ModelToolCloudV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV2(const ModelToolCloudV2 &p_other);
    ModelToolCloudV2 &operator=(const ModelToolCloudV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolMotionV2 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelToolMotionV2();
    ModelToolMotionV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolMotionV2(const ModelToolMotionV2 &p_other);
    ModelToolMotionV2 &operator=(const ModelToolMotionV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolBlitTextureV2 {
    qword blitId;
    helpers::FileName filename;

public:
    ModelToolBlitTextureV2();
    ModelToolBlitTextureV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolBlitTextureV2(const ModelToolBlitTextureV2 &p_other);
    ModelToolBlitTextureV2 &operator=(const ModelToolBlitTextureV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV2 {
    helpers::Array<helpers::String> materialNames;
    helpers::Ptr<ModelToolCloudV2> cloudData;
    helpers::Array<ModelToolMotionV2> motions;
    helpers::Array<ModelToolBlitTextureV2> blitTextures;

public:
    ModelFileToolV2();
    ModelFileToolV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV2(const ModelFileToolV2 &p_other);
    ModelFileToolV2 &operator=(const ModelFileToolV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<1>{
struct ModelToolCloudV1 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;
    helpers::Array<helpers::String> obstacleNames;

public:
    ModelToolCloudV1();
    ModelToolCloudV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV1(const ModelToolCloudV1 &p_other);
    ModelToolCloudV1 &operator=(const ModelToolCloudV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelToolMotionV1 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelToolMotionV1();
    ModelToolMotionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolMotionV1(const ModelToolMotionV1 &p_other);
    ModelToolMotionV1 &operator=(const ModelToolMotionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV1 {
    helpers::Array<helpers::String> materialNames;
    helpers::Ptr<ModelToolCloudV1> cloudData;
    helpers::Array<ModelToolMotionV1> motions;

public:
    ModelFileToolV1();
    ModelFileToolV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV1(const ModelFileToolV1 &p_other);
    ModelFileToolV1 &operator=(const ModelFileToolV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTOOL<0>{
struct ModelToolCloudV0 {
    helpers::Array<helpers::String> cloudNames;
    helpers::Array<helpers::String> emitterNames;
    helpers::Array<helpers::String> obstacleNames;

public:
    ModelToolCloudV0();
    ModelToolCloudV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelToolCloudV0(const ModelToolCloudV0 &p_other);
    ModelToolCloudV0 &operator=(const ModelToolCloudV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileToolV0 {
    helpers::Array<helpers::String> materialNames;
    helpers::Ptr<ModelToolCloudV0> cloudData;

public:
    ModelFileToolV0();
    ModelFileToolV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileToolV0(const ModelFileToolV0 &p_other);
    ModelFileToolV0 &operator=(const ModelFileToolV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileToolV0 Gw2Struct;
};


/* ===============================================
 * Chunk: ROOT, versions: 2, strucTab: 0x14218FC58
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructROOT;

/* Version: 1, ReferencedFunction: 0x410D840000000001 */

template <>
struct Gw2StructROOT<1>{
struct ModelRootMotionV1 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> posValues;
    helpers::Array<float4> quatValues;

public:
    ModelRootMotionV1();
    ModelRootMotionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelRootMotionV1(const ModelRootMotionV1 &p_other);
    ModelRootMotionV1 &operator=(const ModelRootMotionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileRootMotionV1 {
    helpers::Array<ModelRootMotionV1> rootMotions;

public:
    ModelFileRootMotionV1();
    ModelFileRootMotionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileRootMotionV1(const ModelFileRootMotionV1 &p_other);
    ModelFileRootMotionV1 &operator=(const ModelFileRootMotionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileRootMotionV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructROOT<0>{
struct ModelRootMotionV0 {
    qword sequence;
    helpers::Array<float> keys;
    helpers::Array<float3> values;

public:
    ModelRootMotionV0();
    ModelRootMotionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelRootMotionV0(const ModelRootMotionV0 &p_other);
    ModelRootMotionV0 &operator=(const ModelRootMotionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileRootMotionV0 {
    helpers::Array<ModelRootMotionV0> rootMotions;

public:
    ModelFileRootMotionV0();
    ModelFileRootMotionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileRootMotionV0(const ModelFileRootMotionV0 &p_other);
    ModelFileRootMotionV0 &operator=(const ModelFileRootMotionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileRootMotionV0 Gw2Struct;
};


/* ===============================================
 * Chunk: GAME, versions: 1, strucTab: 0x14218FC88
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructGAME;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<0>{
struct ModelFileGame {
    helpers::Array<byte> gameData;

public:
    ModelFileGame();
    ModelFileGame(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGame(const ModelFileGame &p_other);
    ModelFileGame &operator=(const ModelFileGame &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGame Gw2Struct;
};


/* ===============================================
 * Chunk: ICON, versions: 1, strucTab: 0x14218FCA0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructICON;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructICON<0>{
struct ModelFileIcon {
    helpers::Array<byte> jpgData;

public:
    ModelFileIcon();
    ModelFileIcon(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileIcon(const ModelFileIcon &p_other);
    ModelFileIcon &operator=(const ModelFileIcon &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileIcon Gw2Struct;
};


/* ===============================================
 * Chunk: SKEL, versions: 2, strucTab: 0x14218FCB8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructSKEL;

/* Version: 1, ReferencedFunction: 0x410D845000000001 */

template <>
struct Gw2StructSKEL<1>{
struct ModelTransformData {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformData();
    ModelTransformData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformData(const ModelTransformData &p_other);
    ModelTransformData &operator=(const ModelTransformData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneData {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformData LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneData();
    ModelBoneData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneData(const ModelBoneData &p_other);
    ModelBoneData &operator=(const ModelBoneData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelGrannySkeletonV1 {
    helpers::String Name;
    helpers::Array<ModelBoneData> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelGrannySkeletonV1();
    ModelGrannySkeletonV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGrannySkeletonV1(const ModelGrannySkeletonV1 &p_other);
    ModelGrannySkeletonV1 &operator=(const ModelGrannySkeletonV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingData {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingData();
    ModelMeshBindingData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingData(const ModelMeshBindingData &p_other);
    ModelMeshBindingData &operator=(const ModelMeshBindingData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelGrannyModelV1 {
    helpers::String Name;
    helpers::Ptr<ModelGrannySkeletonV1> Skeleton;
    ModelTransformData InitialPlacement;
    helpers::Array<ModelMeshBindingData> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelGrannyModelV1();
    ModelGrannyModelV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGrannyModelV1(const ModelGrannyModelV1 &p_other);
    ModelGrannyModelV1 &operator=(const ModelGrannyModelV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV63 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV63();
    ModelBoneConstraintLinkV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV63(const ModelBoneConstraintLinkV63 &p_other);
    ModelBoneConstraintLinkV63 &operator=(const ModelBoneConstraintLinkV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV63 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV63> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV63();
    ModelBoneConstraintV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV63(const ModelBoneConstraintV63 &p_other);
    ModelBoneConstraintV63 &operator=(const ModelBoneConstraintV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyMirrorSpecType {
    helpers::Array<byte> mirrorSpec;

public:
    PackGrannyMirrorSpecType();
    PackGrannyMirrorSpecType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyMirrorSpecType(const PackGrannyMirrorSpecType &p_other);
    PackGrannyMirrorSpecType &operator=(const PackGrannyMirrorSpecType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV63 {
    PackGrannyTrackMaskType data;
    qword token;

public:
    ModelTrackMaskV63();
    ModelTrackMaskV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV63(const ModelTrackMaskV63 &p_other);
    ModelTrackMaskV63 &operator=(const ModelTrackMaskV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV63 {
    helpers::Ptr<ModelGrannyModelV1> grannyModel;
    helpers::Array<ModelBoneConstraintV63> boneConstraints;
    helpers::Array<dword> boneFlags;
    PackGrannyMirrorSpecType mirrorSpec;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV63> trackMasks;

public:
    ModelSkeletonDataV63();
    ModelSkeletonDataV63(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV63(const ModelSkeletonDataV63 &p_other);
    ModelSkeletonDataV63 &operator=(const ModelSkeletonDataV63 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonOverridesV1 {
    helpers::Array<ModelBoneConstraintV63> boneConstraints;

public:
    ModelSkeletonOverridesV1();
    ModelSkeletonOverridesV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonOverridesV1(const ModelSkeletonOverridesV1 &p_other);
    ModelSkeletonOverridesV1 &operator=(const ModelSkeletonOverridesV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileSkeletonV1 {
    helpers::Ptr<ModelSkeletonDataV63> skeletonData;
    helpers::FileName fileReference;
    helpers::Ptr<ModelSkeletonOverridesV1> overrides;

public:
    ModelFileSkeletonV1();
    ModelFileSkeletonV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSkeletonV1(const ModelFileSkeletonV1 &p_other);
    ModelFileSkeletonV1 &operator=(const ModelFileSkeletonV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileSkeletonV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructSKEL<0>{
struct ModelTransformData {
    dword Flags;
    float3 Position;
    float4 Orientation;
    float3 ScaleShear[3];

public:
    ModelTransformData();
    ModelTransformData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTransformData(const ModelTransformData &p_other);
    ModelTransformData &operator=(const ModelTransformData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneData {
    helpers::String Name;
    dword ParentIndex;
    ModelTransformData LocalTransform;
    float4 InverseWorld4x4[4];
    float LODError;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelBoneData();
    ModelBoneData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneData(const ModelBoneData &p_other);
    ModelBoneData &operator=(const ModelBoneData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelGrannySkeletonV0 {
    helpers::String Name;
    helpers::Array<ModelBoneData> Bones;
    dword LODType;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelGrannySkeletonV0();
    ModelGrannySkeletonV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGrannySkeletonV0(const ModelGrannySkeletonV0 &p_other);
    ModelGrannySkeletonV0 &operator=(const ModelGrannySkeletonV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshBindingData {
    helpers::Ptr<byte> Mesh;

public:
    ModelMeshBindingData();
    ModelMeshBindingData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshBindingData(const ModelMeshBindingData &p_other);
    ModelMeshBindingData &operator=(const ModelMeshBindingData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelGrannyModelV0 {
    helpers::String Name;
    helpers::Ptr<ModelGrannySkeletonV0> Skeleton;
    ModelTransformData InitialPlacement;
    helpers::Array<ModelMeshBindingData> MeshBindings;
    helpers::Ptr<byte> ExtendedData.Type;
    helpers::Ptr<byte> ExtendedData.Object;

public:
    ModelGrannyModelV0();
    ModelGrannyModelV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelGrannyModelV0(const ModelGrannyModelV0 &p_other);
    ModelGrannyModelV0 &operator=(const ModelGrannyModelV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintLinkV62 {
    float angle;
    float azimuth;
    float2 distance;
    qword token;

public:
    ModelBoneConstraintLinkV62();
    ModelBoneConstraintLinkV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintLinkV62(const ModelBoneConstraintLinkV62 &p_other);
    ModelBoneConstraintLinkV62 &operator=(const ModelBoneConstraintLinkV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneConstraintV62 {
    qword token;
    word flags;
    float twistOffset;
    float animBlend;
    float drag;
    float ellipseRatio;
    float gravity;
    float collisionRadius;
    float wind;
    float2 angle;
    float angleStrength;
    byte angleType;
    float2 distanceInner;
    float distanceInnerStrength;
    byte distanceInnerType;
    helpers::Array<ModelBoneConstraintLinkV62> links;
    float2 distanceOuter;
    float distanceOuterStrength;
    byte distanceOuterType;
    float2 twist;
    float twistStrength;
    byte twistType;

public:
    ModelBoneConstraintV62();
    ModelBoneConstraintV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneConstraintV62(const ModelBoneConstraintV62 &p_other);
    ModelBoneConstraintV62 &operator=(const ModelBoneConstraintV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelBoneSymmetryV62 {
    qword boneLeft;
    qword boneRight;

public:
    ModelBoneSymmetryV62();
    ModelBoneSymmetryV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelBoneSymmetryV62(const ModelBoneSymmetryV62 &p_other);
    ModelBoneSymmetryV62 &operator=(const ModelBoneSymmetryV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackGrannyTrackMaskType {
    helpers::Array<byte> trackMask;

public:
    PackGrannyTrackMaskType();
    PackGrannyTrackMaskType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackGrannyTrackMaskType(const PackGrannyTrackMaskType &p_other);
    PackGrannyTrackMaskType &operator=(const PackGrannyTrackMaskType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelTrackMaskV62 {
    PackGrannyTrackMaskType data;
    qword token;

public:
    ModelTrackMaskV62();
    ModelTrackMaskV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelTrackMaskV62(const ModelTrackMaskV62 &p_other);
    ModelTrackMaskV62 &operator=(const ModelTrackMaskV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelSkeletonDataV62 {
    helpers::Ptr<ModelGrannyModelV0> grannyModel;
    helpers::Array<ModelBoneConstraintV62> boneConstraints;
    helpers::Array<dword> boneFlags;
    helpers::Array<ModelBoneSymmetryV62> boneSymmetries;
    helpers::Array<dword> emitterBones;
    helpers::Array<ModelTrackMaskV62> trackMasks;

public:
    ModelSkeletonDataV62();
    ModelSkeletonDataV62(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelSkeletonDataV62(const ModelSkeletonDataV62 &p_other);
    ModelSkeletonDataV62 &operator=(const ModelSkeletonDataV62 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileSkeletonV0 {
    helpers::Ptr<ModelSkeletonDataV62> skeletonData;
    helpers::FileName fileReference;

public:
    ModelFileSkeletonV0();
    ModelFileSkeletonV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSkeletonV0(const ModelFileSkeletonV0 &p_other);
    ModelFileSkeletonV0 &operator=(const ModelFileSkeletonV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileSkeletonV0 Gw2Struct;
};


/* ===============================================
 * Chunk: PRPS, versions: 1, strucTab: 0x14218FCE8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructPRPS;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPRPS<0>{
struct ModelFixedOffsetData {
    qword name;
    qword parentBone;
    float3 translation;

public:
    ModelFixedOffsetData();
    ModelFixedOffsetData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFixedOffsetData(const ModelFixedOffsetData &p_other);
    ModelFixedOffsetData &operator=(const ModelFixedOffsetData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelPropertyData {
    qword id;
    dword type;
    dword mergeIndex;
    float time;
    qword val;
    helpers::FileName strVal;

public:
    ModelPropertyData();
    ModelPropertyData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelPropertyData(const ModelPropertyData &p_other);
    ModelPropertyData &operator=(const ModelPropertyData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileProperties {
    helpers::Array<ModelFixedOffsetData> fixedOffsetData;
    helpers::Array<ModelPropertyData> properties;

public:
    ModelFileProperties();
    ModelFileProperties(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileProperties(const ModelFileProperties &p_other);
    ModelFileProperties &operator=(const ModelFileProperties &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileProperties Gw2Struct;
};


/* ===============================================
 * Chunk: GEOM, versions: 2, strucTab: 0x14218FD00
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructGEOM;

/* Version: 1, ReferencedFunction: 0x410D6E7000000001 */

template <>
struct Gw2StructGEOM<1>{
struct ModelMeshMorphVertV66 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV66();
    ModelMeshMorphVertV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV66(const ModelMeshMorphVertV66 &p_other);
    ModelMeshMorphVertV66 &operator=(const ModelMeshMorphVertV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV66 {
    helpers::Array<ModelMeshMorphVertV66> positions;
    helpers::Array<ModelMeshMorphVertV66> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV66();
    ModelMeshMorphTargetV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV66(const ModelMeshMorphTargetV66 &p_other);
    ModelMeshMorphTargetV66 &operator=(const ModelMeshMorphTargetV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshVertexDataV1 {
    dword vertexCount;
    PackVertexType mesh;

public:
    ModelMeshVertexDataV1();
    ModelMeshVertexDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshVertexDataV1(const ModelMeshVertexDataV1 &p_other);
    ModelMeshVertexDataV1 &operator=(const ModelMeshVertexDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshIndexDataV1 {
    helpers::Array<word> indices;

public:
    ModelMeshIndexDataV1();
    ModelMeshIndexDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshIndexDataV1(const ModelMeshIndexDataV1 &p_other);
    ModelMeshIndexDataV1 &operator=(const ModelMeshIndexDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshGeometryV1 {
    ModelMeshVertexDataV1 verts;
    ModelMeshIndexDataV1 indices;
    helpers::Array<ModelMeshIndexDataV1> lods;
    helpers::Array<dword> transforms;

public:
    ModelMeshGeometryV1();
    ModelMeshGeometryV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshGeometryV1(const ModelMeshGeometryV1 &p_other);
    ModelMeshGeometryV1 &operator=(const ModelMeshGeometryV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV66 {
    qword visBone;
    helpers::Array<ModelMeshMorphTargetV66> morphTargets;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;
    helpers::Array<qword> boneBindings;
    helpers::Ptr<ModelMeshGeometryV1> geometry;

public:
    ModelMeshDataV66();
    ModelMeshDataV66(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV66(const ModelMeshDataV66 &p_other);
    ModelMeshDataV66 &operator=(const ModelMeshDataV66 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGeometryV1 {
    helpers::Ptr<ModelMeshDataV66> meshes;

public:
    ModelFileGeometryV1();
    ModelFileGeometryV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGeometryV1(const ModelFileGeometryV1 &p_other);
    ModelFileGeometryV1 &operator=(const ModelFileGeometryV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGeometryV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGEOM<0>{
struct ModelMeshMorphVertV65 {
    word index;
    float3 vector;

public:
    ModelMeshMorphVertV65();
    ModelMeshMorphVertV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphVertV65(const ModelMeshMorphVertV65 &p_other);
    ModelMeshMorphVertV65 &operator=(const ModelMeshMorphVertV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshMorphTargetV65 {
    helpers::Array<ModelMeshMorphVertV65> positions;
    helpers::Array<ModelMeshMorphVertV65> normals;
    qword mesh;

public:
    ModelMeshMorphTargetV65();
    ModelMeshMorphTargetV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshMorphTargetV65(const ModelMeshMorphTargetV65 &p_other);
    ModelMeshMorphTargetV65 &operator=(const ModelMeshMorphTargetV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct GrBoundData {
    float3 center;
    float3 boxExtent;
    float sphereRadius;

public:
    GrBoundData();
    GrBoundData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    GrBoundData(const GrBoundData &p_other);
    GrBoundData &operator=(const GrBoundData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackVertexType {
    dword fvf;
    helpers::Array<byte> vertices;

public:
    PackVertexType();
    PackVertexType(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackVertexType(const PackVertexType &p_other);
    PackVertexType &operator=(const PackVertexType &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshVertexDataV0 {
    dword vertexCount;
    PackVertexType mesh;

public:
    ModelMeshVertexDataV0();
    ModelMeshVertexDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshVertexDataV0(const ModelMeshVertexDataV0 &p_other);
    ModelMeshVertexDataV0 &operator=(const ModelMeshVertexDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshIndexDataV0 {
    helpers::Array<word> indices;

public:
    ModelMeshIndexDataV0();
    ModelMeshIndexDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshIndexDataV0(const ModelMeshIndexDataV0 &p_other);
    ModelMeshIndexDataV0 &operator=(const ModelMeshIndexDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshGeometryV0 {
    ModelMeshVertexDataV0 verts;
    ModelMeshIndexDataV0 indices;
    helpers::Array<ModelMeshIndexDataV0> lods;

public:
    ModelMeshGeometryV0();
    ModelMeshGeometryV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshGeometryV0(const ModelMeshGeometryV0 &p_other);
    ModelMeshGeometryV0 &operator=(const ModelMeshGeometryV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelMeshDataV65 {
    qword visBone;
    helpers::Array<ModelMeshMorphTargetV65> morphTargets;
    dword flags;
    helpers::Array<dword> seamVertIndices;
    qword meshName;
    float3 minBound;
    float3 maxBound;
    helpers::Array<GrBoundData> bounds;
    dword materialIndex;
    helpers::String materialName;
    helpers::Array<helpers::String> boneNames;
    helpers::Ptr<ModelMeshGeometryV0> geometry;

public:
    ModelMeshDataV65();
    ModelMeshDataV65(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelMeshDataV65(const ModelMeshDataV65 &p_other);
    ModelMeshDataV65 &operator=(const ModelMeshDataV65 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileGeometryV0 {
    helpers::Ptr<ModelMeshDataV65> meshes;

public:
    ModelFileGeometryV0();
    ModelFileGeometryV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileGeometryV0(const ModelFileGeometryV0 &p_other);
    ModelFileGeometryV0 &operator=(const ModelFileGeometryV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileGeometryV0 Gw2Struct;
};


/* ===============================================
 * Chunk: EXPA, versions: 4, strucTab: 0x14218FD30
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructEXPA;

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructEXPA<3>{
struct ModelFileSnapPointV3 {
    qword bone;
    qword shape;
    dword flags;

public:
    ModelFileSnapPointV3();
    ModelFileSnapPointV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSnapPointV3(const ModelFileSnapPointV3 &p_other);
    ModelFileSnapPointV3 &operator=(const ModelFileSnapPointV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelExpansionEmitterV3 {
    float curl;
    float vortexSize;
    dword curlQuality;
    dword curlFlags;
    float fieldScale;

public:
    ModelExpansionEmitterV3();
    ModelExpansionEmitterV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelExpansionEmitterV3(const ModelExpansionEmitterV3 &p_other);
    ModelExpansionEmitterV3 &operator=(const ModelExpansionEmitterV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileExpansionV3 {
    helpers::Array<ModelFileSnapPointV3> snapPoints;
    float snapPointPriority;
    helpers::Array<ModelExpansionEmitterV3> emitters;

public:
    ModelFileExpansionV3();
    ModelFileExpansionV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileExpansionV3(const ModelFileExpansionV3 &p_other);
    ModelFileExpansionV3 &operator=(const ModelFileExpansionV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileExpansionV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructEXPA<2>{
struct ModelFileSnapPointV2 {
    qword bone;
    qword shape;

public:
    ModelFileSnapPointV2();
    ModelFileSnapPointV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSnapPointV2(const ModelFileSnapPointV2 &p_other);
    ModelFileSnapPointV2 &operator=(const ModelFileSnapPointV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelExpansionEmitterV2 {
    float curl;
    float vortexSize;
    dword curlQuality;
    dword curlFlags;
    float fieldScale;

public:
    ModelExpansionEmitterV2();
    ModelExpansionEmitterV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelExpansionEmitterV2(const ModelExpansionEmitterV2 &p_other);
    ModelExpansionEmitterV2 &operator=(const ModelExpansionEmitterV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileExpansionV2 {
    helpers::Array<ModelFileSnapPointV2> snapPoints;
    float snapPointPriority;
    helpers::Array<ModelExpansionEmitterV2> emitters;

public:
    ModelFileExpansionV2();
    ModelFileExpansionV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileExpansionV2(const ModelFileExpansionV2 &p_other);
    ModelFileExpansionV2 &operator=(const ModelFileExpansionV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileExpansionV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructEXPA<1>{
struct ModelFileSnapPointV1 {
    qword bone;

public:
    ModelFileSnapPointV1();
    ModelFileSnapPointV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSnapPointV1(const ModelFileSnapPointV1 &p_other);
    ModelFileSnapPointV1 &operator=(const ModelFileSnapPointV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelExpansionEmitterV1 {
    float curl;
    float vortexSize;
    dword curlQuality;
    dword curlFlags;
    float fieldScale;

public:
    ModelExpansionEmitterV1();
    ModelExpansionEmitterV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelExpansionEmitterV1(const ModelExpansionEmitterV1 &p_other);
    ModelExpansionEmitterV1 &operator=(const ModelExpansionEmitterV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileExpansionV1 {
    helpers::Array<ModelFileSnapPointV1> snapPoints;
    float snapPointPriority;
    helpers::Array<ModelExpansionEmitterV1> emitters;

public:
    ModelFileExpansionV1();
    ModelFileExpansionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileExpansionV1(const ModelFileExpansionV1 &p_other);
    ModelFileExpansionV1 &operator=(const ModelFileExpansionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileExpansionV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructEXPA<0>{
struct ModelFileSnapPointV0 {
    qword bone;

public:
    ModelFileSnapPointV0();
    ModelFileSnapPointV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileSnapPointV0(const ModelFileSnapPointV0 &p_other);
    ModelFileSnapPointV0 &operator=(const ModelFileSnapPointV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelExpansionEmitterV0 {
    float curl;
    float vortexSize;

public:
    ModelExpansionEmitterV0();
    ModelExpansionEmitterV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelExpansionEmitterV0(const ModelExpansionEmitterV0 &p_other);
    ModelExpansionEmitterV0 &operator=(const ModelExpansionEmitterV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ModelFileExpansionV0 {
    helpers::Array<ModelFileSnapPointV0> snapPoints;
    float snapPointPriority;
    helpers::Array<ModelExpansionEmitterV0> emitters;

public:
    ModelFileExpansionV0();
    ModelFileExpansionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ModelFileExpansionV0(const ModelFileExpansionV0 &p_other);
    ModelFileExpansionV0 &operator=(const ModelFileExpansionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ModelFileExpansionV0 Gw2Struct;
};


/* ===============================================
 * Chunk: PHYS, versions: 9, strucTab: 0x1422A95A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructPHYS;

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<8>{
struct SceneBoxShapeV8 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV8();
    SceneBoxShapeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV8(const SceneBoxShapeV8 &p_other);
    SceneBoxShapeV8 &operator=(const SceneBoxShapeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV8 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV8();
    SceneSphereShapeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV8(const SceneSphereShapeV8 &p_other);
    SceneSphereShapeV8 &operator=(const SceneSphereShapeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV8 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV8();
    SceneCapsuleShapeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV8(const SceneCapsuleShapeV8 &p_other);
    SceneCapsuleShapeV8 &operator=(const SceneCapsuleShapeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV8 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<byte> surfaces;

public:
    SceneMeshShapeV8();
    SceneMeshShapeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV8(const SceneMeshShapeV8 &p_other);
    SceneMeshShapeV8 &operator=(const SceneMeshShapeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSurfaceV8 {
    helpers::Array<qword> tokens;

public:
    SceneSurfaceV8();
    SceneSurfaceV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSurfaceV8(const SceneSurfaceV8 &p_other);
    SceneSurfaceV8 &operator=(const SceneSurfaceV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV8 {
    helpers::Array<SceneBoxShapeV8> boxes;
    helpers::Array<SceneSphereShapeV8> spheres;
    helpers::Array<SceneCapsuleShapeV8> capsules;
    helpers::Array<SceneMeshShapeV8> meshes;
    helpers::Array<SceneSurfaceV8> surfaces;

public:
    SceneFilePhysicsV8();
    SceneFilePhysicsV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV8(const SceneFilePhysicsV8 &p_other);
    SceneFilePhysicsV8 &operator=(const SceneFilePhysicsV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<7>{
struct SceneBoxShapeV7 {
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV7();
    SceneBoxShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV7(const SceneBoxShapeV7 &p_other);
    SceneBoxShapeV7 &operator=(const SceneBoxShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV7 {
    float3 center;
    float radius;

public:
    SceneSphereShapeV7();
    SceneSphereShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV7(const SceneSphereShapeV7 &p_other);
    SceneSphereShapeV7 &operator=(const SceneSphereShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV7 {
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV7();
    SceneCapsuleShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV7(const SceneCapsuleShapeV7 &p_other);
    SceneCapsuleShapeV7 &operator=(const SceneCapsuleShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV7 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV7();
    SceneMeshShapeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV7(const SceneMeshShapeV7 &p_other);
    SceneMeshShapeV7 &operator=(const SceneMeshShapeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV7 {
    helpers::Array<SceneBoxShapeV7> boxes;
    helpers::Array<SceneSphereShapeV7> spheres;
    helpers::Array<SceneCapsuleShapeV7> capsules;
    helpers::Array<SceneMeshShapeV7> meshes;

public:
    SceneFilePhysicsV7();
    SceneFilePhysicsV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV7(const SceneFilePhysicsV7 &p_other);
    SceneFilePhysicsV7 &operator=(const SceneFilePhysicsV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<6>{
struct SceneShapeSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    SceneShapeSurfaceV6();
    SceneShapeSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeSurfaceV6(const SceneShapeSurfaceV6 &p_other);
    SceneShapeSurfaceV6 &operator=(const SceneShapeSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV6 {
    byte surface;
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV6();
    SceneBoxShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV6(const SceneBoxShapeV6 &p_other);
    SceneBoxShapeV6 &operator=(const SceneBoxShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV6 {
    byte surface;
    float3 center;
    float radius;

public:
    SceneSphereShapeV6();
    SceneSphereShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV6(const SceneSphereShapeV6 &p_other);
    SceneSphereShapeV6 &operator=(const SceneSphereShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCapsuleShapeV6 {
    byte surface;
    float3 p0;
    float3 p1;
    float radius;

public:
    SceneCapsuleShapeV6();
    SceneCapsuleShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCapsuleShapeV6(const SceneCapsuleShapeV6 &p_other);
    SceneCapsuleShapeV6 &operator=(const SceneCapsuleShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV6 {
    helpers::Array<byte> surfaces;
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV6();
    SceneMeshShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV6(const SceneMeshShapeV6 &p_other);
    SceneMeshShapeV6 &operator=(const SceneMeshShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV6 {
    dword shapeIndex;

public:
    SceneCollisionShapeV6();
    SceneCollisionShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV6(const SceneCollisionShapeV6 &p_other);
    SceneCollisionShapeV6 &operator=(const SceneCollisionShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneTriggerShapeV6 {
    dword shapeIndex;
    dword flags;

public:
    SceneTriggerShapeV6();
    SceneTriggerShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneTriggerShapeV6(const SceneTriggerShapeV6 &p_other);
    SceneTriggerShapeV6 &operator=(const SceneTriggerShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV6 {
    dword shapeIndex;

public:
    SceneNamedShapeV6();
    SceneNamedShapeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV6(const SceneNamedShapeV6 &p_other);
    SceneNamedShapeV6 &operator=(const SceneNamedShapeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV6 {
    helpers::Array<SceneShapeSurfaceV6> surfaces;
    helpers::Array<SceneBoxShapeV6> boxes;
    helpers::Array<SceneSphereShapeV6> spheres;
    helpers::Array<SceneCapsuleShapeV6> capsules;
    helpers::Array<SceneMeshShapeV6> meshes;
    helpers::Array<SceneCollisionShapeV6> collisionShapes;
    helpers::Array<SceneTriggerShapeV6> triggerShapes;
    helpers::Array<SceneNamedShapeV6> namedShapes;

public:
    SceneFilePhysicsV6();
    SceneFilePhysicsV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV6(const SceneFilePhysicsV6 &p_other);
    SceneFilePhysicsV6 &operator=(const SceneFilePhysicsV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<5>{
struct SceneShapeSurfaceV5 {
    helpers::Array<qword> tokens;

public:
    SceneShapeSurfaceV5();
    SceneShapeSurfaceV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeSurfaceV5(const SceneShapeSurfaceV5 &p_other);
    SceneShapeSurfaceV5 &operator=(const SceneShapeSurfaceV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneBoxShapeV5 {
    byte surface;
    float3 dimensions;
    float3 position;
    float4 rotation;

public:
    SceneBoxShapeV5();
    SceneBoxShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoxShapeV5(const SceneBoxShapeV5 &p_other);
    SceneBoxShapeV5 &operator=(const SceneBoxShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneSphereShapeV5 {
    byte surface;
    float3 center;
    float radius;

public:
    SceneSphereShapeV5();
    SceneSphereShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneSphereShapeV5(const SceneSphereShapeV5 &p_other);
    SceneSphereShapeV5 &operator=(const SceneSphereShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMeshShapeV5 {
    helpers::Array<byte> surfaces;
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneMeshShapeV5();
    SceneMeshShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMeshShapeV5(const SceneMeshShapeV5 &p_other);
    SceneMeshShapeV5 &operator=(const SceneMeshShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV5 {
    dword shapeIndex;

public:
    SceneCollisionShapeV5();
    SceneCollisionShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV5(const SceneCollisionShapeV5 &p_other);
    SceneCollisionShapeV5 &operator=(const SceneCollisionShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneTriggerShapeV5 {
    dword shapeIndex;
    dword flags;

public:
    SceneTriggerShapeV5();
    SceneTriggerShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneTriggerShapeV5(const SceneTriggerShapeV5 &p_other);
    SceneTriggerShapeV5 &operator=(const SceneTriggerShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV5 {
    dword shapeIndex;

public:
    SceneNamedShapeV5();
    SceneNamedShapeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV5(const SceneNamedShapeV5 &p_other);
    SceneNamedShapeV5 &operator=(const SceneNamedShapeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV5 {
    helpers::Array<SceneShapeSurfaceV5> surfaces;
    helpers::Array<SceneBoxShapeV5> boxes;
    helpers::Array<SceneSphereShapeV5> spheres;
    helpers::Array<SceneMeshShapeV5> meshes;
    helpers::Array<SceneCollisionShapeV5> collisionShapes;
    helpers::Array<SceneTriggerShapeV5> triggerShapes;
    helpers::Array<SceneNamedShapeV5> namedShapes;

public:
    SceneFilePhysicsV5();
    SceneFilePhysicsV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV5(const SceneFilePhysicsV5 &p_other);
    SceneFilePhysicsV5 &operator=(const SceneFilePhysicsV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<4>{
struct SceneShapeV4 {
    helpers::Array<byte> surfaces;

public:
    SceneShapeV4();
    SceneShapeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeV4(const SceneShapeV4 &p_other);
    SceneShapeV4 &operator=(const SceneShapeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneShapeSurfaceV4 {
    helpers::Array<qword> tokens;

public:
    SceneShapeSurfaceV4();
    SceneShapeSurfaceV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeSurfaceV4(const SceneShapeSurfaceV4 &p_other);
    SceneShapeSurfaceV4 &operator=(const SceneShapeSurfaceV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV4 {
    dword shapeIndex;

public:
    SceneCollisionShapeV4();
    SceneCollisionShapeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV4(const SceneCollisionShapeV4 &p_other);
    SceneCollisionShapeV4 &operator=(const SceneCollisionShapeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneTriggerShapeV4 {
    dword shapeIndex;
    dword flags;

public:
    SceneTriggerShapeV4();
    SceneTriggerShapeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneTriggerShapeV4(const SceneTriggerShapeV4 &p_other);
    SceneTriggerShapeV4 &operator=(const SceneTriggerShapeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV4 {
    dword shapeIndex;

public:
    SceneNamedShapeV4();
    SceneNamedShapeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV4(const SceneNamedShapeV4 &p_other);
    SceneNamedShapeV4 &operator=(const SceneNamedShapeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV4 {
    helpers::Array<byte> shapeData;
    helpers::Array<SceneShapeV4> shapes;
    helpers::Array<SceneShapeSurfaceV4> surfaces;
    helpers::Array<SceneCollisionShapeV4> collisionShapes;
    helpers::Array<SceneTriggerShapeV4> triggerShapes;
    helpers::Array<SceneNamedShapeV4> namedShapes;

public:
    SceneFilePhysicsV4();
    SceneFilePhysicsV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV4(const SceneFilePhysicsV4 &p_other);
    SceneFilePhysicsV4 &operator=(const SceneFilePhysicsV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<3>{
struct SceneShapeV3 {
    helpers::Array<byte> surfaces;

public:
    SceneShapeV3();
    SceneShapeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeV3(const SceneShapeV3 &p_other);
    SceneShapeV3 &operator=(const SceneShapeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneShapeSurfaceV3 {
    helpers::Array<qword> tokens;

public:
    SceneShapeSurfaceV3();
    SceneShapeSurfaceV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeSurfaceV3(const SceneShapeSurfaceV3 &p_other);
    SceneShapeSurfaceV3 &operator=(const SceneShapeSurfaceV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV3 {
    dword shapeIndex;

public:
    SceneCollisionShapeV3();
    SceneCollisionShapeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV3(const SceneCollisionShapeV3 &p_other);
    SceneCollisionShapeV3 &operator=(const SceneCollisionShapeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneTriggerShapeV3 {
    dword shapeIndex;
    dword flags;

public:
    SceneTriggerShapeV3();
    SceneTriggerShapeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneTriggerShapeV3(const SceneTriggerShapeV3 &p_other);
    SceneTriggerShapeV3 &operator=(const SceneTriggerShapeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV3 {
    dword shapeIndex;

public:
    SceneNamedShapeV3();
    SceneNamedShapeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV3(const SceneNamedShapeV3 &p_other);
    SceneNamedShapeV3 &operator=(const SceneNamedShapeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathPhysicsV3 {
    helpers::Array<float4> pathData;

public:
    ScenePathPhysicsV3();
    ScenePathPhysicsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathPhysicsV3(const ScenePathPhysicsV3 &p_other);
    ScenePathPhysicsV3 &operator=(const ScenePathPhysicsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV3 {
    helpers::Array<byte> shapeData;
    helpers::Array<SceneShapeV3> shapes;
    helpers::Array<SceneShapeSurfaceV3> surfaces;
    helpers::Array<SceneCollisionShapeV3> collisionShapes;
    helpers::Array<SceneTriggerShapeV3> triggerShapes;
    helpers::Array<SceneNamedShapeV3> namedShapes;
    helpers::Array<ScenePathPhysicsV3> paths;

public:
    SceneFilePhysicsV3();
    SceneFilePhysicsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV3(const SceneFilePhysicsV3 &p_other);
    SceneFilePhysicsV3 &operator=(const SceneFilePhysicsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<2>{
struct SceneShapeV2 {
    dword shapeOffset;

public:
    SceneShapeV2();
    SceneShapeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeV2(const SceneShapeV2 &p_other);
    SceneShapeV2 &operator=(const SceneShapeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV2 {
    dword shapeIndex;

public:
    SceneCollisionShapeV2();
    SceneCollisionShapeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV2(const SceneCollisionShapeV2 &p_other);
    SceneCollisionShapeV2 &operator=(const SceneCollisionShapeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneQueryShapeV2 {
    dword shapeIndex;

public:
    SceneQueryShapeV2();
    SceneQueryShapeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneQueryShapeV2(const SceneQueryShapeV2 &p_other);
    SceneQueryShapeV2 &operator=(const SceneQueryShapeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV2 {
    dword shapeIndex;

public:
    SceneNamedShapeV2();
    SceneNamedShapeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV2(const SceneNamedShapeV2 &p_other);
    SceneNamedShapeV2 &operator=(const SceneNamedShapeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathPhysicsV2 {
    helpers::Array<float4> pathData;

public:
    ScenePathPhysicsV2();
    ScenePathPhysicsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathPhysicsV2(const ScenePathPhysicsV2 &p_other);
    ScenePathPhysicsV2 &operator=(const ScenePathPhysicsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV2 {
    helpers::Array<byte> shapeData;
    helpers::Array<SceneShapeV2> shapes;
    helpers::Array<SceneCollisionShapeV2> collisionShapes;
    helpers::Array<SceneQueryShapeV2> queryShapes;
    helpers::Array<SceneNamedShapeV2> namedShapes;
    helpers::Array<ScenePathPhysicsV2> paths;

public:
    SceneFilePhysicsV2();
    SceneFilePhysicsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV2(const SceneFilePhysicsV2 &p_other);
    SceneFilePhysicsV2 &operator=(const SceneFilePhysicsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<1>{
struct SceneShapeV1 {
    dword shapeOffset;

public:
    SceneShapeV1();
    SceneShapeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeV1(const SceneShapeV1 &p_other);
    SceneShapeV1 &operator=(const SceneShapeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV1 {
    dword shapeIndex;

public:
    SceneCollisionShapeV1();
    SceneCollisionShapeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV1(const SceneCollisionShapeV1 &p_other);
    SceneCollisionShapeV1 &operator=(const SceneCollisionShapeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV1 {
    dword shapeIndex;

public:
    SceneNamedShapeV1();
    SceneNamedShapeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV1(const SceneNamedShapeV1 &p_other);
    SceneNamedShapeV1 &operator=(const SceneNamedShapeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathPhysicsV1 {
    helpers::Array<float4> pathData;

public:
    ScenePathPhysicsV1();
    ScenePathPhysicsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathPhysicsV1(const ScenePathPhysicsV1 &p_other);
    ScenePathPhysicsV1 &operator=(const ScenePathPhysicsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV1 {
    helpers::Array<byte> shapeData;
    helpers::Array<SceneShapeV1> shapes;
    helpers::Array<SceneCollisionShapeV1> collisionShapes;
    helpers::Array<SceneNamedShapeV1> namedShapes;
    helpers::Array<ScenePathPhysicsV1> paths;

public:
    SceneFilePhysicsV1();
    SceneFilePhysicsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV1(const SceneFilePhysicsV1 &p_other);
    SceneFilePhysicsV1 &operator=(const SceneFilePhysicsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructPHYS<0>{
struct SceneShapeV0 {
    dword shapeOffset;

public:
    SceneShapeV0();
    SceneShapeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneShapeV0(const SceneShapeV0 &p_other);
    SceneShapeV0 &operator=(const SceneShapeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneCollisionShapeV0 {
    dword shapeIndex;

public:
    SceneCollisionShapeV0();
    SceneCollisionShapeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneCollisionShapeV0(const SceneCollisionShapeV0 &p_other);
    SceneCollisionShapeV0 &operator=(const SceneCollisionShapeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneNamedShapeV0 {
    dword shapeIndex;

public:
    SceneNamedShapeV0();
    SceneNamedShapeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneNamedShapeV0(const SceneNamedShapeV0 &p_other);
    SceneNamedShapeV0 &operator=(const SceneNamedShapeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFilePhysicsV0 {
    helpers::Array<byte> shapeData;
    helpers::Array<SceneShapeV0> shapes;
    helpers::Array<SceneCollisionShapeV0> collisionShapes;
    helpers::Array<SceneNamedShapeV0> namedShapes;

public:
    SceneFilePhysicsV0();
    SceneFilePhysicsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFilePhysicsV0(const SceneFilePhysicsV0 &p_other);
    SceneFilePhysicsV0 &operator=(const SceneFilePhysicsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFilePhysicsV0 Gw2Struct;
};


/* ===============================================
 * Chunk: ANIM, versions: 3, strucTab: 0x1422A9680
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructANIM;

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<2>{
struct SceneKeyframeV2 {
    float time;
    float3 position;
    float4 rotation;

public:
    SceneKeyframeV2();
    SceneKeyframeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneKeyframeV2(const SceneKeyframeV2 &p_other);
    SceneKeyframeV2 &operator=(const SceneKeyframeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMotionV2 {
    helpers::Array<SceneKeyframeV2> keys;

public:
    SceneMotionV2();
    SceneMotionV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMotionV2(const SceneMotionV2 &p_other);
    SceneMotionV2 &operator=(const SceneMotionV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneActionPointV2 {
    qword name;
    SceneMotionV2 motion;

public:
    SceneActionPointV2();
    SceneActionPointV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneActionPointV2(const SceneActionPointV2 &p_other);
    SceneActionPointV2 &operator=(const SceneActionPointV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationEventV2 {
    qword name;
    float time;

public:
    SceneAnimationEventV2();
    SceneAnimationEventV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationEventV2(const SceneAnimationEventV2 &p_other);
    SceneAnimationEventV2 &operator=(const SceneAnimationEventV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationV2 {
    qword name;
    SceneMotionV2 motion;
    helpers::Array<SceneActionPointV2> actionPoints;
    helpers::Array<SceneAnimationEventV2> events;

public:
    SceneAnimationV2();
    SceneAnimationV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationV2(const SceneAnimationV2 &p_other);
    SceneAnimationV2 &operator=(const SceneAnimationV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneTransformV2 {
    qword name;
    float3 translation;
    float4 rotation;

public:
    SceneTransformV2();
    SceneTransformV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneTransformV2(const SceneTransformV2 &p_other);
    SceneTransformV2 &operator=(const SceneTransformV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePoseV2 {
    qword name;
    helpers::Array<SceneTransformV2> transforms;

public:
    ScenePoseV2();
    ScenePoseV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePoseV2(const ScenePoseV2 &p_other);
    ScenePoseV2 &operator=(const ScenePoseV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneImportSequenceV2 {
    qword name;

public:
    SceneImportSequenceV2();
    SceneImportSequenceV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneImportSequenceV2(const SceneImportSequenceV2 &p_other);
    SceneImportSequenceV2 &operator=(const SceneImportSequenceV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationImportV2 {
    helpers::FileName filename;
    helpers::Array<SceneImportSequenceV2> animNames;
    dword flags;

public:
    SceneAnimationImportV2();
    SceneAnimationImportV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationImportV2(const SceneAnimationImportV2 &p_other);
    SceneAnimationImportV2 &operator=(const SceneAnimationImportV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileAnimationV2 {
    helpers::Array<SceneAnimationV2> animations;
    helpers::Array<ScenePoseV2> poses;
    helpers::Array<SceneAnimationImportV2> imports;

public:
    SceneFileAnimationV2();
    SceneFileAnimationV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileAnimationV2(const SceneFileAnimationV2 &p_other);
    SceneFileAnimationV2 &operator=(const SceneFileAnimationV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileAnimationV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<1>{
struct SceneKeyframeV1 {
    float time;
    float3 position;
    float4 rotation;

public:
    SceneKeyframeV1();
    SceneKeyframeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneKeyframeV1(const SceneKeyframeV1 &p_other);
    SceneKeyframeV1 &operator=(const SceneKeyframeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMotionV1 {
    helpers::Array<SceneKeyframeV1> keys;

public:
    SceneMotionV1();
    SceneMotionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMotionV1(const SceneMotionV1 &p_other);
    SceneMotionV1 &operator=(const SceneMotionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneActionPointV1 {
    qword name;
    SceneMotionV1 motion;

public:
    SceneActionPointV1();
    SceneActionPointV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneActionPointV1(const SceneActionPointV1 &p_other);
    SceneActionPointV1 &operator=(const SceneActionPointV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationEventV1 {
    qword name;
    float time;

public:
    SceneAnimationEventV1();
    SceneAnimationEventV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationEventV1(const SceneAnimationEventV1 &p_other);
    SceneAnimationEventV1 &operator=(const SceneAnimationEventV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationV1 {
    qword name;
    SceneMotionV1 motion;
    helpers::Array<SceneActionPointV1> actionPoints;
    helpers::Array<SceneAnimationEventV1> events;

public:
    SceneAnimationV1();
    SceneAnimationV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationV1(const SceneAnimationV1 &p_other);
    SceneAnimationV1 &operator=(const SceneAnimationV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationImportV1 {
    helpers::FileName filename;
    helpers::Array<qword> animNames;

public:
    SceneAnimationImportV1();
    SceneAnimationImportV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationImportV1(const SceneAnimationImportV1 &p_other);
    SceneAnimationImportV1 &operator=(const SceneAnimationImportV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileAnimationV1 {
    helpers::Array<SceneAnimationV1> animations;
    helpers::Array<SceneAnimationImportV1> imports;

public:
    SceneFileAnimationV1();
    SceneFileAnimationV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileAnimationV1(const SceneFileAnimationV1 &p_other);
    SceneFileAnimationV1 &operator=(const SceneFileAnimationV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileAnimationV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructANIM<0>{
struct SceneKeyframeV0 {
    float time;
    float3 position;
    float4 rotation;

public:
    SceneKeyframeV0();
    SceneKeyframeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneKeyframeV0(const SceneKeyframeV0 &p_other);
    SceneKeyframeV0 &operator=(const SceneKeyframeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneMotionV0 {
    helpers::Array<SceneKeyframeV0> keys;

public:
    SceneMotionV0();
    SceneMotionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneMotionV0(const SceneMotionV0 &p_other);
    SceneMotionV0 &operator=(const SceneMotionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneActionPointV0 {
    qword name;
    SceneMotionV0 motion;

public:
    SceneActionPointV0();
    SceneActionPointV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneActionPointV0(const SceneActionPointV0 &p_other);
    SceneActionPointV0 &operator=(const SceneActionPointV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationV0 {
    qword name;
    SceneMotionV0 motion;
    helpers::Array<SceneActionPointV0> actionPoints;

public:
    SceneAnimationV0();
    SceneAnimationV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationV0(const SceneAnimationV0 &p_other);
    SceneAnimationV0 &operator=(const SceneAnimationV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneAnimationImportV0 {
    helpers::FileName filename;
    helpers::Array<qword> animNames;

public:
    SceneAnimationImportV0();
    SceneAnimationImportV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneAnimationImportV0(const SceneAnimationImportV0 &p_other);
    SceneAnimationImportV0 &operator=(const SceneAnimationImportV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileAnimationV0 {
    helpers::Array<SceneAnimationV0> animations;
    helpers::Array<SceneAnimationImportV0> imports;

public:
    SceneFileAnimationV0();
    SceneFileAnimationV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileAnimationV0(const SceneFileAnimationV0 &p_other);
    SceneFileAnimationV0 &operator=(const SceneFileAnimationV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileAnimationV0 Gw2Struct;
};


/* ===============================================
 * Chunk: GAME, versions: 7, strucTab: 0x1422A96D0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructGAME;

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<6>{
struct ScenePathNodeV6 {
    float3 position;
    float4 rotation;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV6();
    ScenePathNodeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV6(const ScenePathNodeV6 &p_other);
    ScenePathNodeV6 &operator=(const ScenePathNodeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV6 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV6> points;
    byte closed;

public:
    ScenePathV6();
    ScenePathV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV6(const ScenePathV6 &p_other);
    ScenePathV6 &operator=(const ScenePathV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV6 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV6();
    SceneEdgeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV6(const SceneEdgeV6 &p_other);
    SceneEdgeV6 &operator=(const SceneEdgeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV6 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV6> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<byte> surfaces;

public:
    SceneGameMeshV6();
    SceneGameMeshV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV6(const SceneGameMeshV6 &p_other);
    SceneGameMeshV6 &operator=(const SceneGameMeshV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameSurfaceV6 {
    helpers::Array<qword> tokens;

public:
    SceneGameSurfaceV6();
    SceneGameSurfaceV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameSurfaceV6(const SceneGameSurfaceV6 &p_other);
    SceneGameSurfaceV6 &operator=(const SceneGameSurfaceV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV6 {
    helpers::Array<ScenePathV6> paths;
    helpers::Array<SceneGameMeshV6> meshes;
    helpers::Array<SceneGameSurfaceV6> surfaces;

public:
    SceneFileGameV6();
    SceneFileGameV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV6(const SceneFileGameV6 &p_other);
    SceneFileGameV6 &operator=(const SceneFileGameV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<5>{
struct ScenePathNodeV5 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV5();
    ScenePathNodeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV5(const ScenePathNodeV5 &p_other);
    ScenePathNodeV5 &operator=(const ScenePathNodeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV5 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV5> points;
    byte closed;

public:
    ScenePathV5();
    ScenePathV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV5(const ScenePathV5 &p_other);
    ScenePathV5 &operator=(const ScenePathV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV5 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV5();
    SceneEdgeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV5(const SceneEdgeV5 &p_other);
    SceneEdgeV5 &operator=(const SceneEdgeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV5 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV5> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<dword> surfaceFlags;

public:
    SceneGameMeshV5();
    SceneGameMeshV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV5(const SceneGameMeshV5 &p_other);
    SceneGameMeshV5 &operator=(const SceneGameMeshV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV5 {
    helpers::Array<ScenePathV5> paths;
    helpers::Array<SceneGameMeshV5> meshes;

public:
    SceneFileGameV5();
    SceneFileGameV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV5(const SceneFileGameV5 &p_other);
    SceneFileGameV5 &operator=(const SceneFileGameV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<4>{
struct ScenePathNodeV4 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;
    byte singlesided;

public:
    ScenePathNodeV4();
    ScenePathNodeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV4(const ScenePathNodeV4 &p_other);
    ScenePathNodeV4 &operator=(const ScenePathNodeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV4 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV4> points;
    byte closed;

public:
    ScenePathV4();
    ScenePathV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV4(const ScenePathV4 &p_other);
    ScenePathV4 &operator=(const ScenePathV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV4 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV4();
    SceneEdgeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV4(const SceneEdgeV4 &p_other);
    SceneEdgeV4 &operator=(const SceneEdgeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV4 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV4> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<dword> surfaceFlags;

public:
    SceneGameMeshV4();
    SceneGameMeshV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV4(const SceneGameMeshV4 &p_other);
    SceneGameMeshV4 &operator=(const SceneGameMeshV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGrabNodeV4 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    SceneGrabNodeV4();
    SceneGrabNodeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGrabNodeV4(const SceneGrabNodeV4 &p_other);
    SceneGrabNodeV4 &operator=(const SceneGrabNodeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV4 {
    helpers::Array<ScenePathV4> paths;
    helpers::Array<SceneGameMeshV4> meshes;
    helpers::Array<SceneGrabNodeV4> grabPoints;

public:
    SceneFileGameV4();
    SceneFileGameV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV4(const SceneFileGameV4 &p_other);
    SceneFileGameV4 &operator=(const SceneFileGameV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<3>{
struct ScenePathNodeV3 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    ScenePathNodeV3();
    ScenePathNodeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV3(const ScenePathNodeV3 &p_other);
    ScenePathNodeV3 &operator=(const ScenePathNodeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV3 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV3> points;
    byte closed;

public:
    ScenePathV3();
    ScenePathV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV3(const ScenePathV3 &p_other);
    ScenePathV3 &operator=(const ScenePathV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV3 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV3();
    SceneEdgeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV3(const SceneEdgeV3 &p_other);
    SceneEdgeV3 &operator=(const SceneEdgeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV3 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV3> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;
    helpers::Array<dword> surfaceFlags;

public:
    SceneGameMeshV3();
    SceneGameMeshV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV3(const SceneGameMeshV3 &p_other);
    SceneGameMeshV3 &operator=(const SceneGameMeshV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGrabNodeV3 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    SceneGrabNodeV3();
    SceneGrabNodeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGrabNodeV3(const SceneGrabNodeV3 &p_other);
    SceneGrabNodeV3 &operator=(const SceneGrabNodeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV3 {
    helpers::Array<ScenePathV3> paths;
    helpers::Array<SceneGameMeshV3> meshes;
    helpers::Array<SceneGrabNodeV3> grabPoints;

public:
    SceneFileGameV3();
    SceneFileGameV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV3(const SceneFileGameV3 &p_other);
    SceneFileGameV3 &operator=(const SceneFileGameV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<2>{
struct ScenePathNodeV2 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    ScenePathNodeV2();
    ScenePathNodeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV2(const ScenePathNodeV2 &p_other);
    ScenePathNodeV2 &operator=(const ScenePathNodeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV2 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV2> points;
    byte closed;

public:
    ScenePathV2();
    ScenePathV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV2(const ScenePathV2 &p_other);
    ScenePathV2 &operator=(const ScenePathV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV2 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV2();
    SceneEdgeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV2(const SceneEdgeV2 &p_other);
    SceneEdgeV2 &operator=(const SceneEdgeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV2 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV2> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneGameMeshV2();
    SceneGameMeshV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV2(const SceneGameMeshV2 &p_other);
    SceneGameMeshV2 &operator=(const SceneGameMeshV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGrabNodeV2 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    SceneGrabNodeV2();
    SceneGrabNodeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGrabNodeV2(const SceneGrabNodeV2 &p_other);
    SceneGrabNodeV2 &operator=(const SceneGrabNodeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV2 {
    helpers::Array<ScenePathV2> paths;
    helpers::Array<SceneGameMeshV2> meshes;
    helpers::Array<SceneGrabNodeV2> grabPoints;

public:
    SceneFileGameV2();
    SceneFileGameV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV2(const SceneFileGameV2 &p_other);
    SceneFileGameV2 &operator=(const SceneFileGameV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<1>{
struct ScenePathNodeV1 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;
    float smoothing;

public:
    ScenePathNodeV1();
    ScenePathNodeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV1(const ScenePathNodeV1 &p_other);
    ScenePathNodeV1 &operator=(const ScenePathNodeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV1 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV1> points;
    byte closed;

public:
    ScenePathV1();
    ScenePathV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV1(const ScenePathV1 &p_other);
    ScenePathV1 &operator=(const ScenePathV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV1 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV1();
    SceneEdgeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV1(const SceneEdgeV1 &p_other);
    SceneEdgeV1 &operator=(const SceneEdgeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV1 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV1> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneGameMeshV1();
    SceneGameMeshV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV1(const SceneGameMeshV1 &p_other);
    SceneGameMeshV1 &operator=(const SceneGameMeshV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV1 {
    helpers::Array<ScenePathV1> paths;
    helpers::Array<SceneGameMeshV1> meshes;

public:
    SceneFileGameV1();
    SceneFileGameV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV1(const SceneFileGameV1 &p_other);
    SceneFileGameV1 &operator=(const SceneFileGameV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructGAME<0>{
struct ScenePathNodeV0 {
    float3 position;
    float4 rotation;
    float radius;
    dword flags;

public:
    ScenePathNodeV0();
    ScenePathNodeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathNodeV0(const ScenePathNodeV0 &p_other);
    ScenePathNodeV0 &operator=(const ScenePathNodeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ScenePathV0 {
    helpers::Array<qword> properties;
    helpers::Array<ScenePathNodeV0> points;
    byte closed;

public:
    ScenePathV0();
    ScenePathV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ScenePathV0(const ScenePathV0 &p_other);
    ScenePathV0 &operator=(const ScenePathV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneEdgeV0 {
    dword indices[2];
    helpers::Array<dword> triangles;

public:
    SceneEdgeV0();
    SceneEdgeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneEdgeV0(const SceneEdgeV0 &p_other);
    SceneEdgeV0 &operator=(const SceneEdgeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneGameMeshV0 {
    helpers::Array<word> indices;
    helpers::Array<float3> vertices;
    helpers::Array<SceneEdgeV0> edges;
    float4 moppInfo;
    helpers::Array<byte> moppBytes;

public:
    SceneGameMeshV0();
    SceneGameMeshV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneGameMeshV0(const SceneGameMeshV0 &p_other);
    SceneGameMeshV0 &operator=(const SceneGameMeshV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileGameV0 {
    helpers::Array<ScenePathV0> paths;
    helpers::Array<SceneGameMeshV0> meshes;

public:
    SceneFileGameV0();
    SceneFileGameV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileGameV0(const SceneFileGameV0 &p_other);
    SceneFileGameV0 &operator=(const SceneFileGameV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileGameV0 Gw2Struct;
};


/* ===============================================
 * Chunk: SKEL, versions: 4, strucTab: 0x1422A9780
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructSKEL;

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructSKEL<3>{
struct SceneBoneV3 {
    float3 vertexA;
    float3 vertexB;
    float radius;
    float mass;
    qword name;

public:
    SceneBoneV3();
    SceneBoneV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoneV3(const SceneBoneV3 &p_other);
    SceneBoneV3 &operator=(const SceneBoneV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneJointV3 {
    dword bones[2];
    float3 pivots[2];
    float3 twists[2];
    float3 planes[2];
    float coneLimit;
    float planeMin;
    float planeMax;
    float twistMin;
    float twistMax;

public:
    SceneJointV3();
    SceneJointV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneJointV3(const SceneJointV3 &p_other);
    SceneJointV3 &operator=(const SceneJointV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneHingeJointV3 {
    dword bones[2];
    float3 pivots[2];
    float3 hinges[2];
    float3 normals[2];
    float limitMin;
    float limitMax;

public:
    SceneHingeJointV3();
    SceneHingeJointV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneHingeJointV3(const SceneHingeJointV3 &p_other);
    SceneHingeJointV3 &operator=(const SceneHingeJointV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileSkeletonV3 {
    helpers::Array<SceneBoneV3> bones;
    helpers::Array<SceneJointV3> joints;
    helpers::Array<SceneHingeJointV3> hingeJoints;
    helpers::Array<dword> ragdollToModel;

public:
    SceneFileSkeletonV3();
    SceneFileSkeletonV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileSkeletonV3(const SceneFileSkeletonV3 &p_other);
    SceneFileSkeletonV3 &operator=(const SceneFileSkeletonV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileSkeletonV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructSKEL<2>{
struct SceneBoneV2 {
    float3 vertexA;
    float3 vertexB;
    float radius;
    float mass;

public:
    SceneBoneV2();
    SceneBoneV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoneV2(const SceneBoneV2 &p_other);
    SceneBoneV2 &operator=(const SceneBoneV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneJointV2 {
    dword bones[2];
    float3 pivots[2];
    float3 twists[2];
    float3 planes[2];
    float coneLimit;
    float planeMin;
    float planeMax;
    float twistMin;
    float twistMax;

public:
    SceneJointV2();
    SceneJointV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneJointV2(const SceneJointV2 &p_other);
    SceneJointV2 &operator=(const SceneJointV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneHingeJointV2 {
    dword bones[2];
    float3 pivots[2];
    float3 hinges[2];
    float3 normals[2];
    float limitMin;
    float limitMax;

public:
    SceneHingeJointV2();
    SceneHingeJointV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneHingeJointV2(const SceneHingeJointV2 &p_other);
    SceneHingeJointV2 &operator=(const SceneHingeJointV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileSkeletonV2 {
    helpers::Array<SceneBoneV2> bones;
    helpers::Array<SceneJointV2> joints;
    helpers::Array<SceneHingeJointV2> hingeJoints;
    helpers::Array<dword> ragdollToModel;

public:
    SceneFileSkeletonV2();
    SceneFileSkeletonV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileSkeletonV2(const SceneFileSkeletonV2 &p_other);
    SceneFileSkeletonV2 &operator=(const SceneFileSkeletonV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileSkeletonV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructSKEL<1>{
struct SceneBoneV1 {
    float3 vertexA;
    float3 vertexB;
    float radius;
    float mass;

public:
    SceneBoneV1();
    SceneBoneV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoneV1(const SceneBoneV1 &p_other);
    SceneBoneV1 &operator=(const SceneBoneV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneJointV1 {
    dword bones[2];
    float3 pivots[2];
    float3 twists[2];
    float3 planes[2];
    float coneLimit;
    float planeMin;
    float planeMax;
    float twistMin;
    float twistMax;

public:
    SceneJointV1();
    SceneJointV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneJointV1(const SceneJointV1 &p_other);
    SceneJointV1 &operator=(const SceneJointV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneHingeJointV1 {
    dword bones[2];
    float3 pivots[2];
    float3 hinges[2];
    float3 normals[2];
    float limitMin;
    float limitMax;

public:
    SceneHingeJointV1();
    SceneHingeJointV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneHingeJointV1(const SceneHingeJointV1 &p_other);
    SceneHingeJointV1 &operator=(const SceneHingeJointV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneUnmappedBoneV1 {
    dword modelBoneIndex;
    dword sceneBoneIndex;
    float4 localPose[3];

public:
    SceneUnmappedBoneV1();
    SceneUnmappedBoneV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneUnmappedBoneV1(const SceneUnmappedBoneV1 &p_other);
    SceneUnmappedBoneV1 &operator=(const SceneUnmappedBoneV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileSkeletonV1 {
    helpers::Array<SceneBoneV1> bones;
    helpers::Array<SceneJointV1> joints;
    helpers::Array<SceneHingeJointV1> hingeJoints;
    helpers::Array<SceneUnmappedBoneV1> unmappedBones;
    helpers::Array<dword> ragdollToModel;
    helpers::Array<dword> modelToRagdoll;

public:
    SceneFileSkeletonV1();
    SceneFileSkeletonV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileSkeletonV1(const SceneFileSkeletonV1 &p_other);
    SceneFileSkeletonV1 &operator=(const SceneFileSkeletonV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileSkeletonV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructSKEL<0>{
struct SceneBoneV0 {
    float3 vertexA;
    float3 vertexB;
    float radius;
    float mass;

public:
    SceneBoneV0();
    SceneBoneV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneBoneV0(const SceneBoneV0 &p_other);
    SceneBoneV0 &operator=(const SceneBoneV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneJointV0 {
    dword bones[2];
    float3 pivots[2];
    float3 twists[2];
    float3 planes[2];
    float coneLimit;
    float planeMin;
    float planeMax;
    float twistMin;
    float twistMax;

public:
    SceneJointV0();
    SceneJointV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneJointV0(const SceneJointV0 &p_other);
    SceneJointV0 &operator=(const SceneJointV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneUnmappedBoneV0 {
    dword modelBoneIndex;
    dword sceneBoneIndex;
    float4 localPose[3];

public:
    SceneUnmappedBoneV0();
    SceneUnmappedBoneV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneUnmappedBoneV0(const SceneUnmappedBoneV0 &p_other);
    SceneUnmappedBoneV0 &operator=(const SceneUnmappedBoneV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct SceneFileSkeletonV0 {
    helpers::Array<SceneBoneV0> bones;
    helpers::Array<SceneJointV0> joints;
    helpers::Array<SceneUnmappedBoneV0> unmappedBones;
    helpers::Array<dword> ragdollToModel;
    helpers::Array<dword> modelToRagdoll;

public:
    SceneFileSkeletonV0();
    SceneFileSkeletonV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    SceneFileSkeletonV0(const SceneFileSkeletonV0 &p_other);
    SceneFileSkeletonV0 &operator=(const SceneFileSkeletonV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef SceneFileSkeletonV0 Gw2Struct;
};


/* ===============================================
 * Chunk: MFST, versions: 7, strucTab: 0x1422AF610
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructMFST;

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<6>{
struct PackAssetManifestRecord {
    dword baseId;
    dword fileId;
    dword size;
    dword flags;

public:
    PackAssetManifestRecord();
    PackAssetManifestRecord(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecord(const PackAssetManifestRecord &p_other);
    PackAssetManifestRecord &operator=(const PackAssetManifestRecord &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStream {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStream();
    PackAssetManifestStream(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStream(const PackAssetManifestStream &p_other);
    PackAssetManifestStream &operator=(const PackAssetManifestStream &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestProperty {
    byte type;
    helpers::Array<byte> data;

public:
    PackAssetManifestProperty();
    PackAssetManifestProperty(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestProperty(const PackAssetManifestProperty &p_other);
    PackAssetManifestProperty &operator=(const PackAssetManifestProperty &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestPropertyIndex {
    dword baseId;
    dword properyIndex;

public:
    PackAssetManifestPropertyIndex();
    PackAssetManifestPropertyIndex(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestPropertyIndex(const PackAssetManifestPropertyIndex &p_other);
    PackAssetManifestPropertyIndex &operator=(const PackAssetManifestPropertyIndex &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifest {
    dword buildId;
    qword totalRecordSize;
    helpers::Array<PackAssetManifestRecord> records;
    helpers::Array<PackAssetManifestStream> streams;
    helpers::Array<PackAssetManifestProperty> properties;
    helpers::Array<PackAssetManifestPropertyIndex> propertyTable;

public:
    PackAssetManifest();
    PackAssetManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifest(const PackAssetManifest &p_other);
    PackAssetManifest &operator=(const PackAssetManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifest Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<5>{
struct PackAssetManifestRecordV5 {
    dword baseId;
    dword fileId;
    dword size;
    dword flags;

public:
    PackAssetManifestRecordV5();
    PackAssetManifestRecordV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV5(const PackAssetManifestRecordV5 &p_other);
    PackAssetManifestRecordV5 &operator=(const PackAssetManifestRecordV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStreamV5 {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStreamV5();
    PackAssetManifestStreamV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStreamV5(const PackAssetManifestStreamV5 &p_other);
    PackAssetManifestStreamV5 &operator=(const PackAssetManifestStreamV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestPropertyV5 {
    byte type;
    helpers::Array<byte> data;

public:
    PackAssetManifestPropertyV5();
    PackAssetManifestPropertyV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestPropertyV5(const PackAssetManifestPropertyV5 &p_other);
    PackAssetManifestPropertyV5 &operator=(const PackAssetManifestPropertyV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestPropertyIndexV5 {
    dword baseId;
    dword properyIndex;

public:
    PackAssetManifestPropertyIndexV5();
    PackAssetManifestPropertyIndexV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestPropertyIndexV5(const PackAssetManifestPropertyIndexV5 &p_other);
    PackAssetManifestPropertyIndexV5 &operator=(const PackAssetManifestPropertyIndexV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV5 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV5> records;
    helpers::Array<PackAssetManifestStreamV5> streams;
    helpers::Array<PackAssetManifestPropertyV5> properties;
    helpers::Array<PackAssetManifestPropertyIndexV5> propertyTable;

public:
    PackAssetManifestV5();
    PackAssetManifestV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV5(const PackAssetManifestV5 &p_other);
    PackAssetManifestV5 &operator=(const PackAssetManifestV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<4>{
struct PackAssetManifestRecordV4 {
    dword baseId;
    dword fileId;
    dword size;
    dword flags;

public:
    PackAssetManifestRecordV4();
    PackAssetManifestRecordV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV4(const PackAssetManifestRecordV4 &p_other);
    PackAssetManifestRecordV4 &operator=(const PackAssetManifestRecordV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStreamV4 {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStreamV4();
    PackAssetManifestStreamV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStreamV4(const PackAssetManifestStreamV4 &p_other);
    PackAssetManifestStreamV4 &operator=(const PackAssetManifestStreamV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestOptionsV4 {
    dword baseId;
    dword fileId;
    dword flags;

public:
    PackAssetManifestOptionsV4();
    PackAssetManifestOptionsV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestOptionsV4(const PackAssetManifestOptionsV4 &p_other);
    PackAssetManifestOptionsV4 &operator=(const PackAssetManifestOptionsV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestPropertyV4 {
    byte type;
    helpers::Array<byte> data;

public:
    PackAssetManifestPropertyV4();
    PackAssetManifestPropertyV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestPropertyV4(const PackAssetManifestPropertyV4 &p_other);
    PackAssetManifestPropertyV4 &operator=(const PackAssetManifestPropertyV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestPropertyIndexV4 {
    dword baseId;
    dword properyIndex;

public:
    PackAssetManifestPropertyIndexV4();
    PackAssetManifestPropertyIndexV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestPropertyIndexV4(const PackAssetManifestPropertyIndexV4 &p_other);
    PackAssetManifestPropertyIndexV4 &operator=(const PackAssetManifestPropertyIndexV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV4 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV4> records;
    helpers::Array<PackAssetManifestStreamV4> streams;
    helpers::Array<PackAssetManifestOptionsV4> options;
    helpers::Array<PackAssetManifestPropertyV4> properties;
    helpers::Array<PackAssetManifestPropertyIndexV4> propertyTable;

public:
    PackAssetManifestV4();
    PackAssetManifestV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV4(const PackAssetManifestV4 &p_other);
    PackAssetManifestV4 &operator=(const PackAssetManifestV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<3>{
struct PackAssetManifestRecordV3 {
    dword baseId;
    dword fileId;
    dword size;

public:
    PackAssetManifestRecordV3();
    PackAssetManifestRecordV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV3(const PackAssetManifestRecordV3 &p_other);
    PackAssetManifestRecordV3 &operator=(const PackAssetManifestRecordV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStreamV3 {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStreamV3();
    PackAssetManifestStreamV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStreamV3(const PackAssetManifestStreamV3 &p_other);
    PackAssetManifestStreamV3 &operator=(const PackAssetManifestStreamV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestOptionsV3 {
    dword baseId;
    dword fileId;
    dword flags;

public:
    PackAssetManifestOptionsV3();
    PackAssetManifestOptionsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestOptionsV3(const PackAssetManifestOptionsV3 &p_other);
    PackAssetManifestOptionsV3 &operator=(const PackAssetManifestOptionsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV3 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV3> records;
    helpers::Array<PackAssetManifestStreamV3> streams;
    helpers::Array<PackAssetManifestOptionsV3> options;

public:
    PackAssetManifestV3();
    PackAssetManifestV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV3(const PackAssetManifestV3 &p_other);
    PackAssetManifestV3 &operator=(const PackAssetManifestV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<2>{
struct PackAssetManifestRecordV2 {
    dword baseId;
    dword fileId;
    dword size;

public:
    PackAssetManifestRecordV2();
    PackAssetManifestRecordV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV2(const PackAssetManifestRecordV2 &p_other);
    PackAssetManifestRecordV2 &operator=(const PackAssetManifestRecordV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStreamV2 {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStreamV2();
    PackAssetManifestStreamV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStreamV2(const PackAssetManifestStreamV2 &p_other);
    PackAssetManifestStreamV2 &operator=(const PackAssetManifestStreamV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV2 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV2> records;
    helpers::Array<PackAssetManifestStreamV2> streams;
    helpers::Array<PackAssetManifestRecordV2> noDeltaRecords;

public:
    PackAssetManifestV2();
    PackAssetManifestV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV2(const PackAssetManifestV2 &p_other);
    PackAssetManifestV2 &operator=(const PackAssetManifestV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<1>{
struct PackAssetManifestRecordV1 {
    dword baseId;
    dword fileId;
    dword size;

public:
    PackAssetManifestRecordV1();
    PackAssetManifestRecordV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV1(const PackAssetManifestRecordV1 &p_other);
    PackAssetManifestRecordV1 &operator=(const PackAssetManifestRecordV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestStreamV1 {
    dword parentBaseId;
    dword streamBaseId;

public:
    PackAssetManifestStreamV1();
    PackAssetManifestStreamV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestStreamV1(const PackAssetManifestStreamV1 &p_other);
    PackAssetManifestStreamV1 &operator=(const PackAssetManifestStreamV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV1 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV1> records;
    helpers::Array<PackAssetManifestStreamV1> streams;

public:
    PackAssetManifestV1();
    PackAssetManifestV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV1(const PackAssetManifestV1 &p_other);
    PackAssetManifestV1 &operator=(const PackAssetManifestV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMFST<0>{
struct PackAssetManifestRecordV0 {
    dword baseId;
    dword fileId;
    dword size;

public:
    PackAssetManifestRecordV0();
    PackAssetManifestRecordV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestRecordV0(const PackAssetManifestRecordV0 &p_other);
    PackAssetManifestRecordV0 &operator=(const PackAssetManifestRecordV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetManifestV0 {
    dword buildId;
    helpers::Array<PackAssetManifestRecordV0> records;

public:
    PackAssetManifestV0();
    PackAssetManifestV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestV0(const PackAssetManifestV0 &p_other);
    PackAssetManifestV0 &operator=(const PackAssetManifestV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetManifestV0 Gw2Struct;
};


/* ===============================================
 * Chunk: ARMF, versions: 2, strucTab: 0x1422AF6C8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructARMF;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2StructARMF<1>{
struct PackAssetManifestFile {
    dword baseId;
    dword fileId;
    dword size;
    dword flags;
    helpers::WString name;

public:
    PackAssetManifestFile();
    PackAssetManifestFile(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetManifestFile(const PackAssetManifestFile &p_other);
    PackAssetManifestFile &operator=(const PackAssetManifestFile &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetExtraFile {
    dword baseId;
    dword fileId;
    dword size;
    dword fileType;

public:
    PackAssetExtraFile();
    PackAssetExtraFile(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetExtraFile(const PackAssetExtraFile &p_other);
    PackAssetExtraFile &operator=(const PackAssetExtraFile &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetRootManifest {
    dword buildId;
    helpers::Array<PackAssetManifestFile> manifests;
    helpers::Array<PackAssetExtraFile> extraFiles;

public:
    PackAssetRootManifest();
    PackAssetRootManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetRootManifest(const PackAssetRootManifest &p_other);
    PackAssetRootManifest &operator=(const PackAssetRootManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetRootManifest Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructARMF<0>{
struct PackAssetExtraFile {
    dword baseId;
    dword fileId;
    dword size;
    dword fileType;

public:
    PackAssetExtraFile();
    PackAssetExtraFile(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetExtraFile(const PackAssetExtraFile &p_other);
    PackAssetExtraFile &operator=(const PackAssetExtraFile &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAssetRootManifestV0 {
    dword buildId;
    helpers::Array<PackAssetExtraFile> extraFiles;

public:
    PackAssetRootManifestV0();
    PackAssetRootManifestV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAssetRootManifestV0(const PackAssetRootManifestV0 &p_other);
    PackAssetRootManifestV0 &operator=(const PackAssetRootManifestV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAssetRootManifestV0 Gw2Struct;
};


/* ===============================================
 * Chunk: TKAC, versions: 1, strucTab: 0x1422B10A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructTKAC;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructTKAC<0>{
struct KeyEntry {
    dword assetType;
    dword assetId;
    qword key;

public:
    KeyEntry();
    KeyEntry(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    KeyEntry(const KeyEntry &p_other);
    KeyEntry &operator=(const KeyEntry &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct KeyTableData {
    helpers::Array<KeyEntry> keyEntryArr;

public:
    KeyTableData();
    KeyTableData(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    KeyTableData(const KeyTableData &p_other);
    KeyTableData &operator=(const KeyTableData &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef KeyTableData Gw2Struct;
};


/* ===============================================
 * Chunk: main, versions: 1, strucTab: 0x142307370
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmain;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmain<0>{
struct CollideNavMeshChunkRef {
    float3 boundsMin;
    float3 boundsMax;
    helpers::FileName chunkFilename;

public:
    CollideNavMeshChunkRef();
    CollideNavMeshChunkRef(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideNavMeshChunkRef(const CollideNavMeshChunkRef &p_other);
    CollideNavMeshChunkRef &operator=(const CollideNavMeshChunkRef &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CollideNavMesh {
    float3 boundsMin;
    float3 boundsMax;
    dword2 chunkDims;
    helpers::Array<CollideNavMeshChunkRef> chunkRefArray;

public:
    CollideNavMesh();
    CollideNavMesh(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideNavMesh(const CollideNavMesh &p_other);
    CollideNavMesh &operator=(const CollideNavMesh &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef CollideNavMesh Gw2Struct;
};


/* ===============================================
 * Chunk: main, versions: 1, strucTab: 0x142307398
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmain;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmain<0>{
struct CollideNavMeshChunk {
    helpers::Array<byte> navMeshData;
    helpers::Array<byte> coarseGraphData;
    helpers::Array<byte> queryMediatorMoppData;

public:
    CollideNavMeshChunk();
    CollideNavMeshChunk(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideNavMeshChunk(const CollideNavMeshChunk &p_other);
    CollideNavMeshChunk &operator=(const CollideNavMeshChunk &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef CollideNavMeshChunk Gw2Struct;
};


/* ===============================================
 * Chunk: main, versions: 2, strucTab: 0x1423073C0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmain;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmain<1>{
struct CollideModelManifestFile {
    helpers::WString modelFileStr;
    helpers::FileName modelFile;
    helpers::FileName collisionFile;
    helpers::Array<float> scales;

public:
    CollideModelManifestFile();
    CollideModelManifestFile(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideModelManifestFile(const CollideModelManifestFile &p_other);
    CollideModelManifestFile &operator=(const CollideModelManifestFile &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CollideModelManifest {
    helpers::Array<CollideModelManifestFile> files;

public:
    CollideModelManifest();
    CollideModelManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideModelManifest(const CollideModelManifest &p_other);
    CollideModelManifest &operator=(const CollideModelManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef CollideModelManifest Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmain<0>{
struct CollideModelManifestFile {
    helpers::FileName modelFile;
    helpers::FileName collisionFile;
    helpers::Array<float> scales;

public:
    CollideModelManifestFile();
    CollideModelManifestFile(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideModelManifestFile(const CollideModelManifestFile &p_other);
    CollideModelManifestFile &operator=(const CollideModelManifestFile &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct CollideModelManifest {
    helpers::Array<CollideModelManifestFile> files;

public:
    CollideModelManifest();
    CollideModelManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    CollideModelManifest(const CollideModelManifest &p_other);
    CollideModelManifest &operator=(const CollideModelManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef CollideModelManifest Gw2Struct;
};


/* ===============================================
 * Chunk: mach, versions: 2, strucTab: 0x142312CD0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmach;

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmach<1>{
struct PackAnimMachineActionV1 {
    Unknown0x1C actionData;

public:
    PackAnimMachineActionV1();
    PackAnimMachineActionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionV1(const PackAnimMachineActionV1 &p_other);
    PackAnimMachineActionV1 &operator=(const PackAnimMachineActionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionBlockV1 {
    helpers::Array<PackAnimMachineActionV1> actions;

public:
    PackAnimMachineActionBlockV1();
    PackAnimMachineActionBlockV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionBlockV1(const PackAnimMachineActionBlockV1 &p_other);
    PackAnimMachineActionBlockV1 &operator=(const PackAnimMachineActionBlockV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionVariantV1 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV1> actionBlock;

public:
    PackAnimMachineActionVariantV1();
    PackAnimMachineActionVariantV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionVariantV1(const PackAnimMachineActionVariantV1 &p_other);
    PackAnimMachineActionVariantV1 &operator=(const PackAnimMachineActionVariantV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionVariantBlockV1 {
    helpers::Array<PackAnimMachineActionVariantV1> actionVariants;

public:
    PackAnimMachineActionVariantBlockV1();
    PackAnimMachineActionVariantBlockV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionVariantBlockV1(const PackAnimMachineActionVariantBlockV1 &p_other);
    PackAnimMachineActionVariantBlockV1 &operator=(const PackAnimMachineActionVariantBlockV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineTransitionVariantV1 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV1> actionBlock;

public:
    PackAnimMachineTransitionVariantV1();
    PackAnimMachineTransitionVariantV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineTransitionVariantV1(const PackAnimMachineTransitionVariantV1 &p_other);
    PackAnimMachineTransitionVariantV1 &operator=(const PackAnimMachineTransitionVariantV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineTransitionV1 {
    helpers::WString name;
    helpers::WString targetStateName;
    helpers::Ptr<PackAnimMachineActionBlockV1> actionBlock;
    helpers::Array<PackAnimMachineTransitionVariantV1> variants;

public:
    PackAnimMachineTransitionV1();
    PackAnimMachineTransitionV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineTransitionV1(const PackAnimMachineTransitionV1 &p_other);
    PackAnimMachineTransitionV1 &operator=(const PackAnimMachineTransitionV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineStateVariantV1 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV1> actionBlock;
    helpers::Ptr<PackAnimMachineActionVariantBlockV1> actionVariantBlock;
    helpers::Array<PackAnimMachineTransitionV1> transitions;

public:
    PackAnimMachineStateVariantV1();
    PackAnimMachineStateVariantV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineStateVariantV1(const PackAnimMachineStateVariantV1 &p_other);
    PackAnimMachineStateVariantV1 &operator=(const PackAnimMachineStateVariantV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineStateV1 {
    helpers::WString name;
    helpers::Ptr<PackAnimMachineActionBlockV1> actionBlock;
    helpers::Ptr<PackAnimMachineActionVariantBlockV1> actionVariantBlock;
    helpers::Array<PackAnimMachineTransitionV1> transitions;
    helpers::Array<PackAnimMachineStateVariantV1> variants;

public:
    PackAnimMachineStateV1();
    PackAnimMachineStateV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineStateV1(const PackAnimMachineStateV1 &p_other);
    PackAnimMachineStateV1 &operator=(const PackAnimMachineStateV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineV1 {
    helpers::Array<PackAnimMachineStateV1> states;

public:
    PackAnimMachineV1();
    PackAnimMachineV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineV1(const PackAnimMachineV1 &p_other);
    PackAnimMachineV1 &operator=(const PackAnimMachineV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimModelV1 {
    helpers::FileName modelFileId;
    helpers::WString modelFileRaw;
    dword machineIndex;
    byte16 listeners;

public:
    PackAnimModelV1();
    PackAnimModelV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimModelV1(const PackAnimModelV1 &p_other);
    PackAnimModelV1 &operator=(const PackAnimModelV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachinesV1 {
    helpers::Array<PackAnimMachineV1> machines;
    helpers::Array<PackAnimModelV1> models;

public:
    PackAnimMachinesV1();
    PackAnimMachinesV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachinesV1(const PackAnimMachinesV1 &p_other);
    PackAnimMachinesV1 &operator=(const PackAnimMachinesV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAnimMachinesV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmach<0>{
struct PackAnimMachineActionV0 {
    Unknown0x1C actionData;

public:
    PackAnimMachineActionV0();
    PackAnimMachineActionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionV0(const PackAnimMachineActionV0 &p_other);
    PackAnimMachineActionV0 &operator=(const PackAnimMachineActionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionBlockV0 {
    helpers::Array<PackAnimMachineActionV0> actions;

public:
    PackAnimMachineActionBlockV0();
    PackAnimMachineActionBlockV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionBlockV0(const PackAnimMachineActionBlockV0 &p_other);
    PackAnimMachineActionBlockV0 &operator=(const PackAnimMachineActionBlockV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionVariantV0 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV0> actionBlock;

public:
    PackAnimMachineActionVariantV0();
    PackAnimMachineActionVariantV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionVariantV0(const PackAnimMachineActionVariantV0 &p_other);
    PackAnimMachineActionVariantV0 &operator=(const PackAnimMachineActionVariantV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineActionVariantBlockV0 {
    helpers::Array<PackAnimMachineActionVariantV0> actionVariants;

public:
    PackAnimMachineActionVariantBlockV0();
    PackAnimMachineActionVariantBlockV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineActionVariantBlockV0(const PackAnimMachineActionVariantBlockV0 &p_other);
    PackAnimMachineActionVariantBlockV0 &operator=(const PackAnimMachineActionVariantBlockV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineTransitionVariantV0 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV0> actionBlock;

public:
    PackAnimMachineTransitionVariantV0();
    PackAnimMachineTransitionVariantV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineTransitionVariantV0(const PackAnimMachineTransitionVariantV0 &p_other);
    PackAnimMachineTransitionVariantV0 &operator=(const PackAnimMachineTransitionVariantV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineTransitionV0 {
    helpers::WString name;
    helpers::WString targetStateName;
    helpers::Ptr<PackAnimMachineActionBlockV0> actionBlock;
    helpers::Array<PackAnimMachineTransitionVariantV0> variants;

public:
    PackAnimMachineTransitionV0();
    PackAnimMachineTransitionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineTransitionV0(const PackAnimMachineTransitionV0 &p_other);
    PackAnimMachineTransitionV0 &operator=(const PackAnimMachineTransitionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineStateVariantV0 {
    qword token;
    helpers::Ptr<PackAnimMachineActionBlockV0> actionBlock;
    helpers::Ptr<PackAnimMachineActionVariantBlockV0> actionVariantBlock;
    helpers::Array<PackAnimMachineTransitionV0> transitions;

public:
    PackAnimMachineStateVariantV0();
    PackAnimMachineStateVariantV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineStateVariantV0(const PackAnimMachineStateVariantV0 &p_other);
    PackAnimMachineStateVariantV0 &operator=(const PackAnimMachineStateVariantV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineStateV0 {
    helpers::WString name;
    helpers::Ptr<PackAnimMachineActionBlockV0> actionBlock;
    helpers::Ptr<PackAnimMachineActionVariantBlockV0> actionVariantBlock;
    helpers::Array<PackAnimMachineTransitionV0> transitions;
    helpers::Array<PackAnimMachineStateVariantV0> variants;

public:
    PackAnimMachineStateV0();
    PackAnimMachineStateV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineStateV0(const PackAnimMachineStateV0 &p_other);
    PackAnimMachineStateV0 &operator=(const PackAnimMachineStateV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachineV0 {
    helpers::Array<PackAnimMachineStateV0> states;

public:
    PackAnimMachineV0();
    PackAnimMachineV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachineV0(const PackAnimMachineV0 &p_other);
    PackAnimMachineV0 &operator=(const PackAnimMachineV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimModelV0 {
    helpers::FileName modelFileId;
    helpers::WString modelFileRaw;
    dword machineIndex;

public:
    PackAnimModelV0();
    PackAnimModelV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimModelV0(const PackAnimModelV0 &p_other);
    PackAnimModelV0 &operator=(const PackAnimModelV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimMachinesV0 {
    helpers::Array<PackAnimMachineV0> machines;
    helpers::Array<PackAnimModelV0> models;

public:
    PackAnimMachinesV0();
    PackAnimMachinesV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimMachinesV0(const PackAnimMachinesV0 &p_other);
    PackAnimMachinesV0 &operator=(const PackAnimMachinesV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAnimMachinesV0 Gw2Struct;
};


/* ===============================================
 * Chunk: fall, versions: 1, strucTab: 0x142312B90
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structfall;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structfall<0>{
struct PackAnimFallbackV0 {
    qword sourceAnim;
    helpers::Array<qword> targetAnims;

public:
    PackAnimFallbackV0();
    PackAnimFallbackV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimFallbackV0(const PackAnimFallbackV0 &p_other);
    PackAnimFallbackV0 &operator=(const PackAnimFallbackV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimFallbacksV0 {
    helpers::Array<PackAnimFallbackV0> fallbacks;

public:
    PackAnimFallbacksV0();
    PackAnimFallbacksV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimFallbacksV0(const PackAnimFallbacksV0 &p_other);
    PackAnimFallbacksV0 &operator=(const PackAnimFallbacksV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAnimFallbacksV0 Gw2Struct;
};


/* ===============================================
 * Chunk: seqn, versions: 1, strucTab: 0x142312B30
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structseqn;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structseqn<0>{
struct PackAnimSequenceChargeStageV0 {
    word duration;
    byte endingChargeLevel;

public:
    PackAnimSequenceChargeStageV0();
    PackAnimSequenceChargeStageV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceChargeStageV0(const PackAnimSequenceChargeStageV0 &p_other);
    PackAnimSequenceChargeStageV0 &operator=(const PackAnimSequenceChargeStageV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceStepActionV0 {
    dword duration;

public:
    PackAnimSequenceStepActionV0();
    PackAnimSequenceStepActionV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceStepActionV0(const PackAnimSequenceStepActionV0 &p_other);
    PackAnimSequenceStepActionV0 &operator=(const PackAnimSequenceStepActionV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceStepMoveV0 {
    dword duration;
    float4 moveRotation;
    float4 facingRotation;
    float2 velocity;

public:
    PackAnimSequenceStepMoveV0();
    PackAnimSequenceStepMoveV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceStepMoveV0(const PackAnimSequenceStepMoveV0 &p_other);
    PackAnimSequenceStepMoveV0 &operator=(const PackAnimSequenceStepMoveV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceStepV0 {
    byte type;
    float animationSpeed;
    dword flags;
    helpers::Ptr<PackAnimSequenceStepActionV0> action;
    helpers::Ptr<PackAnimSequenceStepMoveV0> move;

public:
    PackAnimSequenceStepV0();
    PackAnimSequenceStepV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceStepV0(const PackAnimSequenceStepV0 &p_other);
    PackAnimSequenceStepV0 &operator=(const PackAnimSequenceStepV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceTriggerV0 {
    byte trigger;
    dword time;
    dword flags;

public:
    PackAnimSequenceTriggerV0();
    PackAnimSequenceTriggerV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceTriggerV0(const PackAnimSequenceTriggerV0 &p_other);
    PackAnimSequenceTriggerV0 &operator=(const PackAnimSequenceTriggerV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceDataV0 {
    ERROR token
;
    dword flags;
    float blendInTime;
    float blendOutTime;
    helpers::Array<PackAnimSequenceChargeStageV0> chargeStages;
    helpers::Array<PackAnimSequenceStepV0> steps;
    helpers::Array<PackAnimSequenceTriggerV0> triggers;

public:
    PackAnimSequenceDataV0();
    PackAnimSequenceDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceDataV0(const PackAnimSequenceDataV0 &p_other);
    PackAnimSequenceDataV0 &operator=(const PackAnimSequenceDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequenceV0 {
    qword sequence;
    helpers::Array<PackAnimSequenceDataV0> animationData;

public:
    PackAnimSequenceV0();
    PackAnimSequenceV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequenceV0(const PackAnimSequenceV0 &p_other);
    PackAnimSequenceV0 &operator=(const PackAnimSequenceV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimSequencesV0 {
    helpers::Array<PackAnimSequenceV0> sequences;

public:
    PackAnimSequencesV0();
    PackAnimSequencesV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimSequencesV0(const PackAnimSequencesV0 &p_other);
    PackAnimSequencesV0 &operator=(const PackAnimSequencesV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAnimSequencesV0 Gw2Struct;
};


/* ===============================================
 * Chunk: cnfg, versions: 1, strucTab: 0x142312E00
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structcnfg;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcnfg<0>{
struct PackAnimAimIKBoneV0 {
    qword boneToken;
    float clampAngle;
    float weight;
    float smoothingWeight;

public:
    PackAnimAimIKBoneV0();
    PackAnimAimIKBoneV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimAimIKBoneV0(const PackAnimAimIKBoneV0 &p_other);
    PackAnimAimIKBoneV0 &operator=(const PackAnimAimIKBoneV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimAimIKConfigV0 {
    qword name;
    qword boneEye;
    qword boneSight;
    qword endEffector;
    float frustumHAngle;
    float frustumVAngle;
    float frustumLength;
    float targetVelocityConstraint;
    helpers::Array<PackAnimAimIKBoneV0> bones;
    helpers::Array<qword> targets;
    byte flags;

public:
    PackAnimAimIKConfigV0();
    PackAnimAimIKConfigV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimAimIKConfigV0(const PackAnimAimIKConfigV0 &p_other);
    PackAnimAimIKConfigV0 &operator=(const PackAnimAimIKConfigV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimIKRaycastTargetV0 {
    dword flags;
    float3 direction;

public:
    PackAnimIKRaycastTargetV0();
    PackAnimIKRaycastTargetV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimIKRaycastTargetV0(const PackAnimIKRaycastTargetV0 &p_other);
    PackAnimIKRaycastTargetV0 &operator=(const PackAnimIKRaycastTargetV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimIKChainV0 {
    qword name;
    float3 smoothWeight;
    float hyperExtensionStart;
    float hyperExtensionScale;
    helpers::Array<qword> bones;
    helpers::Ptr<PackAnimIKRaycastTargetV0> targetRaycastInfo;
    byte targetMode;
    byte chainType;

public:
    PackAnimIKChainV0();
    PackAnimIKChainV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimIKChainV0(const PackAnimIKChainV0 &p_other);
    PackAnimIKChainV0 &operator=(const PackAnimIKChainV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimIKChainGroupV0 {
    qword name;
    helpers::Array<PackAnimIKChainV0> chains;

public:
    PackAnimIKChainGroupV0();
    PackAnimIKChainGroupV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimIKChainGroupV0(const PackAnimIKChainGroupV0 &p_other);
    PackAnimIKChainGroupV0 &operator=(const PackAnimIKChainGroupV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackAnimConfigV0 {
    helpers::Array<PackAnimAimIKConfigV0> aimIKConfigs;
    helpers::Array<PackAnimIKChainGroupV0> chainGroups;

public:
    PackAnimConfigV0();
    PackAnimConfigV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackAnimConfigV0(const PackAnimConfigV0 &p_other);
    PackAnimConfigV0 &operator=(const PackAnimConfigV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackAnimConfigV0 Gw2Struct;
};


/* ===============================================
 * Chunk: comp, versions: 20, strucTab: 0x1423143A0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structcomp;

/* Version: 19, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<19>{
struct PackCompositeBlitRectSetV20 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV20();
    PackCompositeBlitRectSetV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV20(const PackCompositeBlitRectSetV20 &p_other);
    PackCompositeBlitRectSetV20 &operator=(const PackCompositeBlitRectSetV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV20 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV20();
    PackCompositeBoneScaleParamV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV20(const PackCompositeBoneScaleParamV20 &p_other);
    PackCompositeBoneScaleParamV20 &operator=(const PackCompositeBoneScaleParamV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV20 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV20> Bone;

public:
    PackCompositeBoneScaleRegionV20();
    PackCompositeBoneScaleRegionV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV20(const PackCompositeBoneScaleRegionV20 &p_other);
    PackCompositeBoneScaleRegionV20 &operator=(const PackCompositeBoneScaleRegionV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV20 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV20();
    PackCompositeMorphWeightV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV20(const PackCompositeMorphWeightV20 &p_other);
    PackCompositeMorphWeightV20 &operator=(const PackCompositeMorphWeightV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV20 {
    helpers::Array<PackCompositeBoneScaleRegionV20> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV20> MorphWeight;

public:
    PackCompositeBoneScaleV20();
    PackCompositeBoneScaleV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV20(const PackCompositeBoneScaleV20 &p_other);
    PackCompositeBoneScaleV20 &operator=(const PackCompositeBoneScaleV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV20 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV20();
    PackCompositeBoneScaleFileV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV20(const PackCompositeBoneScaleFileV20 &p_other);
    PackCompositeBoneScaleFileV20 &operator=(const PackCompositeBoneScaleFileV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV20 {
    qword name;
    byte type;
    byte flags;
    qword animRoleOverride;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV20();
    PackCompositeFileDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV20(const PackCompositeFileDataV20 &p_other);
    PackCompositeFileDataV20 &operator=(const PackCompositeFileDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV20 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV20();
    PackCompositeSkinPatternV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV20(const PackCompositeSkinPatternV20 &p_other);
    PackCompositeSkinPatternV20 &operator=(const PackCompositeSkinPatternV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinStyleV20 {
    qword chest;
    qword feet;
    qword hands;
    qword legs;

public:
    PackCompositeSkinStyleV20();
    PackCompositeSkinStyleV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinStyleV20(const PackCompositeSkinStyleV20 &p_other);
    PackCompositeSkinStyleV20 &operator=(const PackCompositeSkinStyleV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV20 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV20();
    PackCompositeColorV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV20(const PackCompositeColorV20 &p_other);
    PackCompositeColorV20 &operator=(const PackCompositeColorV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV20 {
    qword nameToken;
    PackCompositeColorV20 color0;
    PackCompositeColorV20 color1;
    PackCompositeColorV20 color2;
    PackCompositeColorV20 color3;

public:
    PackCompositeVariantComponentV20();
    PackCompositeVariantComponentV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV20(const PackCompositeVariantComponentV20 &p_other);
    PackCompositeVariantComponentV20 &operator=(const PackCompositeVariantComponentV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV20 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV20> components;
    PackCompositeColorV20 eyeColor;
    PackCompositeColorV20 hairColor;
    PackCompositeColorV20 hairColor2;
    PackCompositeColorV20 patternColor;
    PackCompositeColorV20 skinColor;
    dword skinIndex;
    dword skinStyle;

public:
    PackCompositeVariantV20();
    PackCompositeVariantV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV20(const PackCompositeVariantV20 &p_other);
    PackCompositeVariantV20 &operator=(const PackCompositeVariantV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeAnimOverrideV20 {
    qword animRole;
    helpers::FileName filepath;

public:
    PackCompositeAnimOverrideV20();
    PackCompositeAnimOverrideV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeAnimOverrideV20(const PackCompositeAnimOverrideV20 &p_other);
    PackCompositeAnimOverrideV20 &operator=(const PackCompositeAnimOverrideV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV20 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV20> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV20> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV20> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV20> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV20> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    helpers::Array<PackCompositeSkinStyleV20> skinStyles;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV20> variants;
    helpers::Array<PackCompositeAnimOverrideV20> animOverrides;

public:
    PackCompositeRaceDataV20();
    PackCompositeRaceDataV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV20(const PackCompositeRaceDataV20 &p_other);
    PackCompositeRaceDataV20 &operator=(const PackCompositeRaceDataV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV20 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV20> blitRects;
    helpers::Array<PackCompositeBoneScaleV20> boneScales;
    helpers::Array<PackCompositeRaceDataV20> raceSexData;
    word configVersion;

public:
    PackCompositeV20();
    PackCompositeV20(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV20(const PackCompositeV20 &p_other);
    PackCompositeV20 &operator=(const PackCompositeV20 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV20 Gw2Struct;
};

/* Version: 18, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<18>{
struct PackCompositeBlitRectSetV18 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV18();
    PackCompositeBlitRectSetV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV18(const PackCompositeBlitRectSetV18 &p_other);
    PackCompositeBlitRectSetV18 &operator=(const PackCompositeBlitRectSetV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV18 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV18();
    PackCompositeBoneScaleParamV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV18(const PackCompositeBoneScaleParamV18 &p_other);
    PackCompositeBoneScaleParamV18 &operator=(const PackCompositeBoneScaleParamV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV18 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV18> Bone;

public:
    PackCompositeBoneScaleRegionV18();
    PackCompositeBoneScaleRegionV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV18(const PackCompositeBoneScaleRegionV18 &p_other);
    PackCompositeBoneScaleRegionV18 &operator=(const PackCompositeBoneScaleRegionV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV18 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV18();
    PackCompositeMorphWeightV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV18(const PackCompositeMorphWeightV18 &p_other);
    PackCompositeMorphWeightV18 &operator=(const PackCompositeMorphWeightV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV18 {
    helpers::Array<PackCompositeBoneScaleRegionV18> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV18> MorphWeight;

public:
    PackCompositeBoneScaleV18();
    PackCompositeBoneScaleV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV18(const PackCompositeBoneScaleV18 &p_other);
    PackCompositeBoneScaleV18 &operator=(const PackCompositeBoneScaleV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV18 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV18();
    PackCompositeBoneScaleFileV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV18(const PackCompositeBoneScaleFileV18 &p_other);
    PackCompositeBoneScaleFileV18 &operator=(const PackCompositeBoneScaleFileV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV18 {
    qword name;
    byte type;
    byte flags;
    qword animRoleOverride;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV18();
    PackCompositeFileDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV18(const PackCompositeFileDataV18 &p_other);
    PackCompositeFileDataV18 &operator=(const PackCompositeFileDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV18 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV18();
    PackCompositeSkinPatternV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV18(const PackCompositeSkinPatternV18 &p_other);
    PackCompositeSkinPatternV18 &operator=(const PackCompositeSkinPatternV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinStyleV18 {
    qword chest;
    qword feet;
    qword hands;
    qword legs;

public:
    PackCompositeSkinStyleV18();
    PackCompositeSkinStyleV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinStyleV18(const PackCompositeSkinStyleV18 &p_other);
    PackCompositeSkinStyleV18 &operator=(const PackCompositeSkinStyleV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV18 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV18();
    PackCompositeColorV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV18(const PackCompositeColorV18 &p_other);
    PackCompositeColorV18 &operator=(const PackCompositeColorV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV18 {
    qword nameToken;
    PackCompositeColorV18 color0;
    PackCompositeColorV18 color1;
    PackCompositeColorV18 color2;
    PackCompositeColorV18 color3;

public:
    PackCompositeVariantComponentV18();
    PackCompositeVariantComponentV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV18(const PackCompositeVariantComponentV18 &p_other);
    PackCompositeVariantComponentV18 &operator=(const PackCompositeVariantComponentV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV18 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV18> components;
    PackCompositeColorV18 eyeColor;
    PackCompositeColorV18 hairColor;
    PackCompositeColorV18 hairColor2;
    PackCompositeColorV18 patternColor;
    PackCompositeColorV18 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV18();
    PackCompositeVariantV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV18(const PackCompositeVariantV18 &p_other);
    PackCompositeVariantV18 &operator=(const PackCompositeVariantV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeAnimOverrideV18 {
    qword animRole;
    helpers::FileName filepath;

public:
    PackCompositeAnimOverrideV18();
    PackCompositeAnimOverrideV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeAnimOverrideV18(const PackCompositeAnimOverrideV18 &p_other);
    PackCompositeAnimOverrideV18 &operator=(const PackCompositeAnimOverrideV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV18 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV18> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV18> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV18> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV18> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV18> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    helpers::Array<PackCompositeSkinStyleV18> skinStyles;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV18> variants;
    helpers::Array<PackCompositeAnimOverrideV18> animOverrides;

public:
    PackCompositeRaceDataV18();
    PackCompositeRaceDataV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV18(const PackCompositeRaceDataV18 &p_other);
    PackCompositeRaceDataV18 &operator=(const PackCompositeRaceDataV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV18 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV18> blitRects;
    helpers::Array<PackCompositeBoneScaleV18> boneScales;
    helpers::Array<PackCompositeRaceDataV18> raceSexData;
    word configVersion;

public:
    PackCompositeV18();
    PackCompositeV18(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV18(const PackCompositeV18 &p_other);
    PackCompositeV18 &operator=(const PackCompositeV18 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV18 Gw2Struct;
};

/* Version: 17, ReferencedFunction: 0x41385D0000000001 */

template <>
struct Gw2Structcomp<17>{
struct PackCompositeBlitRectSetV17 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV17();
    PackCompositeBlitRectSetV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV17(const PackCompositeBlitRectSetV17 &p_other);
    PackCompositeBlitRectSetV17 &operator=(const PackCompositeBlitRectSetV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV17 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV17();
    PackCompositeBoneScaleParamV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV17(const PackCompositeBoneScaleParamV17 &p_other);
    PackCompositeBoneScaleParamV17 &operator=(const PackCompositeBoneScaleParamV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV17 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV17> Bone;

public:
    PackCompositeBoneScaleRegionV17();
    PackCompositeBoneScaleRegionV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV17(const PackCompositeBoneScaleRegionV17 &p_other);
    PackCompositeBoneScaleRegionV17 &operator=(const PackCompositeBoneScaleRegionV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV17 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV17();
    PackCompositeMorphWeightV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV17(const PackCompositeMorphWeightV17 &p_other);
    PackCompositeMorphWeightV17 &operator=(const PackCompositeMorphWeightV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV17 {
    helpers::Array<PackCompositeBoneScaleRegionV17> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV17> MorphWeight;

public:
    PackCompositeBoneScaleV17();
    PackCompositeBoneScaleV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV17(const PackCompositeBoneScaleV17 &p_other);
    PackCompositeBoneScaleV17 &operator=(const PackCompositeBoneScaleV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV17 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV17();
    PackCompositeBoneScaleFileV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV17(const PackCompositeBoneScaleFileV17 &p_other);
    PackCompositeBoneScaleFileV17 &operator=(const PackCompositeBoneScaleFileV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV17 {
    qword name;
    byte type;
    byte flags;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV17();
    PackCompositeFileDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV17(const PackCompositeFileDataV17 &p_other);
    PackCompositeFileDataV17 &operator=(const PackCompositeFileDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV17 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV17();
    PackCompositeSkinPatternV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV17(const PackCompositeSkinPatternV17 &p_other);
    PackCompositeSkinPatternV17 &operator=(const PackCompositeSkinPatternV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinStyleV17 {
    qword chest;
    qword feet;
    qword hands;
    qword legs;

public:
    PackCompositeSkinStyleV17();
    PackCompositeSkinStyleV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinStyleV17(const PackCompositeSkinStyleV17 &p_other);
    PackCompositeSkinStyleV17 &operator=(const PackCompositeSkinStyleV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV17 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV17();
    PackCompositeColorV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV17(const PackCompositeColorV17 &p_other);
    PackCompositeColorV17 &operator=(const PackCompositeColorV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV17 {
    qword nameToken;
    PackCompositeColorV17 color0;
    PackCompositeColorV17 color1;
    PackCompositeColorV17 color2;
    PackCompositeColorV17 color3;

public:
    PackCompositeVariantComponentV17();
    PackCompositeVariantComponentV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV17(const PackCompositeVariantComponentV17 &p_other);
    PackCompositeVariantComponentV17 &operator=(const PackCompositeVariantComponentV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV17 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV17> components;
    PackCompositeColorV17 eyeColor;
    PackCompositeColorV17 hairColor;
    PackCompositeColorV17 hairColor2;
    PackCompositeColorV17 patternColor;
    PackCompositeColorV17 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV17();
    PackCompositeVariantV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV17(const PackCompositeVariantV17 &p_other);
    PackCompositeVariantV17 &operator=(const PackCompositeVariantV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeAnimOverrideV17 {
    qword animRole;
    helpers::FileName filepath;

public:
    PackCompositeAnimOverrideV17();
    PackCompositeAnimOverrideV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeAnimOverrideV17(const PackCompositeAnimOverrideV17 &p_other);
    PackCompositeAnimOverrideV17 &operator=(const PackCompositeAnimOverrideV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV17 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV17> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV17> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV17> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV17> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV17> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    helpers::Array<PackCompositeSkinStyleV17> skinStyles;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV17> variants;
    helpers::Array<PackCompositeAnimOverrideV17> animOverrides;

public:
    PackCompositeRaceDataV17();
    PackCompositeRaceDataV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV17(const PackCompositeRaceDataV17 &p_other);
    PackCompositeRaceDataV17 &operator=(const PackCompositeRaceDataV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV17 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV17> blitRects;
    helpers::Array<PackCompositeBoneScaleV17> boneScales;
    helpers::Array<PackCompositeRaceDataV17> raceSexData;
    word configVersion;

public:
    PackCompositeV17();
    PackCompositeV17(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV17(const PackCompositeV17 &p_other);
    PackCompositeV17 &operator=(const PackCompositeV17 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV17 Gw2Struct;
};

/* Version: 16, ReferencedFunction: 0x4138588000000001 */

template <>
struct Gw2Structcomp<16>{
struct PackCompositeBlitRectSetV16 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV16();
    PackCompositeBlitRectSetV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV16(const PackCompositeBlitRectSetV16 &p_other);
    PackCompositeBlitRectSetV16 &operator=(const PackCompositeBlitRectSetV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV16 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV16();
    PackCompositeBoneScaleParamV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV16(const PackCompositeBoneScaleParamV16 &p_other);
    PackCompositeBoneScaleParamV16 &operator=(const PackCompositeBoneScaleParamV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV16 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV16> Bone;

public:
    PackCompositeBoneScaleRegionV16();
    PackCompositeBoneScaleRegionV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV16(const PackCompositeBoneScaleRegionV16 &p_other);
    PackCompositeBoneScaleRegionV16 &operator=(const PackCompositeBoneScaleRegionV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV16 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV16();
    PackCompositeMorphWeightV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV16(const PackCompositeMorphWeightV16 &p_other);
    PackCompositeMorphWeightV16 &operator=(const PackCompositeMorphWeightV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV16 {
    helpers::Array<PackCompositeBoneScaleRegionV16> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV16> MorphWeight;

public:
    PackCompositeBoneScaleV16();
    PackCompositeBoneScaleV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV16(const PackCompositeBoneScaleV16 &p_other);
    PackCompositeBoneScaleV16 &operator=(const PackCompositeBoneScaleV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV16 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV16();
    PackCompositeBoneScaleFileV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV16(const PackCompositeBoneScaleFileV16 &p_other);
    PackCompositeBoneScaleFileV16 &operator=(const PackCompositeBoneScaleFileV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV16 {
    qword name;
    byte type;
    byte flags;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV16();
    PackCompositeFileDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV16(const PackCompositeFileDataV16 &p_other);
    PackCompositeFileDataV16 &operator=(const PackCompositeFileDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV16 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV16();
    PackCompositeSkinPatternV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV16(const PackCompositeSkinPatternV16 &p_other);
    PackCompositeSkinPatternV16 &operator=(const PackCompositeSkinPatternV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV16 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV16();
    PackCompositeColorV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV16(const PackCompositeColorV16 &p_other);
    PackCompositeColorV16 &operator=(const PackCompositeColorV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV16 {
    qword nameToken;
    PackCompositeColorV16 color0;
    PackCompositeColorV16 color1;
    PackCompositeColorV16 color2;
    PackCompositeColorV16 color3;

public:
    PackCompositeVariantComponentV16();
    PackCompositeVariantComponentV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV16(const PackCompositeVariantComponentV16 &p_other);
    PackCompositeVariantComponentV16 &operator=(const PackCompositeVariantComponentV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV16 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV16> components;
    PackCompositeColorV16 eyeColor;
    PackCompositeColorV16 hairColor;
    PackCompositeColorV16 hairColor2;
    PackCompositeColorV16 patternColor;
    PackCompositeColorV16 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV16();
    PackCompositeVariantV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV16(const PackCompositeVariantV16 &p_other);
    PackCompositeVariantV16 &operator=(const PackCompositeVariantV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeAnimOverrideV16 {
    qword animRole;
    helpers::FileName filepath;

public:
    PackCompositeAnimOverrideV16();
    PackCompositeAnimOverrideV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeAnimOverrideV16(const PackCompositeAnimOverrideV16 &p_other);
    PackCompositeAnimOverrideV16 &operator=(const PackCompositeAnimOverrideV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV16 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV16> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV16> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV16> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV16> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV16> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    byte skinStyleCount;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV16> variants;
    helpers::Array<PackCompositeAnimOverrideV16> animOverrides;

public:
    PackCompositeRaceDataV16();
    PackCompositeRaceDataV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV16(const PackCompositeRaceDataV16 &p_other);
    PackCompositeRaceDataV16 &operator=(const PackCompositeRaceDataV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV16 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV16> blitRects;
    helpers::Array<PackCompositeBoneScaleV16> boneScales;
    helpers::Array<PackCompositeRaceDataV16> raceSexData;
    word configVersion;

public:
    PackCompositeV16();
    PackCompositeV16(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV16(const PackCompositeV16 &p_other);
    PackCompositeV16 &operator=(const PackCompositeV16 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV16 Gw2Struct;
};

/* Version: 15, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<15>{
struct PackCompositeBlitRectSetV15 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV15();
    PackCompositeBlitRectSetV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV15(const PackCompositeBlitRectSetV15 &p_other);
    PackCompositeBlitRectSetV15 &operator=(const PackCompositeBlitRectSetV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV15 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV15();
    PackCompositeBoneScaleParamV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV15(const PackCompositeBoneScaleParamV15 &p_other);
    PackCompositeBoneScaleParamV15 &operator=(const PackCompositeBoneScaleParamV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV15 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV15> Bone;

public:
    PackCompositeBoneScaleRegionV15();
    PackCompositeBoneScaleRegionV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV15(const PackCompositeBoneScaleRegionV15 &p_other);
    PackCompositeBoneScaleRegionV15 &operator=(const PackCompositeBoneScaleRegionV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV15 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV15();
    PackCompositeMorphWeightV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV15(const PackCompositeMorphWeightV15 &p_other);
    PackCompositeMorphWeightV15 &operator=(const PackCompositeMorphWeightV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV15 {
    helpers::Array<PackCompositeBoneScaleRegionV15> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV15> MorphWeight;

public:
    PackCompositeBoneScaleV15();
    PackCompositeBoneScaleV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV15(const PackCompositeBoneScaleV15 &p_other);
    PackCompositeBoneScaleV15 &operator=(const PackCompositeBoneScaleV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV15 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV15();
    PackCompositeBoneScaleFileV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV15(const PackCompositeBoneScaleFileV15 &p_other);
    PackCompositeBoneScaleFileV15 &operator=(const PackCompositeBoneScaleFileV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV15 {
    qword name;
    byte type;
    byte flags;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV15();
    PackCompositeFileDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV15(const PackCompositeFileDataV15 &p_other);
    PackCompositeFileDataV15 &operator=(const PackCompositeFileDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV15 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV15();
    PackCompositeSkinPatternV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV15(const PackCompositeSkinPatternV15 &p_other);
    PackCompositeSkinPatternV15 &operator=(const PackCompositeSkinPatternV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV15 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV15();
    PackCompositeColorV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV15(const PackCompositeColorV15 &p_other);
    PackCompositeColorV15 &operator=(const PackCompositeColorV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV15 {
    qword nameToken;
    PackCompositeColorV15 color0;
    PackCompositeColorV15 color1;
    PackCompositeColorV15 color2;
    PackCompositeColorV15 color3;

public:
    PackCompositeVariantComponentV15();
    PackCompositeVariantComponentV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV15(const PackCompositeVariantComponentV15 &p_other);
    PackCompositeVariantComponentV15 &operator=(const PackCompositeVariantComponentV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV15 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV15> components;
    PackCompositeColorV15 eyeColor;
    PackCompositeColorV15 hairColor;
    PackCompositeColorV15 hairColor2;
    PackCompositeColorV15 patternColor;
    PackCompositeColorV15 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV15();
    PackCompositeVariantV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV15(const PackCompositeVariantV15 &p_other);
    PackCompositeVariantV15 &operator=(const PackCompositeVariantV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeAnimOverrideV15 {
    qword animRole;
    helpers::FileName filepath;

public:
    PackCompositeAnimOverrideV15();
    PackCompositeAnimOverrideV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeAnimOverrideV15(const PackCompositeAnimOverrideV15 &p_other);
    PackCompositeAnimOverrideV15 &operator=(const PackCompositeAnimOverrideV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV15 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV15> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV15> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV15> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV15> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV15> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    byte skinStyleCount;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV15> variants;
    helpers::Array<PackCompositeAnimOverrideV15> animOverrides;

public:
    PackCompositeRaceDataV15();
    PackCompositeRaceDataV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV15(const PackCompositeRaceDataV15 &p_other);
    PackCompositeRaceDataV15 &operator=(const PackCompositeRaceDataV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV15 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV15> blitRects;
    helpers::Array<PackCompositeBoneScaleV15> boneScales;
    helpers::Array<PackCompositeRaceDataV15> raceSexData;
    word configVersion;

public:
    PackCompositeV15();
    PackCompositeV15(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV15(const PackCompositeV15 &p_other);
    PackCompositeV15 &operator=(const PackCompositeV15 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV15 Gw2Struct;
};

/* Version: 14, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<14>{
struct PackCompositeBlitRectSetV14 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV14();
    PackCompositeBlitRectSetV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV14(const PackCompositeBlitRectSetV14 &p_other);
    PackCompositeBlitRectSetV14 &operator=(const PackCompositeBlitRectSetV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV14 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV14();
    PackCompositeBoneScaleParamV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV14(const PackCompositeBoneScaleParamV14 &p_other);
    PackCompositeBoneScaleParamV14 &operator=(const PackCompositeBoneScaleParamV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV14 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV14> Bone;

public:
    PackCompositeBoneScaleRegionV14();
    PackCompositeBoneScaleRegionV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV14(const PackCompositeBoneScaleRegionV14 &p_other);
    PackCompositeBoneScaleRegionV14 &operator=(const PackCompositeBoneScaleRegionV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV14 {
    qword name;
    float value;

public:
    PackCompositeMorphWeightV14();
    PackCompositeMorphWeightV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV14(const PackCompositeMorphWeightV14 &p_other);
    PackCompositeMorphWeightV14 &operator=(const PackCompositeMorphWeightV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV14 {
    helpers::Array<PackCompositeBoneScaleRegionV14> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV14> MorphWeight;

public:
    PackCompositeBoneScaleV14();
    PackCompositeBoneScaleV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV14(const PackCompositeBoneScaleV14 &p_other);
    PackCompositeBoneScaleV14 &operator=(const PackCompositeBoneScaleV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV14 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV14();
    PackCompositeBoneScaleFileV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV14(const PackCompositeBoneScaleFileV14 &p_other);
    PackCompositeBoneScaleFileV14 &operator=(const PackCompositeBoneScaleFileV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV14 {
    qword name;
    byte type;
    byte flags;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV14();
    PackCompositeFileDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV14(const PackCompositeFileDataV14 &p_other);
    PackCompositeFileDataV14 &operator=(const PackCompositeFileDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV14 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV14();
    PackCompositeSkinPatternV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV14(const PackCompositeSkinPatternV14 &p_other);
    PackCompositeSkinPatternV14 &operator=(const PackCompositeSkinPatternV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV14 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV14();
    PackCompositeColorV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV14(const PackCompositeColorV14 &p_other);
    PackCompositeColorV14 &operator=(const PackCompositeColorV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV14 {
    qword nameToken;
    PackCompositeColorV14 color0;
    PackCompositeColorV14 color1;
    PackCompositeColorV14 color2;
    PackCompositeColorV14 color3;

public:
    PackCompositeVariantComponentV14();
    PackCompositeVariantComponentV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV14(const PackCompositeVariantComponentV14 &p_other);
    PackCompositeVariantComponentV14 &operator=(const PackCompositeVariantComponentV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV14 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV14> components;
    PackCompositeColorV14 eyeColor;
    PackCompositeColorV14 hairColor;
    PackCompositeColorV14 hairColor2;
    PackCompositeColorV14 patternColor;
    PackCompositeColorV14 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV14();
    PackCompositeVariantV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV14(const PackCompositeVariantV14 &p_other);
    PackCompositeVariantV14 &operator=(const PackCompositeVariantV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV14 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV14> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV14> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::WString eyeColorPalette;
    helpers::Array<PackCompositeBoneScaleV14> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV14> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV14> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    byte skinStyleCount;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV14> variants;

public:
    PackCompositeRaceDataV14();
    PackCompositeRaceDataV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV14(const PackCompositeRaceDataV14 &p_other);
    PackCompositeRaceDataV14 &operator=(const PackCompositeRaceDataV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV14 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV14> blitRects;
    helpers::Array<PackCompositeBoneScaleV14> boneScales;
    helpers::Array<PackCompositeRaceDataV14> raceSexData;
    word configVersion;

public:
    PackCompositeV14();
    PackCompositeV14(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV14(const PackCompositeV14 &p_other);
    PackCompositeV14 &operator=(const PackCompositeV14 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV14 Gw2Struct;
};

/* Version: 13, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<13>{
struct PackCompositeBlitRectSetV13 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV13();
    PackCompositeBlitRectSetV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV13(const PackCompositeBlitRectSetV13 &p_other);
    PackCompositeBlitRectSetV13 &operator=(const PackCompositeBlitRectSetV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV13 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV13();
    PackCompositeBoneScaleParamV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV13(const PackCompositeBoneScaleParamV13 &p_other);
    PackCompositeBoneScaleParamV13 &operator=(const PackCompositeBoneScaleParamV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV13 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV13> Bone;

public:
    PackCompositeBoneScaleRegionV13();
    PackCompositeBoneScaleRegionV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV13(const PackCompositeBoneScaleRegionV13 &p_other);
    PackCompositeBoneScaleRegionV13 &operator=(const PackCompositeBoneScaleRegionV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV13 {
    float value;
    qword name;

public:
    PackCompositeMorphWeightV13();
    PackCompositeMorphWeightV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV13(const PackCompositeMorphWeightV13 &p_other);
    PackCompositeMorphWeightV13 &operator=(const PackCompositeMorphWeightV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV13 {
    helpers::Array<PackCompositeBoneScaleRegionV13> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV13> MorphWeight;

public:
    PackCompositeBoneScaleV13();
    PackCompositeBoneScaleV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV13(const PackCompositeBoneScaleV13 &p_other);
    PackCompositeBoneScaleV13 &operator=(const PackCompositeBoneScaleV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV13 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV13();
    PackCompositeBoneScaleFileV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV13(const PackCompositeBoneScaleFileV13 &p_other);
    PackCompositeBoneScaleFileV13 &operator=(const PackCompositeBoneScaleFileV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV13 {
    qword name;
    byte type;
    byte flags;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    byte blitRectIndex;

public:
    PackCompositeFileDataV13();
    PackCompositeFileDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV13(const PackCompositeFileDataV13 &p_other);
    PackCompositeFileDataV13 &operator=(const PackCompositeFileDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV13 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV13();
    PackCompositeSkinPatternV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV13(const PackCompositeSkinPatternV13 &p_other);
    PackCompositeSkinPatternV13 &operator=(const PackCompositeSkinPatternV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV13 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV13();
    PackCompositeColorV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV13(const PackCompositeColorV13 &p_other);
    PackCompositeColorV13 &operator=(const PackCompositeColorV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV13 {
    qword nameToken;
    PackCompositeColorV13 color0;
    PackCompositeColorV13 color1;
    PackCompositeColorV13 color2;
    PackCompositeColorV13 color3;

public:
    PackCompositeVariantComponentV13();
    PackCompositeVariantComponentV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV13(const PackCompositeVariantComponentV13 &p_other);
    PackCompositeVariantComponentV13 &operator=(const PackCompositeVariantComponentV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV13 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV13> components;
    PackCompositeColorV13 hairColor;
    PackCompositeColorV13 hairColor2;
    PackCompositeColorV13 patternColor;
    PackCompositeColorV13 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV13();
    PackCompositeVariantV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV13(const PackCompositeVariantV13 &p_other);
    PackCompositeVariantV13 &operator=(const PackCompositeVariantV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV13 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV13> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV13> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::Array<PackCompositeBoneScaleV13> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV13> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV13> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    byte skinStyleCount;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV13> variants;

public:
    PackCompositeRaceDataV13();
    PackCompositeRaceDataV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV13(const PackCompositeRaceDataV13 &p_other);
    PackCompositeRaceDataV13 &operator=(const PackCompositeRaceDataV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV13 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV13> blitRects;
    helpers::Array<PackCompositeBoneScaleV13> boneScales;
    helpers::Array<PackCompositeRaceDataV13> raceSexData;
    word configVersion;

public:
    PackCompositeV13();
    PackCompositeV13(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV13(const PackCompositeV13 &p_other);
    PackCompositeV13 &operator=(const PackCompositeV13 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV13 Gw2Struct;
};

/* Version: 12, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<12>{
struct PackCompositeBlitRectSetV12 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV12();
    PackCompositeBlitRectSetV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV12(const PackCompositeBlitRectSetV12 &p_other);
    PackCompositeBlitRectSetV12 &operator=(const PackCompositeBlitRectSetV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV12 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV12();
    PackCompositeBoneScaleParamV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV12(const PackCompositeBoneScaleParamV12 &p_other);
    PackCompositeBoneScaleParamV12 &operator=(const PackCompositeBoneScaleParamV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV12 {
    qword name;
    float value;
    helpers::Array<PackCompositeBoneScaleParamV12> Bone;

public:
    PackCompositeBoneScaleRegionV12();
    PackCompositeBoneScaleRegionV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV12(const PackCompositeBoneScaleRegionV12 &p_other);
    PackCompositeBoneScaleRegionV12 &operator=(const PackCompositeBoneScaleRegionV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeMorphWeightV12 {
    float value;
    qword name;

public:
    PackCompositeMorphWeightV12();
    PackCompositeMorphWeightV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeMorphWeightV12(const PackCompositeMorphWeightV12 &p_other);
    PackCompositeMorphWeightV12 &operator=(const PackCompositeMorphWeightV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV12 {
    helpers::Array<PackCompositeBoneScaleRegionV12> BodyRegion;
    helpers::Array<PackCompositeMorphWeightV12> MorphWeight;

public:
    PackCompositeBoneScaleV12();
    PackCompositeBoneScaleV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV12(const PackCompositeBoneScaleV12 &p_other);
    PackCompositeBoneScaleV12 &operator=(const PackCompositeBoneScaleV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleFileV12 {
    helpers::WString fileName;

public:
    PackCompositeBoneScaleFileV12();
    PackCompositeBoneScaleFileV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleFileV12(const PackCompositeBoneScaleFileV12 &p_other);
    PackCompositeBoneScaleFileV12 &operator=(const PackCompositeBoneScaleFileV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV12 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV12();
    PackCompositeFileDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV12(const PackCompositeFileDataV12 &p_other);
    PackCompositeFileDataV12 &operator=(const PackCompositeFileDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV12 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV12();
    PackCompositeSkinPatternV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV12(const PackCompositeSkinPatternV12 &p_other);
    PackCompositeSkinPatternV12 &operator=(const PackCompositeSkinPatternV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV12 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV12();
    PackCompositeColorV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV12(const PackCompositeColorV12 &p_other);
    PackCompositeColorV12 &operator=(const PackCompositeColorV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV12 {
    qword nameToken;
    PackCompositeColorV12 color0;
    PackCompositeColorV12 color1;
    PackCompositeColorV12 color2;
    PackCompositeColorV12 color3;

public:
    PackCompositeVariantComponentV12();
    PackCompositeVariantComponentV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV12(const PackCompositeVariantComponentV12 &p_other);
    PackCompositeVariantComponentV12 &operator=(const PackCompositeVariantComponentV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV12 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV12> components;
    PackCompositeColorV12 hairColor;
    PackCompositeColorV12 hairColor2;
    PackCompositeColorV12 patternColor;
    PackCompositeColorV12 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV12();
    PackCompositeVariantV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV12(const PackCompositeVariantV12 &p_other);
    PackCompositeVariantV12 &operator=(const PackCompositeVariantV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV12 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<PackCompositeBoneScaleV12> bodyBoneScales;
    helpers::Array<PackCompositeBoneScaleFileV12> bodyBoneScaleFiles;
    helpers::Array<qword> ears;
    helpers::Array<PackCompositeBoneScaleV12> faceBoneScales;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV12> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV12> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    byte skinStyleCount;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV12> variants;

public:
    PackCompositeRaceDataV12();
    PackCompositeRaceDataV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV12(const PackCompositeRaceDataV12 &p_other);
    PackCompositeRaceDataV12 &operator=(const PackCompositeRaceDataV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV12 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV12> blitRects;
    helpers::Array<PackCompositeBoneScaleV12> boneScales;
    helpers::Array<PackCompositeRaceDataV12> raceSexData;
    word configVersion;

public:
    PackCompositeV12();
    PackCompositeV12(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV12(const PackCompositeV12 &p_other);
    PackCompositeV12 &operator=(const PackCompositeV12 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV12 Gw2Struct;
};

/* Version: 11, ReferencedFunction: 0x4138582000000001 */

template <>
struct Gw2Structcomp<11>{
struct PackCompositeBlitRectSetV11 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV11();
    PackCompositeBlitRectSetV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV11(const PackCompositeBlitRectSetV11 &p_other);
    PackCompositeBlitRectSetV11 &operator=(const PackCompositeBlitRectSetV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleParamV11 {
    qword name;
    byte flags;
    float max;
    float min;
    float3 rotate;
    float3 scale;
    float3 translate;

public:
    PackCompositeBoneScaleParamV11();
    PackCompositeBoneScaleParamV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleParamV11(const PackCompositeBoneScaleParamV11 &p_other);
    PackCompositeBoneScaleParamV11 &operator=(const PackCompositeBoneScaleParamV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleRegionV11 {
    float value;
    helpers::Array<PackCompositeBoneScaleParamV11> Bone;

public:
    PackCompositeBoneScaleRegionV11();
    PackCompositeBoneScaleRegionV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleRegionV11(const PackCompositeBoneScaleRegionV11 &p_other);
    PackCompositeBoneScaleRegionV11 &operator=(const PackCompositeBoneScaleRegionV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeBoneScaleV11 {
    helpers::Array<PackCompositeBoneScaleRegionV11> BodyRegion;

public:
    PackCompositeBoneScaleV11();
    PackCompositeBoneScaleV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBoneScaleV11(const PackCompositeBoneScaleV11 &p_other);
    PackCompositeBoneScaleV11 &operator=(const PackCompositeBoneScaleV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV11 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV11();
    PackCompositeFileDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV11(const PackCompositeFileDataV11 &p_other);
    PackCompositeFileDataV11 &operator=(const PackCompositeFileDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV11 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV11();
    PackCompositeSkinPatternV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV11(const PackCompositeSkinPatternV11 &p_other);
    PackCompositeSkinPatternV11 &operator=(const PackCompositeSkinPatternV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV11 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV11();
    PackCompositeColorV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV11(const PackCompositeColorV11 &p_other);
    PackCompositeColorV11 &operator=(const PackCompositeColorV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV11 {
    qword nameToken;
    PackCompositeColorV11 color0;
    PackCompositeColorV11 color1;
    PackCompositeColorV11 color2;
    PackCompositeColorV11 color3;

public:
    PackCompositeVariantComponentV11();
    PackCompositeVariantComponentV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV11(const PackCompositeVariantComponentV11 &p_other);
    PackCompositeVariantComponentV11 &operator=(const PackCompositeVariantComponentV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV11 {
    qword token;
    dword boneScaleIndex;
    helpers::Array<PackCompositeVariantComponentV11> components;
    PackCompositeColorV11 hairColor;
    PackCompositeColorV11 hairColor2;
    PackCompositeColorV11 patternColor;
    PackCompositeColorV11 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV11();
    PackCompositeVariantV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV11(const PackCompositeVariantV11 &p_other);
    PackCompositeVariantV11 &operator=(const PackCompositeVariantV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV11 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV11> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV11> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV11> variants;

public:
    PackCompositeRaceDataV11();
    PackCompositeRaceDataV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV11(const PackCompositeRaceDataV11 &p_other);
    PackCompositeRaceDataV11 &operator=(const PackCompositeRaceDataV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV11 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV11> blitRects;
    helpers::Array<PackCompositeBoneScaleV11> boneScales;
    helpers::Array<PackCompositeRaceDataV11> raceSexData;
    word configVersion;

public:
    PackCompositeV11();
    PackCompositeV11(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV11(const PackCompositeV11 &p_other);
    PackCompositeV11 &operator=(const PackCompositeV11 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV11 Gw2Struct;
};

/* Version: 10, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<10>{
struct PackCompositeBlitRectSetV10 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV10();
    PackCompositeBlitRectSetV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV10(const PackCompositeBlitRectSetV10 &p_other);
    PackCompositeBlitRectSetV10 &operator=(const PackCompositeBlitRectSetV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV10 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV10();
    PackCompositeFileDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV10(const PackCompositeFileDataV10 &p_other);
    PackCompositeFileDataV10 &operator=(const PackCompositeFileDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV10 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV10();
    PackCompositeSkinPatternV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV10(const PackCompositeSkinPatternV10 &p_other);
    PackCompositeSkinPatternV10 &operator=(const PackCompositeSkinPatternV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV10 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV10();
    PackCompositeColorV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV10(const PackCompositeColorV10 &p_other);
    PackCompositeColorV10 &operator=(const PackCompositeColorV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV10 {
    qword nameToken;
    PackCompositeColorV10 color0;
    PackCompositeColorV10 color1;
    PackCompositeColorV10 color2;
    PackCompositeColorV10 color3;

public:
    PackCompositeVariantComponentV10();
    PackCompositeVariantComponentV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV10(const PackCompositeVariantComponentV10 &p_other);
    PackCompositeVariantComponentV10 &operator=(const PackCompositeVariantComponentV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV10 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV10> components;
    PackCompositeColorV10 hairColor;
    PackCompositeColorV10 hairColor2;
    PackCompositeColorV10 patternColor;
    PackCompositeColorV10 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV10();
    PackCompositeVariantV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV10(const PackCompositeVariantV10 &p_other);
    PackCompositeVariantV10 &operator=(const PackCompositeVariantV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV10 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV10> fileData;
    dword flags;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV10> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV10> variants;

public:
    PackCompositeRaceDataV10();
    PackCompositeRaceDataV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV10(const PackCompositeRaceDataV10 &p_other);
    PackCompositeRaceDataV10 &operator=(const PackCompositeRaceDataV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV10 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV10> blitRects;
    helpers::Array<PackCompositeRaceDataV10> raceSexData;
    word configVersion;

public:
    PackCompositeV10();
    PackCompositeV10(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV10(const PackCompositeV10 &p_other);
    PackCompositeV10 &operator=(const PackCompositeV10 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV10 Gw2Struct;
};

/* Version: 9, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<9>{
struct PackCompositeBlitRectSetV9 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV9();
    PackCompositeBlitRectSetV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV9(const PackCompositeBlitRectSetV9 &p_other);
    PackCompositeBlitRectSetV9 &operator=(const PackCompositeBlitRectSetV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV9 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV9();
    PackCompositeFileDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV9(const PackCompositeFileDataV9 &p_other);
    PackCompositeFileDataV9 &operator=(const PackCompositeFileDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV9 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV9();
    PackCompositeSkinPatternV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV9(const PackCompositeSkinPatternV9 &p_other);
    PackCompositeSkinPatternV9 &operator=(const PackCompositeSkinPatternV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV9 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV9();
    PackCompositeColorV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV9(const PackCompositeColorV9 &p_other);
    PackCompositeColorV9 &operator=(const PackCompositeColorV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV9 {
    qword nameToken;
    PackCompositeColorV9 color0;
    PackCompositeColorV9 color1;
    PackCompositeColorV9 color2;
    PackCompositeColorV9 color3;

public:
    PackCompositeVariantComponentV9();
    PackCompositeVariantComponentV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV9(const PackCompositeVariantComponentV9 &p_other);
    PackCompositeVariantComponentV9 &operator=(const PackCompositeVariantComponentV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV9 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV9> components;
    PackCompositeColorV9 hairColor;
    PackCompositeColorV9 hairColor2;
    PackCompositeColorV9 patternColor;
    PackCompositeColorV9 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV9();
    PackCompositeVariantV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV9(const PackCompositeVariantV9 &p_other);
    PackCompositeVariantV9 &operator=(const PackCompositeVariantV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV9 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV9> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV9> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV9> variants;

public:
    PackCompositeRaceDataV9();
    PackCompositeRaceDataV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV9(const PackCompositeRaceDataV9 &p_other);
    PackCompositeRaceDataV9 &operator=(const PackCompositeRaceDataV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV9 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV9> blitRects;
    helpers::Array<PackCompositeRaceDataV9> raceSexData;
    word configVersion;

public:
    PackCompositeV9();
    PackCompositeV9(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV9(const PackCompositeV9 &p_other);
    PackCompositeV9 &operator=(const PackCompositeV9 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV9 Gw2Struct;
};

/* Version: 8, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<8>{
struct PackCompositeBlitRectSetV8 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV8();
    PackCompositeBlitRectSetV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV8(const PackCompositeBlitRectSetV8 &p_other);
    PackCompositeBlitRectSetV8 &operator=(const PackCompositeBlitRectSetV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV8 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV8();
    PackCompositeFileDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV8(const PackCompositeFileDataV8 &p_other);
    PackCompositeFileDataV8 &operator=(const PackCompositeFileDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV8 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV8();
    PackCompositeSkinPatternV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV8(const PackCompositeSkinPatternV8 &p_other);
    PackCompositeSkinPatternV8 &operator=(const PackCompositeSkinPatternV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV8 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV8();
    PackCompositeColorV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV8(const PackCompositeColorV8 &p_other);
    PackCompositeColorV8 &operator=(const PackCompositeColorV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV8 {
    qword nameToken;
    PackCompositeColorV8 color0;
    PackCompositeColorV8 color1;
    PackCompositeColorV8 color2;
    PackCompositeColorV8 color3;

public:
    PackCompositeVariantComponentV8();
    PackCompositeVariantComponentV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV8(const PackCompositeVariantComponentV8 &p_other);
    PackCompositeVariantComponentV8 &operator=(const PackCompositeVariantComponentV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV8 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV8> components;
    PackCompositeColorV8 hairColor;
    PackCompositeColorV8 hairColor2;
    PackCompositeColorV8 patternColor;
    PackCompositeColorV8 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV8();
    PackCompositeVariantV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV8(const PackCompositeVariantV8 &p_other);
    PackCompositeVariantV8 &operator=(const PackCompositeVariantV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV8 {
    helpers::WString name;
    qword nameToken;
    qword baseHeadToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV8> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV8> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV8> variants;

public:
    PackCompositeRaceDataV8();
    PackCompositeRaceDataV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV8(const PackCompositeRaceDataV8 &p_other);
    PackCompositeRaceDataV8 &operator=(const PackCompositeRaceDataV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV8 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV8> blitRects;
    helpers::Array<PackCompositeRaceDataV8> raceSexData;

public:
    PackCompositeV8();
    PackCompositeV8(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV8(const PackCompositeV8 &p_other);
    PackCompositeV8 &operator=(const PackCompositeV8 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV8 Gw2Struct;
};

/* Version: 7, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<7>{
struct PackCompositeBlitRectSetV7 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV7();
    PackCompositeBlitRectSetV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV7(const PackCompositeBlitRectSetV7 &p_other);
    PackCompositeBlitRectSetV7 &operator=(const PackCompositeBlitRectSetV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV7 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV7();
    PackCompositeFileDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV7(const PackCompositeFileDataV7 &p_other);
    PackCompositeFileDataV7 &operator=(const PackCompositeFileDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV7 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV7();
    PackCompositeSkinPatternV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV7(const PackCompositeSkinPatternV7 &p_other);
    PackCompositeSkinPatternV7 &operator=(const PackCompositeSkinPatternV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV7 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV7();
    PackCompositeColorV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV7(const PackCompositeColorV7 &p_other);
    PackCompositeColorV7 &operator=(const PackCompositeColorV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV7 {
    qword nameToken;
    PackCompositeColorV7 color0;
    PackCompositeColorV7 color1;
    PackCompositeColorV7 color2;
    PackCompositeColorV7 color3;

public:
    PackCompositeVariantComponentV7();
    PackCompositeVariantComponentV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV7(const PackCompositeVariantComponentV7 &p_other);
    PackCompositeVariantComponentV7 &operator=(const PackCompositeVariantComponentV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV7 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV7> components;
    PackCompositeColorV7 hairColor;
    PackCompositeColorV7 hairColor2;
    PackCompositeColorV7 patternColor;
    PackCompositeColorV7 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV7();
    PackCompositeVariantV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV7(const PackCompositeVariantV7 &p_other);
    PackCompositeVariantV7 &operator=(const PackCompositeVariantV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV7 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV7> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV7> skinPatterns;
    helpers::WString skinColorPalette;
    helpers::WString skinPatternPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV7> variants;

public:
    PackCompositeRaceDataV7();
    PackCompositeRaceDataV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV7(const PackCompositeRaceDataV7 &p_other);
    PackCompositeRaceDataV7 &operator=(const PackCompositeRaceDataV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV7 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV7> blitRects;
    helpers::Array<PackCompositeRaceDataV7> raceSexData;

public:
    PackCompositeV7();
    PackCompositeV7(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV7(const PackCompositeV7 &p_other);
    PackCompositeV7 &operator=(const PackCompositeV7 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV7 Gw2Struct;
};

/* Version: 6, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<6>{
struct PackCompositeBlitRectSetV6 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV6();
    PackCompositeBlitRectSetV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV6(const PackCompositeBlitRectSetV6 &p_other);
    PackCompositeBlitRectSetV6 &operator=(const PackCompositeBlitRectSetV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV6 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV6();
    PackCompositeFileDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV6(const PackCompositeFileDataV6 &p_other);
    PackCompositeFileDataV6 &operator=(const PackCompositeFileDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV6 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;
    helpers::FileName ears;

public:
    PackCompositeSkinPatternV6();
    PackCompositeSkinPatternV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV6(const PackCompositeSkinPatternV6 &p_other);
    PackCompositeSkinPatternV6 &operator=(const PackCompositeSkinPatternV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV6 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV6();
    PackCompositeColorV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV6(const PackCompositeColorV6 &p_other);
    PackCompositeColorV6 &operator=(const PackCompositeColorV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV6 {
    qword nameToken;
    PackCompositeColorV6 color0;
    PackCompositeColorV6 color1;
    PackCompositeColorV6 color2;
    PackCompositeColorV6 color3;

public:
    PackCompositeVariantComponentV6();
    PackCompositeVariantComponentV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV6(const PackCompositeVariantComponentV6 &p_other);
    PackCompositeVariantComponentV6 &operator=(const PackCompositeVariantComponentV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV6 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV6> components;
    PackCompositeColorV6 hairColor;
    PackCompositeColorV6 hairColor2;
    PackCompositeColorV6 patternColor;
    PackCompositeColorV6 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV6();
    PackCompositeVariantV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV6(const PackCompositeVariantV6 &p_other);
    PackCompositeVariantV6 &operator=(const PackCompositeVariantV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV6 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV6> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV6> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV6> variants;

public:
    PackCompositeRaceDataV6();
    PackCompositeRaceDataV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV6(const PackCompositeRaceDataV6 &p_other);
    PackCompositeRaceDataV6 &operator=(const PackCompositeRaceDataV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV6 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV6> blitRects;
    helpers::Array<PackCompositeRaceDataV6> raceSexData;

public:
    PackCompositeV6();
    PackCompositeV6(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV6(const PackCompositeV6 &p_other);
    PackCompositeV6 &operator=(const PackCompositeV6 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV6 Gw2Struct;
};

/* Version: 5, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<5>{
struct PackCompositeBlitRectSetV5 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV5();
    PackCompositeBlitRectSetV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV5(const PackCompositeBlitRectSetV5 &p_other);
    PackCompositeBlitRectSetV5 &operator=(const PackCompositeBlitRectSetV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV5 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV5();
    PackCompositeFileDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV5(const PackCompositeFileDataV5 &p_other);
    PackCompositeFileDataV5 &operator=(const PackCompositeFileDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV5 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV5();
    PackCompositeSkinPatternV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV5(const PackCompositeSkinPatternV5 &p_other);
    PackCompositeSkinPatternV5 &operator=(const PackCompositeSkinPatternV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV5 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV5();
    PackCompositeColorV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV5(const PackCompositeColorV5 &p_other);
    PackCompositeColorV5 &operator=(const PackCompositeColorV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV5 {
    qword nameToken;
    PackCompositeColorV5 color0;
    PackCompositeColorV5 color1;
    PackCompositeColorV5 color2;
    PackCompositeColorV5 color3;

public:
    PackCompositeVariantComponentV5();
    PackCompositeVariantComponentV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV5(const PackCompositeVariantComponentV5 &p_other);
    PackCompositeVariantComponentV5 &operator=(const PackCompositeVariantComponentV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV5 {
    qword token;
    helpers::Array<PackCompositeVariantComponentV5> components;
    PackCompositeColorV5 hairColor;
    PackCompositeColorV5 hairColor2;
    PackCompositeColorV5 patternColor;
    PackCompositeColorV5 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV5();
    PackCompositeVariantV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV5(const PackCompositeVariantV5 &p_other);
    PackCompositeVariantV5 &operator=(const PackCompositeVariantV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV5 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV5> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV5> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV5> variants;

public:
    PackCompositeRaceDataV5();
    PackCompositeRaceDataV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV5(const PackCompositeRaceDataV5 &p_other);
    PackCompositeRaceDataV5 &operator=(const PackCompositeRaceDataV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV5 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV5> blitRects;
    helpers::Array<PackCompositeRaceDataV5> raceSexData;

public:
    PackCompositeV5();
    PackCompositeV5(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV5(const PackCompositeV5 &p_other);
    PackCompositeV5 &operator=(const PackCompositeV5 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV5 Gw2Struct;
};

/* Version: 4, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<4>{
struct PackCompositeBlitRectSetV4 {
    helpers::WString name;
    dword2 size;
    helpers::Array<byte> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV4();
    PackCompositeBlitRectSetV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV4(const PackCompositeBlitRectSetV4 &p_other);
    PackCompositeBlitRectSetV4 &operator=(const PackCompositeBlitRectSetV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV4 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV4();
    PackCompositeFileDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV4(const PackCompositeFileDataV4 &p_other);
    PackCompositeFileDataV4 &operator=(const PackCompositeFileDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV4 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV4();
    PackCompositeSkinPatternV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV4(const PackCompositeSkinPatternV4 &p_other);
    PackCompositeSkinPatternV4 &operator=(const PackCompositeSkinPatternV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV4 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV4();
    PackCompositeColorV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV4(const PackCompositeColorV4 &p_other);
    PackCompositeColorV4 &operator=(const PackCompositeColorV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV4 {
    qword nameToken;
    PackCompositeColorV4 clothColor;
    PackCompositeColorV4 leatherColor;
    PackCompositeColorV4 metalColor;

public:
    PackCompositeVariantComponentV4();
    PackCompositeVariantComponentV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV4(const PackCompositeVariantComponentV4 &p_other);
    PackCompositeVariantComponentV4 &operator=(const PackCompositeVariantComponentV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV4 {
    helpers::Array<PackCompositeVariantComponentV4> components;
    PackCompositeColorV4 hairColor;
    PackCompositeColorV4 patternColor;
    PackCompositeColorV4 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV4();
    PackCompositeVariantV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV4(const PackCompositeVariantV4 &p_other);
    PackCompositeVariantV4 &operator=(const PackCompositeVariantV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV4 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV4> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV4> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV4> variants;

public:
    PackCompositeRaceDataV4();
    PackCompositeRaceDataV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV4(const PackCompositeRaceDataV4 &p_other);
    PackCompositeRaceDataV4 &operator=(const PackCompositeRaceDataV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV4 {
    helpers::Array<dword> armorColorIds;
    helpers::Array<PackCompositeBlitRectSetV4> blitRects;
    helpers::Array<PackCompositeRaceDataV4> raceSexData;

public:
    PackCompositeV4();
    PackCompositeV4(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV4(const PackCompositeV4 &p_other);
    PackCompositeV4 &operator=(const PackCompositeV4 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV4 Gw2Struct;
};

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<3>{
struct PackCompositeBlitRectSetV3 {
    helpers::WString name;
    dword2 size;
    helpers::Array<dword> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV3();
    PackCompositeBlitRectSetV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV3(const PackCompositeBlitRectSetV3 &p_other);
    PackCompositeBlitRectSetV3 &operator=(const PackCompositeBlitRectSetV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV3 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV3();
    PackCompositeFileDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV3(const PackCompositeFileDataV3 &p_other);
    PackCompositeFileDataV3 &operator=(const PackCompositeFileDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV3 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV3();
    PackCompositeSkinPatternV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV3(const PackCompositeSkinPatternV3 &p_other);
    PackCompositeSkinPatternV3 &operator=(const PackCompositeSkinPatternV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV3 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV3();
    PackCompositeColorV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV3(const PackCompositeColorV3 &p_other);
    PackCompositeColorV3 &operator=(const PackCompositeColorV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV3 {
    qword nameToken;
    PackCompositeColorV3 clothColor;
    PackCompositeColorV3 leatherColor;
    PackCompositeColorV3 metalColor;

public:
    PackCompositeVariantComponentV3();
    PackCompositeVariantComponentV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV3(const PackCompositeVariantComponentV3 &p_other);
    PackCompositeVariantComponentV3 &operator=(const PackCompositeVariantComponentV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV3 {
    helpers::Array<PackCompositeVariantComponentV3> components;
    PackCompositeColorV3 hairColor;
    PackCompositeColorV3 patternColor;
    PackCompositeColorV3 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV3();
    PackCompositeVariantV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV3(const PackCompositeVariantV3 &p_other);
    PackCompositeVariantV3 &operator=(const PackCompositeVariantV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV3 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> beard;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV3> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV3> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV3> variants;

public:
    PackCompositeRaceDataV3();
    PackCompositeRaceDataV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV3(const PackCompositeRaceDataV3 &p_other);
    PackCompositeRaceDataV3 &operator=(const PackCompositeRaceDataV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV3 {
    helpers::Array<PackCompositeBlitRectSetV3> blitRects;
    helpers::Array<PackCompositeRaceDataV3> raceSexData;

public:
    PackCompositeV3();
    PackCompositeV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV3(const PackCompositeV3 &p_other);
    PackCompositeV3 &operator=(const PackCompositeV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<2>{
struct PackCompositeBlitRectSetV2 {
    helpers::WString name;
    dword2 size;
    helpers::Array<dword> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV2();
    PackCompositeBlitRectSetV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV2(const PackCompositeBlitRectSetV2 &p_other);
    PackCompositeBlitRectSetV2 &operator=(const PackCompositeBlitRectSetV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV2 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV2();
    PackCompositeFileDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV2(const PackCompositeFileDataV2 &p_other);
    PackCompositeFileDataV2 &operator=(const PackCompositeFileDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV2 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV2();
    PackCompositeSkinPatternV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV2(const PackCompositeSkinPatternV2 &p_other);
    PackCompositeSkinPatternV2 &operator=(const PackCompositeSkinPatternV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV2 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV2();
    PackCompositeColorV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV2(const PackCompositeColorV2 &p_other);
    PackCompositeColorV2 &operator=(const PackCompositeColorV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV2 {
    qword nameToken;
    PackCompositeColorV2 clothColor;
    PackCompositeColorV2 leatherColor;
    PackCompositeColorV2 metalColor;

public:
    PackCompositeVariantComponentV2();
    PackCompositeVariantComponentV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV2(const PackCompositeVariantComponentV2 &p_other);
    PackCompositeVariantComponentV2 &operator=(const PackCompositeVariantComponentV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV2 {
    helpers::Array<PackCompositeVariantComponentV2> components;
    PackCompositeColorV2 hairColor;
    PackCompositeColorV2 patternColor;
    PackCompositeColorV2 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV2();
    PackCompositeVariantV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV2(const PackCompositeVariantV2 &p_other);
    PackCompositeVariantV2 &operator=(const PackCompositeVariantV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV2 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV2> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV2> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV2> variants;

public:
    PackCompositeRaceDataV2();
    PackCompositeRaceDataV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV2(const PackCompositeRaceDataV2 &p_other);
    PackCompositeRaceDataV2 &operator=(const PackCompositeRaceDataV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV2 {
    helpers::Array<PackCompositeBlitRectSetV2> blitRects;
    helpers::Array<PackCompositeRaceDataV2> raceSexData;

public:
    PackCompositeV2();
    PackCompositeV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV2(const PackCompositeV2 &p_other);
    PackCompositeV2 &operator=(const PackCompositeV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<1>{
struct PackCompositeBlitRectSetV1 {
    helpers::WString name;
    dword2 size;
    helpers::Array<dword> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV1();
    PackCompositeBlitRectSetV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV1(const PackCompositeBlitRectSetV1 &p_other);
    PackCompositeBlitRectSetV1 &operator=(const PackCompositeBlitRectSetV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV1 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskDye1;
    helpers::FileName maskDye2;
    helpers::FileName maskDye3;
    helpers::FileName maskDye4;
    helpers::FileName maskCut;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword dyeFlags;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV1();
    PackCompositeFileDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV1(const PackCompositeFileDataV1 &p_other);
    PackCompositeFileDataV1 &operator=(const PackCompositeFileDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV1 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV1();
    PackCompositeSkinPatternV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV1(const PackCompositeSkinPatternV1 &p_other);
    PackCompositeSkinPatternV1 &operator=(const PackCompositeSkinPatternV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV1 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV1();
    PackCompositeColorV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV1(const PackCompositeColorV1 &p_other);
    PackCompositeColorV1 &operator=(const PackCompositeColorV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV1 {
    qword nameToken;
    PackCompositeColorV1 clothColor;
    PackCompositeColorV1 leatherColor;
    PackCompositeColorV1 metalColor;

public:
    PackCompositeVariantComponentV1();
    PackCompositeVariantComponentV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV1(const PackCompositeVariantComponentV1 &p_other);
    PackCompositeVariantComponentV1 &operator=(const PackCompositeVariantComponentV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV1 {
    helpers::Array<PackCompositeVariantComponentV1> components;
    PackCompositeColorV1 hairColor;
    PackCompositeColorV1 patternColor;
    PackCompositeColorV1 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV1();
    PackCompositeVariantV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV1(const PackCompositeVariantV1 &p_other);
    PackCompositeVariantV1 &operator=(const PackCompositeVariantV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV1 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV1> fileData;
    helpers::Array<qword> hairStyles;
    helpers::WString hairColorPalette;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV1> skinPatterns;
    helpers::WString skinColorPalette;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV1> variants;

public:
    PackCompositeRaceDataV1();
    PackCompositeRaceDataV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV1(const PackCompositeRaceDataV1 &p_other);
    PackCompositeRaceDataV1 &operator=(const PackCompositeRaceDataV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV1 {
    helpers::Array<PackCompositeBlitRectSetV1> blitRects;
    helpers::Array<PackCompositeRaceDataV1> raceSexData;

public:
    PackCompositeV1();
    PackCompositeV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV1(const PackCompositeV1 &p_other);
    PackCompositeV1 &operator=(const PackCompositeV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structcomp<0>{
struct PackCompositeBlitRectSetV0 {
    helpers::WString name;
    dword2 size;
    helpers::Array<dword> rectIndex;
    helpers::Array<dword4> rectArray;

public:
    PackCompositeBlitRectSetV0();
    PackCompositeBlitRectSetV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeBlitRectSetV0(const PackCompositeBlitRectSetV0 &p_other);
    PackCompositeBlitRectSetV0 &operator=(const PackCompositeBlitRectSetV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeFileDataV0 {
    qword name;
    dword type;
    helpers::FileName meshBase;
    helpers::FileName meshOverlap;
    helpers::FileName maskClothSkin;
    helpers::FileName maskLeather;
    helpers::FileName maskMetal;
    helpers::FileName maskGlow;
    helpers::FileName textureBase;
    helpers::FileName textureNormal;
    dword hideFlags;
    dword skinFlags;
    dword blitRectIndex;

public:
    PackCompositeFileDataV0();
    PackCompositeFileDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeFileDataV0(const PackCompositeFileDataV0 &p_other);
    PackCompositeFileDataV0 &operator=(const PackCompositeFileDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeSkinPatternV0 {
    helpers::FileName chest;
    helpers::FileName face;
    helpers::FileName feet;
    helpers::FileName hands;
    helpers::FileName legs;

public:
    PackCompositeSkinPatternV0();
    PackCompositeSkinPatternV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeSkinPatternV0(const PackCompositeSkinPatternV0 &p_other);
    PackCompositeSkinPatternV0 &operator=(const PackCompositeSkinPatternV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeColorV0 {
    byte brightness;
    byte contrast;
    byte hue;
    byte saturation;
    byte lightness;

public:
    PackCompositeColorV0();
    PackCompositeColorV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeColorV0(const PackCompositeColorV0 &p_other);
    PackCompositeColorV0 &operator=(const PackCompositeColorV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantComponentV0 {
    qword nameToken;
    PackCompositeColorV0 clothColor;
    PackCompositeColorV0 leatherColor;
    PackCompositeColorV0 metalColor;

public:
    PackCompositeVariantComponentV0();
    PackCompositeVariantComponentV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantComponentV0(const PackCompositeVariantComponentV0 &p_other);
    PackCompositeVariantComponentV0 &operator=(const PackCompositeVariantComponentV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeVariantV0 {
    helpers::Array<PackCompositeVariantComponentV0> components;
    PackCompositeColorV0 hairColor;
    PackCompositeColorV0 patternColor;
    PackCompositeColorV0 skinColor;
    dword skinIndex;

public:
    PackCompositeVariantV0();
    PackCompositeVariantV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeVariantV0(const PackCompositeVariantV0 &p_other);
    PackCompositeVariantV0 &operator=(const PackCompositeVariantV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeRaceDataV0 {
    helpers::WString name;
    qword nameToken;
    helpers::Array<qword> ears;
    helpers::Array<qword> faces;
    helpers::Array<PackCompositeFileDataV0> fileData;
    helpers::Array<qword> hairStyles;
    helpers::FileName skeletonFile;
    helpers::Array<PackCompositeSkinPatternV0> skinPatterns;
    dword type;
    qword variantRefRace;
    helpers::Array<PackCompositeVariantV0> variants;

public:
    PackCompositeRaceDataV0();
    PackCompositeRaceDataV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeRaceDataV0(const PackCompositeRaceDataV0 &p_other);
    PackCompositeRaceDataV0 &operator=(const PackCompositeRaceDataV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackCompositeV0 {
    helpers::Array<PackCompositeBlitRectSetV0> blitRects;
    helpers::Array<PackCompositeRaceDataV0> raceSexData;

public:
    PackCompositeV0();
    PackCompositeV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackCompositeV0(const PackCompositeV0 &p_other);
    PackCompositeV0 &operator=(const PackCompositeV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackCompositeV0 Gw2Struct;
};


/* ===============================================
 * Chunk: Main, versions: 1, strucTab: 0x1423147D0
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructMain;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMain<0>{
struct PackContentTypeInfo {
    dword guidOffset;
    dword uidOffset;
    dword dataIdOffset;
    dword nameOffset;
    byte trackReferences;

public:
    PackContentTypeInfo();
    PackContentTypeInfo(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentTypeInfo(const PackContentTypeInfo &p_other);
    PackContentTypeInfo &operator=(const PackContentTypeInfo &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentNamespace {
    helpers::WString name;
    dword domain;
    dword parentIndex;

public:
    PackContentNamespace();
    PackContentNamespace(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentNamespace(const PackContentNamespace &p_other);
    PackContentNamespace &operator=(const PackContentNamespace &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentIndexEntry {
    dword type;
    dword offset;
    dword namespaceIndex;
    dword rootIndex;

public:
    PackContentIndexEntry();
    PackContentIndexEntry(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentIndexEntry(const PackContentIndexEntry &p_other);
    PackContentIndexEntry &operator=(const PackContentIndexEntry &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentLocalOffsetFixup {
    dword relocOffset;

public:
    PackContentLocalOffsetFixup();
    PackContentLocalOffsetFixup(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentLocalOffsetFixup(const PackContentLocalOffsetFixup &p_other);
    PackContentLocalOffsetFixup &operator=(const PackContentLocalOffsetFixup &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentExternalOffsetFixup {
    dword relocOffset;
    dword targetFileIndex;

public:
    PackContentExternalOffsetFixup();
    PackContentExternalOffsetFixup(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentExternalOffsetFixup(const PackContentExternalOffsetFixup &p_other);
    PackContentExternalOffsetFixup &operator=(const PackContentExternalOffsetFixup &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentFileIndexFixup {
    dword relocOffset;

public:
    PackContentFileIndexFixup();
    PackContentFileIndexFixup(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentFileIndexFixup(const PackContentFileIndexFixup &p_other);
    PackContentFileIndexFixup &operator=(const PackContentFileIndexFixup &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentStringIndexFixup {
    dword relocOffset;

public:
    PackContentStringIndexFixup();
    PackContentStringIndexFixup(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentStringIndexFixup(const PackContentStringIndexFixup &p_other);
    PackContentStringIndexFixup &operator=(const PackContentStringIndexFixup &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContentTrackedReference {
    dword sourceOffset;
    dword targetFileIndex;
    dword targetOffset;

public:
    PackContentTrackedReference();
    PackContentTrackedReference(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContentTrackedReference(const PackContentTrackedReference &p_other);
    PackContentTrackedReference &operator=(const PackContentTrackedReference &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackContent {
    dword flags;
    helpers::Array<PackContentTypeInfo> typeInfos;
    helpers::Array<PackContentNamespace> namespaces;
    helpers::Array<helpers::FileName> fileRefs;
    helpers::Array<PackContentIndexEntry> indexEntries;
    helpers::Array<PackContentLocalOffsetFixup> localOffsets;
    helpers::Array<PackContentExternalOffsetFixup> externalOffsets;
    helpers::Array<PackContentFileIndexFixup> fileIndices;
    helpers::Array<PackContentStringIndexFixup> stringIndices;
    helpers::Array<PackContentTrackedReference> trackedReferences;
    helpers::Array<helpers::WString> strings;
    helpers::Array<byte> content;

public:
    PackContent();
    PackContent(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackContent(const PackContent &p_other);
    PackContent &operator=(const PackContent &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackContent Gw2Struct;
};


/* ===============================================
 * Chunk: Main, versions: 1, strucTab: 0x142314840
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructMain;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2StructMain<0>{
struct PackMapMetadataMap {
    word mapId;
    byte mapType;

public:
    PackMapMetadataMap();
    PackMapMetadataMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapMetadataMap(const PackMapMetadataMap &p_other);
    PackMapMetadataMap &operator=(const PackMapMetadataMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackMapMetadata {
    helpers::Array<PackMapMetadataMap> maps;

public:
    PackMapMetadata();
    PackMapMetadata(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackMapMetadata(const PackMapMetadata &p_other);
    PackMapMetadata &operator=(const PackMapMetadata &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackMapMetadata Gw2Struct;
};


/* ===============================================
 * Chunk: anim, versions: 4, strucTab: 0x142314970
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structanim;

/* Version: 3, ReferencedFunction: 0x1 */

template <>
struct Gw2Structanim<3>{
struct PackEmoteTimingV3 {
    helpers::FileName ModelFile;
    float BlendIn;
    float BlendOut;
    dword IntroDuration;
    dword LoopDuration;
    dword OutroDuration;
    dword StartOffset;

public:
    PackEmoteTimingV3();
    PackEmoteTimingV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteTimingV3(const PackEmoteTimingV3 &p_other);
    PackEmoteTimingV3 &operator=(const PackEmoteTimingV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationV3 {
    qword Token;
    helpers::Array<PackEmoteTimingV3> Timing;

public:
    PackEmoteAnimationV3();
    PackEmoteAnimationV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationV3(const PackEmoteAnimationV3 &p_other);
    PackEmoteAnimationV3 &operator=(const PackEmoteAnimationV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationsV3 {
    helpers::Array<PackEmoteAnimationV3> Animation;

public:
    PackEmoteAnimationsV3();
    PackEmoteAnimationsV3(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationsV3(const PackEmoteAnimationsV3 &p_other);
    PackEmoteAnimationsV3 &operator=(const PackEmoteAnimationsV3 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackEmoteAnimationsV3 Gw2Struct;
};

/* Version: 2, ReferencedFunction: 0x41385DD000000001 */

template <>
struct Gw2Structanim<2>{
struct PackEmoteTimingV2 {
    helpers::FileName ModelFile;
    float BlendIn;
    float BlendOut;
    dword IntroDuration;
    dword LoopDuration;
    dword OutroDuration;

public:
    PackEmoteTimingV2();
    PackEmoteTimingV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteTimingV2(const PackEmoteTimingV2 &p_other);
    PackEmoteTimingV2 &operator=(const PackEmoteTimingV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationV2 {
    qword Token;
    helpers::Array<PackEmoteTimingV2> Timing;

public:
    PackEmoteAnimationV2();
    PackEmoteAnimationV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationV2(const PackEmoteAnimationV2 &p_other);
    PackEmoteAnimationV2 &operator=(const PackEmoteAnimationV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationsV2 {
    helpers::Array<PackEmoteAnimationV2> Animation;

public:
    PackEmoteAnimationsV2();
    PackEmoteAnimationsV2(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationsV2(const PackEmoteAnimationsV2 &p_other);
    PackEmoteAnimationsV2 &operator=(const PackEmoteAnimationsV2 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackEmoteAnimationsV2 Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structanim<1>{
struct PackEmoteTimingV1 {
    helpers::FileName modelFileId;
    float blendInTime;
    float blendOutTime;
    dword duration;
    dword loopDuration;

public:
    PackEmoteTimingV1();
    PackEmoteTimingV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteTimingV1(const PackEmoteTimingV1 &p_other);
    PackEmoteTimingV1 &operator=(const PackEmoteTimingV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationV1 {
    qword token;
    helpers::Array<PackEmoteTimingV1> timings;

public:
    PackEmoteAnimationV1();
    PackEmoteAnimationV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationV1(const PackEmoteAnimationV1 &p_other);
    PackEmoteAnimationV1 &operator=(const PackEmoteAnimationV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationsV1 {
    helpers::Array<PackEmoteAnimationV1> animations;

public:
    PackEmoteAnimationsV1();
    PackEmoteAnimationsV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationsV1(const PackEmoteAnimationsV1 &p_other);
    PackEmoteAnimationsV1 &operator=(const PackEmoteAnimationsV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackEmoteAnimationsV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structanim<0>{
struct PackEmoteTimingV0 {
    helpers::FileName modelFileId;
    float blendInTime;
    float blendOutTime;
    dword duration;

public:
    PackEmoteTimingV0();
    PackEmoteTimingV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteTimingV0(const PackEmoteTimingV0 &p_other);
    PackEmoteTimingV0 &operator=(const PackEmoteTimingV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationV0 {
    qword token;
    helpers::Array<PackEmoteTimingV0> timings;

public:
    PackEmoteAnimationV0();
    PackEmoteAnimationV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationV0(const PackEmoteAnimationV0 &p_other);
    PackEmoteAnimationV0 &operator=(const PackEmoteAnimationV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEmoteAnimationsV0 {
    helpers::Array<PackEmoteAnimationV0> animations;

public:
    PackEmoteAnimationsV0();
    PackEmoteAnimationsV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEmoteAnimationsV0(const PackEmoteAnimationsV0 &p_other);
    PackEmoteAnimationsV0 &operator=(const PackEmoteAnimationsV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackEmoteAnimationsV0 Gw2Struct;
};


/* ===============================================
 * Chunk: eula, versions: 1, strucTab: 0x142314B80
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structeula;

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structeula<0>{
struct PackEulaLanguageV0 {
    byte Language;
    helpers::WString Text;

public:
    PackEulaLanguageV0();
    PackEulaLanguageV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEulaLanguageV0(const PackEulaLanguageV0 &p_other);
    PackEulaLanguageV0 &operator=(const PackEulaLanguageV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct PackEulaV0 {
    helpers::Array<PackEulaLanguageV0> Language;
    byte Version;

public:
    PackEulaV0();
    PackEulaV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    PackEulaV0(const PackEulaV0 &p_other);
    PackEulaV0 &operator=(const PackEulaV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef PackEulaV0 Gw2Struct;
};


/* ===============================================
 * Chunk: pD6B, versions: 1, strucTab: 0x1423644F8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2StructpD6B;

/* ===============================================
 * Chunk: 8K6B, versions: 1, strucTab: 0x142364BA8
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Struct8K6B;


/* ===============================================
 * Chunk: mfst, versions: 3, strucTab: 0x1423AB260
 * ===============================================
 */


template <uint16_t Version>
struct Gw2Structmfst;

/* Version: 2, ReferencedFunction: 0x4177A39000000001 */

template <>
struct Gw2Structmfst<2>{
struct ContentMapRedirector {
    byte16 mapGUID;
    dword token;
    float3 position;
    float radius;

public:
    ContentMapRedirector();
    ContentMapRedirector(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapRedirector(const ContentMapRedirector &p_other);
    ContentMapRedirector &operator=(const ContentMapRedirector &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapModel {
    helpers::FileName filename;
    dword flags;
    dword type;
    qword permutation;

public:
    ContentMapModel();
    ContentMapModel(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapModel(const ContentMapModel &p_other);
    ContentMapModel &operator=(const ContentMapModel &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapStart {
    dword token;
    helpers::Array<ContentMapModel> modelArray;
    float3 position;
    float radius;

public:
    ContentMapStart();
    ContentMapStart(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapStart(const ContentMapStart &p_other);
    ContentMapStart &operator=(const ContentMapStart &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMap {
    byte16 mapGUID;
    helpers::Array<ContentMapRedirector> mapRedirectorArray;
    helpers::Array<ContentMapStart> mapStartArray;

public:
    ContentMap();
    ContentMap(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMap(const ContentMap &p_other);
    ContentMap &operator=(const ContentMap &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentPortalManifest {
    helpers::Array<ContentMap> mapArray;

public:
    ContentPortalManifest();
    ContentPortalManifest(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentPortalManifest(const ContentPortalManifest &p_other);
    ContentPortalManifest &operator=(const ContentPortalManifest &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ContentPortalManifest Gw2Struct;
};

/* Version: 1, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmfst<1>{
struct ContentMapRedirectorV1 {
    dword mapId;
    dword token;
    float3 position;
    float radius;

public:
    ContentMapRedirectorV1();
    ContentMapRedirectorV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapRedirectorV1(const ContentMapRedirectorV1 &p_other);
    ContentMapRedirectorV1 &operator=(const ContentMapRedirectorV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapModelV1 {
    helpers::FileName filename;
    dword flags;
    dword type;
    qword permutation;

public:
    ContentMapModelV1();
    ContentMapModelV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapModelV1(const ContentMapModelV1 &p_other);
    ContentMapModelV1 &operator=(const ContentMapModelV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapStartV1 {
    dword token;
    helpers::Array<ContentMapModelV1> modelArray;
    float3 position;
    float radius;

public:
    ContentMapStartV1();
    ContentMapStartV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapStartV1(const ContentMapStartV1 &p_other);
    ContentMapStartV1 &operator=(const ContentMapStartV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapV1 {
    dword mapId;
    helpers::Array<ContentMapRedirectorV1> mapRedirectorArray;
    helpers::Array<ContentMapStartV1> mapStartArray;

public:
    ContentMapV1();
    ContentMapV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapV1(const ContentMapV1 &p_other);
    ContentMapV1 &operator=(const ContentMapV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentPortalManifestV1 {
    helpers::Array<ContentMapV1> mapArray;

public:
    ContentPortalManifestV1();
    ContentPortalManifestV1(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentPortalManifestV1(const ContentPortalManifestV1 &p_other);
    ContentPortalManifestV1 &operator=(const ContentPortalManifestV1 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ContentPortalManifestV1 Gw2Struct;
};

/* Version: 0, ReferencedFunction: 0x1 */

template <>
struct Gw2Structmfst<0>{
struct ContentMapRedirectorV0 {
    dword mapId;
    dword token;
    float3 position;
    float radius;

public:
    ContentMapRedirectorV0();
    ContentMapRedirectorV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapRedirectorV0(const ContentMapRedirectorV0 &p_other);
    ContentMapRedirectorV0 &operator=(const ContentMapRedirectorV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapModelV0 {
    helpers::FileName filename;
    dword flags;
    dword type;

public:
    ContentMapModelV0();
    ContentMapModelV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapModelV0(const ContentMapModelV0 &p_other);
    ContentMapModelV0 &operator=(const ContentMapModelV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapStartV0 {
    dword token;
    helpers::Array<ContentMapModelV0> modelArray;
    float3 position;
    float radius;

public:
    ContentMapStartV0();
    ContentMapStartV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapStartV0(const ContentMapStartV0 &p_other);
    ContentMapStartV0 &operator=(const ContentMapStartV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentMapV0 {
    dword mapId;
    helpers::Array<ContentMapRedirectorV0> mapRedirectorArray;
    helpers::Array<ContentMapStartV0> mapStartArray;

public:
    ContentMapV0();
    ContentMapV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentMapV0(const ContentMapV0 &p_other);
    ContentMapV0 &operator=(const ContentMapV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

struct ContentPortalManifestV0 {
    helpers::Array<ContentMapV0> mapArray;

public:
    ContentPortalManifestV0();
    ContentPortalManifestV0(const byte *p_data, size_t p_size, const byte **po_pointer = nullptr);
    ContentPortalManifestV0(const ContentPortalManifestV0 &p_other);
    ContentPortalManifestV0 &operator=(const ContentPortalManifestV0 &p_other);
    const byte *assign(const byte *p_data, size_t p_size);
};

typedef ContentPortalManifestV0 Gw2Struct;
};


